<TracedFile path="src/lean/Init/Data/Vector/Find.lean" md5="105ab1610ed61ccacbb1c9bd35ed9408">
  <FileNode start="(1, 1)" end="(349, 11)">
    <ModuleHeaderNode start="(6, 1)" end="(12, 28)">
      <NullNode start="(6, 1)" end="(6, 7)">
        <OtherNode start="(6, 1)" end="(6, 7)" kind="Lean.Parser.Module.moduleTk">
          <AtomNode start="(6, 1)" end="(6, 7)" leading="" trailing="&#10;&#10;" val="module"/>
        </OtherNode>
      </NullNode>
      <NullNode start="(8, 1)" end="(8, 8)">
        <ModulePreludeNode start="(8, 1)" end="(8, 8)">
          <AtomNode start="(8, 1)" end="(8, 8)" leading="" trailing="&#10;" val="prelude"/>
        </ModulePreludeNode>
      </NullNode>
      <NullNode start="(9, 1)" end="(12, 28)">
        <ModuleImportNode start="(9, 1)" end="(9, 31)" module="Init.Data.Vector.Lemmas" path="src/lean/Init/Data/Vector/Lemmas.lean">
          <NullNode/>
          <AtomNode start="(9, 1)" end="(9, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(9, 8)" end="(9, 31)" leading="" trailing="&#10;" raw_val="Init.Data.Vector.Lemmas" val="Init.Data.Vector.Lemmas"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(10, 1)" end="(10, 31)" module="Init.Data.Vector.Attach" path="src/lean/Init/Data/Vector/Attach.lean">
          <NullNode/>
          <AtomNode start="(10, 1)" end="(10, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(10, 8)" end="(10, 31)" leading="" trailing="&#10;" raw_val="Init.Data.Vector.Attach" val="Init.Data.Vector.Attach"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(11, 1)" end="(11, 30)" module="Init.Data.Vector.Range" path="src/lean/Init/Data/Vector/Range.lean">
          <NullNode/>
          <AtomNode start="(11, 1)" end="(11, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(11, 8)" end="(11, 30)" leading="" trailing="&#10;" raw_val="Init.Data.Vector.Range" val="Init.Data.Vector.Range"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(12, 1)" end="(12, 28)" module="Init.Data.Array.Find" path="src/lean/Init/Data/Array/Find.lean">
          <NullNode/>
          <AtomNode start="(12, 1)" end="(12, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(12, 8)" end="(12, 28)" leading="" trailing="&#10;&#10;" raw_val="Init.Data.Array.Find" val="Init.Data.Array.Find"/>
          <NullNode/>
        </ModuleImportNode>
      </NullNode>
    </ModuleHeaderNode>
    <CommandModuledocNode start="(14, 1)" end="(18, 3)" comment="# Lemmas about `Vector.findSome?`, `Vector.find?`, `Vector.findFinIdx?`.&#10;&#10;We are still missing results about `idxOf?`, `findIdx`, and `findIdx?`.&#10;-/">
      <AtomNode start="(14, 1)" end="(14, 4)" leading="" trailing="&#10;" val="/-!"/>
      <AtomNode start="(15, 1)" end="(18, 3)" leading="" trailing="&#10;&#10;" val="# Lemmas about `Vector.findSome?`, `Vector.find?`, `Vector.findFinIdx?`.&#10;&#10;We are still missing results about `idxOf?`, `findIdx`, and `findIdx?`.&#10;-/"/>
    </CommandModuledocNode>
    <OtherNode start="(20, 1)" end="(20, 37)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(20, 1)" end="(20, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(20, 12)" end="(20, 32)" leading="" trailing=" " raw_val="linter.listVariables" val="linter.listVariables"/>
      <NullNode/>
      <AtomNode start="(20, 33)" end="(20, 37)" leading="" trailing=" -- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;" val="true"/>
    </OtherNode>
    <OtherNode start="(21, 1)" end="(21, 38)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(21, 1)" end="(21, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(21, 12)" end="(21, 33)" leading="" trailing=" " raw_val="linter.indexVariables" val="linter.indexVariables"/>
      <NullNode/>
      <AtomNode start="(21, 34)" end="(21, 38)" leading="" trailing=" -- Enforce naming conventions for index variables.&#10;&#10;" val="true"/>
    </OtherNode>
    <CommandNamespaceNode start="(23, 1)" end="(23, 17)" name="Vector">
      <AtomNode start="(23, 1)" end="(23, 10)" leading="" trailing=" " val="namespace"/>
      <IdentNode start="(23, 11)" end="(23, 17)" leading="" trailing="&#10;&#10;" raw_val="Vector" val="Vector"/>
    </CommandNamespaceNode>
    <CommandOpenNode start="(25, 1)" end="(25, 9)">
      <AtomNode start="(25, 1)" end="(25, 5)" leading="" trailing=" " val="open"/>
      <OtherNode start="(25, 6)" end="(25, 9)" kind="Lean.Parser.Command.openSimple">
        <NullNode start="(25, 6)" end="(25, 9)">
          <IdentNode start="(25, 6)" end="(25, 9)" leading="" trailing="&#10;&#10;" raw_val="Nat" val="Nat"/>
        </NullNode>
      </OtherNode>
    </CommandOpenNode>
    <CommandModuledocNode start="(27, 1)" end="(27, 21)" comment="### findSome? -/">
      <AtomNode start="(27, 1)" end="(27, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(27, 5)" end="(27, 21)" leading="" trailing="&#10;&#10;" val="### findSome? -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(29, 1)" end="(29, 87)" name="findSome?_empty" full_name="Vector.findSome?_empty">
      <CommandDeclmodifiersNode start="(29, 1)" end="(29, 15)">
        <NullNode/>
        <NullNode start="(29, 1)" end="(29, 15)">
          <OtherNode start="(29, 1)" end="(29, 15)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(29, 1)" end="(29, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(29, 3)" end="(29, 14)">
              <OtherNode start="(29, 3)" end="(29, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(29, 3)" end="(29, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(29, 3)" end="(29, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(29, 7)" end="(29, 8)" leading="" trailing=" " val=","/>
              <OtherNode start="(29, 9)" end="(29, 14)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(29, 9)" end="(29, 14)" kind="Lean.Parser.Attr.grind">
                  <AtomNode start="(29, 9)" end="(29, 14)" leading="" trailing="" val="grind"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(29, 14)" end="(29, 15)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(29, 16)" end="(29, 87)" name="findSome?_empty" full_name="Vector.findSome?_empty" _is_private_decl="False">
        <AtomNode start="(29, 16)" end="(29, 23)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(29, 24)" end="(29, 39)">
          <IdentNode start="(29, 24)" end="(29, 39)" leading="" trailing=" " raw_val="findSome?_empty" val="findSome?_empty"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(29, 40)" end="(29, 80)">
          <NullNode/>
          <TermTypespecNode start="(29, 40)" end="(29, 80)">
            <AtomNode start="(29, 40)" end="(29, 41)" leading="" trailing=" " val=":"/>
            <OtherNode start="(29, 42)" end="(29, 80)" kind="«term_=_»">
              <OtherNode start="(29, 42)" end="(29, 73)" kind="Lean.Parser.Term.app">
                <OtherNode start="(29, 42)" end="(29, 71)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(29, 42)" end="(29, 61)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(29, 42)" end="(29, 43)" leading="" trailing="" val="("/>
                    <OtherNode start="(29, 43)" end="(29, 47)" kind="Vector.«term#v[_,]»">
                      <AtomNode start="(29, 43)" end="(29, 46)" leading="" trailing="" val="#v["/>
                      <NullNode/>
                      <AtomNode start="(29, 46)" end="(29, 47)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                    <AtomNode start="(29, 48)" end="(29, 49)" leading="" trailing=" " val=":"/>
                    <NullNode start="(29, 50)" end="(29, 60)">
                      <OtherNode start="(29, 50)" end="(29, 60)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(29, 50)" end="(29, 56)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                        <NullNode start="(29, 57)" end="(29, 60)">
                          <IdentNode start="(29, 57)" end="(29, 58)" leading="" trailing=" " raw_val="α" val="α"/>
                          <OtherNode start="(29, 59)" end="(29, 60)" kind="num">
                            <AtomNode start="(29, 59)" end="(29, 60)" leading="" trailing="" val="0"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(29, 60)" end="(29, 61)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(29, 61)" end="(29, 62)" leading="" trailing="" val="."/>
                  <IdentNode start="(29, 62)" end="(29, 71)" leading="" trailing=" " raw_val="findSome?" val="findSome?" full_name="Vector.findSome?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                </OtherNode>
                <NullNode start="(29, 72)" end="(29, 73)">
                  <IdentNode start="(29, 72)" end="(29, 73)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(29, 74)" end="(29, 75)" leading="" trailing=" " val="="/>
              <IdentNode start="(29, 76)" end="(29, 80)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(29, 81)" end="(29, 87)">
          <AtomNode start="(29, 81)" end="(29, 83)" leading="" trailing=" " val=":="/>
          <IdentNode start="(29, 84)" end="(29, 87)" leading="" trailing="&#10;" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(30, 1)" end="(31, 41)" name="findSome?_push" full_name="Vector.findSome?_push">
      <CommandDeclmodifiersNode start="(30, 1)" end="(30, 15)">
        <NullNode/>
        <NullNode start="(30, 1)" end="(30, 15)">
          <OtherNode start="(30, 1)" end="(30, 15)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(30, 1)" end="(30, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(30, 3)" end="(30, 14)">
              <OtherNode start="(30, 3)" end="(30, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(30, 3)" end="(30, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(30, 3)" end="(30, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(30, 7)" end="(30, 8)" leading="" trailing=" " val=","/>
              <OtherNode start="(30, 9)" end="(30, 14)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(30, 9)" end="(30, 14)" kind="Lean.Parser.Attr.grind">
                  <AtomNode start="(30, 9)" end="(30, 14)" leading="" trailing="" val="grind"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(30, 14)" end="(30, 15)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(30, 16)" end="(31, 41)" name="findSome?_push" full_name="Vector.findSome?_push" _is_private_decl="False">
        <AtomNode start="(30, 16)" end="(30, 23)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(30, 24)" end="(30, 38)">
          <IdentNode start="(30, 24)" end="(30, 38)" leading="" trailing=" " raw_val="findSome?_push" val="findSome?_push"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(30, 39)" end="(30, 110)">
          <NullNode start="(30, 39)" end="(30, 56)">
            <OtherNode start="(30, 39)" end="(30, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(30, 39)" end="(30, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(30, 40)" end="(30, 42)">
                <IdentNode start="(30, 40)" end="(30, 42)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(30, 43)" end="(30, 55)">
                <AtomNode start="(30, 43)" end="(30, 44)" leading="" trailing=" " val=":"/>
                <OtherNode start="(30, 45)" end="(30, 55)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(30, 45)" end="(30, 51)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(30, 52)" end="(30, 55)">
                    <IdentNode start="(30, 52)" end="(30, 53)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(30, 54)" end="(30, 55)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(30, 55)" end="(30, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(30, 57)" end="(30, 110)">
            <AtomNode start="(30, 57)" end="(30, 58)" leading="" trailing=" " val=":"/>
            <OtherNode start="(30, 59)" end="(30, 110)" kind="«term_=_»">
              <OtherNode start="(30, 59)" end="(30, 82)" kind="Lean.Parser.Term.app">
                <OtherNode start="(30, 59)" end="(30, 80)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(30, 59)" end="(30, 70)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(30, 59)" end="(30, 60)" leading="" trailing="" val="("/>
                    <OtherNode start="(30, 60)" end="(30, 69)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(30, 60)" end="(30, 67)" leading="" trailing=" " raw_val="xs.push" val="xs.push"/>
                      <NullNode start="(30, 68)" end="(30, 69)">
                        <IdentNode start="(30, 68)" end="(30, 69)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(30, 69)" end="(30, 70)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(30, 70)" end="(30, 71)" leading="" trailing="" val="."/>
                  <IdentNode start="(30, 71)" end="(30, 80)" leading="" trailing=" " raw_val="findSome?" val="findSome?" full_name="Vector.findSome?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                </OtherNode>
                <NullNode start="(30, 81)" end="(30, 82)">
                  <IdentNode start="(30, 81)" end="(30, 82)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(30, 83)" end="(30, 84)" leading="" trailing=" " val="="/>
              <OtherNode start="(30, 85)" end="(30, 110)" kind="Lean.Parser.Term.app">
                <OtherNode start="(30, 85)" end="(30, 104)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(30, 85)" end="(30, 101)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(30, 85)" end="(30, 86)" leading="" trailing="" val="("/>
                    <OtherNode start="(30, 86)" end="(30, 100)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(30, 86)" end="(30, 98)" leading="" trailing=" " raw_val="xs.findSome?" val="xs.findSome?"/>
                      <NullNode start="(30, 99)" end="(30, 100)">
                        <IdentNode start="(30, 99)" end="(30, 100)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(30, 100)" end="(30, 101)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(30, 101)" end="(30, 102)" leading="" trailing="" val="."/>
                  <IdentNode start="(30, 102)" end="(30, 104)" leading="" trailing=" " raw_val="or" val="or" full_name="Option.or" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(30, 105)" end="(30, 110)">
                  <OtherNode start="(30, 105)" end="(30, 110)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(30, 105)" end="(30, 106)" leading="" trailing="" val="("/>
                    <OtherNode start="(30, 106)" end="(30, 109)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(30, 106)" end="(30, 107)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(30, 108)" end="(30, 109)">
                        <IdentNode start="(30, 108)" end="(30, 109)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(30, 109)" end="(30, 110)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(30, 111)" end="(31, 41)">
          <AtomNode start="(30, 111)" end="(30, 113)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(30, 114)" end="(31, 41)">
            <AtomNode start="(30, 114)" end="(30, 116)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(31, 3)" end="(31, 41)">
              <TacticTacticseq1IndentedNode start="(31, 3)" end="(31, 41)">
                <NullNode start="(31, 3)" end="(31, 41)">
                  <OtherNode start="(31, 3)" end="(31, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;n : Nat&#10;a : α&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;xs : Vector α n&#10;⊢ findSome? f (xs.push a) = (findSome? f xs).or (f a)" state_after="case mk&#10;α : Type u_1&#10;n : Nat&#10;a : α&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n&#10;⊢ findSome? f ({ toArray := toArray✝, size_toArray := size_toArray✝ }.push a) =&#10;    (findSome? f { toArray := toArray✝, size_toArray := size_toArray✝ }).or (f a)" tactic="cases xs">
                    <AtomNode start="(31, 3)" end="(31, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(31, 9)" end="(31, 11)">
                      <OtherNode start="(31, 9)" end="(31, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(31, 9)" end="(31, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(31, 11)" end="(31, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(31, 13)" end="(31, 41)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;n : Nat&#10;a : α&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n&#10;⊢ findSome? f ({ toArray := toArray✝, size_toArray := size_toArray✝ }.push a) =&#10;    (findSome? f { toArray := toArray✝, size_toArray := size_toArray✝ }).or (f a)" state_after="no goals" tactic="simp [List.findSome?_append]">
                    <AtomNode start="(31, 13)" end="(31, 17)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(31, 18)" end="(31, 41)">
                      <AtomNode start="(31, 18)" end="(31, 19)" leading="" trailing="" val="["/>
                      <NullNode start="(31, 19)" end="(31, 40)">
                        <OtherNode start="(31, 19)" end="(31, 40)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(31, 19)" end="(31, 40)" leading="" trailing="" raw_val="List.findSome?_append" val="List.findSome?_append" full_name="List.findSome?_append" mod_name="Init.Data.List.Impl" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Impl.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(31, 40)" end="(31, 41)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(33, 1)" end="(35, 7)" name="findSome?_singleton" full_name="Vector.findSome?_singleton">
      <CommandDeclmodifiersNode start="(33, 1)" end="(33, 9)">
        <NullNode/>
        <NullNode start="(33, 1)" end="(33, 9)">
          <OtherNode start="(33, 1)" end="(33, 9)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(33, 1)" end="(33, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(33, 3)" end="(33, 8)">
              <OtherNode start="(33, 3)" end="(33, 8)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(33, 3)" end="(33, 8)" kind="Lean.Parser.Attr.grind">
                  <AtomNode start="(33, 3)" end="(33, 8)" leading="" trailing="" val="grind"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(33, 8)" end="(33, 9)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(34, 1)" end="(35, 7)" name="findSome?_singleton" full_name="Vector.findSome?_singleton" _is_private_decl="False">
        <AtomNode start="(34, 1)" end="(34, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(34, 9)" end="(34, 28)">
          <IdentNode start="(34, 9)" end="(34, 28)" leading="" trailing=" " raw_val="findSome?_singleton" val="findSome?_singleton"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(34, 29)" end="(34, 81)">
          <NullNode start="(34, 29)" end="(34, 55)">
            <OtherNode start="(34, 29)" end="(34, 36)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(34, 29)" end="(34, 30)" leading="" trailing="" val="{"/>
              <NullNode start="(34, 30)" end="(34, 31)">
                <IdentNode start="(34, 30)" end="(34, 31)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(34, 32)" end="(34, 35)">
                <AtomNode start="(34, 32)" end="(34, 33)" leading="" trailing=" " val=":"/>
                <IdentNode start="(34, 34)" end="(34, 35)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(34, 35)" end="(34, 36)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(34, 37)" end="(34, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(34, 37)" end="(34, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(34, 38)" end="(34, 39)">
                <IdentNode start="(34, 38)" end="(34, 39)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(34, 40)" end="(34, 54)">
                <AtomNode start="(34, 40)" end="(34, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(34, 42)" end="(34, 54)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(34, 42)" end="(34, 43)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(34, 44)" end="(34, 45)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(34, 46)" end="(34, 54)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(34, 46)" end="(34, 52)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(34, 53)" end="(34, 54)">
                      <IdentNode start="(34, 53)" end="(34, 54)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(34, 54)" end="(34, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(34, 56)" end="(34, 81)">
            <AtomNode start="(34, 56)" end="(34, 57)" leading="" trailing=" " val=":"/>
            <OtherNode start="(34, 58)" end="(34, 81)" kind="«term_=_»">
              <OtherNode start="(34, 58)" end="(34, 75)" kind="Lean.Parser.Term.app">
                <OtherNode start="(34, 58)" end="(34, 73)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(34, 58)" end="(34, 63)" kind="Vector.«term#v[_,]»">
                    <AtomNode start="(34, 58)" end="(34, 61)" leading="" trailing="" val="#v["/>
                    <NullNode start="(34, 61)" end="(34, 62)">
                      <IdentNode start="(34, 61)" end="(34, 62)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                    <AtomNode start="(34, 62)" end="(34, 63)" leading="" trailing="" val="]"/>
                  </OtherNode>
                  <AtomNode start="(34, 63)" end="(34, 64)" leading="" trailing="" val="."/>
                  <IdentNode start="(34, 64)" end="(34, 73)" leading="" trailing=" " raw_val="findSome?" val="findSome?" full_name="Vector.findSome?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                </OtherNode>
                <NullNode start="(34, 74)" end="(34, 75)">
                  <IdentNode start="(34, 74)" end="(34, 75)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(34, 76)" end="(34, 77)" leading="" trailing=" " val="="/>
              <OtherNode start="(34, 78)" end="(34, 81)" kind="Lean.Parser.Term.app">
                <IdentNode start="(34, 78)" end="(34, 79)" leading="" trailing=" " raw_val="f" val="f"/>
                <NullNode start="(34, 80)" end="(34, 81)">
                  <IdentNode start="(34, 80)" end="(34, 81)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(34, 82)" end="(35, 7)">
          <AtomNode start="(34, 82)" end="(34, 84)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(34, 85)" end="(35, 7)">
            <AtomNode start="(34, 85)" end="(34, 87)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(35, 3)" end="(35, 7)">
              <TacticTacticseq1IndentedNode start="(35, 3)" end="(35, 7)">
                <NullNode start="(35, 3)" end="(35, 7)">
                  <OtherNode start="(35, 3)" end="(35, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;a : α&#10;f : α → Option β&#10;⊢ findSome? f { toArray := #[a], size_toArray := ⋯ } = f a" state_after="no goals" tactic="simp">
                    <AtomNode start="(35, 3)" end="(35, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(37, 1)" end="(39, 77)" name="findSomeRev?_push_of_isSome" full_name="Vector.findSomeRev?_push_of_isSome">
      <CommandDeclmodifiersNode start="(37, 1)" end="(37, 8)">
        <NullNode/>
        <NullNode start="(37, 1)" end="(37, 8)">
          <OtherNode start="(37, 1)" end="(37, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(37, 1)" end="(37, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(37, 3)" end="(37, 7)">
              <OtherNode start="(37, 3)" end="(37, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(37, 3)" end="(37, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(37, 3)" end="(37, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(37, 7)" end="(37, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(37, 9)" end="(39, 77)" name="findSomeRev?_push_of_isSome" full_name="Vector.findSomeRev?_push_of_isSome" _is_private_decl="False">
        <AtomNode start="(37, 9)" end="(37, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(37, 17)" end="(37, 44)">
          <IdentNode start="(37, 17)" end="(37, 44)" leading="" trailing=" " raw_val="findSomeRev?_push_of_isSome" val="findSomeRev?_push_of_isSome"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(37, 45)" end="(37, 116)">
          <NullNode start="(37, 45)" end="(37, 81)">
            <OtherNode start="(37, 45)" end="(37, 62)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(37, 45)" end="(37, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(37, 46)" end="(37, 48)">
                <IdentNode start="(37, 46)" end="(37, 48)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(37, 49)" end="(37, 61)">
                <AtomNode start="(37, 49)" end="(37, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(37, 51)" end="(37, 61)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(37, 51)" end="(37, 57)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(37, 58)" end="(37, 61)">
                    <IdentNode start="(37, 58)" end="(37, 59)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(37, 60)" end="(37, 61)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(37, 61)" end="(37, 62)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(37, 63)" end="(37, 81)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(37, 63)" end="(37, 64)" leading="" trailing="" val="{"/>
              <NullNode start="(37, 64)" end="(37, 65)">
                <IdentNode start="(37, 64)" end="(37, 65)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(37, 66)" end="(37, 80)">
                <AtomNode start="(37, 66)" end="(37, 67)" leading="" trailing=" " val=":"/>
                <OtherNode start="(37, 68)" end="(37, 80)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(37, 68)" end="(37, 73)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(37, 68)" end="(37, 69)" leading="" trailing="" val="("/>
                    <OtherNode start="(37, 69)" end="(37, 72)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(37, 69)" end="(37, 70)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(37, 71)" end="(37, 72)">
                        <IdentNode start="(37, 71)" end="(37, 72)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(37, 72)" end="(37, 73)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(37, 73)" end="(37, 74)" leading="" trailing="" val="."/>
                  <IdentNode start="(37, 74)" end="(37, 80)" leading="" trailing="" raw_val="isSome" val="isSome" full_name="Option.isSome" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(37, 80)" end="(37, 81)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(37, 82)" end="(37, 116)">
            <AtomNode start="(37, 82)" end="(37, 83)" leading="" trailing=" " val=":"/>
            <OtherNode start="(37, 84)" end="(37, 116)" kind="«term_=_»">
              <OtherNode start="(37, 84)" end="(37, 110)" kind="Lean.Parser.Term.app">
                <OtherNode start="(37, 84)" end="(37, 108)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(37, 84)" end="(37, 95)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(37, 84)" end="(37, 85)" leading="" trailing="" val="("/>
                    <OtherNode start="(37, 85)" end="(37, 94)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(37, 85)" end="(37, 92)" leading="" trailing=" " raw_val="xs.push" val="xs.push"/>
                      <NullNode start="(37, 93)" end="(37, 94)">
                        <IdentNode start="(37, 93)" end="(37, 94)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(37, 94)" end="(37, 95)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(37, 95)" end="(37, 96)" leading="" trailing="" val="."/>
                  <IdentNode start="(37, 96)" end="(37, 108)" leading="" trailing=" " raw_val="findSomeRev?" val="findSomeRev?" full_name="Vector.findSomeRev?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                </OtherNode>
                <NullNode start="(37, 109)" end="(37, 110)">
                  <IdentNode start="(37, 109)" end="(37, 110)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(37, 111)" end="(37, 112)" leading="" trailing=" " val="="/>
              <OtherNode start="(37, 113)" end="(37, 116)" kind="Lean.Parser.Term.app">
                <IdentNode start="(37, 113)" end="(37, 114)" leading="" trailing=" " raw_val="f" val="f"/>
                <NullNode start="(37, 115)" end="(37, 116)">
                  <IdentNode start="(37, 115)" end="(37, 116)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(37, 117)" end="(39, 77)">
          <AtomNode start="(37, 117)" end="(37, 119)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(37, 120)" end="(39, 77)">
            <AtomNode start="(37, 120)" end="(37, 122)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(38, 3)" end="(39, 77)">
              <TacticTacticseq1IndentedNode start="(38, 3)" end="(39, 77)">
                <NullNode start="(38, 3)" end="(39, 77)">
                  <OtherNode start="(38, 3)" end="(38, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;n : Nat&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;a : α&#10;xs : Vector α n&#10;h : (f a).isSome = true&#10;⊢ findSomeRev? f (xs.push a) = f a" state_after="case mk&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;a : α&#10;h : (f a).isSome = true&#10;xs : Array α&#10;⊢ findSomeRev? f ({ toArray := xs, size_toArray := ⋯ }.push a) = f a" tactic="rcases xs with ⟨xs, rfl⟩">
                    <AtomNode start="(38, 3)" end="(38, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(38, 10)" end="(38, 12)">
                      <OtherNode start="(38, 10)" end="(38, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(38, 10)" end="(38, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(38, 13)" end="(38, 27)">
                      <AtomNode start="(38, 13)" end="(38, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(38, 18)" end="(38, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(38, 18)" end="(38, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(38, 18)" end="(38, 27)">
                            <OtherNode start="(38, 18)" end="(38, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(38, 18)" end="(38, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(38, 19)" end="(38, 26)">
                                <OtherNode start="(38, 19)" end="(38, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(38, 19)" end="(38, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(38, 19)" end="(38, 21)">
                                      <OtherNode start="(38, 19)" end="(38, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(38, 19)" end="(38, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(38, 21)" end="(38, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(38, 23)" end="(38, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(38, 23)" end="(38, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(38, 23)" end="(38, 26)">
                                      <OtherNode start="(38, 23)" end="(38, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(38, 23)" end="(38, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(38, 26)" end="(38, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(39, 3)" end="(39, 77)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;a : α&#10;h : (f a).isSome = true&#10;xs : Array α&#10;⊢ findSomeRev? f ({ toArray := xs, size_toArray := ⋯ }.push a) = f a" state_after="no goals" tactic="simp only [push_mk, findSomeRev?_mk, Array.findSomeRev?_push_of_isSome, h]">
                    <AtomNode start="(39, 3)" end="(39, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(39, 8)" end="(39, 12)">
                      <AtomNode start="(39, 8)" end="(39, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(39, 13)" end="(39, 77)">
                      <AtomNode start="(39, 13)" end="(39, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(39, 14)" end="(39, 76)">
                        <OtherNode start="(39, 14)" end="(39, 21)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(39, 14)" end="(39, 21)" leading="" trailing="" raw_val="push_mk" val="push_mk" full_name="Vector.push_mk" mod_name="Init.Data.Vector.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(39, 21)" end="(39, 22)" leading="" trailing=" " val=","/>
                        <OtherNode start="(39, 23)" end="(39, 38)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(39, 23)" end="(39, 38)" leading="" trailing="" raw_val="findSomeRev?_mk" val="findSomeRev?_mk" full_name="Vector.findSomeRev?_mk" mod_name="Init.Data.Vector.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(39, 38)" end="(39, 39)" leading="" trailing=" " val=","/>
                        <OtherNode start="(39, 40)" end="(39, 73)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(39, 40)" end="(39, 73)" leading="" trailing="" raw_val="Array.findSomeRev?_push_of_isSome" val="Array.findSomeRev?_push_of_isSome" full_name="Array.findSomeRev?_push_of_isSome" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean"/>
                        </OtherNode>
                        <AtomNode start="(39, 73)" end="(39, 74)" leading="" trailing=" " val=","/>
                        <OtherNode start="(39, 75)" end="(39, 76)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(39, 75)" end="(39, 76)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(39, 76)" end="(39, 77)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(41, 1)" end="(43, 77)" name="findSomeRev?_push_of_isNone" full_name="Vector.findSomeRev?_push_of_isNone">
      <CommandDeclmodifiersNode start="(41, 1)" end="(41, 8)">
        <NullNode/>
        <NullNode start="(41, 1)" end="(41, 8)">
          <OtherNode start="(41, 1)" end="(41, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(41, 1)" end="(41, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(41, 3)" end="(41, 7)">
              <OtherNode start="(41, 3)" end="(41, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(41, 3)" end="(41, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(41, 3)" end="(41, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(41, 7)" end="(41, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(41, 9)" end="(43, 77)" name="findSomeRev?_push_of_isNone" full_name="Vector.findSomeRev?_push_of_isNone" _is_private_decl="False">
        <AtomNode start="(41, 9)" end="(41, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(41, 17)" end="(41, 44)">
          <IdentNode start="(41, 17)" end="(41, 44)" leading="" trailing=" " raw_val="findSomeRev?_push_of_isNone" val="findSomeRev?_push_of_isNone"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(41, 45)" end="(41, 130)">
          <NullNode start="(41, 45)" end="(41, 81)">
            <OtherNode start="(41, 45)" end="(41, 62)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(41, 45)" end="(41, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(41, 46)" end="(41, 48)">
                <IdentNode start="(41, 46)" end="(41, 48)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(41, 49)" end="(41, 61)">
                <AtomNode start="(41, 49)" end="(41, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(41, 51)" end="(41, 61)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(41, 51)" end="(41, 57)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(41, 58)" end="(41, 61)">
                    <IdentNode start="(41, 58)" end="(41, 59)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(41, 60)" end="(41, 61)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(41, 61)" end="(41, 62)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(41, 63)" end="(41, 81)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(41, 63)" end="(41, 64)" leading="" trailing="" val="{"/>
              <NullNode start="(41, 64)" end="(41, 65)">
                <IdentNode start="(41, 64)" end="(41, 65)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(41, 66)" end="(41, 80)">
                <AtomNode start="(41, 66)" end="(41, 67)" leading="" trailing=" " val=":"/>
                <OtherNode start="(41, 68)" end="(41, 80)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(41, 68)" end="(41, 73)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(41, 68)" end="(41, 69)" leading="" trailing="" val="("/>
                    <OtherNode start="(41, 69)" end="(41, 72)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(41, 69)" end="(41, 70)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(41, 71)" end="(41, 72)">
                        <IdentNode start="(41, 71)" end="(41, 72)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(41, 72)" end="(41, 73)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(41, 73)" end="(41, 74)" leading="" trailing="" val="."/>
                  <IdentNode start="(41, 74)" end="(41, 80)" leading="" trailing="" raw_val="isNone" val="isNone" full_name="Option.isNone" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(41, 80)" end="(41, 81)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(41, 82)" end="(41, 130)">
            <AtomNode start="(41, 82)" end="(41, 83)" leading="" trailing=" " val=":"/>
            <OtherNode start="(41, 84)" end="(41, 130)" kind="«term_=_»">
              <OtherNode start="(41, 84)" end="(41, 110)" kind="Lean.Parser.Term.app">
                <OtherNode start="(41, 84)" end="(41, 108)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(41, 84)" end="(41, 95)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(41, 84)" end="(41, 85)" leading="" trailing="" val="("/>
                    <OtherNode start="(41, 85)" end="(41, 94)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(41, 85)" end="(41, 92)" leading="" trailing=" " raw_val="xs.push" val="xs.push"/>
                      <NullNode start="(41, 93)" end="(41, 94)">
                        <IdentNode start="(41, 93)" end="(41, 94)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(41, 94)" end="(41, 95)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(41, 95)" end="(41, 96)" leading="" trailing="" val="."/>
                  <IdentNode start="(41, 96)" end="(41, 108)" leading="" trailing=" " raw_val="findSomeRev?" val="findSomeRev?" full_name="Vector.findSomeRev?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                </OtherNode>
                <NullNode start="(41, 109)" end="(41, 110)">
                  <IdentNode start="(41, 109)" end="(41, 110)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(41, 111)" end="(41, 112)" leading="" trailing=" " val="="/>
              <OtherNode start="(41, 113)" end="(41, 130)" kind="Lean.Parser.Term.app">
                <IdentNode start="(41, 113)" end="(41, 128)" leading="" trailing=" " raw_val="xs.findSomeRev?" val="xs.findSomeRev?"/>
                <NullNode start="(41, 129)" end="(41, 130)">
                  <IdentNode start="(41, 129)" end="(41, 130)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(41, 131)" end="(43, 77)">
          <AtomNode start="(41, 131)" end="(41, 133)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(41, 134)" end="(43, 77)">
            <AtomNode start="(41, 134)" end="(41, 136)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(42, 3)" end="(43, 77)">
              <TacticTacticseq1IndentedNode start="(42, 3)" end="(43, 77)">
                <NullNode start="(42, 3)" end="(43, 77)">
                  <OtherNode start="(42, 3)" end="(42, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;n : Nat&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;a : α&#10;xs : Vector α n&#10;h : (f a).isNone = true&#10;⊢ findSomeRev? f (xs.push a) = findSomeRev? f xs" state_after="case mk&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;a : α&#10;h : (f a).isNone = true&#10;xs : Array α&#10;⊢ findSomeRev? f ({ toArray := xs, size_toArray := ⋯ }.push a) = findSomeRev? f { toArray := xs, size_toArray := ⋯ }" tactic="rcases xs with ⟨xs, rfl⟩">
                    <AtomNode start="(42, 3)" end="(42, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(42, 10)" end="(42, 12)">
                      <OtherNode start="(42, 10)" end="(42, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(42, 10)" end="(42, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(42, 13)" end="(42, 27)">
                      <AtomNode start="(42, 13)" end="(42, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(42, 18)" end="(42, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(42, 18)" end="(42, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(42, 18)" end="(42, 27)">
                            <OtherNode start="(42, 18)" end="(42, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(42, 18)" end="(42, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(42, 19)" end="(42, 26)">
                                <OtherNode start="(42, 19)" end="(42, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(42, 19)" end="(42, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(42, 19)" end="(42, 21)">
                                      <OtherNode start="(42, 19)" end="(42, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(42, 19)" end="(42, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(42, 21)" end="(42, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(42, 23)" end="(42, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(42, 23)" end="(42, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(42, 23)" end="(42, 26)">
                                      <OtherNode start="(42, 23)" end="(42, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(42, 23)" end="(42, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(42, 26)" end="(42, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(43, 3)" end="(43, 77)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;a : α&#10;h : (f a).isNone = true&#10;xs : Array α&#10;⊢ findSomeRev? f ({ toArray := xs, size_toArray := ⋯ }.push a) = findSomeRev? f { toArray := xs, size_toArray := ⋯ }" state_after="no goals" tactic="simp only [push_mk, findSomeRev?_mk, Array.findSomeRev?_push_of_isNone, h]">
                    <AtomNode start="(43, 3)" end="(43, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(43, 8)" end="(43, 12)">
                      <AtomNode start="(43, 8)" end="(43, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(43, 13)" end="(43, 77)">
                      <AtomNode start="(43, 13)" end="(43, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(43, 14)" end="(43, 76)">
                        <OtherNode start="(43, 14)" end="(43, 21)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(43, 14)" end="(43, 21)" leading="" trailing="" raw_val="push_mk" val="push_mk" full_name="Vector.push_mk" mod_name="Init.Data.Vector.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(43, 21)" end="(43, 22)" leading="" trailing=" " val=","/>
                        <OtherNode start="(43, 23)" end="(43, 38)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(43, 23)" end="(43, 38)" leading="" trailing="" raw_val="findSomeRev?_mk" val="findSomeRev?_mk" full_name="Vector.findSomeRev?_mk" mod_name="Init.Data.Vector.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(43, 38)" end="(43, 39)" leading="" trailing=" " val=","/>
                        <OtherNode start="(43, 40)" end="(43, 73)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(43, 40)" end="(43, 73)" leading="" trailing="" raw_val="Array.findSomeRev?_push_of_isNone" val="Array.findSomeRev?_push_of_isNone" full_name="Array.findSomeRev?_push_of_isNone" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean"/>
                        </OtherNode>
                        <AtomNode start="(43, 73)" end="(43, 74)" leading="" trailing=" " val=","/>
                        <OtherNode start="(43, 75)" end="(43, 76)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(43, 75)" end="(43, 76)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(43, 76)" end="(43, 77)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(45, 1)" end="(48, 67)" name="exists_of_findSome?_eq_some" full_name="Vector.exists_of_findSome?_eq_some">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(45, 1)" end="(48, 67)" name="exists_of_findSome?_eq_some" full_name="Vector.exists_of_findSome?_eq_some" _is_private_decl="False">
        <AtomNode start="(45, 1)" end="(45, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(45, 9)" end="(45, 36)">
          <IdentNode start="(45, 9)" end="(45, 36)" leading="" trailing=" " raw_val="exists_of_findSome?_eq_some" val="exists_of_findSome?_eq_some"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(45, 37)" end="(46, 31)">
          <NullNode start="(45, 37)" end="(45, 103)">
            <OtherNode start="(45, 37)" end="(45, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(45, 37)" end="(45, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(45, 38)" end="(45, 39)">
                <IdentNode start="(45, 38)" end="(45, 39)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(45, 40)" end="(45, 54)">
                <AtomNode start="(45, 40)" end="(45, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(45, 42)" end="(45, 54)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(45, 42)" end="(45, 43)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(45, 44)" end="(45, 45)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(45, 46)" end="(45, 54)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(45, 46)" end="(45, 52)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(45, 53)" end="(45, 54)">
                      <IdentNode start="(45, 53)" end="(45, 54)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(45, 54)" end="(45, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(45, 56)" end="(45, 73)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(45, 56)" end="(45, 57)" leading="" trailing="" val="{"/>
              <NullNode start="(45, 57)" end="(45, 59)">
                <IdentNode start="(45, 57)" end="(45, 59)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(45, 60)" end="(45, 72)">
                <AtomNode start="(45, 60)" end="(45, 61)" leading="" trailing=" " val=":"/>
                <OtherNode start="(45, 62)" end="(45, 72)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(45, 62)" end="(45, 68)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(45, 69)" end="(45, 72)">
                    <IdentNode start="(45, 69)" end="(45, 70)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(45, 71)" end="(45, 72)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(45, 72)" end="(45, 73)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(45, 74)" end="(45, 103)">
              <AtomNode start="(45, 74)" end="(45, 75)" leading="" trailing="" val="("/>
              <NullNode start="(45, 75)" end="(45, 76)">
                <IdentNode start="(45, 75)" end="(45, 76)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(45, 77)" end="(45, 102)">
                <AtomNode start="(45, 77)" end="(45, 78)" leading="" trailing=" " val=":"/>
                <OtherNode start="(45, 79)" end="(45, 102)" kind="«term_=_»">
                  <OtherNode start="(45, 79)" end="(45, 93)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(45, 79)" end="(45, 91)" leading="" trailing=" " raw_val="xs.findSome?" val="xs.findSome?"/>
                    <NullNode start="(45, 92)" end="(45, 93)">
                      <IdentNode start="(45, 92)" end="(45, 93)" leading="" trailing=" " raw_val="f" val="f"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(45, 94)" end="(45, 95)" leading="" trailing=" " val="="/>
                  <OtherNode start="(45, 96)" end="(45, 102)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(45, 96)" end="(45, 100)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(45, 101)" end="(45, 102)">
                      <IdentNode start="(45, 101)" end="(45, 102)" leading="" trailing="" raw_val="b" val="b"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(45, 102)" end="(45, 103)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(45, 104)" end="(46, 31)">
            <AtomNode start="(45, 104)" end="(45, 105)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(46, 5)" end="(46, 31)" kind="«term∃_,_»">
              <AtomNode start="(46, 5)" end="(46, 6)" leading="" trailing=" " val="∃"/>
              <OtherNode start="(46, 7)" end="(46, 8)" kind="Lean.explicitBinders">
                <OtherNode start="(46, 7)" end="(46, 8)" kind="Lean.unbracketedExplicitBinders">
                  <NullNode start="(46, 7)" end="(46, 8)">
                    <LeanBinderidentNode start="(46, 7)" end="(46, 8)">
                      <IdentNode start="(46, 7)" end="(46, 8)" leading="" trailing="" raw_val="a" val="a"/>
                    </LeanBinderidentNode>
                  </NullNode>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(46, 8)" end="(46, 9)" leading="" trailing=" " val=","/>
              <OtherNode start="(46, 10)" end="(46, 31)" kind="«term_∧_»">
                <OtherNode start="(46, 10)" end="(46, 16)" kind="«term_∈_»">
                  <IdentNode start="(46, 10)" end="(46, 11)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(46, 12)" end="(46, 13)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(46, 14)" end="(46, 16)" leading="" trailing=" " raw_val="xs" val="xs"/>
                </OtherNode>
                <AtomNode start="(46, 17)" end="(46, 18)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(46, 19)" end="(46, 31)" kind="«term_=_»">
                  <OtherNode start="(46, 19)" end="(46, 22)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(46, 19)" end="(46, 20)" leading="" trailing=" " raw_val="f" val="f"/>
                    <NullNode start="(46, 21)" end="(46, 22)">
                      <IdentNode start="(46, 21)" end="(46, 22)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(46, 23)" end="(46, 24)" leading="" trailing=" " val="="/>
                  <OtherNode start="(46, 25)" end="(46, 31)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(46, 25)" end="(46, 29)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(46, 30)" end="(46, 31)">
                      <IdentNode start="(46, 30)" end="(46, 31)" leading="" trailing=" " raw_val="b" val="b"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(46, 32)" end="(48, 67)">
          <AtomNode start="(46, 32)" end="(46, 34)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(46, 35)" end="(48, 67)">
            <AtomNode start="(46, 35)" end="(46, 37)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(47, 3)" end="(48, 67)">
              <TacticTacticseq1IndentedNode start="(47, 3)" end="(48, 67)">
                <NullNode start="(47, 3)" end="(48, 67)">
                  <OtherNode start="(47, 3)" end="(47, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;β : Type u_2&#10;n : Nat&#10;b : β&#10;f : α → Option β&#10;xs : Vector α n&#10;w : findSome? f xs = some b&#10;⊢ ∃ a, a ∈ xs ∧ f a = some b" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;b : β&#10;f : α → Option β&#10;xs : Array α&#10;w : findSome? f { toArray := xs, size_toArray := ⋯ } = some b&#10;⊢ ∃ a, a ∈ { toArray := xs, size_toArray := ⋯ } ∧ f a = some b" tactic="rcases xs with ⟨xs, rfl⟩">
                    <AtomNode start="(47, 3)" end="(47, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(47, 10)" end="(47, 12)">
                      <OtherNode start="(47, 10)" end="(47, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(47, 10)" end="(47, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(47, 13)" end="(47, 27)">
                      <AtomNode start="(47, 13)" end="(47, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(47, 18)" end="(47, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(47, 18)" end="(47, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(47, 18)" end="(47, 27)">
                            <OtherNode start="(47, 18)" end="(47, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(47, 18)" end="(47, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(47, 19)" end="(47, 26)">
                                <OtherNode start="(47, 19)" end="(47, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(47, 19)" end="(47, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(47, 19)" end="(47, 21)">
                                      <OtherNode start="(47, 19)" end="(47, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(47, 19)" end="(47, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(47, 21)" end="(47, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(47, 23)" end="(47, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(47, 23)" end="(47, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(47, 23)" end="(47, 26)">
                                      <OtherNode start="(47, 23)" end="(47, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(47, 23)" end="(47, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(47, 26)" end="(47, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(48, 3)" end="(48, 67)" kind="Lean.Parser.Tactic.simpa" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;b : β&#10;f : α → Option β&#10;xs : Array α&#10;w : findSome? f { toArray := xs, size_toArray := ⋯ } = some b&#10;⊢ ∃ a, a ∈ { toArray := xs, size_toArray := ⋯ } ∧ f a = some b" state_after="no goals" tactic="simpa using Array.exists_of_findSome?_eq_some (by simpa using w)">
                    <AtomNode start="(48, 3)" end="(48, 8)" leading="" trailing=" " val="simpa"/>
                    <NullNode/>
                    <NullNode/>
                    <OtherNode start="(48, 9)" end="(48, 67)" kind="Lean.Parser.Tactic.simpaArgsRest">
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(48, 9)" end="(48, 67)">
                        <AtomNode start="(48, 9)" end="(48, 14)" leading="" trailing=" " val="using"/>
                        <OtherNode start="(48, 15)" end="(48, 67)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(48, 15)" end="(48, 48)" leading="" trailing=" " raw_val="Array.exists_of_findSome?_eq_some" val="Array.exists_of_findSome?_eq_some" full_name="Array.exists_of_findSome?_eq_some" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean"/>
                          <NullNode start="(48, 49)" end="(48, 67)">
                            <OtherNode start="(48, 49)" end="(48, 67)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(48, 49)" end="(48, 50)" leading="" trailing="" val="("/>
                              <TermBytacticNode start="(48, 50)" end="(48, 66)">
                                <AtomNode start="(48, 50)" end="(48, 52)" leading="" trailing=" " val="by"/>
                                <TacticTacticseqNode start="(48, 53)" end="(48, 66)">
                                  <TacticTacticseq1IndentedNode start="(48, 53)" end="(48, 66)">
                                    <NullNode start="(48, 53)" end="(48, 66)">
                                      <OtherNode start="(48, 53)" end="(48, 66)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;β : Type u_2&#10;b : β&#10;f : α → Option β&#10;xs : Array α&#10;w : findSome? f { toArray := xs, size_toArray := ⋯ } = some b&#10;⊢ Array.findSome? f xs = some b" state_after="no goals" tactic="simpa using w">
                                        <AtomNode start="(48, 53)" end="(48, 58)" leading="" trailing=" " val="simpa"/>
                                        <NullNode/>
                                        <NullNode/>
                                        <OtherNode start="(48, 59)" end="(48, 66)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode start="(48, 59)" end="(48, 66)">
                                            <AtomNode start="(48, 59)" end="(48, 64)" leading="" trailing=" " val="using"/>
                                            <IdentNode start="(48, 65)" end="(48, 66)" leading="" trailing="" raw_val="w" val="w"/>
                                          </NullNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </NullNode>
                                  </TacticTacticseq1IndentedNode>
                                </TacticTacticseqNode>
                              </TermBytacticNode>
                              <AtomNode start="(48, 66)" end="(48, 67)" leading="" trailing="&#10;&#10;" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(50, 1)" end="(53, 7)" name="findSome?_eq_none_iff" full_name="Vector.findSome?_eq_none_iff">
      <CommandDeclmodifiersNode start="(50, 1)" end="(50, 8)">
        <NullNode/>
        <NullNode start="(50, 1)" end="(50, 8)">
          <OtherNode start="(50, 1)" end="(50, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(50, 1)" end="(50, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(50, 3)" end="(50, 7)">
              <OtherNode start="(50, 3)" end="(50, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(50, 3)" end="(50, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(50, 3)" end="(50, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(50, 7)" end="(50, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(50, 9)" end="(53, 7)" name="findSome?_eq_none_iff" full_name="Vector.findSome?_eq_none_iff" _is_private_decl="False">
        <AtomNode start="(50, 9)" end="(50, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(50, 17)" end="(50, 38)">
          <IdentNode start="(50, 17)" end="(50, 38)" leading="" trailing=" " raw_val="findSome?_eq_none_iff" val="findSome?_eq_none_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(50, 39)" end="(51, 49)">
          <NullNode start="(50, 39)" end="(50, 75)">
            <OtherNode start="(50, 39)" end="(50, 57)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(50, 39)" end="(50, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(50, 40)" end="(50, 41)">
                <IdentNode start="(50, 40)" end="(50, 41)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(50, 42)" end="(50, 56)">
                <AtomNode start="(50, 42)" end="(50, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(50, 44)" end="(50, 56)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(50, 44)" end="(50, 45)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(50, 46)" end="(50, 47)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(50, 48)" end="(50, 56)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(50, 48)" end="(50, 54)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(50, 55)" end="(50, 56)">
                      <IdentNode start="(50, 55)" end="(50, 56)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(50, 56)" end="(50, 57)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(50, 58)" end="(50, 75)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(50, 58)" end="(50, 59)" leading="" trailing="" val="{"/>
              <NullNode start="(50, 59)" end="(50, 61)">
                <IdentNode start="(50, 59)" end="(50, 61)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(50, 62)" end="(50, 74)">
                <AtomNode start="(50, 62)" end="(50, 63)" leading="" trailing=" " val=":"/>
                <OtherNode start="(50, 64)" end="(50, 74)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(50, 64)" end="(50, 70)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(50, 71)" end="(50, 74)">
                    <IdentNode start="(50, 71)" end="(50, 72)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(50, 73)" end="(50, 74)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(50, 74)" end="(50, 75)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(50, 76)" end="(51, 49)">
            <AtomNode start="(50, 76)" end="(50, 77)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(51, 5)" end="(51, 49)" kind="«term_↔_»">
              <OtherNode start="(51, 5)" end="(51, 26)" kind="«term_=_»">
                <OtherNode start="(51, 5)" end="(51, 19)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(51, 5)" end="(51, 17)" leading="" trailing=" " raw_val="xs.findSome?" val="xs.findSome?"/>
                  <NullNode start="(51, 18)" end="(51, 19)">
                    <IdentNode start="(51, 18)" end="(51, 19)" leading="" trailing=" " raw_val="f" val="f"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(51, 20)" end="(51, 21)" leading="" trailing=" " val="="/>
                <IdentNode start="(51, 22)" end="(51, 26)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(51, 27)" end="(51, 28)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(51, 29)" end="(51, 49)" kind="Lean.«term∀__,_»">
                <AtomNode start="(51, 29)" end="(51, 30)" leading="" trailing=" " val="∀"/>
                <LeanBinderidentNode start="(51, 31)" end="(51, 32)">
                  <IdentNode start="(51, 31)" end="(51, 32)" leading="" trailing=" " raw_val="x" val="x"/>
                </LeanBinderidentNode>
                <OtherNode start="(51, 33)" end="(51, 37)" kind="Lean.«binderTerm∈_»">
                  <AtomNode start="(51, 33)" end="(51, 34)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(51, 35)" end="(51, 37)" leading="" trailing="" raw_val="xs" val="xs"/>
                </OtherNode>
                <AtomNode start="(51, 37)" end="(51, 38)" leading="" trailing=" " val=","/>
                <OtherNode start="(51, 39)" end="(51, 49)" kind="«term_=_»">
                  <OtherNode start="(51, 39)" end="(51, 42)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(51, 39)" end="(51, 40)" leading="" trailing=" " raw_val="f" val="f"/>
                    <NullNode start="(51, 41)" end="(51, 42)">
                      <IdentNode start="(51, 41)" end="(51, 42)" leading="" trailing=" " raw_val="x" val="x"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(51, 43)" end="(51, 44)" leading="" trailing=" " val="="/>
                  <IdentNode start="(51, 45)" end="(51, 49)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(51, 50)" end="(53, 7)">
          <AtomNode start="(51, 50)" end="(51, 52)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(51, 53)" end="(53, 7)">
            <AtomNode start="(51, 53)" end="(51, 55)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(52, 3)" end="(53, 7)">
              <TacticTacticseq1IndentedNode start="(52, 3)" end="(53, 7)">
                <NullNode start="(52, 3)" end="(53, 7)">
                  <OtherNode start="(52, 3)" end="(52, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;β : Type u_2&#10;n : Nat&#10;f : α → Option β&#10;xs : Vector α n&#10;⊢ findSome? f xs = none ↔ ∀ (x : α), x ∈ xs → f x = none" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;xs : Array α&#10;⊢ findSome? f { toArray := xs, size_toArray := ⋯ } = none ↔&#10;    ∀ (x : α), x ∈ { toArray := xs, size_toArray := ⋯ } → f x = none" tactic="rcases xs with ⟨xs, rfl⟩">
                    <AtomNode start="(52, 3)" end="(52, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(52, 10)" end="(52, 12)">
                      <OtherNode start="(52, 10)" end="(52, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(52, 10)" end="(52, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(52, 13)" end="(52, 27)">
                      <AtomNode start="(52, 13)" end="(52, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(52, 18)" end="(52, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(52, 18)" end="(52, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(52, 18)" end="(52, 27)">
                            <OtherNode start="(52, 18)" end="(52, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(52, 18)" end="(52, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(52, 19)" end="(52, 26)">
                                <OtherNode start="(52, 19)" end="(52, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(52, 19)" end="(52, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(52, 19)" end="(52, 21)">
                                      <OtherNode start="(52, 19)" end="(52, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(52, 19)" end="(52, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(52, 21)" end="(52, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(52, 23)" end="(52, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(52, 23)" end="(52, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(52, 23)" end="(52, 26)">
                                      <OtherNode start="(52, 23)" end="(52, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(52, 23)" end="(52, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(52, 26)" end="(52, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(53, 3)" end="(53, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;xs : Array α&#10;⊢ findSome? f { toArray := xs, size_toArray := ⋯ } = none ↔&#10;    ∀ (x : α), x ∈ { toArray := xs, size_toArray := ⋯ } → f x = none" state_after="no goals" tactic="simp">
                    <AtomNode start="(53, 3)" end="(53, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(55, 1)" end="(58, 7)" name="findSome?_isSome_iff" full_name="Vector.findSome?_isSome_iff">
      <CommandDeclmodifiersNode start="(55, 1)" end="(55, 8)">
        <NullNode/>
        <NullNode start="(55, 1)" end="(55, 8)">
          <OtherNode start="(55, 1)" end="(55, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(55, 1)" end="(55, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(55, 3)" end="(55, 7)">
              <OtherNode start="(55, 3)" end="(55, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(55, 3)" end="(55, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(55, 3)" end="(55, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(55, 7)" end="(55, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(55, 9)" end="(58, 7)" name="findSome?_isSome_iff" full_name="Vector.findSome?_isSome_iff" _is_private_decl="False">
        <AtomNode start="(55, 9)" end="(55, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(55, 17)" end="(55, 37)">
          <IdentNode start="(55, 17)" end="(55, 37)" leading="" trailing=" " raw_val="findSome?_isSome_iff" val="findSome?_isSome_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(55, 38)" end="(56, 57)">
          <NullNode start="(55, 38)" end="(55, 74)">
            <OtherNode start="(55, 38)" end="(55, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(55, 38)" end="(55, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(55, 39)" end="(55, 40)">
                <IdentNode start="(55, 39)" end="(55, 40)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(55, 41)" end="(55, 55)">
                <AtomNode start="(55, 41)" end="(55, 42)" leading="" trailing=" " val=":"/>
                <OtherNode start="(55, 43)" end="(55, 55)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(55, 43)" end="(55, 44)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(55, 45)" end="(55, 46)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(55, 47)" end="(55, 55)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(55, 47)" end="(55, 53)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(55, 54)" end="(55, 55)">
                      <IdentNode start="(55, 54)" end="(55, 55)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(55, 55)" end="(55, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(55, 57)" end="(55, 74)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(55, 57)" end="(55, 58)" leading="" trailing="" val="{"/>
              <NullNode start="(55, 58)" end="(55, 60)">
                <IdentNode start="(55, 58)" end="(55, 60)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(55, 61)" end="(55, 73)">
                <AtomNode start="(55, 61)" end="(55, 62)" leading="" trailing=" " val=":"/>
                <OtherNode start="(55, 63)" end="(55, 73)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(55, 63)" end="(55, 69)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(55, 70)" end="(55, 73)">
                    <IdentNode start="(55, 70)" end="(55, 71)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(55, 72)" end="(55, 73)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(55, 73)" end="(55, 74)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(55, 75)" end="(56, 57)">
            <AtomNode start="(55, 75)" end="(55, 76)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(56, 5)" end="(56, 57)" kind="«term_↔_»">
              <OtherNode start="(56, 5)" end="(56, 28)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(56, 5)" end="(56, 21)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(56, 5)" end="(56, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(56, 6)" end="(56, 20)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(56, 6)" end="(56, 18)" leading="" trailing=" " raw_val="xs.findSome?" val="xs.findSome?"/>
                    <NullNode start="(56, 19)" end="(56, 20)">
                      <IdentNode start="(56, 19)" end="(56, 20)" leading="" trailing="" raw_val="f" val="f"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(56, 20)" end="(56, 21)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(56, 21)" end="(56, 22)" leading="" trailing="" val="."/>
                <IdentNode start="(56, 22)" end="(56, 28)" leading="" trailing=" " raw_val="isSome" val="isSome" full_name="Option.isSome" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(56, 29)" end="(56, 30)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(56, 31)" end="(56, 57)" kind="«term∃_,_»">
                <AtomNode start="(56, 31)" end="(56, 32)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(56, 33)" end="(56, 34)" kind="Lean.explicitBinders">
                  <OtherNode start="(56, 33)" end="(56, 34)" kind="Lean.unbracketedExplicitBinders">
                    <NullNode start="(56, 33)" end="(56, 34)">
                      <LeanBinderidentNode start="(56, 33)" end="(56, 34)">
                        <IdentNode start="(56, 33)" end="(56, 34)" leading="" trailing="" raw_val="x" val="x"/>
                      </LeanBinderidentNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(56, 34)" end="(56, 35)" leading="" trailing=" " val=","/>
                <OtherNode start="(56, 36)" end="(56, 57)" kind="«term_∧_»">
                  <OtherNode start="(56, 36)" end="(56, 42)" kind="«term_∈_»">
                    <IdentNode start="(56, 36)" end="(56, 37)" leading="" trailing=" " raw_val="x" val="x"/>
                    <AtomNode start="(56, 38)" end="(56, 39)" leading="" trailing=" " val="∈"/>
                    <IdentNode start="(56, 40)" end="(56, 42)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  </OtherNode>
                  <AtomNode start="(56, 43)" end="(56, 44)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(56, 45)" end="(56, 57)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(56, 45)" end="(56, 50)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(56, 45)" end="(56, 46)" leading="" trailing="" val="("/>
                      <OtherNode start="(56, 46)" end="(56, 49)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(56, 46)" end="(56, 47)" leading="" trailing=" " raw_val="f" val="f"/>
                        <NullNode start="(56, 48)" end="(56, 49)">
                          <IdentNode start="(56, 48)" end="(56, 49)" leading="" trailing="" raw_val="x" val="x"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(56, 49)" end="(56, 50)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(56, 50)" end="(56, 51)" leading="" trailing="" val="."/>
                    <IdentNode start="(56, 51)" end="(56, 57)" leading="" trailing=" " raw_val="isSome" val="isSome" full_name="Option.isSome" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(56, 58)" end="(58, 7)">
          <AtomNode start="(56, 58)" end="(56, 60)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(56, 61)" end="(58, 7)">
            <AtomNode start="(56, 61)" end="(56, 63)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(57, 3)" end="(58, 7)">
              <TacticTacticseq1IndentedNode start="(57, 3)" end="(58, 7)">
                <NullNode start="(57, 3)" end="(58, 7)">
                  <OtherNode start="(57, 3)" end="(57, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;β : Type u_2&#10;n : Nat&#10;f : α → Option β&#10;xs : Vector α n&#10;⊢ (findSome? f xs).isSome = true ↔ ∃ x, x ∈ xs ∧ (f x).isSome = true" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;xs : Array α&#10;⊢ (findSome? f { toArray := xs, size_toArray := ⋯ }).isSome = true ↔&#10;    ∃ x, x ∈ { toArray := xs, size_toArray := ⋯ } ∧ (f x).isSome = true" tactic="rcases xs with ⟨xs, rfl⟩">
                    <AtomNode start="(57, 3)" end="(57, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(57, 10)" end="(57, 12)">
                      <OtherNode start="(57, 10)" end="(57, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(57, 10)" end="(57, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(57, 13)" end="(57, 27)">
                      <AtomNode start="(57, 13)" end="(57, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(57, 18)" end="(57, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(57, 18)" end="(57, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(57, 18)" end="(57, 27)">
                            <OtherNode start="(57, 18)" end="(57, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(57, 18)" end="(57, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(57, 19)" end="(57, 26)">
                                <OtherNode start="(57, 19)" end="(57, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(57, 19)" end="(57, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(57, 19)" end="(57, 21)">
                                      <OtherNode start="(57, 19)" end="(57, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(57, 19)" end="(57, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(57, 21)" end="(57, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(57, 23)" end="(57, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(57, 23)" end="(57, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(57, 23)" end="(57, 26)">
                                      <OtherNode start="(57, 23)" end="(57, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(57, 23)" end="(57, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(57, 26)" end="(57, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(58, 3)" end="(58, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;xs : Array α&#10;⊢ (findSome? f { toArray := xs, size_toArray := ⋯ }).isSome = true ↔&#10;    ∃ x, x ∈ { toArray := xs, size_toArray := ⋯ } ∧ (f x).isSome = true" state_after="no goals" tactic="simp">
                    <AtomNode start="(58, 3)" end="(58, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(60, 1)" end="(71, 74)" name="findSome?_eq_some_iff" full_name="Vector.findSome?_eq_some_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(60, 1)" end="(71, 74)" name="findSome?_eq_some_iff" full_name="Vector.findSome?_eq_some_iff" _is_private_decl="False">
        <AtomNode start="(60, 1)" end="(60, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(60, 9)" end="(60, 30)">
          <IdentNode start="(60, 9)" end="(60, 30)" leading="" trailing=" " raw_val="findSome?_eq_some_iff" val="findSome?_eq_some_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(60, 31)" end="(63, 81)">
          <NullNode start="(60, 31)" end="(60, 75)">
            <OtherNode start="(60, 31)" end="(60, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(60, 31)" end="(60, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(60, 32)" end="(60, 33)">
                <IdentNode start="(60, 32)" end="(60, 33)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(60, 34)" end="(60, 48)">
                <AtomNode start="(60, 34)" end="(60, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(60, 36)" end="(60, 48)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(60, 36)" end="(60, 37)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(60, 38)" end="(60, 39)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(60, 40)" end="(60, 48)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(60, 40)" end="(60, 46)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(60, 47)" end="(60, 48)">
                      <IdentNode start="(60, 47)" end="(60, 48)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(60, 48)" end="(60, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(60, 50)" end="(60, 67)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(60, 50)" end="(60, 51)" leading="" trailing="" val="{"/>
              <NullNode start="(60, 51)" end="(60, 53)">
                <IdentNode start="(60, 51)" end="(60, 53)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(60, 54)" end="(60, 66)">
                <AtomNode start="(60, 54)" end="(60, 55)" leading="" trailing=" " val=":"/>
                <OtherNode start="(60, 56)" end="(60, 66)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(60, 56)" end="(60, 62)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(60, 63)" end="(60, 66)">
                    <IdentNode start="(60, 63)" end="(60, 64)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(60, 65)" end="(60, 66)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(60, 66)" end="(60, 67)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(60, 68)" end="(60, 75)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(60, 68)" end="(60, 69)" leading="" trailing="" val="{"/>
              <NullNode start="(60, 69)" end="(60, 70)">
                <IdentNode start="(60, 69)" end="(60, 70)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(60, 71)" end="(60, 74)">
                <AtomNode start="(60, 71)" end="(60, 72)" leading="" trailing=" " val=":"/>
                <IdentNode start="(60, 73)" end="(60, 74)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(60, 74)" end="(60, 75)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(60, 76)" end="(63, 81)">
            <AtomNode start="(60, 76)" end="(60, 77)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(61, 5)" end="(63, 81)" kind="«term_↔_»">
              <OtherNode start="(61, 5)" end="(61, 28)" kind="«term_=_»">
                <OtherNode start="(61, 5)" end="(61, 19)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(61, 5)" end="(61, 17)" leading="" trailing=" " raw_val="xs.findSome?" val="xs.findSome?"/>
                  <NullNode start="(61, 18)" end="(61, 19)">
                    <IdentNode start="(61, 18)" end="(61, 19)" leading="" trailing=" " raw_val="f" val="f"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(61, 20)" end="(61, 21)" leading="" trailing=" " val="="/>
                <OtherNode start="(61, 22)" end="(61, 28)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(61, 22)" end="(61, 26)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(61, 27)" end="(61, 28)">
                    <IdentNode start="(61, 27)" end="(61, 28)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(61, 29)" end="(61, 30)" leading="" trailing="&#10;      " val="↔"/>
              <OtherNode start="(62, 7)" end="(63, 81)" kind="«term∃_,_»">
                <AtomNode start="(62, 7)" end="(62, 8)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(62, 9)" end="(62, 90)" kind="Lean.explicitBinders">
                  <NullNode start="(62, 9)" end="(62, 90)">
                    <OtherNode start="(62, 9)" end="(62, 22)" kind="Lean.bracketedExplicitBinders">
                      <AtomNode start="(62, 9)" end="(62, 10)" leading="" trailing="" val="("/>
                      <NullNode start="(62, 10)" end="(62, 15)">
                        <LeanBinderidentNode start="(62, 10)" end="(62, 12)">
                          <IdentNode start="(62, 10)" end="(62, 12)" leading="" trailing=" " raw_val="k₁" val="k₁"/>
                        </LeanBinderidentNode>
                        <LeanBinderidentNode start="(62, 13)" end="(62, 15)">
                          <IdentNode start="(62, 13)" end="(62, 15)" leading="" trailing=" " raw_val="k₂" val="k₂"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <AtomNode start="(62, 16)" end="(62, 17)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(62, 18)" end="(62, 21)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <AtomNode start="(62, 21)" end="(62, 22)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(62, 23)" end="(62, 44)" kind="Lean.bracketedExplicitBinders">
                      <AtomNode start="(62, 23)" end="(62, 24)" leading="" trailing="" val="("/>
                      <NullNode start="(62, 24)" end="(62, 25)">
                        <LeanBinderidentNode start="(62, 24)" end="(62, 25)">
                          <IdentNode start="(62, 24)" end="(62, 25)" leading="" trailing=" " raw_val="w" val="w"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <AtomNode start="(62, 26)" end="(62, 27)" leading="" trailing=" " val=":"/>
                      <OtherNode start="(62, 28)" end="(62, 43)" kind="«term_=_»">
                        <IdentNode start="(62, 28)" end="(62, 29)" leading="" trailing=" " raw_val="n" val="n"/>
                        <AtomNode start="(62, 30)" end="(62, 31)" leading="" trailing=" " val="="/>
                        <OtherNode start="(62, 32)" end="(62, 43)" kind="«term_+_»">
                          <OtherNode start="(62, 32)" end="(62, 38)" kind="«term_+_»">
                            <IdentNode start="(62, 32)" end="(62, 34)" leading="" trailing=" " raw_val="k₁" val="k₁"/>
                            <AtomNode start="(62, 35)" end="(62, 36)" leading="" trailing=" " val="+"/>
                            <OtherNode start="(62, 37)" end="(62, 38)" kind="num">
                              <AtomNode start="(62, 37)" end="(62, 38)" leading="" trailing=" " val="1"/>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(62, 39)" end="(62, 40)" leading="" trailing=" " val="+"/>
                          <IdentNode start="(62, 41)" end="(62, 43)" leading="" trailing="" raw_val="k₂" val="k₂"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(62, 43)" end="(62, 44)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(62, 45)" end="(62, 63)" kind="Lean.bracketedExplicitBinders">
                      <AtomNode start="(62, 45)" end="(62, 46)" leading="" trailing="" val="("/>
                      <NullNode start="(62, 46)" end="(62, 48)">
                        <LeanBinderidentNode start="(62, 46)" end="(62, 48)">
                          <IdentNode start="(62, 46)" end="(62, 48)" leading="" trailing=" " raw_val="ys" val="ys"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <AtomNode start="(62, 49)" end="(62, 50)" leading="" trailing=" " val=":"/>
                      <OtherNode start="(62, 51)" end="(62, 62)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(62, 51)" end="(62, 57)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                        <NullNode start="(62, 58)" end="(62, 62)">
                          <IdentNode start="(62, 58)" end="(62, 59)" leading="" trailing=" " raw_val="α" val="α"/>
                          <IdentNode start="(62, 60)" end="(62, 62)" leading="" trailing="" raw_val="k₁" val="k₁"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(62, 62)" end="(62, 63)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(62, 64)" end="(62, 71)" kind="Lean.bracketedExplicitBinders">
                      <AtomNode start="(62, 64)" end="(62, 65)" leading="" trailing="" val="("/>
                      <NullNode start="(62, 65)" end="(62, 66)">
                        <LeanBinderidentNode start="(62, 65)" end="(62, 66)">
                          <IdentNode start="(62, 65)" end="(62, 66)" leading="" trailing=" " raw_val="a" val="a"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <AtomNode start="(62, 67)" end="(62, 68)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(62, 69)" end="(62, 70)" leading="" trailing="" raw_val="α" val="α"/>
                      <AtomNode start="(62, 70)" end="(62, 71)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <OtherNode start="(62, 72)" end="(62, 90)" kind="Lean.bracketedExplicitBinders">
                      <AtomNode start="(62, 72)" end="(62, 73)" leading="" trailing="" val="("/>
                      <NullNode start="(62, 73)" end="(62, 75)">
                        <LeanBinderidentNode start="(62, 73)" end="(62, 75)">
                          <IdentNode start="(62, 73)" end="(62, 75)" leading="" trailing=" " raw_val="zs" val="zs"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <AtomNode start="(62, 76)" end="(62, 77)" leading="" trailing=" " val=":"/>
                      <OtherNode start="(62, 78)" end="(62, 89)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(62, 78)" end="(62, 84)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                        <NullNode start="(62, 85)" end="(62, 89)">
                          <IdentNode start="(62, 85)" end="(62, 86)" leading="" trailing=" " raw_val="α" val="α"/>
                          <IdentNode start="(62, 87)" end="(62, 89)" leading="" trailing="" raw_val="k₂" val="k₂"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(62, 89)" end="(62, 90)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(62, 90)" end="(62, 91)" leading="" trailing="&#10;        " val=","/>
                <OtherNode start="(63, 9)" end="(63, 81)" kind="«term_∧_»">
                  <OtherNode start="(63, 9)" end="(63, 43)" kind="«term_=_»">
                    <IdentNode start="(63, 9)" end="(63, 11)" leading="" trailing=" " raw_val="xs" val="xs"/>
                    <AtomNode start="(63, 12)" end="(63, 13)" leading="" trailing=" " val="="/>
                    <OtherNode start="(63, 14)" end="(63, 43)" kind="Lean.Parser.Term.app">
                      <OtherNode start="(63, 14)" end="(63, 36)" kind="Lean.Parser.Term.proj">
                        <OtherNode start="(63, 14)" end="(63, 31)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(63, 14)" end="(63, 15)" leading="" trailing="" val="("/>
                          <OtherNode start="(63, 15)" end="(63, 30)" kind="«term_++_»">
                            <OtherNode start="(63, 15)" end="(63, 24)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(63, 15)" end="(63, 22)" leading="" trailing=" " raw_val="ys.push" val="ys.push"/>
                              <NullNode start="(63, 23)" end="(63, 24)">
                                <IdentNode start="(63, 23)" end="(63, 24)" leading="" trailing=" " raw_val="a" val="a"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(63, 25)" end="(63, 27)" leading="" trailing=" " val="++"/>
                            <IdentNode start="(63, 28)" end="(63, 30)" leading="" trailing="" raw_val="zs" val="zs"/>
                          </OtherNode>
                          <AtomNode start="(63, 30)" end="(63, 31)" leading="" trailing="" val=")"/>
                        </OtherNode>
                        <AtomNode start="(63, 31)" end="(63, 32)" leading="" trailing="" val="."/>
                        <IdentNode start="(63, 32)" end="(63, 36)" leading="" trailing=" " raw_val="cast" val="cast" full_name="Vector.cast" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                      </OtherNode>
                      <NullNode start="(63, 37)" end="(63, 43)">
                        <IdentNode start="(63, 37)" end="(63, 43)" leading="" trailing=" " raw_val="w.symm" val="w.symm"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(63, 44)" end="(63, 45)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(63, 46)" end="(63, 81)" kind="«term_∧_»">
                    <OtherNode start="(63, 46)" end="(63, 58)" kind="«term_=_»">
                      <OtherNode start="(63, 46)" end="(63, 49)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(63, 46)" end="(63, 47)" leading="" trailing=" " raw_val="f" val="f"/>
                        <NullNode start="(63, 48)" end="(63, 49)">
                          <IdentNode start="(63, 48)" end="(63, 49)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(63, 50)" end="(63, 51)" leading="" trailing=" " val="="/>
                      <OtherNode start="(63, 52)" end="(63, 58)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(63, 52)" end="(63, 56)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(63, 57)" end="(63, 58)">
                          <IdentNode start="(63, 57)" end="(63, 58)" leading="" trailing=" " raw_val="b" val="b"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(63, 59)" end="(63, 60)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(63, 61)" end="(63, 81)" kind="Lean.«term∀__,_»">
                      <AtomNode start="(63, 61)" end="(63, 62)" leading="" trailing=" " val="∀"/>
                      <LeanBinderidentNode start="(63, 63)" end="(63, 64)">
                        <IdentNode start="(63, 63)" end="(63, 64)" leading="" trailing=" " raw_val="x" val="x"/>
                      </LeanBinderidentNode>
                      <OtherNode start="(63, 65)" end="(63, 69)" kind="Lean.«binderTerm∈_»">
                        <AtomNode start="(63, 65)" end="(63, 66)" leading="" trailing=" " val="∈"/>
                        <IdentNode start="(63, 67)" end="(63, 69)" leading="" trailing="" raw_val="ys" val="ys"/>
                      </OtherNode>
                      <AtomNode start="(63, 69)" end="(63, 70)" leading="" trailing=" " val=","/>
                      <OtherNode start="(63, 71)" end="(63, 81)" kind="«term_=_»">
                        <OtherNode start="(63, 71)" end="(63, 74)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(63, 71)" end="(63, 72)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode start="(63, 73)" end="(63, 74)">
                            <IdentNode start="(63, 73)" end="(63, 74)" leading="" trailing=" " raw_val="x" val="x"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(63, 75)" end="(63, 76)" leading="" trailing=" " val="="/>
                        <IdentNode start="(63, 77)" end="(63, 81)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(63, 82)" end="(71, 74)">
          <AtomNode start="(63, 82)" end="(63, 84)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(63, 85)" end="(71, 74)">
            <AtomNode start="(63, 85)" end="(63, 87)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(64, 3)" end="(71, 74)">
              <TacticTacticseq1IndentedNode start="(64, 3)" end="(71, 74)">
                <NullNode start="(64, 3)" end="(71, 74)">
                  <OtherNode start="(64, 3)" end="(64, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;β : Type u_2&#10;n : Nat&#10;f : α → Option β&#10;xs : Vector α n&#10;b : β&#10;⊢ findSome? f xs = some b ↔&#10;    ∃ k₁ k₂ w ys a zs, xs = Vector.cast ⋯ (ys.push a ++ zs) ∧ f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;xs : Array α&#10;⊢ findSome? f { toArray := xs, size_toArray := ⋯ } = some b ↔&#10;    ∃ k₁ k₂ w ys a zs,&#10;      { toArray := xs, size_toArray := ⋯ } = Vector.cast ⋯ (ys.push a ++ zs) ∧&#10;        f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none" tactic="rcases xs with ⟨xs, rfl⟩">
                    <AtomNode start="(64, 3)" end="(64, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(64, 10)" end="(64, 12)">
                      <OtherNode start="(64, 10)" end="(64, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(64, 10)" end="(64, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(64, 13)" end="(64, 27)">
                      <AtomNode start="(64, 13)" end="(64, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(64, 18)" end="(64, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(64, 18)" end="(64, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(64, 18)" end="(64, 27)">
                            <OtherNode start="(64, 18)" end="(64, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(64, 18)" end="(64, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(64, 19)" end="(64, 26)">
                                <OtherNode start="(64, 19)" end="(64, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(64, 19)" end="(64, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(64, 19)" end="(64, 21)">
                                      <OtherNode start="(64, 19)" end="(64, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(64, 19)" end="(64, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(64, 21)" end="(64, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(64, 23)" end="(64, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(64, 23)" end="(64, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(64, 23)" end="(64, 26)">
                                      <OtherNode start="(64, 23)" end="(64, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(64, 23)" end="(64, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(64, 26)" end="(64, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(65, 3)" end="(65, 34)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;xs : Array α&#10;⊢ findSome? f { toArray := xs, size_toArray := ⋯ } = some b ↔&#10;    ∃ k₁ k₂ w ys a zs,&#10;      { toArray := xs, size_toArray := ⋯ } = Vector.cast ⋯ (ys.push a ++ zs) ∧&#10;        f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;xs : Array α&#10;⊢ Array.findSome? f xs = some b ↔&#10;    ∃ k₁ k₂ h ys a zs, xs = (Vector.cast ⋯ (ys.push a ++ zs)).toArray ∧ f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none" tactic="simp only [findSome?_mk, mk_eq]">
                    <AtomNode start="(65, 3)" end="(65, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(65, 8)" end="(65, 12)">
                      <AtomNode start="(65, 8)" end="(65, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(65, 13)" end="(65, 34)">
                      <AtomNode start="(65, 13)" end="(65, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(65, 14)" end="(65, 33)">
                        <OtherNode start="(65, 14)" end="(65, 26)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(65, 14)" end="(65, 26)" leading="" trailing="" raw_val="findSome?_mk" val="findSome?_mk" full_name="Vector.findSome?_mk" mod_name="Init.Data.Vector.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(65, 26)" end="(65, 27)" leading="" trailing=" " val=","/>
                        <OtherNode start="(65, 28)" end="(65, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(65, 28)" end="(65, 33)" leading="" trailing="" raw_val="mk_eq" val="mk_eq" full_name="Vector.mk_eq" mod_name="Init.Data.Vector.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(65, 33)" end="(65, 34)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(66, 3)" end="(66, 35)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;xs : Array α&#10;⊢ Array.findSome? f xs = some b ↔&#10;    ∃ k₁ k₂ h ys a zs, xs = (Vector.cast ⋯ (ys.push a ++ zs)).toArray ∧ f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;xs : Array α&#10;⊢ (∃ ys a zs, xs = ys.push a ++ zs ∧ f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none) ↔&#10;    ∃ k₁ k₂ h ys a zs, xs = (Vector.cast ⋯ (ys.push a ++ zs)).toArray ∧ f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none" tactic="rw [Array.findSome?_eq_some_iff]">
                    <AtomNode start="(66, 3)" end="(66, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(66, 6)" end="(66, 35)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(66, 6)" end="(66, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(66, 7)" end="(66, 34)">
                        <OtherNode start="(66, 7)" end="(66, 34)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(66, 7)" end="(66, 34)" leading="" trailing="" raw_val="Array.findSome?_eq_some_iff" val="Array.findSome?_eq_some_iff" full_name="Array.findSome?_eq_some_iff" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(66, 34)" end="(66, 35)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(67, 3)" end="(67, 14)" kind="Lean.Parser.Tactic.constructor" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;xs : Array α&#10;⊢ (∃ ys a zs, xs = ys.push a ++ zs ∧ f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none) ↔&#10;    ∃ k₁ k₂ h ys a zs, xs = (Vector.cast ⋯ (ys.push a ++ zs)).toArray ∧ f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none" state_after="case mk.mp&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;xs : Array α&#10;⊢ (∃ ys a zs, xs = ys.push a ++ zs ∧ f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none) →&#10;    ∃ k₁ k₂ h ys a zs, xs = (Vector.cast ⋯ (ys.push a ++ zs)).toArray ∧ f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none&#10;&#10;case mk.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;xs : Array α&#10;⊢ (∃ k₁ k₂ h ys a zs, xs = (Vector.cast ⋯ (ys.push a ++ zs)).toArray ∧ f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none) →&#10;    ∃ ys a zs, xs = ys.push a ++ zs ∧ f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none" tactic="constructor">
                    <AtomNode start="(67, 3)" end="(67, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(68, 3)" end="(69, 95)" kind="Lean.cdot" state_before="case mk.mp&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;xs : Array α&#10;⊢ (∃ ys a zs, xs = ys.push a ++ zs ∧ f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none) →&#10;    ∃ k₁ k₂ h ys a zs, xs = (Vector.cast ⋯ (ys.push a ++ zs)).toArray ∧ f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none&#10;&#10;case mk.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;xs : Array α&#10;⊢ (∃ k₁ k₂ h ys a zs, xs = (Vector.cast ⋯ (ys.push a ++ zs)).toArray ∧ f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none) →&#10;    ∃ ys a zs, xs = ys.push a ++ zs ∧ f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none" state_after="case mk.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;xs : Array α&#10;⊢ (∃ k₁ k₂ h ys a zs, xs = (Vector.cast ⋯ (ys.push a ++ zs)).toArray ∧ f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none) →&#10;    ∃ ys a zs, xs = ys.push a ++ zs ∧ f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none" tactic="· rintro ⟨ys, a, zs, rfl, h₁, h₂⟩&#10;  exact ⟨ys.size, zs.size, by simp, ⟨ys, rfl⟩, a, ⟨zs, rfl⟩, by simp, h₁, by simpa using h₂⟩">
                    <OtherNode start="(68, 3)" end="(68, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(68, 3)" end="(68, 4)" kind="patternIgnore">
                        <OtherNode start="(68, 3)" end="(68, 4)" kind="token.«· »">
                          <AtomNode start="(68, 3)" end="(68, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(68, 5)" end="(69, 95)">
                      <TacticTacticseq1IndentedNode start="(68, 5)" end="(69, 95)">
                        <NullNode start="(68, 5)" end="(69, 95)">
                          <OtherNode start="(68, 5)" end="(68, 36)" kind="Lean.Parser.Tactic.rintro" state_before="case mk.mp&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;xs : Array α&#10;⊢ (∃ ys a zs, xs = ys.push a ++ zs ∧ f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none) →&#10;    ∃ k₁ k₂ h ys a zs, xs = (Vector.cast ⋯ (ys.push a ++ zs)).toArray ∧ f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none" state_after="case mk.mp.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;ys : Array α&#10;a : α&#10;zs : Array α&#10;h₁ : f a = some b&#10;h₂ : ∀ (x : α), x ∈ ys → f x = none&#10;⊢ ∃ k₁ k₂ h ys_1 a_1 zs_1,&#10;    ys.push a ++ zs = (Vector.cast ⋯ (ys_1.push a_1 ++ zs_1)).toArray ∧&#10;      f a_1 = some b ∧ ∀ (x : α), x ∈ ys_1 → f x = none" tactic="rintro ⟨ys, a, zs, rfl, h₁, h₂⟩">
                            <AtomNode start="(68, 5)" end="(68, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(68, 12)" end="(68, 36)">
                              <OtherNode start="(68, 12)" end="(68, 36)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(68, 12)" end="(68, 36)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                  <AtomNode start="(68, 12)" end="(68, 13)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(68, 13)" end="(68, 35)">
                                    <OtherNode start="(68, 13)" end="(68, 15)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(68, 13)" end="(68, 15)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(68, 13)" end="(68, 15)">
                                          <OtherNode start="(68, 13)" end="(68, 15)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(68, 13)" end="(68, 15)" leading="" trailing="" raw_val="ys" val="ys"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(68, 15)" end="(68, 16)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(68, 17)" end="(68, 18)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(68, 17)" end="(68, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(68, 17)" end="(68, 18)">
                                          <OtherNode start="(68, 17)" end="(68, 18)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(68, 17)" end="(68, 18)" leading="" trailing="" raw_val="a" val="a"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(68, 18)" end="(68, 19)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(68, 20)" end="(68, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(68, 20)" end="(68, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(68, 20)" end="(68, 22)">
                                          <OtherNode start="(68, 20)" end="(68, 22)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(68, 20)" end="(68, 22)" leading="" trailing="" raw_val="zs" val="zs"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(68, 22)" end="(68, 23)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(68, 24)" end="(68, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(68, 24)" end="(68, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(68, 24)" end="(68, 27)">
                                          <OtherNode start="(68, 24)" end="(68, 27)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(68, 24)" end="(68, 27)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(68, 27)" end="(68, 28)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(68, 29)" end="(68, 31)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(68, 29)" end="(68, 31)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(68, 29)" end="(68, 31)">
                                          <OtherNode start="(68, 29)" end="(68, 31)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(68, 29)" end="(68, 31)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(68, 31)" end="(68, 32)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(68, 33)" end="(68, 35)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(68, 33)" end="(68, 35)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(68, 33)" end="(68, 35)">
                                          <OtherNode start="(68, 33)" end="(68, 35)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(68, 33)" end="(68, 35)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(68, 35)" end="(68, 36)" leading="" trailing="&#10;    " val="⟩"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(69, 5)" end="(69, 95)" kind="Lean.Parser.Tactic.exact" state_before="case mk.mp.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;ys : Array α&#10;a : α&#10;zs : Array α&#10;h₁ : f a = some b&#10;h₂ : ∀ (x : α), x ∈ ys → f x = none&#10;⊢ ∃ k₁ k₂ h ys_1 a_1 zs_1,&#10;    ys.push a ++ zs = (Vector.cast ⋯ (ys_1.push a_1 ++ zs_1)).toArray ∧&#10;      f a_1 = some b ∧ ∀ (x : α), x ∈ ys_1 → f x = none" state_after="no goals" tactic="exact ⟨ys.size, zs.size, by simp, ⟨ys, rfl⟩, a, ⟨zs, rfl⟩, by simp, h₁, by simpa using h₂⟩">
                            <AtomNode start="(69, 5)" end="(69, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(69, 11)" end="(69, 95)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(69, 11)" end="(69, 12)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(69, 12)" end="(69, 94)">
                                <IdentNode start="(69, 12)" end="(69, 19)" leading="" trailing="" raw_val="ys.size" val="ys.size"/>
                                <AtomNode start="(69, 19)" end="(69, 20)" leading="" trailing=" " val=","/>
                                <IdentNode start="(69, 21)" end="(69, 28)" leading="" trailing="" raw_val="zs.size" val="zs.size"/>
                                <AtomNode start="(69, 28)" end="(69, 29)" leading="" trailing=" " val=","/>
                                <TermBytacticNode start="(69, 30)" end="(69, 37)">
                                  <AtomNode start="(69, 30)" end="(69, 32)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(69, 33)" end="(69, 37)">
                                    <TacticTacticseq1IndentedNode start="(69, 33)" end="(69, 37)">
                                      <NullNode start="(69, 33)" end="(69, 37)">
                                        <OtherNode start="(69, 33)" end="(69, 37)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;ys : Array α&#10;a : α&#10;zs : Array α&#10;h₁ : f a = some b&#10;h₂ : ∀ (x : α), x ∈ ys → f x = none&#10;⊢ (ys.push a ++ zs).size = ys.size + 1 + zs.size" state_after="no goals" tactic="simp">
                                          <AtomNode start="(69, 33)" end="(69, 37)" leading="" trailing="" val="simp"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                                <AtomNode start="(69, 37)" end="(69, 38)" leading="" trailing=" " val=","/>
                                <OtherNode start="(69, 39)" end="(69, 48)" kind="Lean.Parser.Term.anonymousCtor">
                                  <AtomNode start="(69, 39)" end="(69, 40)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(69, 40)" end="(69, 47)">
                                    <IdentNode start="(69, 40)" end="(69, 42)" leading="" trailing="" raw_val="ys" val="ys"/>
                                    <AtomNode start="(69, 42)" end="(69, 43)" leading="" trailing=" " val=","/>
                                    <IdentNode start="(69, 44)" end="(69, 47)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  </NullNode>
                                  <AtomNode start="(69, 47)" end="(69, 48)" leading="" trailing="" val="⟩"/>
                                </OtherNode>
                                <AtomNode start="(69, 48)" end="(69, 49)" leading="" trailing=" " val=","/>
                                <IdentNode start="(69, 50)" end="(69, 51)" leading="" trailing="" raw_val="a" val="a"/>
                                <AtomNode start="(69, 51)" end="(69, 52)" leading="" trailing=" " val=","/>
                                <OtherNode start="(69, 53)" end="(69, 62)" kind="Lean.Parser.Term.anonymousCtor">
                                  <AtomNode start="(69, 53)" end="(69, 54)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(69, 54)" end="(69, 61)">
                                    <IdentNode start="(69, 54)" end="(69, 56)" leading="" trailing="" raw_val="zs" val="zs"/>
                                    <AtomNode start="(69, 56)" end="(69, 57)" leading="" trailing=" " val=","/>
                                    <IdentNode start="(69, 58)" end="(69, 61)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  </NullNode>
                                  <AtomNode start="(69, 61)" end="(69, 62)" leading="" trailing="" val="⟩"/>
                                </OtherNode>
                                <AtomNode start="(69, 62)" end="(69, 63)" leading="" trailing=" " val=","/>
                                <TermBytacticNode start="(69, 64)" end="(69, 71)">
                                  <AtomNode start="(69, 64)" end="(69, 66)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(69, 67)" end="(69, 71)">
                                    <TacticTacticseq1IndentedNode start="(69, 67)" end="(69, 71)">
                                      <NullNode start="(69, 67)" end="(69, 71)">
                                        <OtherNode start="(69, 67)" end="(69, 71)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;ys : Array α&#10;a : α&#10;zs : Array α&#10;h₁ : f a = some b&#10;h₂ : ∀ (x : α), x ∈ ys → f x = none&#10;⊢ ys.push a ++ zs =&#10;    (Vector.cast ⋯ ({ toArray := ys, size_toArray := ⋯ }.push a ++ { toArray := zs, size_toArray := ⋯ })).toArray" state_after="no goals" tactic="simp">
                                          <AtomNode start="(69, 67)" end="(69, 71)" leading="" trailing="" val="simp"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                                <AtomNode start="(69, 71)" end="(69, 72)" leading="" trailing=" " val=","/>
                                <IdentNode start="(69, 73)" end="(69, 75)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                <AtomNode start="(69, 75)" end="(69, 76)" leading="" trailing=" " val=","/>
                                <TermBytacticNode start="(69, 77)" end="(69, 94)">
                                  <AtomNode start="(69, 77)" end="(69, 79)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(69, 80)" end="(69, 94)">
                                    <TacticTacticseq1IndentedNode start="(69, 80)" end="(69, 94)">
                                      <NullNode start="(69, 80)" end="(69, 94)">
                                        <OtherNode start="(69, 80)" end="(69, 94)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;ys : Array α&#10;a : α&#10;zs : Array α&#10;h₁ : f a = some b&#10;h₂ : ∀ (x : α), x ∈ ys → f x = none&#10;⊢ ∀ (x : α), x ∈ { toArray := ys, size_toArray := ⋯ } → f x = none" state_after="no goals" tactic="simpa using h₂">
                                          <AtomNode start="(69, 80)" end="(69, 85)" leading="" trailing=" " val="simpa"/>
                                          <NullNode/>
                                          <NullNode/>
                                          <OtherNode start="(69, 86)" end="(69, 94)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode start="(69, 86)" end="(69, 94)">
                                              <AtomNode start="(69, 86)" end="(69, 91)" leading="" trailing=" " val="using"/>
                                              <IdentNode start="(69, 92)" end="(69, 94)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </NullNode>
                              <AtomNode start="(69, 94)" end="(69, 95)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(70, 3)" end="(71, 74)" kind="Lean.cdot" state_before="case mk.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;xs : Array α&#10;⊢ (∃ k₁ k₂ h ys a zs, xs = (Vector.cast ⋯ (ys.push a ++ zs)).toArray ∧ f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none) →&#10;    ∃ ys a zs, xs = ys.push a ++ zs ∧ f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none" state_after="no goals" tactic="· rintro ⟨k₁, k₂, h, ys, a, zs, w, h₁, h₂⟩&#10;  exact ⟨ys.toArray, a, zs.toArray, by simp [w], h₁, by simpa using h₂⟩">
                    <OtherNode start="(70, 3)" end="(70, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(70, 3)" end="(70, 4)" kind="patternIgnore">
                        <OtherNode start="(70, 3)" end="(70, 4)" kind="token.«· »">
                          <AtomNode start="(70, 3)" end="(70, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(70, 5)" end="(71, 74)">
                      <TacticTacticseq1IndentedNode start="(70, 5)" end="(71, 74)">
                        <NullNode start="(70, 5)" end="(71, 74)">
                          <OtherNode start="(70, 5)" end="(70, 45)" kind="Lean.Parser.Tactic.rintro" state_before="case mk.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;xs : Array α&#10;⊢ (∃ k₁ k₂ h ys a zs, xs = (Vector.cast ⋯ (ys.push a ++ zs)).toArray ∧ f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none) →&#10;    ∃ ys a zs, xs = ys.push a ++ zs ∧ f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none" state_after="case mk.mpr.intro.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;xs : Array α&#10;k₁ k₂ : Nat&#10;h : xs.size = k₁ + 1 + k₂&#10;ys : Vector α k₁&#10;a : α&#10;zs : Vector α k₂&#10;w : xs = (Vector.cast ⋯ (ys.push a ++ zs)).toArray&#10;h₁ : f a = some b&#10;h₂ : ∀ (x : α), x ∈ ys → f x = none&#10;⊢ ∃ ys a zs, xs = ys.push a ++ zs ∧ f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none" tactic="rintro ⟨k₁, k₂, h, ys, a, zs, w, h₁, h₂⟩">
                            <AtomNode start="(70, 5)" end="(70, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(70, 12)" end="(70, 45)">
                              <OtherNode start="(70, 12)" end="(70, 45)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(70, 12)" end="(70, 45)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                  <AtomNode start="(70, 12)" end="(70, 13)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(70, 13)" end="(70, 44)">
                                    <OtherNode start="(70, 13)" end="(70, 15)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(70, 13)" end="(70, 15)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(70, 13)" end="(70, 15)">
                                          <OtherNode start="(70, 13)" end="(70, 15)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(70, 13)" end="(70, 15)" leading="" trailing="" raw_val="k₁" val="k₁"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(70, 15)" end="(70, 16)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(70, 17)" end="(70, 19)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(70, 17)" end="(70, 19)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(70, 17)" end="(70, 19)">
                                          <OtherNode start="(70, 17)" end="(70, 19)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(70, 17)" end="(70, 19)" leading="" trailing="" raw_val="k₂" val="k₂"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(70, 19)" end="(70, 20)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(70, 21)" end="(70, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(70, 21)" end="(70, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(70, 21)" end="(70, 22)">
                                          <OtherNode start="(70, 21)" end="(70, 22)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(70, 21)" end="(70, 22)" leading="" trailing="" raw_val="h" val="h"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(70, 22)" end="(70, 23)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(70, 24)" end="(70, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(70, 24)" end="(70, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(70, 24)" end="(70, 26)">
                                          <OtherNode start="(70, 24)" end="(70, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(70, 24)" end="(70, 26)" leading="" trailing="" raw_val="ys" val="ys"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(70, 26)" end="(70, 27)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(70, 28)" end="(70, 29)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(70, 28)" end="(70, 29)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(70, 28)" end="(70, 29)">
                                          <OtherNode start="(70, 28)" end="(70, 29)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(70, 28)" end="(70, 29)" leading="" trailing="" raw_val="a" val="a"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(70, 29)" end="(70, 30)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(70, 31)" end="(70, 33)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(70, 31)" end="(70, 33)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(70, 31)" end="(70, 33)">
                                          <OtherNode start="(70, 31)" end="(70, 33)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(70, 31)" end="(70, 33)" leading="" trailing="" raw_val="zs" val="zs"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(70, 33)" end="(70, 34)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(70, 35)" end="(70, 36)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(70, 35)" end="(70, 36)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(70, 35)" end="(70, 36)">
                                          <OtherNode start="(70, 35)" end="(70, 36)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(70, 35)" end="(70, 36)" leading="" trailing="" raw_val="w" val="w"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(70, 36)" end="(70, 37)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(70, 38)" end="(70, 40)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(70, 38)" end="(70, 40)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(70, 38)" end="(70, 40)">
                                          <OtherNode start="(70, 38)" end="(70, 40)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(70, 38)" end="(70, 40)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(70, 40)" end="(70, 41)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(70, 42)" end="(70, 44)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(70, 42)" end="(70, 44)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(70, 42)" end="(70, 44)">
                                          <OtherNode start="(70, 42)" end="(70, 44)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(70, 42)" end="(70, 44)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(70, 44)" end="(70, 45)" leading="" trailing="&#10;    " val="⟩"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(71, 5)" end="(71, 74)" kind="Lean.Parser.Tactic.exact" state_before="case mk.mpr.intro.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;xs : Array α&#10;k₁ k₂ : Nat&#10;h : xs.size = k₁ + 1 + k₂&#10;ys : Vector α k₁&#10;a : α&#10;zs : Vector α k₂&#10;w : xs = (Vector.cast ⋯ (ys.push a ++ zs)).toArray&#10;h₁ : f a = some b&#10;h₂ : ∀ (x : α), x ∈ ys → f x = none&#10;⊢ ∃ ys a zs, xs = ys.push a ++ zs ∧ f a = some b ∧ ∀ (x : α), x ∈ ys → f x = none" state_after="no goals" tactic="exact ⟨ys.toArray, a, zs.toArray, by simp [w], h₁, by simpa using h₂⟩">
                            <AtomNode start="(71, 5)" end="(71, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(71, 11)" end="(71, 74)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(71, 11)" end="(71, 12)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(71, 12)" end="(71, 73)">
                                <IdentNode start="(71, 12)" end="(71, 22)" leading="" trailing="" raw_val="ys.toArray" val="ys.toArray"/>
                                <AtomNode start="(71, 22)" end="(71, 23)" leading="" trailing=" " val=","/>
                                <IdentNode start="(71, 24)" end="(71, 25)" leading="" trailing="" raw_val="a" val="a"/>
                                <AtomNode start="(71, 25)" end="(71, 26)" leading="" trailing=" " val=","/>
                                <IdentNode start="(71, 27)" end="(71, 37)" leading="" trailing="" raw_val="zs.toArray" val="zs.toArray"/>
                                <AtomNode start="(71, 37)" end="(71, 38)" leading="" trailing=" " val=","/>
                                <TermBytacticNode start="(71, 39)" end="(71, 50)">
                                  <AtomNode start="(71, 39)" end="(71, 41)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(71, 42)" end="(71, 50)">
                                    <TacticTacticseq1IndentedNode start="(71, 42)" end="(71, 50)">
                                      <NullNode start="(71, 42)" end="(71, 50)">
                                        <OtherNode start="(71, 42)" end="(71, 50)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;xs : Array α&#10;k₁ k₂ : Nat&#10;h : xs.size = k₁ + 1 + k₂&#10;ys : Vector α k₁&#10;a : α&#10;zs : Vector α k₂&#10;w : xs = (Vector.cast ⋯ (ys.push a ++ zs)).toArray&#10;h₁ : f a = some b&#10;h₂ : ∀ (x : α), x ∈ ys → f x = none&#10;⊢ xs = ys.push a ++ zs.toArray" state_after="no goals" tactic="simp [w]">
                                          <AtomNode start="(71, 42)" end="(71, 46)" leading="" trailing=" " val="simp"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode start="(71, 47)" end="(71, 50)">
                                            <AtomNode start="(71, 47)" end="(71, 48)" leading="" trailing="" val="["/>
                                            <NullNode start="(71, 48)" end="(71, 49)">
                                              <OtherNode start="(71, 48)" end="(71, 49)" kind="Lean.Parser.Tactic.simpLemma">
                                                <NullNode/>
                                                <NullNode/>
                                                <IdentNode start="(71, 48)" end="(71, 49)" leading="" trailing="" raw_val="w" val="w"/>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(71, 49)" end="(71, 50)" leading="" trailing="" val="]"/>
                                          </NullNode>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                                <AtomNode start="(71, 50)" end="(71, 51)" leading="" trailing=" " val=","/>
                                <IdentNode start="(71, 52)" end="(71, 54)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                <AtomNode start="(71, 54)" end="(71, 55)" leading="" trailing=" " val=","/>
                                <TermBytacticNode start="(71, 56)" end="(71, 73)">
                                  <AtomNode start="(71, 56)" end="(71, 58)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(71, 59)" end="(71, 73)">
                                    <TacticTacticseq1IndentedNode start="(71, 59)" end="(71, 73)">
                                      <NullNode start="(71, 59)" end="(71, 73)">
                                        <OtherNode start="(71, 59)" end="(71, 73)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;β : Type u_2&#10;f : α → Option β&#10;b : β&#10;xs : Array α&#10;k₁ k₂ : Nat&#10;h : xs.size = k₁ + 1 + k₂&#10;ys : Vector α k₁&#10;a : α&#10;zs : Vector α k₂&#10;w : xs = (Vector.cast ⋯ (ys.push a ++ zs)).toArray&#10;h₁ : f a = some b&#10;h₂ : ∀ (x : α), x ∈ ys → f x = none&#10;⊢ ∀ (x : α), x ∈ ys.toArray → f x = none" state_after="no goals" tactic="simpa using h₂">
                                          <AtomNode start="(71, 59)" end="(71, 64)" leading="" trailing=" " val="simpa"/>
                                          <NullNode/>
                                          <NullNode/>
                                          <OtherNode start="(71, 65)" end="(71, 73)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode start="(71, 65)" end="(71, 73)">
                                              <AtomNode start="(71, 65)" end="(71, 70)" leading="" trailing=" " val="using"/>
                                              <IdentNode start="(71, 71)" end="(71, 73)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </NullNode>
                              <AtomNode start="(71, 73)" end="(71, 74)" leading="" trailing="&#10;&#10;" val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(73, 1)" end="(75, 7)" name="findSome?_guard" full_name="Vector.findSome?_guard">
      <CommandDeclmodifiersNode start="(73, 1)" end="(73, 8)">
        <NullNode/>
        <NullNode start="(73, 1)" end="(73, 8)">
          <OtherNode start="(73, 1)" end="(73, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(73, 1)" end="(73, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(73, 3)" end="(73, 7)">
              <OtherNode start="(73, 3)" end="(73, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(73, 3)" end="(73, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(73, 3)" end="(73, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(73, 7)" end="(73, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(73, 9)" end="(75, 7)" name="findSome?_guard" full_name="Vector.findSome?_guard" _is_private_decl="False">
        <AtomNode start="(73, 9)" end="(73, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(73, 17)" end="(73, 32)">
          <IdentNode start="(73, 17)" end="(73, 32)" leading="" trailing=" " raw_val="findSome?_guard" val="findSome?_guard"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(73, 33)" end="(73, 106)">
          <NullNode start="(73, 33)" end="(73, 50)">
            <OtherNode start="(73, 33)" end="(73, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(73, 33)" end="(73, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(73, 34)" end="(73, 36)">
                <IdentNode start="(73, 34)" end="(73, 36)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(73, 37)" end="(73, 49)">
                <AtomNode start="(73, 37)" end="(73, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(73, 39)" end="(73, 49)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(73, 39)" end="(73, 45)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(73, 46)" end="(73, 49)">
                    <IdentNode start="(73, 46)" end="(73, 47)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(73, 48)" end="(73, 49)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(73, 49)" end="(73, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(73, 51)" end="(73, 106)">
            <AtomNode start="(73, 51)" end="(73, 52)" leading="" trailing=" " val=":"/>
            <OtherNode start="(73, 53)" end="(73, 106)" kind="«term_=_»">
              <OtherNode start="(73, 53)" end="(73, 93)" kind="Lean.Parser.Term.app">
                <IdentNode start="(73, 53)" end="(73, 62)" leading="" trailing=" " raw_val="findSome?" val="findSome?" full_name="Vector.findSome?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(73, 63)" end="(73, 93)">
                  <OtherNode start="(73, 63)" end="(73, 90)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(73, 63)" end="(73, 64)" leading="" trailing="" val="("/>
                    <OtherNode start="(73, 64)" end="(73, 89)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(73, 64)" end="(73, 76)" leading="" trailing=" " raw_val="Option.guard" val="Option.guard" full_name="Option.guard" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                      <NullNode start="(73, 77)" end="(73, 89)">
                        <OtherNode start="(73, 77)" end="(73, 89)" kind="Lean.Parser.Term.fun">
                          <AtomNode start="(73, 77)" end="(73, 80)" leading="" trailing=" " val="fun"/>
                          <OtherNode start="(73, 81)" end="(73, 89)" kind="Lean.Parser.Term.basicFun">
                            <NullNode start="(73, 81)" end="(73, 82)">
                              <IdentNode start="(73, 81)" end="(73, 82)" leading="" trailing=" " raw_val="x" val="x"/>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(73, 83)" end="(73, 85)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(73, 86)" end="(73, 89)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(73, 86)" end="(73, 87)" leading="" trailing=" " raw_val="p" val="p"/>
                              <NullNode start="(73, 88)" end="(73, 89)">
                                <IdentNode start="(73, 88)" end="(73, 89)" leading="" trailing="" raw_val="x" val="x"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(73, 89)" end="(73, 90)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(73, 91)" end="(73, 93)" leading="" trailing=" " raw_val="xs" val="xs"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(73, 94)" end="(73, 95)" leading="" trailing=" " val="="/>
              <OtherNode start="(73, 96)" end="(73, 106)" kind="Lean.Parser.Term.app">
                <IdentNode start="(73, 96)" end="(73, 101)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Vector.find?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(73, 102)" end="(73, 106)">
                  <IdentNode start="(73, 102)" end="(73, 103)" leading="" trailing=" " raw_val="p" val="p"/>
                  <IdentNode start="(73, 104)" end="(73, 106)" leading="" trailing=" " raw_val="xs" val="xs"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(73, 107)" end="(75, 7)">
          <AtomNode start="(73, 107)" end="(73, 109)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(73, 110)" end="(75, 7)">
            <AtomNode start="(73, 110)" end="(73, 112)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(74, 3)" end="(75, 7)">
              <TacticTacticseq1IndentedNode start="(74, 3)" end="(75, 7)">
                <NullNode start="(74, 3)" end="(75, 7)">
                  <OtherNode start="(74, 3)" end="(74, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type&#10;n : Nat&#10;p : α → Bool&#10;xs : Vector α n&#10;⊢ findSome? (Option.guard fun x =&amp;gt; p x) xs = find? p xs" state_after="case mk&#10;α : Type&#10;p : α → Bool&#10;xs : Array α&#10;⊢ findSome? (Option.guard fun x =&amp;gt; p x) { toArray := xs, size_toArray := ⋯ } =&#10;    find? p { toArray := xs, size_toArray := ⋯ }" tactic="rcases xs with ⟨xs, rfl⟩">
                    <AtomNode start="(74, 3)" end="(74, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(74, 10)" end="(74, 12)">
                      <OtherNode start="(74, 10)" end="(74, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(74, 10)" end="(74, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(74, 13)" end="(74, 27)">
                      <AtomNode start="(74, 13)" end="(74, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(74, 18)" end="(74, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(74, 18)" end="(74, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(74, 18)" end="(74, 27)">
                            <OtherNode start="(74, 18)" end="(74, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(74, 18)" end="(74, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(74, 19)" end="(74, 26)">
                                <OtherNode start="(74, 19)" end="(74, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(74, 19)" end="(74, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(74, 19)" end="(74, 21)">
                                      <OtherNode start="(74, 19)" end="(74, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(74, 19)" end="(74, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(74, 21)" end="(74, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(74, 23)" end="(74, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(74, 23)" end="(74, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(74, 23)" end="(74, 26)">
                                      <OtherNode start="(74, 23)" end="(74, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(74, 23)" end="(74, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(74, 26)" end="(74, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(75, 3)" end="(75, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type&#10;p : α → Bool&#10;xs : Array α&#10;⊢ findSome? (Option.guard fun x =&amp;gt; p x) { toArray := xs, size_toArray := ⋯ } =&#10;    find? p { toArray := xs, size_toArray := ⋯ }" state_after="no goals" tactic="simp">
                    <AtomNode start="(75, 3)" end="(75, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(77, 1)" end="(78, 23)" name="find?_eq_findSome?_guard" full_name="Vector.find?_eq_findSome?_guard">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(77, 1)" end="(78, 23)" name="find?_eq_findSome?_guard" full_name="Vector.find?_eq_findSome?_guard" _is_private_decl="False">
        <AtomNode start="(77, 1)" end="(77, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(77, 9)" end="(77, 33)">
          <IdentNode start="(77, 9)" end="(77, 33)" leading="" trailing=" " raw_val="find?_eq_findSome?_guard" val="find?_eq_findSome?_guard"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(77, 34)" end="(77, 107)">
          <NullNode start="(77, 34)" end="(77, 51)">
            <OtherNode start="(77, 34)" end="(77, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(77, 34)" end="(77, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(77, 35)" end="(77, 37)">
                <IdentNode start="(77, 35)" end="(77, 37)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(77, 38)" end="(77, 50)">
                <AtomNode start="(77, 38)" end="(77, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(77, 40)" end="(77, 50)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(77, 40)" end="(77, 46)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(77, 47)" end="(77, 50)">
                    <IdentNode start="(77, 47)" end="(77, 48)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(77, 49)" end="(77, 50)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(77, 50)" end="(77, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(77, 52)" end="(77, 107)">
            <AtomNode start="(77, 52)" end="(77, 53)" leading="" trailing=" " val=":"/>
            <OtherNode start="(77, 54)" end="(77, 107)" kind="«term_=_»">
              <OtherNode start="(77, 54)" end="(77, 64)" kind="Lean.Parser.Term.app">
                <IdentNode start="(77, 54)" end="(77, 59)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Vector.find?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(77, 60)" end="(77, 64)">
                  <IdentNode start="(77, 60)" end="(77, 61)" leading="" trailing=" " raw_val="p" val="p"/>
                  <IdentNode start="(77, 62)" end="(77, 64)" leading="" trailing=" " raw_val="xs" val="xs"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(77, 65)" end="(77, 66)" leading="" trailing=" " val="="/>
              <OtherNode start="(77, 67)" end="(77, 107)" kind="Lean.Parser.Term.app">
                <IdentNode start="(77, 67)" end="(77, 76)" leading="" trailing=" " raw_val="findSome?" val="findSome?" full_name="Vector.findSome?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(77, 77)" end="(77, 107)">
                  <OtherNode start="(77, 77)" end="(77, 104)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(77, 77)" end="(77, 78)" leading="" trailing="" val="("/>
                    <OtherNode start="(77, 78)" end="(77, 103)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(77, 78)" end="(77, 90)" leading="" trailing=" " raw_val="Option.guard" val="Option.guard" full_name="Option.guard" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                      <NullNode start="(77, 91)" end="(77, 103)">
                        <OtherNode start="(77, 91)" end="(77, 103)" kind="Lean.Parser.Term.fun">
                          <AtomNode start="(77, 91)" end="(77, 94)" leading="" trailing=" " val="fun"/>
                          <OtherNode start="(77, 95)" end="(77, 103)" kind="Lean.Parser.Term.basicFun">
                            <NullNode start="(77, 95)" end="(77, 96)">
                              <IdentNode start="(77, 95)" end="(77, 96)" leading="" trailing=" " raw_val="x" val="x"/>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(77, 97)" end="(77, 99)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(77, 100)" end="(77, 103)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(77, 100)" end="(77, 101)" leading="" trailing=" " raw_val="p" val="p"/>
                              <NullNode start="(77, 102)" end="(77, 103)">
                                <IdentNode start="(77, 102)" end="(77, 103)" leading="" trailing="" raw_val="x" val="x"/>
                              </NullNode>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(77, 103)" end="(77, 104)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(77, 105)" end="(77, 107)" leading="" trailing=" " raw_val="xs" val="xs"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(77, 108)" end="(78, 23)">
          <AtomNode start="(77, 108)" end="(77, 110)" leading="" trailing="&#10;  " val=":="/>
          <IdentNode start="(78, 3)" end="(78, 23)" leading="" trailing="&#10;&#10;" raw_val="findSome?_guard.symm" val="findSome?_guard.symm"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(80, 1)" end="(82, 17)" name="map_findSome?" full_name="Vector.map_findSome?">
      <CommandDeclmodifiersNode start="(80, 1)" end="(80, 8)">
        <NullNode/>
        <NullNode start="(80, 1)" end="(80, 8)">
          <OtherNode start="(80, 1)" end="(80, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(80, 1)" end="(80, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(80, 3)" end="(80, 7)">
              <OtherNode start="(80, 3)" end="(80, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(80, 3)" end="(80, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(80, 3)" end="(80, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(80, 7)" end="(80, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(80, 9)" end="(82, 17)" name="map_findSome?" full_name="Vector.map_findSome?" _is_private_decl="False">
        <AtomNode start="(80, 9)" end="(80, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(80, 17)" end="(80, 30)">
          <IdentNode start="(80, 17)" end="(80, 30)" leading="" trailing=" " raw_val="map_findSome?" val="map_findSome?"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(80, 31)" end="(81, 61)">
          <NullNode start="(80, 31)" end="(80, 79)">
            <OtherNode start="(80, 31)" end="(80, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(80, 31)" end="(80, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(80, 32)" end="(80, 33)">
                <IdentNode start="(80, 32)" end="(80, 33)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(80, 34)" end="(80, 48)">
                <AtomNode start="(80, 34)" end="(80, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(80, 36)" end="(80, 48)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(80, 36)" end="(80, 37)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(80, 38)" end="(80, 39)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(80, 40)" end="(80, 48)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(80, 40)" end="(80, 46)" leading="" trailing=" " raw_val="Option" val="Option" full_name="Option" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(80, 47)" end="(80, 48)">
                      <IdentNode start="(80, 47)" end="(80, 48)" leading="" trailing="" raw_val="β" val="β"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(80, 48)" end="(80, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(80, 50)" end="(80, 61)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(80, 50)" end="(80, 51)" leading="" trailing="" val="{"/>
              <NullNode start="(80, 51)" end="(80, 52)">
                <IdentNode start="(80, 51)" end="(80, 52)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(80, 53)" end="(80, 60)">
                <AtomNode start="(80, 53)" end="(80, 54)" leading="" trailing=" " val=":"/>
                <OtherNode start="(80, 55)" end="(80, 60)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(80, 55)" end="(80, 56)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(80, 57)" end="(80, 58)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(80, 59)" end="(80, 60)" leading="" trailing="" raw_val="γ" val="γ"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(80, 60)" end="(80, 61)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(80, 62)" end="(80, 79)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(80, 62)" end="(80, 63)" leading="" trailing="" val="{"/>
              <NullNode start="(80, 63)" end="(80, 65)">
                <IdentNode start="(80, 63)" end="(80, 65)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(80, 66)" end="(80, 78)">
                <AtomNode start="(80, 66)" end="(80, 67)" leading="" trailing=" " val=":"/>
                <OtherNode start="(80, 68)" end="(80, 78)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(80, 68)" end="(80, 74)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(80, 75)" end="(80, 78)">
                    <IdentNode start="(80, 75)" end="(80, 76)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(80, 77)" end="(80, 78)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(80, 78)" end="(80, 79)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(80, 80)" end="(81, 61)">
            <AtomNode start="(80, 80)" end="(80, 81)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(81, 5)" end="(81, 61)" kind="«term_=_»">
              <OtherNode start="(81, 5)" end="(81, 27)" kind="Lean.Parser.Term.app">
                <OtherNode start="(81, 5)" end="(81, 25)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(81, 5)" end="(81, 21)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(81, 5)" end="(81, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(81, 6)" end="(81, 20)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(81, 6)" end="(81, 18)" leading="" trailing=" " raw_val="xs.findSome?" val="xs.findSome?"/>
                      <NullNode start="(81, 19)" end="(81, 20)">
                        <IdentNode start="(81, 19)" end="(81, 20)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(81, 20)" end="(81, 21)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(81, 21)" end="(81, 22)" leading="" trailing="" val="."/>
                  <IdentNode start="(81, 22)" end="(81, 25)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(81, 26)" end="(81, 27)">
                  <IdentNode start="(81, 26)" end="(81, 27)" leading="" trailing=" " raw_val="g" val="g"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(81, 28)" end="(81, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(81, 30)" end="(81, 61)" kind="Lean.Parser.Term.app">
                <IdentNode start="(81, 30)" end="(81, 42)" leading="" trailing=" " raw_val="xs.findSome?" val="xs.findSome?"/>
                <NullNode start="(81, 43)" end="(81, 61)">
                  <OtherNode start="(81, 43)" end="(81, 61)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(81, 43)" end="(81, 44)" leading="" trailing="" val="("/>
                    <OtherNode start="(81, 44)" end="(81, 60)" kind="«term_∘_»">
                      <OtherNode start="(81, 44)" end="(81, 56)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(81, 44)" end="(81, 54)" leading="" trailing=" " raw_val="Option.map" val="Option.map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(81, 55)" end="(81, 56)">
                          <IdentNode start="(81, 55)" end="(81, 56)" leading="" trailing=" " raw_val="g" val="g"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(81, 57)" end="(81, 58)" leading="" trailing=" " val="∘"/>
                      <IdentNode start="(81, 59)" end="(81, 60)" leading="" trailing="" raw_val="f" val="f"/>
                    </OtherNode>
                    <AtomNode start="(81, 60)" end="(81, 61)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(81, 62)" end="(82, 17)">
          <AtomNode start="(81, 62)" end="(81, 64)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(81, 65)" end="(82, 17)">
            <AtomNode start="(81, 65)" end="(81, 67)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(82, 3)" end="(82, 17)">
              <TacticTacticseq1IndentedNode start="(82, 3)" end="(82, 17)">
                <NullNode start="(82, 3)" end="(82, 17)">
                  <OtherNode start="(82, 3)" end="(82, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;n : Nat&#10;f : α → Option β&#10;g : β → γ&#10;xs : Vector α n&#10;⊢ Option.map g (findSome? f xs) = findSome? (Option.map g ∘ f) xs" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;n : Nat&#10;f : α → Option β&#10;g : β → γ&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n&#10;⊢ Option.map g (findSome? f { toArray := toArray✝, size_toArray := size_toArray✝ }) =&#10;    findSome? (Option.map g ∘ f) { toArray := toArray✝, size_toArray := size_toArray✝ }" tactic="cases xs">
                    <AtomNode start="(82, 3)" end="(82, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(82, 9)" end="(82, 11)">
                      <OtherNode start="(82, 9)" end="(82, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(82, 9)" end="(82, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(82, 11)" end="(82, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(82, 13)" end="(82, 17)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;n : Nat&#10;f : α → Option β&#10;g : β → γ&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n&#10;⊢ Option.map g (findSome? f { toArray := toArray✝, size_toArray := size_toArray✝ }) =&#10;    findSome? (Option.map g ∘ f) { toArray := toArray✝, size_toArray := size_toArray✝ }" state_after="no goals" tactic="simp">
                    <AtomNode start="(82, 13)" end="(82, 17)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(84, 1)" end="(86, 29)" name="findSome?_map" full_name="Vector.findSome?_map">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(84, 1)" end="(86, 29)" name="findSome?_map" full_name="Vector.findSome?_map" _is_private_decl="False">
        <AtomNode start="(84, 1)" end="(84, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(84, 9)" end="(84, 22)">
          <IdentNode start="(84, 9)" end="(84, 22)" leading="" trailing=" " raw_val="findSome?_map" val="findSome?_map"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(84, 23)" end="(84, 100)">
          <NullNode start="(84, 23)" end="(84, 52)">
            <OtherNode start="(84, 23)" end="(84, 34)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(84, 23)" end="(84, 24)" leading="" trailing="" val="{"/>
              <NullNode start="(84, 24)" end="(84, 25)">
                <IdentNode start="(84, 24)" end="(84, 25)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(84, 26)" end="(84, 33)">
                <AtomNode start="(84, 26)" end="(84, 27)" leading="" trailing=" " val=":"/>
                <OtherNode start="(84, 28)" end="(84, 33)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(84, 28)" end="(84, 29)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(84, 30)" end="(84, 31)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(84, 32)" end="(84, 33)" leading="" trailing="" raw_val="γ" val="γ"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(84, 33)" end="(84, 34)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(84, 35)" end="(84, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(84, 35)" end="(84, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(84, 36)" end="(84, 38)">
                <IdentNode start="(84, 36)" end="(84, 38)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(84, 39)" end="(84, 51)">
                <AtomNode start="(84, 39)" end="(84, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(84, 41)" end="(84, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(84, 41)" end="(84, 47)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(84, 48)" end="(84, 51)">
                    <IdentNode start="(84, 48)" end="(84, 49)" leading="" trailing=" " raw_val="β" val="β"/>
                    <IdentNode start="(84, 50)" end="(84, 51)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(84, 51)" end="(84, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(84, 53)" end="(84, 100)">
            <AtomNode start="(84, 53)" end="(84, 54)" leading="" trailing=" " val=":"/>
            <OtherNode start="(84, 55)" end="(84, 100)" kind="«term_=_»">
              <OtherNode start="(84, 55)" end="(84, 77)" kind="Lean.Parser.Term.app">
                <IdentNode start="(84, 55)" end="(84, 64)" leading="" trailing=" " raw_val="findSome?" val="findSome?" full_name="Vector.findSome?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(84, 65)" end="(84, 77)">
                  <IdentNode start="(84, 65)" end="(84, 66)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(84, 67)" end="(84, 77)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(84, 67)" end="(84, 68)" leading="" trailing="" val="("/>
                    <OtherNode start="(84, 68)" end="(84, 76)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(84, 68)" end="(84, 74)" leading="" trailing=" " raw_val="xs.map" val="xs.map"/>
                      <NullNode start="(84, 75)" end="(84, 76)">
                        <IdentNode start="(84, 75)" end="(84, 76)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(84, 76)" end="(84, 77)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(84, 78)" end="(84, 79)" leading="" trailing=" " val="="/>
              <OtherNode start="(84, 80)" end="(84, 100)" kind="Lean.Parser.Term.app">
                <IdentNode start="(84, 80)" end="(84, 92)" leading="" trailing=" " raw_val="xs.findSome?" val="xs.findSome?"/>
                <NullNode start="(84, 93)" end="(84, 100)">
                  <OtherNode start="(84, 93)" end="(84, 100)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(84, 93)" end="(84, 94)" leading="" trailing="" val="("/>
                    <OtherNode start="(84, 94)" end="(84, 99)" kind="«term_∘_»">
                      <IdentNode start="(84, 94)" end="(84, 95)" leading="" trailing=" " raw_val="p" val="p"/>
                      <AtomNode start="(84, 96)" end="(84, 97)" leading="" trailing=" " val="∘"/>
                      <IdentNode start="(84, 98)" end="(84, 99)" leading="" trailing="" raw_val="f" val="f"/>
                    </OtherNode>
                    <AtomNode start="(84, 99)" end="(84, 100)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(84, 101)" end="(86, 29)">
          <AtomNode start="(84, 101)" end="(84, 103)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(84, 104)" end="(86, 29)">
            <AtomNode start="(84, 104)" end="(84, 106)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(85, 3)" end="(86, 29)">
              <TacticTacticseq1IndentedNode start="(85, 3)" end="(86, 29)">
                <NullNode start="(85, 3)" end="(86, 29)">
                  <OtherNode start="(85, 3)" end="(85, 27)" kind="Lean.Parser.Tactic.rcases" state_before="β : Type u_1&#10;γ : Type u_2&#10;n : Nat&#10;α✝ : Type u_3&#10;p : γ → Option α✝&#10;f : β → γ&#10;xs : Vector β n&#10;⊢ findSome? p (map f xs) = findSome? (p ∘ f) xs" state_after="case mk&#10;β : Type u_1&#10;γ : Type u_2&#10;α✝ : Type u_3&#10;p : γ → Option α✝&#10;f : β → γ&#10;xs : Array β&#10;⊢ findSome? p (map f { toArray := xs, size_toArray := ⋯ }) = findSome? (p ∘ f) { toArray := xs, size_toArray := ⋯ }" tactic="rcases xs with ⟨xs, rfl⟩">
                    <AtomNode start="(85, 3)" end="(85, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(85, 10)" end="(85, 12)">
                      <OtherNode start="(85, 10)" end="(85, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(85, 10)" end="(85, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(85, 13)" end="(85, 27)">
                      <AtomNode start="(85, 13)" end="(85, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(85, 18)" end="(85, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(85, 18)" end="(85, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(85, 18)" end="(85, 27)">
                            <OtherNode start="(85, 18)" end="(85, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(85, 18)" end="(85, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(85, 19)" end="(85, 26)">
                                <OtherNode start="(85, 19)" end="(85, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(85, 19)" end="(85, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(85, 19)" end="(85, 21)">
                                      <OtherNode start="(85, 19)" end="(85, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(85, 19)" end="(85, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(85, 21)" end="(85, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(85, 23)" end="(85, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(85, 23)" end="(85, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(85, 23)" end="(85, 26)">
                                      <OtherNode start="(85, 23)" end="(85, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(85, 23)" end="(85, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(85, 26)" end="(85, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(86, 3)" end="(86, 29)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;β : Type u_1&#10;γ : Type u_2&#10;α✝ : Type u_3&#10;p : γ → Option α✝&#10;f : β → γ&#10;xs : Array β&#10;⊢ findSome? p (map f { toArray := xs, size_toArray := ⋯ }) = findSome? (p ∘ f) { toArray := xs, size_toArray := ⋯ }" state_after="no goals" tactic="simp [Array.findSome?_map]">
                    <AtomNode start="(86, 3)" end="(86, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(86, 8)" end="(86, 29)">
                      <AtomNode start="(86, 8)" end="(86, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(86, 9)" end="(86, 28)">
                        <OtherNode start="(86, 9)" end="(86, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(86, 9)" end="(86, 28)" leading="" trailing="" raw_val="Array.findSome?_map" val="Array.findSome?_map" full_name="Array.findSome?_map" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(86, 28)" end="(86, 29)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(88, 1)" end="(89, 52)" name="findSome?_append" full_name="Vector.findSome?_append">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(88, 1)" end="(89, 52)" name="findSome?_append" full_name="Vector.findSome?_append" _is_private_decl="False">
        <AtomNode start="(88, 1)" end="(88, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(88, 9)" end="(88, 25)">
          <IdentNode start="(88, 9)" end="(88, 25)" leading="" trailing=" " raw_val="findSome?_append" val="findSome?_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(88, 26)" end="(88, 127)">
          <NullNode start="(88, 26)" end="(88, 63)">
            <OtherNode start="(88, 26)" end="(88, 44)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(88, 26)" end="(88, 27)" leading="" trailing="" val="{"/>
              <NullNode start="(88, 27)" end="(88, 29)">
                <IdentNode start="(88, 27)" end="(88, 29)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(88, 30)" end="(88, 43)">
                <AtomNode start="(88, 30)" end="(88, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(88, 32)" end="(88, 43)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(88, 32)" end="(88, 38)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(88, 39)" end="(88, 43)">
                    <IdentNode start="(88, 39)" end="(88, 40)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(88, 41)" end="(88, 43)" leading="" trailing="" raw_val="n₁" val="n₁"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(88, 43)" end="(88, 44)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(88, 45)" end="(88, 63)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(88, 45)" end="(88, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(88, 46)" end="(88, 48)">
                <IdentNode start="(88, 46)" end="(88, 48)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(88, 49)" end="(88, 62)">
                <AtomNode start="(88, 49)" end="(88, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(88, 51)" end="(88, 62)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(88, 51)" end="(88, 57)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(88, 58)" end="(88, 62)">
                    <IdentNode start="(88, 58)" end="(88, 59)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(88, 60)" end="(88, 62)" leading="" trailing="" raw_val="n₂" val="n₂"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(88, 62)" end="(88, 63)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(88, 64)" end="(88, 127)">
            <AtomNode start="(88, 64)" end="(88, 65)" leading="" trailing=" " val=":"/>
            <OtherNode start="(88, 66)" end="(88, 127)" kind="«term_=_»">
              <OtherNode start="(88, 66)" end="(88, 88)" kind="Lean.Parser.Term.app">
                <OtherNode start="(88, 66)" end="(88, 86)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(88, 66)" end="(88, 76)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(88, 66)" end="(88, 67)" leading="" trailing="" val="("/>
                    <OtherNode start="(88, 67)" end="(88, 75)" kind="«term_++_»">
                      <IdentNode start="(88, 67)" end="(88, 69)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(88, 70)" end="(88, 72)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(88, 73)" end="(88, 75)" leading="" trailing="" raw_val="ys" val="ys"/>
                    </OtherNode>
                    <AtomNode start="(88, 75)" end="(88, 76)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(88, 76)" end="(88, 77)" leading="" trailing="" val="."/>
                  <IdentNode start="(88, 77)" end="(88, 86)" leading="" trailing=" " raw_val="findSome?" val="findSome?" full_name="Vector.findSome?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                </OtherNode>
                <NullNode start="(88, 87)" end="(88, 88)">
                  <IdentNode start="(88, 87)" end="(88, 88)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(88, 89)" end="(88, 90)" leading="" trailing=" " val="="/>
              <OtherNode start="(88, 91)" end="(88, 127)" kind="Lean.Parser.Term.app">
                <OtherNode start="(88, 91)" end="(88, 110)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(88, 91)" end="(88, 107)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(88, 91)" end="(88, 92)" leading="" trailing="" val="("/>
                    <OtherNode start="(88, 92)" end="(88, 106)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(88, 92)" end="(88, 104)" leading="" trailing=" " raw_val="xs.findSome?" val="xs.findSome?"/>
                      <NullNode start="(88, 105)" end="(88, 106)">
                        <IdentNode start="(88, 105)" end="(88, 106)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(88, 106)" end="(88, 107)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(88, 107)" end="(88, 108)" leading="" trailing="" val="."/>
                  <IdentNode start="(88, 108)" end="(88, 110)" leading="" trailing=" " raw_val="or" val="or" full_name="Option.or" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(88, 111)" end="(88, 127)">
                  <OtherNode start="(88, 111)" end="(88, 127)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(88, 111)" end="(88, 112)" leading="" trailing="" val="("/>
                    <OtherNode start="(88, 112)" end="(88, 126)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(88, 112)" end="(88, 124)" leading="" trailing=" " raw_val="ys.findSome?" val="ys.findSome?"/>
                      <NullNode start="(88, 125)" end="(88, 126)">
                        <IdentNode start="(88, 125)" end="(88, 126)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(88, 126)" end="(88, 127)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(88, 128)" end="(89, 52)">
          <AtomNode start="(88, 128)" end="(88, 130)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(88, 131)" end="(89, 52)">
            <AtomNode start="(88, 131)" end="(88, 133)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(89, 3)" end="(89, 52)">
              <TacticTacticseq1IndentedNode start="(89, 3)" end="(89, 52)">
                <NullNode start="(89, 3)" end="(89, 52)">
                  <OtherNode start="(89, 3)" end="(89, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;n₁ n₂ : Nat&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;xs : Vector α n₁&#10;ys : Vector α n₂&#10;⊢ findSome? f (xs ++ ys) = (findSome? f xs).or (findSome? f ys)" state_after="case mk&#10;α : Type u_1&#10;n₁ n₂ : Nat&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;ys : Vector α n₂&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n₁&#10;⊢ findSome? f ({ toArray := toArray✝, size_toArray := size_toArray✝ } ++ ys) =&#10;    (findSome? f { toArray := toArray✝, size_toArray := size_toArray✝ }).or (findSome? f ys)" tactic="cases xs">
                    <AtomNode start="(89, 3)" end="(89, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(89, 9)" end="(89, 11)">
                      <OtherNode start="(89, 9)" end="(89, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(89, 9)" end="(89, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(89, 11)" end="(89, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(89, 13)" end="(89, 21)" kind="Lean.Parser.Tactic.cases" state_before="case mk&#10;α : Type u_1&#10;n₁ n₂ : Nat&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;ys : Vector α n₂&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n₁&#10;⊢ findSome? f ({ toArray := toArray✝, size_toArray := size_toArray✝ } ++ ys) =&#10;    (findSome? f { toArray := toArray✝, size_toArray := size_toArray✝ }).or (findSome? f ys)" state_after="case mk.mk&#10;α : Type u_1&#10;n₁ n₂ : Nat&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;toArray✝¹ : Array α&#10;size_toArray✝¹ : toArray✝¹.size = n₁&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n₂&#10;⊢ findSome? f&#10;      ({ toArray := toArray✝¹, size_toArray := size_toArray✝¹ } ++&#10;        { toArray := toArray✝, size_toArray := size_toArray✝ }) =&#10;    (findSome? f { toArray := toArray✝¹, size_toArray := size_toArray✝¹ }).or&#10;      (findSome? f { toArray := toArray✝, size_toArray := size_toArray✝ })" tactic="cases ys">
                    <AtomNode start="(89, 13)" end="(89, 18)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(89, 19)" end="(89, 21)">
                      <OtherNode start="(89, 19)" end="(89, 21)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(89, 19)" end="(89, 21)" leading="" trailing="" raw_val="ys" val="ys"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(89, 21)" end="(89, 22)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(89, 23)" end="(89, 52)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α : Type u_1&#10;n₁ n₂ : Nat&#10;α✝ : Type u_2&#10;f : α → Option α✝&#10;toArray✝¹ : Array α&#10;size_toArray✝¹ : toArray✝¹.size = n₁&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n₂&#10;⊢ findSome? f&#10;      ({ toArray := toArray✝¹, size_toArray := size_toArray✝¹ } ++&#10;        { toArray := toArray✝, size_toArray := size_toArray✝ }) =&#10;    (findSome? f { toArray := toArray✝¹, size_toArray := size_toArray✝¹ }).or&#10;      (findSome? f { toArray := toArray✝, size_toArray := size_toArray✝ })" state_after="no goals" tactic="simp [Array.findSome?_append]">
                    <AtomNode start="(89, 23)" end="(89, 27)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(89, 28)" end="(89, 52)">
                      <AtomNode start="(89, 28)" end="(89, 29)" leading="" trailing="" val="["/>
                      <NullNode start="(89, 29)" end="(89, 51)">
                        <OtherNode start="(89, 29)" end="(89, 51)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(89, 29)" end="(89, 51)" leading="" trailing="" raw_val="Array.findSome?_append" val="Array.findSome?_append" full_name="Array.findSome?_append" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(89, 51)" end="(89, 52)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(91, 1)" end="(94, 77)" name="getElem?_zero_flatten" full_name="Vector.getElem?_zero_flatten">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(91, 1)" end="(94, 77)" name="getElem?_zero_flatten" full_name="Vector.getElem?_zero_flatten" _is_private_decl="False">
        <AtomNode start="(91, 1)" end="(91, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(91, 9)" end="(91, 30)">
          <IdentNode start="(91, 9)" end="(91, 30)" leading="" trailing=" " raw_val="getElem?_zero_flatten" val="getElem?_zero_flatten"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(91, 31)" end="(92, 55)">
          <NullNode start="(91, 31)" end="(91, 60)">
            <OtherNode start="(91, 31)" end="(91, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(91, 31)" end="(91, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(91, 32)" end="(91, 35)">
                <IdentNode start="(91, 32)" end="(91, 35)" leading="" trailing=" " raw_val="xss" val="xss"/>
              </NullNode>
              <NullNode start="(91, 36)" end="(91, 59)">
                <AtomNode start="(91, 36)" end="(91, 37)" leading="" trailing=" " val=":"/>
                <OtherNode start="(91, 38)" end="(91, 59)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(91, 38)" end="(91, 44)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(91, 45)" end="(91, 59)">
                    <OtherNode start="(91, 45)" end="(91, 57)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(91, 45)" end="(91, 46)" leading="" trailing="" val="("/>
                      <OtherNode start="(91, 46)" end="(91, 56)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(91, 46)" end="(91, 52)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                        <NullNode start="(91, 53)" end="(91, 56)">
                          <IdentNode start="(91, 53)" end="(91, 54)" leading="" trailing=" " raw_val="α" val="α"/>
                          <IdentNode start="(91, 55)" end="(91, 56)" leading="" trailing="" raw_val="m" val="m"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(91, 56)" end="(91, 57)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <IdentNode start="(91, 58)" end="(91, 59)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(91, 59)" end="(91, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(91, 61)" end="(92, 55)">
            <AtomNode start="(91, 61)" end="(91, 62)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(92, 5)" end="(92, 55)" kind="«term_=_»">
              <OtherNode start="(92, 5)" end="(92, 22)" kind="«term__[_]_?»">
                <OtherNode start="(92, 5)" end="(92, 18)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(92, 5)" end="(92, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(92, 6)" end="(92, 17)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(92, 6)" end="(92, 13)" leading="" trailing=" " raw_val="flatten" val="flatten" full_name="Vector.flatten" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                    <NullNode start="(92, 14)" end="(92, 17)">
                      <IdentNode start="(92, 14)" end="(92, 17)" leading="" trailing="" raw_val="xss" val="xss"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(92, 17)" end="(92, 18)" leading="" trailing="" val=")"/>
                </OtherNode>
                <GroupNode/>
                <AtomNode start="(92, 18)" end="(92, 19)" leading="" trailing="" val="["/>
                <OtherNode start="(92, 19)" end="(92, 20)" kind="num">
                  <AtomNode start="(92, 19)" end="(92, 20)" leading="" trailing="" val="0"/>
                </OtherNode>
                <AtomNode start="(92, 20)" end="(92, 21)" leading="" trailing="" val="]"/>
                <GroupNode/>
                <AtomNode start="(92, 21)" end="(92, 22)" leading="" trailing=" " val="?"/>
              </OtherNode>
              <AtomNode start="(92, 23)" end="(92, 24)" leading="" trailing=" " val="="/>
              <OtherNode start="(92, 25)" end="(92, 55)" kind="Lean.Parser.Term.app">
                <IdentNode start="(92, 25)" end="(92, 38)" leading="" trailing=" " raw_val="xss.findSome?" val="xss.findSome?"/>
                <NullNode start="(92, 39)" end="(92, 55)">
                  <OtherNode start="(92, 39)" end="(92, 55)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(92, 39)" end="(92, 42)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(92, 43)" end="(92, 55)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(92, 43)" end="(92, 45)">
                        <IdentNode start="(92, 43)" end="(92, 45)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(92, 46)" end="(92, 48)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(92, 49)" end="(92, 55)" kind="«term__[_]_?»">
                        <IdentNode start="(92, 49)" end="(92, 51)" leading="" trailing="" raw_val="xs" val="xs"/>
                        <GroupNode/>
                        <AtomNode start="(92, 51)" end="(92, 52)" leading="" trailing="" val="["/>
                        <OtherNode start="(92, 52)" end="(92, 53)" kind="num">
                          <AtomNode start="(92, 52)" end="(92, 53)" leading="" trailing="" val="0"/>
                        </OtherNode>
                        <AtomNode start="(92, 53)" end="(92, 54)" leading="" trailing="" val="]"/>
                        <GroupNode/>
                        <AtomNode start="(92, 54)" end="(92, 55)" leading="" trailing=" " val="?"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(92, 56)" end="(94, 77)">
          <AtomNode start="(92, 56)" end="(92, 58)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(92, 59)" end="(94, 77)">
            <AtomNode start="(92, 59)" end="(92, 61)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(93, 3)" end="(94, 77)">
              <TacticTacticseq1IndentedNode start="(93, 3)" end="(94, 77)">
                <NullNode start="(93, 3)" end="(94, 77)">
                  <OtherNode start="(93, 3)" end="(93, 36)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;m n : Nat&#10;xss : Vector (Vector α m) n&#10;⊢ xss.flatten[0]? = findSome? (fun xs =&amp;gt; xs[0]?) xss" state_after="case of&#10;α : Type u_1&#10;m n : Nat&#10;xss✝ : Array (Array α)&#10;h₁✝ : xss✝.size = n&#10;h₂✝ : ∀ (xs : Array α), xs ∈ xss✝ → xs.size = m&#10;⊢ {&#10;          toArray :=&#10;            Array.map&#10;              (fun x =&amp;gt;&#10;                match x with&#10;                | ⟨xs, m_1⟩ =&amp;gt; { toArray := xs, size_toArray := ⋯ })&#10;              xss✝.attach,&#10;          size_toArray := ⋯ }.flatten[0]? =&#10;    findSome? (fun xs =&amp;gt; xs[0]?)&#10;      {&#10;        toArray :=&#10;          Array.map&#10;            (fun x =&amp;gt;&#10;              match x with&#10;              | ⟨xs, m_1⟩ =&amp;gt; { toArray := xs, size_toArray := ⋯ })&#10;            xss✝.attach,&#10;        size_toArray := ⋯ }" tactic="cases xss using vector₂_induction">
                    <AtomNode start="(93, 3)" end="(93, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(93, 9)" end="(93, 12)">
                      <OtherNode start="(93, 9)" end="(93, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(93, 9)" end="(93, 12)" leading="" trailing=" " raw_val="xss" val="xss"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(93, 13)" end="(93, 36)">
                      <AtomNode start="(93, 13)" end="(93, 18)" leading="" trailing=" " val="using"/>
                      <IdentNode start="(93, 19)" end="(93, 36)" leading="" trailing="&#10;  " raw_val="vector₂_induction" val="vector₂_induction" full_name="Vector.vector₂_induction" mod_name="Init.Data.Vector.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Lemmas.lean"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(94, 3)" end="(94, 77)" kind="Lean.Parser.Tactic.simp" state_before="case of&#10;α : Type u_1&#10;m n : Nat&#10;xss✝ : Array (Array α)&#10;h₁✝ : xss✝.size = n&#10;h₂✝ : ∀ (xs : Array α), xs ∈ xss✝ → xs.size = m&#10;⊢ {&#10;          toArray :=&#10;            Array.map&#10;              (fun x =&amp;gt;&#10;                match x with&#10;                | ⟨xs, m_1⟩ =&amp;gt; { toArray := xs, size_toArray := ⋯ })&#10;              xss✝.attach,&#10;          size_toArray := ⋯ }.flatten[0]? =&#10;    findSome? (fun xs =&amp;gt; xs[0]?)&#10;      {&#10;        toArray :=&#10;          Array.map&#10;            (fun x =&amp;gt;&#10;              match x with&#10;              | ⟨xs, m_1⟩ =&amp;gt; { toArray := xs, size_toArray := ⋯ })&#10;            xss✝.attach,&#10;        size_toArray := ⋯ }" state_after="no goals" tactic="simp [Array.getElem?_zero_flatten, Array.findSome?_map, Function.comp_def]">
                    <AtomNode start="(94, 3)" end="(94, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(94, 8)" end="(94, 77)">
                      <AtomNode start="(94, 8)" end="(94, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(94, 9)" end="(94, 76)">
                        <OtherNode start="(94, 9)" end="(94, 36)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(94, 9)" end="(94, 36)" leading="" trailing="" raw_val="Array.getElem?_zero_flatten" val="Array.getElem?_zero_flatten" full_name="Array.getElem?_zero_flatten" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean"/>
                        </OtherNode>
                        <AtomNode start="(94, 36)" end="(94, 37)" leading="" trailing=" " val=","/>
                        <OtherNode start="(94, 38)" end="(94, 57)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(94, 38)" end="(94, 57)" leading="" trailing="" raw_val="Array.findSome?_map" val="Array.findSome?_map" full_name="Array.findSome?_map" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean"/>
                        </OtherNode>
                        <AtomNode start="(94, 57)" end="(94, 58)" leading="" trailing=" " val=","/>
                        <OtherNode start="(94, 59)" end="(94, 76)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(94, 59)" end="(94, 76)" leading="" trailing="" raw_val="Function.comp_def" val="Function.comp_def" full_name="Function.comp_def" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(94, 76)" end="(94, 77)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(96, 1)" end="(105, 46)" name="getElem_zero_flatten.proof" full_name="Vector.getElem_zero_flatten.proof">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(96, 1)" end="(105, 46)" name="getElem_zero_flatten.proof" full_name="Vector.getElem_zero_flatten.proof" _is_private_decl="False">
        <AtomNode start="(96, 1)" end="(96, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(96, 9)" end="(96, 35)">
          <IdentNode start="(96, 9)" end="(96, 35)" leading="" trailing=" " raw_val="getElem_zero_flatten.proof" val="getElem_zero_flatten.proof"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(96, 36)" end="(97, 44)">
          <NullNode start="(96, 36)" end="(96, 81)">
            <OtherNode start="(96, 36)" end="(96, 65)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(96, 36)" end="(96, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(96, 37)" end="(96, 40)">
                <IdentNode start="(96, 37)" end="(96, 40)" leading="" trailing=" " raw_val="xss" val="xss"/>
              </NullNode>
              <NullNode start="(96, 41)" end="(96, 64)">
                <AtomNode start="(96, 41)" end="(96, 42)" leading="" trailing=" " val=":"/>
                <OtherNode start="(96, 43)" end="(96, 64)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(96, 43)" end="(96, 49)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(96, 50)" end="(96, 64)">
                    <OtherNode start="(96, 50)" end="(96, 62)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(96, 50)" end="(96, 51)" leading="" trailing="" val="("/>
                      <OtherNode start="(96, 51)" end="(96, 61)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(96, 51)" end="(96, 57)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                        <NullNode start="(96, 58)" end="(96, 61)">
                          <IdentNode start="(96, 58)" end="(96, 59)" leading="" trailing=" " raw_val="α" val="α"/>
                          <IdentNode start="(96, 60)" end="(96, 61)" leading="" trailing="" raw_val="m" val="m"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(96, 61)" end="(96, 62)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <IdentNode start="(96, 63)" end="(96, 64)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(96, 64)" end="(96, 65)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(96, 66)" end="(96, 81)">
              <AtomNode start="(96, 66)" end="(96, 67)" leading="" trailing="" val="("/>
              <NullNode start="(96, 67)" end="(96, 68)">
                <IdentNode start="(96, 67)" end="(96, 68)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(96, 69)" end="(96, 80)">
                <AtomNode start="(96, 69)" end="(96, 70)" leading="" trailing=" " val=":"/>
                <OtherNode start="(96, 71)" end="(96, 80)" kind="«term_&amp;lt;_»">
                  <OtherNode start="(96, 71)" end="(96, 72)" kind="num">
                    <AtomNode start="(96, 71)" end="(96, 72)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                  <AtomNode start="(96, 73)" end="(96, 74)" leading="" trailing=" " val="&amp;lt;"/>
                  <OtherNode start="(96, 75)" end="(96, 80)" kind="«term_*_»">
                    <IdentNode start="(96, 75)" end="(96, 76)" leading="" trailing=" " raw_val="n" val="n"/>
                    <AtomNode start="(96, 77)" end="(96, 78)" leading="" trailing=" " val="*"/>
                    <IdentNode start="(96, 79)" end="(96, 80)" leading="" trailing="" raw_val="m" val="m"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(96, 80)" end="(96, 81)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(96, 82)" end="(97, 44)">
            <AtomNode start="(96, 82)" end="(96, 83)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(97, 5)" end="(97, 44)" kind="Lean.Parser.Term.proj">
              <OtherNode start="(97, 5)" end="(97, 37)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(97, 5)" end="(97, 6)" leading="" trailing="" val="("/>
                <OtherNode start="(97, 6)" end="(97, 36)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(97, 6)" end="(97, 19)" leading="" trailing=" " raw_val="xss.findSome?" val="xss.findSome?"/>
                  <NullNode start="(97, 20)" end="(97, 36)">
                    <OtherNode start="(97, 20)" end="(97, 36)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(97, 20)" end="(97, 23)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(97, 24)" end="(97, 36)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(97, 24)" end="(97, 26)">
                          <IdentNode start="(97, 24)" end="(97, 26)" leading="" trailing=" " raw_val="xs" val="xs"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(97, 27)" end="(97, 29)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(97, 30)" end="(97, 36)" kind="«term__[_]_?»">
                          <IdentNode start="(97, 30)" end="(97, 32)" leading="" trailing="" raw_val="xs" val="xs"/>
                          <GroupNode/>
                          <AtomNode start="(97, 32)" end="(97, 33)" leading="" trailing="" val="["/>
                          <OtherNode start="(97, 33)" end="(97, 34)" kind="num">
                            <AtomNode start="(97, 33)" end="(97, 34)" leading="" trailing="" val="0"/>
                          </OtherNode>
                          <AtomNode start="(97, 34)" end="(97, 35)" leading="" trailing="" val="]"/>
                          <GroupNode/>
                          <AtomNode start="(97, 35)" end="(97, 36)" leading="" trailing="" val="?"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(97, 36)" end="(97, 37)" leading="" trailing="" val=")"/>
              </OtherNode>
              <AtomNode start="(97, 37)" end="(97, 38)" leading="" trailing="" val="."/>
              <IdentNode start="(97, 38)" end="(97, 44)" leading="" trailing=" " raw_val="isSome" val="isSome" full_name="Option.isSome" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(97, 45)" end="(105, 46)">
          <AtomNode start="(97, 45)" end="(97, 47)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(97, 48)" end="(105, 46)">
            <AtomNode start="(97, 48)" end="(97, 50)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(98, 3)" end="(105, 46)">
              <TacticTacticseq1IndentedNode start="(98, 3)" end="(105, 46)">
                <NullNode start="(98, 3)" end="(105, 46)">
                  <OtherNode start="(98, 3)" end="(105, 46)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;m n : Nat&#10;xss : Vector (Vector α m) n&#10;h : 0 &amp;lt; n * m&#10;⊢ (findSome? (fun xs =&amp;gt; xs[0]?) xss).isSome = true" state_after="no goals" tactic="cases xss using vector₂_induction with&#10;| of xss h₁ h₂ =&amp;gt;&#10;  have hn : 0 &amp;lt; n := Nat.pos_of_mul_pos_right h&#10;  have hm : 0 &amp;lt; m := Nat.pos_of_mul_pos_left h&#10;  simp only [hm, getElem?_eq_getElem, findSome?_mk, Array.findSome?_isSome_iff, Array.mem_map,&#10;    Array.mem_attach, mk_eq, true_and, Subtype.exists, exists_prop, exists_eq_right,&#10;    Option.isSome_some, and_true]&#10;  exact ⟨⟨xss[0], h₂ _ (by simp)⟩, by simp⟩">
                    <AtomNode start="(98, 3)" end="(98, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(98, 9)" end="(98, 12)">
                      <OtherNode start="(98, 9)" end="(98, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(98, 9)" end="(98, 12)" leading="" trailing=" " raw_val="xss" val="xss"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(98, 13)" end="(98, 36)">
                      <AtomNode start="(98, 13)" end="(98, 18)" leading="" trailing=" " val="using"/>
                      <IdentNode start="(98, 19)" end="(98, 36)" leading="" trailing=" " raw_val="vector₂_induction" val="vector₂_induction" full_name="Vector.vector₂_induction" mod_name="Init.Data.Vector.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Lemmas.lean"/>
                    </NullNode>
                    <NullNode start="(98, 37)" end="(105, 46)">
                      <OtherNode start="(98, 37)" end="(105, 46)" kind="Lean.Parser.Tactic.inductionAlts">
                        <AtomNode start="(98, 37)" end="(98, 41)" leading="" trailing="&#10;  " val="with"/>
                        <NullNode/>
                        <NullNode start="(99, 3)" end="(105, 46)">
                          <OtherNode start="(99, 3)" end="(105, 46)" kind="Lean.Parser.Tactic.inductionAlt">
                            <NullNode start="(99, 3)" end="(99, 17)">
                              <OtherNode start="(99, 3)" end="(99, 17)" kind="Lean.Parser.Tactic.inductionAltLHS">
                                <AtomNode start="(99, 3)" end="(99, 4)" leading="" trailing=" " val="|"/>
                                <GroupNode start="(99, 5)" end="(99, 7)">
                                  <NullNode/>
                                  <IdentNode start="(99, 5)" end="(99, 7)" leading="" trailing=" " raw_val="of" val="of"/>
                                </GroupNode>
                                <NullNode start="(99, 8)" end="(99, 17)">
                                  <IdentNode start="(99, 8)" end="(99, 11)" leading="" trailing=" " raw_val="xss" val="xss"/>
                                  <IdentNode start="(99, 12)" end="(99, 14)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                  <IdentNode start="(99, 15)" end="(99, 17)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode start="(99, 18)" end="(105, 46)">
                              <AtomNode start="(99, 18)" end="(99, 20)" leading="" trailing="&#10;    " val="=&amp;gt;"/>
                              <TacticTacticseqNode start="(100, 5)" end="(105, 46)">
                                <TacticTacticseq1IndentedNode start="(100, 5)" end="(105, 46)">
                                  <NullNode start="(100, 5)" end="(105, 46)">
                                    <OtherNode start="(100, 5)" end="(100, 50)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case of&#10;α : Type u_1&#10;m n : Nat&#10;h : 0 &amp;lt; n * m&#10;xss : Array (Array α)&#10;h₁ : xss.size = n&#10;h₂ : ∀ (xs : Array α), xs ∈ xss → xs.size = m&#10;⊢ (findSome? (fun xs =&amp;gt; xs[0]?)&#10;        {&#10;          toArray :=&#10;            Array.map&#10;              (fun x =&amp;gt;&#10;                match x with&#10;                | ⟨xs, m_1⟩ =&amp;gt; { toArray := xs, size_toArray := ⋯ })&#10;              xss.attach,&#10;          size_toArray := ⋯ }).isSome =&#10;    true" state_after="case of&#10;α : Type u_1&#10;m n : Nat&#10;h : 0 &amp;lt; n * m&#10;xss : Array (Array α)&#10;h₁ : xss.size = n&#10;h₂ : ∀ (xs : Array α), xs ∈ xss → xs.size = m&#10;hn : 0 &amp;lt; n&#10;⊢ (findSome? (fun xs =&amp;gt; xs[0]?)&#10;        {&#10;          toArray :=&#10;            Array.map&#10;              (fun x =&amp;gt;&#10;                match x with&#10;                | ⟨xs, m_1⟩ =&amp;gt; { toArray := xs, size_toArray := ⋯ })&#10;              xss.attach,&#10;          size_toArray := ⋯ }).isSome =&#10;    true" tactic="have hn : 0 &amp;lt; n := Nat.pos_of_mul_pos_right h">
                                      <AtomNode start="(100, 5)" end="(100, 9)" leading="" trailing=" " val="have"/>
                                      <OtherNode start="(100, 10)" end="(100, 50)" kind="Lean.Parser.Term.haveDecl">
                                        <OtherNode start="(100, 10)" end="(100, 50)" kind="Lean.Parser.Term.haveIdDecl">
                                          <OtherNode start="(100, 10)" end="(100, 12)" kind="Lean.Parser.Term.haveId">
                                            <IdentNode start="(100, 10)" end="(100, 12)" leading="" trailing=" " raw_val="hn" val="hn"/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode start="(100, 13)" end="(100, 20)">
                                            <TermTypespecNode start="(100, 13)" end="(100, 20)">
                                              <AtomNode start="(100, 13)" end="(100, 14)" leading="" trailing=" " val=":"/>
                                              <OtherNode start="(100, 15)" end="(100, 20)" kind="«term_&amp;lt;_»">
                                                <OtherNode start="(100, 15)" end="(100, 16)" kind="num">
                                                  <AtomNode start="(100, 15)" end="(100, 16)" leading="" trailing=" " val="0"/>
                                                </OtherNode>
                                                <AtomNode start="(100, 17)" end="(100, 18)" leading="" trailing=" " val="&amp;lt;"/>
                                                <IdentNode start="(100, 19)" end="(100, 20)" leading="" trailing=" " raw_val="n" val="n"/>
                                              </OtherNode>
                                            </TermTypespecNode>
                                          </NullNode>
                                          <AtomNode start="(100, 21)" end="(100, 23)" leading="" trailing=" " val=":="/>
                                          <OtherNode start="(100, 24)" end="(100, 50)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(100, 24)" end="(100, 48)" leading="" trailing=" " raw_val="Nat.pos_of_mul_pos_right" val="Nat.pos_of_mul_pos_right" full_name="Nat.pos_of_mul_pos_right" mod_name="Init.Data.Nat.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Lemmas.lean"/>
                                            <NullNode start="(100, 49)" end="(100, 50)">
                                              <IdentNode start="(100, 49)" end="(100, 50)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(101, 5)" end="(101, 49)" kind="Lean.Parser.Tactic.tacticHave_" state_before="case of&#10;α : Type u_1&#10;m n : Nat&#10;h : 0 &amp;lt; n * m&#10;xss : Array (Array α)&#10;h₁ : xss.size = n&#10;h₂ : ∀ (xs : Array α), xs ∈ xss → xs.size = m&#10;hn : 0 &amp;lt; n&#10;⊢ (findSome? (fun xs =&amp;gt; xs[0]?)&#10;        {&#10;          toArray :=&#10;            Array.map&#10;              (fun x =&amp;gt;&#10;                match x with&#10;                | ⟨xs, m_1⟩ =&amp;gt; { toArray := xs, size_toArray := ⋯ })&#10;              xss.attach,&#10;          size_toArray := ⋯ }).isSome =&#10;    true" state_after="case of&#10;α : Type u_1&#10;m n : Nat&#10;h : 0 &amp;lt; n * m&#10;xss : Array (Array α)&#10;h₁ : xss.size = n&#10;h₂ : ∀ (xs : Array α), xs ∈ xss → xs.size = m&#10;hn : 0 &amp;lt; n&#10;hm : 0 &amp;lt; m&#10;⊢ (findSome? (fun xs =&amp;gt; xs[0]?)&#10;        {&#10;          toArray :=&#10;            Array.map&#10;              (fun x =&amp;gt;&#10;                match x with&#10;                | ⟨xs, m_1⟩ =&amp;gt; { toArray := xs, size_toArray := ⋯ })&#10;              xss.attach,&#10;          size_toArray := ⋯ }).isSome =&#10;    true" tactic="have hm : 0 &amp;lt; m := Nat.pos_of_mul_pos_left h">
                                      <AtomNode start="(101, 5)" end="(101, 9)" leading="" trailing=" " val="have"/>
                                      <OtherNode start="(101, 10)" end="(101, 49)" kind="Lean.Parser.Term.haveDecl">
                                        <OtherNode start="(101, 10)" end="(101, 49)" kind="Lean.Parser.Term.haveIdDecl">
                                          <OtherNode start="(101, 10)" end="(101, 12)" kind="Lean.Parser.Term.haveId">
                                            <IdentNode start="(101, 10)" end="(101, 12)" leading="" trailing=" " raw_val="hm" val="hm"/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode start="(101, 13)" end="(101, 20)">
                                            <TermTypespecNode start="(101, 13)" end="(101, 20)">
                                              <AtomNode start="(101, 13)" end="(101, 14)" leading="" trailing=" " val=":"/>
                                              <OtherNode start="(101, 15)" end="(101, 20)" kind="«term_&amp;lt;_»">
                                                <OtherNode start="(101, 15)" end="(101, 16)" kind="num">
                                                  <AtomNode start="(101, 15)" end="(101, 16)" leading="" trailing=" " val="0"/>
                                                </OtherNode>
                                                <AtomNode start="(101, 17)" end="(101, 18)" leading="" trailing=" " val="&amp;lt;"/>
                                                <IdentNode start="(101, 19)" end="(101, 20)" leading="" trailing=" " raw_val="m" val="m"/>
                                              </OtherNode>
                                            </TermTypespecNode>
                                          </NullNode>
                                          <AtomNode start="(101, 21)" end="(101, 23)" leading="" trailing=" " val=":="/>
                                          <OtherNode start="(101, 24)" end="(101, 49)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(101, 24)" end="(101, 47)" leading="" trailing=" " raw_val="Nat.pos_of_mul_pos_left" val="Nat.pos_of_mul_pos_left" full_name="Nat.pos_of_mul_pos_left" mod_name="Init.Data.Nat.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Lemmas.lean"/>
                                            <NullNode start="(101, 48)" end="(101, 49)">
                                              <IdentNode start="(101, 48)" end="(101, 49)" leading="" trailing="&#10;    " raw_val="h" val="h"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(102, 5)" end="(104, 36)" kind="Lean.Parser.Tactic.simp" state_before="case of&#10;α : Type u_1&#10;m n : Nat&#10;h : 0 &amp;lt; n * m&#10;xss : Array (Array α)&#10;h₁ : xss.size = n&#10;h₂ : ∀ (xs : Array α), xs ∈ xss → xs.size = m&#10;hn : 0 &amp;lt; n&#10;hm : 0 &amp;lt; m&#10;⊢ (findSome? (fun xs =&amp;gt; xs[0]?)&#10;        {&#10;          toArray :=&#10;            Array.map&#10;              (fun x =&amp;gt;&#10;                match x with&#10;                | ⟨xs, m_1⟩ =&amp;gt; { toArray := xs, size_toArray := ⋯ })&#10;              xss.attach,&#10;          size_toArray := ⋯ }).isSome =&#10;    true" state_after="case of&#10;α : Type u_1&#10;m n : Nat&#10;h : 0 &amp;lt; n * m&#10;xss : Array (Array α)&#10;h₁ : xss.size = n&#10;h₂ : ∀ (xs : Array α), xs ∈ xss → xs.size = m&#10;hn : 0 &amp;lt; n&#10;hm : 0 &amp;lt; m&#10;⊢ ∃ x, x.toArray ∈ xss" tactic="simp only [hm, getElem?_eq_getElem, findSome?_mk, Array.findSome?_isSome_iff, Array.mem_map,&#10;  Array.mem_attach, mk_eq, true_and, Subtype.exists, exists_prop, exists_eq_right,&#10;  Option.isSome_some, and_true]">
                                      <AtomNode start="(102, 5)" end="(102, 9)" leading="" trailing=" " val="simp"/>
                                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                        <NullNode/>
                                      </OtherNode>
                                      <NullNode/>
                                      <NullNode start="(102, 10)" end="(102, 14)">
                                        <AtomNode start="(102, 10)" end="(102, 14)" leading="" trailing=" " val="only"/>
                                      </NullNode>
                                      <NullNode start="(102, 15)" end="(104, 36)">
                                        <AtomNode start="(102, 15)" end="(102, 16)" leading="" trailing="" val="["/>
                                        <NullNode start="(102, 16)" end="(104, 35)">
                                          <OtherNode start="(102, 16)" end="(102, 18)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(102, 16)" end="(102, 18)" leading="" trailing="" raw_val="hm" val="hm"/>
                                          </OtherNode>
                                          <AtomNode start="(102, 18)" end="(102, 19)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(102, 20)" end="(102, 39)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(102, 20)" end="(102, 39)" leading="" trailing="" raw_val="getElem?_eq_getElem" val="getElem?_eq_getElem" full_name="Vector.getElem?_eq_getElem" mod_name="Init.Data.Vector.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Lemmas.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(102, 39)" end="(102, 40)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(102, 41)" end="(102, 53)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(102, 41)" end="(102, 53)" leading="" trailing="" raw_val="findSome?_mk" val="findSome?_mk" full_name="Vector.findSome?_mk" mod_name="Init.Data.Vector.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Lemmas.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(102, 53)" end="(102, 54)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(102, 55)" end="(102, 81)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(102, 55)" end="(102, 81)" leading="" trailing="" raw_val="Array.findSome?_isSome_iff" val="Array.findSome?_isSome_iff" full_name="Array.findSome?_isSome_iff" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(102, 81)" end="(102, 82)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(102, 83)" end="(102, 96)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(102, 83)" end="(102, 96)" leading="" trailing="" raw_val="Array.mem_map" val="Array.mem_map" full_name="Array.mem_map" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(102, 96)" end="(102, 97)" leading="" trailing="&#10;      " val=","/>
                                          <OtherNode start="(103, 7)" end="(103, 23)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(103, 7)" end="(103, 23)" leading="" trailing="" raw_val="Array.mem_attach" val="Array.mem_attach" full_name="Array.mem_attach" mod_name="Init.Data.Array.Attach" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Attach.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(103, 23)" end="(103, 24)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(103, 25)" end="(103, 30)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(103, 25)" end="(103, 30)" leading="" trailing="" raw_val="mk_eq" val="mk_eq" full_name="Vector.mk_eq" mod_name="Init.Data.Vector.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Lemmas.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(103, 30)" end="(103, 31)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(103, 32)" end="(103, 40)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(103, 32)" end="(103, 40)" leading="" trailing="" raw_val="true_and" val="true_and" full_name="true_and" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(103, 40)" end="(103, 41)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(103, 42)" end="(103, 56)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(103, 42)" end="(103, 56)" leading="" trailing="" raw_val="Subtype.exists" val="Subtype.exists" full_name="Subtype.exists" mod_name="Init.Data.Subtype" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Subtype.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(103, 56)" end="(103, 57)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(103, 58)" end="(103, 69)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(103, 58)" end="(103, 69)" leading="" trailing="" raw_val="exists_prop" val="exists_prop" full_name="exists_prop" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(103, 69)" end="(103, 70)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(103, 71)" end="(103, 86)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(103, 71)" end="(103, 86)" leading="" trailing="" raw_val="exists_eq_right" val="exists_eq_right" full_name="exists_eq_right" mod_name="Init.PropLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/PropLemmas.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(103, 86)" end="(103, 87)" leading="" trailing="&#10;      " val=","/>
                                          <OtherNode start="(104, 7)" end="(104, 25)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(104, 7)" end="(104, 25)" leading="" trailing="" raw_val="Option.isSome_some" val="Option.isSome_some" full_name="Option.isSome_some" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                                          </OtherNode>
                                          <AtomNode start="(104, 25)" end="(104, 26)" leading="" trailing=" " val=","/>
                                          <OtherNode start="(104, 27)" end="(104, 35)" kind="Lean.Parser.Tactic.simpLemma">
                                            <NullNode/>
                                            <NullNode/>
                                            <IdentNode start="(104, 27)" end="(104, 35)" leading="" trailing="" raw_val="and_true" val="and_true" full_name="and_true" mod_name="Init.SimpLemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/SimpLemmas.lean"/>
                                          </OtherNode>
                                        </NullNode>
                                        <AtomNode start="(104, 35)" end="(104, 36)" leading="" trailing="&#10;    " val="]"/>
                                      </NullNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(105, 5)" end="(105, 46)" kind="Lean.Parser.Tactic.exact" state_before="case of&#10;α : Type u_1&#10;m n : Nat&#10;h : 0 &amp;lt; n * m&#10;xss : Array (Array α)&#10;h₁ : xss.size = n&#10;h₂ : ∀ (xs : Array α), xs ∈ xss → xs.size = m&#10;hn : 0 &amp;lt; n&#10;hm : 0 &amp;lt; m&#10;⊢ ∃ x, x.toArray ∈ xss" state_after="no goals" tactic="exact ⟨⟨xss[0], h₂ _ (by simp)⟩, by simp⟩">
                                      <AtomNode start="(105, 5)" end="(105, 10)" leading="" trailing=" " val="exact"/>
                                      <OtherNode start="(105, 11)" end="(105, 46)" kind="Lean.Parser.Term.anonymousCtor">
                                        <AtomNode start="(105, 11)" end="(105, 12)" leading="" trailing="" val="⟨"/>
                                        <NullNode start="(105, 12)" end="(105, 45)">
                                          <OtherNode start="(105, 12)" end="(105, 36)" kind="Lean.Parser.Term.anonymousCtor">
                                            <AtomNode start="(105, 12)" end="(105, 13)" leading="" trailing="" val="⟨"/>
                                            <NullNode start="(105, 13)" end="(105, 35)">
                                              <OtherNode start="(105, 13)" end="(105, 19)" kind="«term__[_]»">
                                                <IdentNode start="(105, 13)" end="(105, 16)" leading="" trailing="" raw_val="xss" val="xss"/>
                                                <AtomNode start="(105, 16)" end="(105, 17)" leading="" trailing="" val="["/>
                                                <OtherNode start="(105, 17)" end="(105, 18)" kind="num">
                                                  <AtomNode start="(105, 17)" end="(105, 18)" leading="" trailing="" val="0"/>
                                                </OtherNode>
                                                <AtomNode start="(105, 18)" end="(105, 19)" leading="" trailing="" val="]"/>
                                              </OtherNode>
                                              <AtomNode start="(105, 19)" end="(105, 20)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(105, 21)" end="(105, 35)" kind="Lean.Parser.Term.app">
                                                <IdentNode start="(105, 21)" end="(105, 23)" leading="" trailing=" " raw_val="h₂" val="h₂"/>
                                                <NullNode start="(105, 24)" end="(105, 35)">
                                                  <TermHoleNode start="(105, 24)" end="(105, 25)">
                                                    <AtomNode start="(105, 24)" end="(105, 25)" leading="" trailing=" " val="_"/>
                                                  </TermHoleNode>
                                                  <OtherNode start="(105, 26)" end="(105, 35)" kind="Lean.Parser.Term.paren">
                                                    <AtomNode start="(105, 26)" end="(105, 27)" leading="" trailing="" val="("/>
                                                    <TermBytacticNode start="(105, 27)" end="(105, 34)">
                                                      <AtomNode start="(105, 27)" end="(105, 29)" leading="" trailing=" " val="by"/>
                                                      <TacticTacticseqNode start="(105, 30)" end="(105, 34)">
                                                        <TacticTacticseq1IndentedNode start="(105, 30)" end="(105, 34)">
                                                          <NullNode start="(105, 30)" end="(105, 34)">
                                                            <OtherNode start="(105, 30)" end="(105, 34)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;m n : Nat&#10;h : 0 &amp;lt; n * m&#10;xss : Array (Array α)&#10;h₁ : xss.size = n&#10;h₂ : ∀ (xs : Array α), xs ∈ xss → xs.size = m&#10;hn : 0 &amp;lt; n&#10;hm : 0 &amp;lt; m&#10;⊢ xss[0] ∈ xss" state_after="no goals" tactic="simp">
                                                            <AtomNode start="(105, 30)" end="(105, 34)" leading="" trailing="" val="simp"/>
                                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                            <NullNode/>
                                                            </OtherNode>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            <NullNode/>
                                                            </OtherNode>
                                                          </NullNode>
                                                        </TacticTacticseq1IndentedNode>
                                                      </TacticTacticseqNode>
                                                    </TermBytacticNode>
                                                    <AtomNode start="(105, 34)" end="(105, 35)" leading="" trailing="" val=")"/>
                                                  </OtherNode>
                                                </NullNode>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(105, 35)" end="(105, 36)" leading="" trailing="" val="⟩"/>
                                          </OtherNode>
                                          <AtomNode start="(105, 36)" end="(105, 37)" leading="" trailing=" " val=","/>
                                          <TermBytacticNode start="(105, 38)" end="(105, 45)">
                                            <AtomNode start="(105, 38)" end="(105, 40)" leading="" trailing=" " val="by"/>
                                            <TacticTacticseqNode start="(105, 41)" end="(105, 45)">
                                              <TacticTacticseq1IndentedNode start="(105, 41)" end="(105, 45)">
                                                <NullNode start="(105, 41)" end="(105, 45)">
                                                  <OtherNode start="(105, 41)" end="(105, 45)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;m n : Nat&#10;h : 0 &amp;lt; n * m&#10;xss : Array (Array α)&#10;h₁ : xss.size = n&#10;h₂ : ∀ (xs : Array α), xs ∈ xss → xs.size = m&#10;hn : 0 &amp;lt; n&#10;hm : 0 &amp;lt; m&#10;⊢ { toArray := xss[0], size_toArray := ⋯ }.toArray ∈ xss" state_after="no goals" tactic="simp">
                                                    <AtomNode start="(105, 41)" end="(105, 45)" leading="" trailing="" val="simp"/>
                                                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <NullNode/>
                                                  </OtherNode>
                                                </NullNode>
                                              </TacticTacticseq1IndentedNode>
                                            </TacticTacticseqNode>
                                          </TermBytacticNode>
                                        </NullNode>
                                        <AtomNode start="(105, 45)" end="(105, 46)" leading="" trailing="&#10;&#10;" val="⟩"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(107, 1)" end="(111, 13)" name="getElem_zero_flatten" full_name="Vector.getElem_zero_flatten">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(107, 1)" end="(111, 13)" name="getElem_zero_flatten" full_name="Vector.getElem_zero_flatten" _is_private_decl="False">
        <AtomNode start="(107, 1)" end="(107, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(107, 9)" end="(107, 29)">
          <IdentNode start="(107, 9)" end="(107, 29)" leading="" trailing=" " raw_val="getElem_zero_flatten" val="getElem_zero_flatten"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(107, 30)" end="(108, 91)">
          <NullNode start="(107, 30)" end="(107, 75)">
            <OtherNode start="(107, 30)" end="(107, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(107, 30)" end="(107, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(107, 31)" end="(107, 34)">
                <IdentNode start="(107, 31)" end="(107, 34)" leading="" trailing=" " raw_val="xss" val="xss"/>
              </NullNode>
              <NullNode start="(107, 35)" end="(107, 58)">
                <AtomNode start="(107, 35)" end="(107, 36)" leading="" trailing=" " val=":"/>
                <OtherNode start="(107, 37)" end="(107, 58)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(107, 37)" end="(107, 43)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(107, 44)" end="(107, 58)">
                    <OtherNode start="(107, 44)" end="(107, 56)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(107, 44)" end="(107, 45)" leading="" trailing="" val="("/>
                      <OtherNode start="(107, 45)" end="(107, 55)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(107, 45)" end="(107, 51)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                        <NullNode start="(107, 52)" end="(107, 55)">
                          <IdentNode start="(107, 52)" end="(107, 53)" leading="" trailing=" " raw_val="α" val="α"/>
                          <IdentNode start="(107, 54)" end="(107, 55)" leading="" trailing="" raw_val="m" val="m"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(107, 55)" end="(107, 56)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <IdentNode start="(107, 57)" end="(107, 58)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(107, 58)" end="(107, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(107, 60)" end="(107, 75)">
              <AtomNode start="(107, 60)" end="(107, 61)" leading="" trailing="" val="("/>
              <NullNode start="(107, 61)" end="(107, 62)">
                <IdentNode start="(107, 61)" end="(107, 62)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(107, 63)" end="(107, 74)">
                <AtomNode start="(107, 63)" end="(107, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(107, 65)" end="(107, 74)" kind="«term_&amp;lt;_»">
                  <OtherNode start="(107, 65)" end="(107, 66)" kind="num">
                    <AtomNode start="(107, 65)" end="(107, 66)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                  <AtomNode start="(107, 67)" end="(107, 68)" leading="" trailing=" " val="&amp;lt;"/>
                  <OtherNode start="(107, 69)" end="(107, 74)" kind="«term_*_»">
                    <IdentNode start="(107, 69)" end="(107, 70)" leading="" trailing=" " raw_val="n" val="n"/>
                    <AtomNode start="(107, 71)" end="(107, 72)" leading="" trailing=" " val="*"/>
                    <IdentNode start="(107, 73)" end="(107, 74)" leading="" trailing="" raw_val="m" val="m"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(107, 74)" end="(107, 75)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(107, 76)" end="(108, 91)">
            <AtomNode start="(107, 76)" end="(107, 77)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(108, 5)" end="(108, 91)" kind="«term_=_»">
              <OtherNode start="(108, 5)" end="(108, 21)" kind="«term__[_]»">
                <OtherNode start="(108, 5)" end="(108, 18)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(108, 5)" end="(108, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(108, 6)" end="(108, 17)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(108, 6)" end="(108, 13)" leading="" trailing=" " raw_val="flatten" val="flatten" full_name="Vector.flatten" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                    <NullNode start="(108, 14)" end="(108, 17)">
                      <IdentNode start="(108, 14)" end="(108, 17)" leading="" trailing="" raw_val="xss" val="xss"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(108, 17)" end="(108, 18)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(108, 18)" end="(108, 19)" leading="" trailing="" val="["/>
                <OtherNode start="(108, 19)" end="(108, 20)" kind="num">
                  <AtomNode start="(108, 19)" end="(108, 20)" leading="" trailing="" val="0"/>
                </OtherNode>
                <AtomNode start="(108, 20)" end="(108, 21)" leading="" trailing=" " val="]"/>
              </OtherNode>
              <AtomNode start="(108, 22)" end="(108, 23)" leading="" trailing=" " val="="/>
              <OtherNode start="(108, 24)" end="(108, 91)" kind="Lean.Parser.Term.app">
                <OtherNode start="(108, 24)" end="(108, 60)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(108, 24)" end="(108, 56)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(108, 24)" end="(108, 25)" leading="" trailing="" val="("/>
                    <OtherNode start="(108, 25)" end="(108, 55)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(108, 25)" end="(108, 38)" leading="" trailing=" " raw_val="xss.findSome?" val="xss.findSome?"/>
                      <NullNode start="(108, 39)" end="(108, 55)">
                        <OtherNode start="(108, 39)" end="(108, 55)" kind="Lean.Parser.Term.fun">
                          <AtomNode start="(108, 39)" end="(108, 42)" leading="" trailing=" " val="fun"/>
                          <OtherNode start="(108, 43)" end="(108, 55)" kind="Lean.Parser.Term.basicFun">
                            <NullNode start="(108, 43)" end="(108, 45)">
                              <IdentNode start="(108, 43)" end="(108, 45)" leading="" trailing=" " raw_val="xs" val="xs"/>
                            </NullNode>
                            <NullNode/>
                            <AtomNode start="(108, 46)" end="(108, 48)" leading="" trailing=" " val="=&amp;gt;"/>
                            <OtherNode start="(108, 49)" end="(108, 55)" kind="«term__[_]_?»">
                              <IdentNode start="(108, 49)" end="(108, 51)" leading="" trailing="" raw_val="xs" val="xs"/>
                              <GroupNode/>
                              <AtomNode start="(108, 51)" end="(108, 52)" leading="" trailing="" val="["/>
                              <OtherNode start="(108, 52)" end="(108, 53)" kind="num">
                                <AtomNode start="(108, 52)" end="(108, 53)" leading="" trailing="" val="0"/>
                              </OtherNode>
                              <AtomNode start="(108, 53)" end="(108, 54)" leading="" trailing="" val="]"/>
                              <GroupNode/>
                              <AtomNode start="(108, 54)" end="(108, 55)" leading="" trailing="" val="?"/>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(108, 55)" end="(108, 56)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(108, 56)" end="(108, 57)" leading="" trailing="" val="."/>
                  <IdentNode start="(108, 57)" end="(108, 60)" leading="" trailing=" " raw_val="get" val="get" full_name="Option.get" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(108, 61)" end="(108, 91)">
                  <OtherNode start="(108, 61)" end="(108, 91)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(108, 61)" end="(108, 62)" leading="" trailing="" val="("/>
                    <OtherNode start="(108, 62)" end="(108, 90)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(108, 62)" end="(108, 88)" leading="" trailing=" " raw_val="getElem_zero_flatten.proof" val="getElem_zero_flatten.proof" full_name="Vector.getElem_zero_flatten.proof" mod_name="Init.Data.Vector.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Find.lean" def_start="(96, 9)" def_end="(96, 35)"/>
                      <NullNode start="(108, 89)" end="(108, 90)">
                        <IdentNode start="(108, 89)" end="(108, 90)" leading="" trailing="" raw_val="h" val="h"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(108, 90)" end="(108, 91)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(108, 92)" end="(111, 13)">
          <AtomNode start="(108, 92)" end="(108, 94)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(108, 95)" end="(111, 13)">
            <AtomNode start="(108, 95)" end="(108, 97)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(109, 3)" end="(111, 13)">
              <TacticTacticseq1IndentedNode start="(109, 3)" end="(111, 13)">
                <NullNode start="(109, 3)" end="(111, 13)">
                  <OtherNode start="(109, 3)" end="(109, 47)" kind="Lean.Parser.Tactic.tacticHave_" state_before="α : Type u_1&#10;m n : Nat&#10;xss : Vector (Vector α m) n&#10;h : 0 &amp;lt; n * m&#10;⊢ xss.flatten[0] = (findSome? (fun xs =&amp;gt; xs[0]?) xss).get ⋯" state_after="α : Type u_1&#10;m n : Nat&#10;xss : Vector (Vector α m) n&#10;h : 0 &amp;lt; n * m&#10;t : xss.flatten[0]? = findSome? (fun xs =&amp;gt; xs[0]?) xss&#10;⊢ xss.flatten[0] = (findSome? (fun xs =&amp;gt; xs[0]?) xss).get ⋯" tactic="have t := getElem?_zero_flatten (xss := xss)">
                    <AtomNode start="(109, 3)" end="(109, 7)" leading="" trailing=" " val="have"/>
                    <OtherNode start="(109, 8)" end="(109, 47)" kind="Lean.Parser.Term.haveDecl">
                      <OtherNode start="(109, 8)" end="(109, 47)" kind="Lean.Parser.Term.haveIdDecl">
                        <OtherNode start="(109, 8)" end="(109, 9)" kind="Lean.Parser.Term.haveId">
                          <IdentNode start="(109, 8)" end="(109, 9)" leading="" trailing=" " raw_val="t" val="t"/>
                        </OtherNode>
                        <NullNode/>
                        <NullNode/>
                        <AtomNode start="(109, 10)" end="(109, 12)" leading="" trailing=" " val=":="/>
                        <OtherNode start="(109, 13)" end="(109, 47)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(109, 13)" end="(109, 34)" leading="" trailing=" " raw_val="getElem?_zero_flatten" val="getElem?_zero_flatten" full_name="Vector.getElem?_zero_flatten" mod_name="Init.Data.Vector.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Find.lean" def_start="(91, 9)" def_end="(91, 30)"/>
                          <NullNode start="(109, 35)" end="(109, 47)">
                            <OtherNode start="(109, 35)" end="(109, 47)" kind="Lean.Parser.Term.namedArgument">
                              <AtomNode start="(109, 35)" end="(109, 36)" leading="" trailing="" val="("/>
                              <IdentNode start="(109, 36)" end="(109, 39)" leading="" trailing=" " raw_val="xss" val="xss"/>
                              <AtomNode start="(109, 40)" end="(109, 42)" leading="" trailing=" " val=":="/>
                              <IdentNode start="(109, 43)" end="(109, 46)" leading="" trailing="" raw_val="xss" val="xss"/>
                              <AtomNode start="(109, 46)" end="(109, 47)" leading="" trailing="&#10;  " val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(110, 3)" end="(110, 37)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;m n : Nat&#10;xss : Vector (Vector α m) n&#10;h : 0 &amp;lt; n * m&#10;t : xss.flatten[0]? = findSome? (fun xs =&amp;gt; xs[0]?) xss&#10;⊢ xss.flatten[0] = (findSome? (fun xs =&amp;gt; xs[0]?) xss).get ⋯" state_after="α : Type u_1&#10;m n : Nat&#10;xss : Vector (Vector α m) n&#10;h : 0 &amp;lt; n * m&#10;t : some xss[0][0] = findSome? (fun xs =&amp;gt; xs[0]?) xss&#10;⊢ xss.flatten[0] = (findSome? (fun xs =&amp;gt; xs[0]?) xss).get ⋯" tactic="simp [getElem?_eq_getElem, h] at t">
                    <AtomNode start="(110, 3)" end="(110, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(110, 8)" end="(110, 32)">
                      <AtomNode start="(110, 8)" end="(110, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(110, 9)" end="(110, 31)">
                        <OtherNode start="(110, 9)" end="(110, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(110, 9)" end="(110, 28)" leading="" trailing="" raw_val="getElem?_eq_getElem" val="getElem?_eq_getElem" full_name="Vector.getElem?_eq_getElem" mod_name="Init.Data.Vector.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(110, 28)" end="(110, 29)" leading="" trailing=" " val=","/>
                        <OtherNode start="(110, 30)" end="(110, 31)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(110, 30)" end="(110, 31)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(110, 31)" end="(110, 32)" leading="" trailing=" " val="]"/>
                    </NullNode>
                    <NullNode start="(110, 33)" end="(110, 37)">
                      <OtherNode start="(110, 33)" end="(110, 37)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(110, 33)" end="(110, 35)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(110, 36)" end="(110, 37)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(110, 36)" end="(110, 37)">
                            <IdentNode start="(110, 36)" end="(110, 37)" leading="" trailing="&#10;  " raw_val="t" val="t"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(111, 3)" end="(111, 13)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;m n : Nat&#10;xss : Vector (Vector α m) n&#10;h : 0 &amp;lt; n * m&#10;t : some xss[0][0] = findSome? (fun xs =&amp;gt; xs[0]?) xss&#10;⊢ xss.flatten[0] = (findSome? (fun xs =&amp;gt; xs[0]?) xss).get ⋯" state_after="no goals" tactic="simp [← t]">
                    <AtomNode start="(111, 3)" end="(111, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(111, 8)" end="(111, 13)">
                      <AtomNode start="(111, 8)" end="(111, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(111, 9)" end="(111, 12)">
                        <OtherNode start="(111, 9)" end="(111, 12)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode start="(111, 9)" end="(111, 10)">
                            <OtherNode start="(111, 9)" end="(111, 10)" kind="patternIgnore">
                              <OtherNode start="(111, 9)" end="(111, 10)" kind="token.«← »">
                                <AtomNode start="(111, 9)" end="(111, 10)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(111, 11)" end="(111, 12)" leading="" trailing="" raw_val="t" val="t"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(111, 12)" end="(111, 13)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(113, 1)" end="(114, 74)" name="findSome?_replicate" full_name="Vector.findSome?_replicate">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(113, 1)" end="(114, 74)" name="findSome?_replicate" full_name="Vector.findSome?_replicate" _is_private_decl="False">
        <AtomNode start="(113, 1)" end="(113, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(113, 9)" end="(113, 28)">
          <IdentNode start="(113, 9)" end="(113, 28)" leading="" trailing=" " raw_val="findSome?_replicate" val="findSome?_replicate"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(113, 29)" end="(113, 88)">
          <NullNode/>
          <TermTypespecNode start="(113, 29)" end="(113, 88)">
            <AtomNode start="(113, 29)" end="(113, 30)" leading="" trailing=" " val=":"/>
            <OtherNode start="(113, 31)" end="(113, 88)" kind="«term_=_»">
              <OtherNode start="(113, 31)" end="(113, 58)" kind="Lean.Parser.Term.app">
                <IdentNode start="(113, 31)" end="(113, 40)" leading="" trailing=" " raw_val="findSome?" val="findSome?" full_name="Vector.findSome?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(113, 41)" end="(113, 58)">
                  <IdentNode start="(113, 41)" end="(113, 42)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(113, 43)" end="(113, 58)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(113, 43)" end="(113, 44)" leading="" trailing="" val="("/>
                    <OtherNode start="(113, 44)" end="(113, 57)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(113, 44)" end="(113, 53)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Vector.replicate" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                      <NullNode start="(113, 54)" end="(113, 57)">
                        <IdentNode start="(113, 54)" end="(113, 55)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(113, 56)" end="(113, 57)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(113, 57)" end="(113, 58)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(113, 59)" end="(113, 60)" leading="" trailing=" " val="="/>
              <OtherNode start="(113, 61)" end="(113, 88)" kind="termIfThenElse">
                <AtomNode start="(113, 61)" end="(113, 63)" leading="" trailing=" " val="if"/>
                <OtherNode start="(113, 64)" end="(113, 69)" kind="«term_=_»">
                  <IdentNode start="(113, 64)" end="(113, 65)" leading="" trailing=" " raw_val="n" val="n"/>
                  <AtomNode start="(113, 66)" end="(113, 67)" leading="" trailing=" " val="="/>
                  <OtherNode start="(113, 68)" end="(113, 69)" kind="num">
                    <AtomNode start="(113, 68)" end="(113, 69)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(113, 70)" end="(113, 74)" leading="" trailing=" " val="then"/>
                <IdentNode start="(113, 75)" end="(113, 79)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <AtomNode start="(113, 80)" end="(113, 84)" leading="" trailing=" " val="else"/>
                <OtherNode start="(113, 85)" end="(113, 88)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(113, 85)" end="(113, 86)" leading="" trailing=" " raw_val="f" val="f"/>
                  <NullNode start="(113, 87)" end="(113, 88)">
                    <IdentNode start="(113, 87)" end="(113, 88)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(113, 89)" end="(114, 74)">
          <AtomNode start="(113, 89)" end="(113, 91)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(113, 92)" end="(114, 74)">
            <AtomNode start="(113, 92)" end="(113, 94)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(114, 3)" end="(114, 74)">
              <TacticTacticseq1IndentedNode start="(114, 3)" end="(114, 74)">
                <NullNode start="(114, 3)" end="(114, 74)">
                  <OtherNode start="(114, 3)" end="(114, 74)" kind="Lean.Parser.Tactic.rwSeq" state_before="α✝¹ : Type u_1&#10;α✝ : Type u_2&#10;f : α✝¹ → Option α✝&#10;n : Nat&#10;a : α✝¹&#10;⊢ findSome? f (replicate n a) = if n = 0 then none else f a" state_after="no goals" tactic="rw [replicate_eq_mk_replicate, findSome?_mk, Array.findSome?_replicate]">
                    <AtomNode start="(114, 3)" end="(114, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(114, 6)" end="(114, 74)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(114, 6)" end="(114, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(114, 7)" end="(114, 73)">
                        <OtherNode start="(114, 7)" end="(114, 32)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(114, 7)" end="(114, 32)" leading="" trailing="" raw_val="replicate_eq_mk_replicate" val="replicate_eq_mk_replicate" full_name="Vector.replicate_eq_mk_replicate" mod_name="Init.Data.Vector.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(114, 32)" end="(114, 33)" leading="" trailing=" " val=","/>
                        <OtherNode start="(114, 34)" end="(114, 46)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(114, 34)" end="(114, 46)" leading="" trailing="" raw_val="findSome?_mk" val="findSome?_mk" full_name="Vector.findSome?_mk" mod_name="Init.Data.Vector.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(114, 46)" end="(114, 47)" leading="" trailing=" " val=","/>
                        <OtherNode start="(114, 48)" end="(114, 73)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(114, 48)" end="(114, 73)" leading="" trailing="" raw_val="Array.findSome?_replicate" val="Array.findSome?_replicate" full_name="Array.findSome?_replicate" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(114, 73)" end="(114, 74)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(116, 1)" end="(117, 50)" name="findSome?_mkVector" full_name="Vector.findSome?_mkVector">
      <CommandDeclmodifiersNode start="(116, 1)" end="(116, 58)">
        <NullNode/>
        <NullNode start="(116, 1)" end="(116, 58)">
          <OtherNode start="(116, 1)" end="(116, 58)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(116, 1)" end="(116, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(116, 3)" end="(116, 57)">
              <OtherNode start="(116, 3)" end="(116, 57)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(116, 3)" end="(116, 57)" kind="Lean.deprecated">
                  <AtomNode start="(116, 3)" end="(116, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(116, 14)" end="(116, 33)">
                    <IdentNode start="(116, 14)" end="(116, 33)" leading="" trailing=" " raw_val="findSome?_replicate" val="findSome?_replicate" full_name="Vector.findSome?_replicate" mod_name="Init.Data.Vector.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Find.lean" def_start="(113, 9)" def_end="(113, 28)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(116, 34)" end="(116, 57)">
                    <AtomNode start="(116, 34)" end="(116, 35)" leading="" trailing="" val="("/>
                    <AtomNode start="(116, 35)" end="(116, 40)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(116, 41)" end="(116, 43)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(116, 44)" end="(116, 56)" kind="str">
                      <AtomNode start="(116, 44)" end="(116, 56)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(116, 56)" end="(116, 57)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(116, 57)" end="(116, 58)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(117, 1)" end="(117, 50)" name="findSome?_mkVector">
        <AtomNode start="(117, 1)" end="(117, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(117, 8)" end="(117, 26)">
          <IdentNode start="(117, 8)" end="(117, 26)" leading="" trailing=" " raw_val="findSome?_mkVector" val="findSome?_mkVector"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(117, 27)" end="(117, 50)">
          <AtomNode start="(117, 27)" end="(117, 29)" leading="" trailing=" " val=":="/>
          <OtherNode start="(117, 30)" end="(117, 50)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(117, 30)" end="(117, 31)" leading="" trailing="" val="@"/>
            <IdentNode start="(117, 31)" end="(117, 50)" leading="" trailing="&#10;&#10;" raw_val="findSome?_replicate" val="findSome?_replicate" full_name="Vector.findSome?_replicate" mod_name="Init.Data.Vector.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Find.lean" def_start="(113, 9)" def_end="(113, 28)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(119, 1)" end="(120, 45)" name="findSome?_replicate_of_pos" full_name="Vector.findSome?_replicate_of_pos">
      <CommandDeclmodifiersNode start="(119, 1)" end="(119, 8)">
        <NullNode/>
        <NullNode start="(119, 1)" end="(119, 8)">
          <OtherNode start="(119, 1)" end="(119, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(119, 1)" end="(119, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(119, 3)" end="(119, 7)">
              <OtherNode start="(119, 3)" end="(119, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(119, 3)" end="(119, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(119, 3)" end="(119, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(119, 7)" end="(119, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(119, 9)" end="(120, 45)" name="findSome?_replicate_of_pos" full_name="Vector.findSome?_replicate_of_pos" _is_private_decl="False">
        <AtomNode start="(119, 9)" end="(119, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(119, 17)" end="(119, 43)">
          <IdentNode start="(119, 17)" end="(119, 43)" leading="" trailing=" " raw_val="findSome?_replicate_of_pos" val="findSome?_replicate_of_pos"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(119, 44)" end="(119, 91)">
          <NullNode start="(119, 44)" end="(119, 55)">
            <TermExplicitbinderNode start="(119, 44)" end="(119, 55)">
              <AtomNode start="(119, 44)" end="(119, 45)" leading="" trailing="" val="("/>
              <NullNode start="(119, 45)" end="(119, 46)">
                <IdentNode start="(119, 45)" end="(119, 46)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(119, 47)" end="(119, 54)">
                <AtomNode start="(119, 47)" end="(119, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(119, 49)" end="(119, 54)" kind="«term_&amp;lt;_»">
                  <OtherNode start="(119, 49)" end="(119, 50)" kind="num">
                    <AtomNode start="(119, 49)" end="(119, 50)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                  <AtomNode start="(119, 51)" end="(119, 52)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(119, 53)" end="(119, 54)" leading="" trailing="" raw_val="n" val="n"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(119, 54)" end="(119, 55)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(119, 56)" end="(119, 91)">
            <AtomNode start="(119, 56)" end="(119, 57)" leading="" trailing=" " val=":"/>
            <OtherNode start="(119, 58)" end="(119, 91)" kind="«term_=_»">
              <OtherNode start="(119, 58)" end="(119, 85)" kind="Lean.Parser.Term.app">
                <IdentNode start="(119, 58)" end="(119, 67)" leading="" trailing=" " raw_val="findSome?" val="findSome?" full_name="Vector.findSome?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(119, 68)" end="(119, 85)">
                  <IdentNode start="(119, 68)" end="(119, 69)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(119, 70)" end="(119, 85)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(119, 70)" end="(119, 71)" leading="" trailing="" val="("/>
                    <OtherNode start="(119, 71)" end="(119, 84)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(119, 71)" end="(119, 80)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Vector.replicate" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                      <NullNode start="(119, 81)" end="(119, 84)">
                        <IdentNode start="(119, 81)" end="(119, 82)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(119, 83)" end="(119, 84)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(119, 84)" end="(119, 85)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(119, 86)" end="(119, 87)" leading="" trailing=" " val="="/>
              <OtherNode start="(119, 88)" end="(119, 91)" kind="Lean.Parser.Term.app">
                <IdentNode start="(119, 88)" end="(119, 89)" leading="" trailing=" " raw_val="f" val="f"/>
                <NullNode start="(119, 90)" end="(119, 91)">
                  <IdentNode start="(119, 90)" end="(119, 91)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(119, 92)" end="(120, 45)">
          <AtomNode start="(119, 92)" end="(119, 94)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(119, 95)" end="(120, 45)">
            <AtomNode start="(119, 95)" end="(119, 97)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(120, 3)" end="(120, 45)">
              <TacticTacticseq1IndentedNode start="(120, 3)" end="(120, 45)">
                <NullNode start="(120, 3)" end="(120, 45)">
                  <OtherNode start="(120, 3)" end="(120, 45)" kind="Lean.Parser.Tactic.simp" state_before="n : Nat&#10;α✝¹ : Type u_1&#10;α✝ : Type u_2&#10;f : α✝¹ → Option α✝&#10;a : α✝¹&#10;h : 0 &amp;lt; n&#10;⊢ findSome? f (replicate n a) = f a" state_after="no goals" tactic="simp [findSome?_replicate, Nat.ne_of_gt h]">
                    <AtomNode start="(120, 3)" end="(120, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(120, 8)" end="(120, 45)">
                      <AtomNode start="(120, 8)" end="(120, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(120, 9)" end="(120, 44)">
                        <OtherNode start="(120, 9)" end="(120, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(120, 9)" end="(120, 28)" leading="" trailing="" raw_val="findSome?_replicate" val="findSome?_replicate" full_name="Vector.findSome?_replicate" mod_name="Init.Data.Vector.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Find.lean" def_start="(113, 9)" def_end="(113, 28)"/>
                        </OtherNode>
                        <AtomNode start="(120, 28)" end="(120, 29)" leading="" trailing=" " val=","/>
                        <OtherNode start="(120, 30)" end="(120, 44)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <OtherNode start="(120, 30)" end="(120, 44)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(120, 30)" end="(120, 42)" leading="" trailing=" " raw_val="Nat.ne_of_gt" val="Nat.ne_of_gt" full_name="Nat.ne_of_gt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                            <NullNode start="(120, 43)" end="(120, 44)">
                              <IdentNode start="(120, 43)" end="(120, 44)" leading="" trailing="" raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(120, 44)" end="(120, 45)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(122, 1)" end="(123, 64)" name="findSome?_mkVector_of_pos" full_name="Vector.findSome?_mkVector_of_pos">
      <CommandDeclmodifiersNode start="(122, 1)" end="(122, 65)">
        <NullNode/>
        <NullNode start="(122, 1)" end="(122, 65)">
          <OtherNode start="(122, 1)" end="(122, 65)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(122, 1)" end="(122, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(122, 3)" end="(122, 64)">
              <OtherNode start="(122, 3)" end="(122, 64)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(122, 3)" end="(122, 64)" kind="Lean.deprecated">
                  <AtomNode start="(122, 3)" end="(122, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(122, 14)" end="(122, 40)">
                    <IdentNode start="(122, 14)" end="(122, 40)" leading="" trailing=" " raw_val="findSome?_replicate_of_pos" val="findSome?_replicate_of_pos" full_name="Vector.findSome?_replicate_of_pos" mod_name="Init.Data.Vector.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Find.lean" def_start="(119, 17)" def_end="(119, 43)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(122, 41)" end="(122, 64)">
                    <AtomNode start="(122, 41)" end="(122, 42)" leading="" trailing="" val="("/>
                    <AtomNode start="(122, 42)" end="(122, 47)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(122, 48)" end="(122, 50)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(122, 51)" end="(122, 63)" kind="str">
                      <AtomNode start="(122, 51)" end="(122, 63)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(122, 63)" end="(122, 64)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(122, 64)" end="(122, 65)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(123, 1)" end="(123, 64)" name="findSome?_mkVector_of_pos">
        <AtomNode start="(123, 1)" end="(123, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(123, 8)" end="(123, 33)">
          <IdentNode start="(123, 8)" end="(123, 33)" leading="" trailing=" " raw_val="findSome?_mkVector_of_pos" val="findSome?_mkVector_of_pos"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(123, 34)" end="(123, 64)">
          <AtomNode start="(123, 34)" end="(123, 36)" leading="" trailing=" " val=":="/>
          <OtherNode start="(123, 37)" end="(123, 64)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(123, 37)" end="(123, 38)" leading="" trailing="" val="@"/>
            <IdentNode start="(123, 38)" end="(123, 64)" leading="" trailing="&#10;&#10;-- Argument is unused, but used to decide whether `simp` should unfold.&#10;" raw_val="findSome?_replicate_of_pos" val="findSome?_replicate_of_pos" full_name="Vector.findSome?_replicate_of_pos" mod_name="Init.Data.Vector.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Find.lean" def_start="(119, 17)" def_end="(119, 43)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(126, 1)" end="(128, 29)" name="findSome?_replicate_of_isSome" full_name="Vector.findSome?_replicate_of_isSome">
      <CommandDeclmodifiersNode start="(126, 1)" end="(126, 8)">
        <NullNode/>
        <NullNode start="(126, 1)" end="(126, 8)">
          <OtherNode start="(126, 1)" end="(126, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(126, 1)" end="(126, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(126, 3)" end="(126, 7)">
              <OtherNode start="(126, 3)" end="(126, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(126, 3)" end="(126, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(126, 3)" end="(126, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(126, 7)" end="(126, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(126, 9)" end="(128, 29)" name="findSome?_replicate_of_isSome" full_name="Vector.findSome?_replicate_of_isSome" _is_private_decl="False">
        <AtomNode start="(126, 9)" end="(126, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(126, 17)" end="(126, 46)">
          <IdentNode start="(126, 17)" end="(126, 46)" leading="" trailing=" " raw_val="findSome?_replicate_of_isSome" val="findSome?_replicate_of_isSome"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(126, 47)" end="(127, 61)">
          <NullNode start="(126, 47)" end="(126, 65)">
            <TermExplicitbinderNode start="(126, 47)" end="(126, 65)">
              <AtomNode start="(126, 47)" end="(126, 48)" leading="" trailing="" val="("/>
              <NullNode start="(126, 48)" end="(126, 49)">
                <TermHoleNode start="(126, 48)" end="(126, 49)">
                  <AtomNode start="(126, 48)" end="(126, 49)" leading="" trailing=" " val="_"/>
                </TermHoleNode>
              </NullNode>
              <NullNode start="(126, 50)" end="(126, 64)">
                <AtomNode start="(126, 50)" end="(126, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(126, 52)" end="(126, 64)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(126, 52)" end="(126, 57)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(126, 52)" end="(126, 53)" leading="" trailing="" val="("/>
                    <OtherNode start="(126, 53)" end="(126, 56)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(126, 53)" end="(126, 54)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(126, 55)" end="(126, 56)">
                        <IdentNode start="(126, 55)" end="(126, 56)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(126, 56)" end="(126, 57)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(126, 57)" end="(126, 58)" leading="" trailing="" val="."/>
                  <IdentNode start="(126, 58)" end="(126, 64)" leading="" trailing="" raw_val="isSome" val="isSome" full_name="Option.isSome" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(126, 64)" end="(126, 65)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(126, 66)" end="(127, 61)">
            <AtomNode start="(126, 66)" end="(126, 67)" leading="" trailing="&#10;   " val=":"/>
            <OtherNode start="(127, 4)" end="(127, 61)" kind="«term_=_»">
              <OtherNode start="(127, 4)" end="(127, 31)" kind="Lean.Parser.Term.app">
                <IdentNode start="(127, 4)" end="(127, 13)" leading="" trailing=" " raw_val="findSome?" val="findSome?" full_name="Vector.findSome?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(127, 14)" end="(127, 31)">
                  <IdentNode start="(127, 14)" end="(127, 15)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(127, 16)" end="(127, 31)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(127, 16)" end="(127, 17)" leading="" trailing="" val="("/>
                    <OtherNode start="(127, 17)" end="(127, 30)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(127, 17)" end="(127, 26)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Vector.replicate" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                      <NullNode start="(127, 27)" end="(127, 30)">
                        <IdentNode start="(127, 27)" end="(127, 28)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(127, 29)" end="(127, 30)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(127, 30)" end="(127, 31)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(127, 32)" end="(127, 33)" leading="" trailing=" " val="="/>
              <OtherNode start="(127, 34)" end="(127, 61)" kind="termIfThenElse">
                <AtomNode start="(127, 34)" end="(127, 36)" leading="" trailing=" " val="if"/>
                <OtherNode start="(127, 37)" end="(127, 42)" kind="«term_=_»">
                  <IdentNode start="(127, 37)" end="(127, 38)" leading="" trailing=" " raw_val="n" val="n"/>
                  <AtomNode start="(127, 39)" end="(127, 40)" leading="" trailing=" " val="="/>
                  <OtherNode start="(127, 41)" end="(127, 42)" kind="num">
                    <AtomNode start="(127, 41)" end="(127, 42)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(127, 43)" end="(127, 47)" leading="" trailing=" " val="then"/>
                <IdentNode start="(127, 48)" end="(127, 52)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <AtomNode start="(127, 53)" end="(127, 57)" leading="" trailing=" " val="else"/>
                <OtherNode start="(127, 58)" end="(127, 61)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(127, 58)" end="(127, 59)" leading="" trailing=" " raw_val="f" val="f"/>
                  <NullNode start="(127, 60)" end="(127, 61)">
                    <IdentNode start="(127, 60)" end="(127, 61)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(127, 62)" end="(128, 29)">
          <AtomNode start="(127, 62)" end="(127, 64)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(127, 65)" end="(128, 29)">
            <AtomNode start="(127, 65)" end="(127, 67)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(128, 3)" end="(128, 29)">
              <TacticTacticseq1IndentedNode start="(128, 3)" end="(128, 29)">
                <NullNode start="(128, 3)" end="(128, 29)">
                  <OtherNode start="(128, 3)" end="(128, 29)" kind="Lean.Parser.Tactic.simp" state_before="α✝¹ : Type u_1&#10;α✝ : Type u_2&#10;f : α✝¹ → Option α✝&#10;n : Nat&#10;a : α✝¹&#10;x✝ : (f a).isSome = true&#10;⊢ findSome? f (replicate n a) = if n = 0 then none else f a" state_after="no goals" tactic="simp [findSome?_replicate]">
                    <AtomNode start="(128, 3)" end="(128, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(128, 8)" end="(128, 29)">
                      <AtomNode start="(128, 8)" end="(128, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(128, 9)" end="(128, 28)">
                        <OtherNode start="(128, 9)" end="(128, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(128, 9)" end="(128, 28)" leading="" trailing="" raw_val="findSome?_replicate" val="findSome?_replicate" full_name="Vector.findSome?_replicate" mod_name="Init.Data.Vector.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Find.lean" def_start="(113, 9)" def_end="(113, 28)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(128, 28)" end="(128, 29)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(130, 1)" end="(131, 70)" name="findSome?_mkVector_of_isSome" full_name="Vector.findSome?_mkVector_of_isSome">
      <CommandDeclmodifiersNode start="(130, 1)" end="(130, 68)">
        <NullNode/>
        <NullNode start="(130, 1)" end="(130, 68)">
          <OtherNode start="(130, 1)" end="(130, 68)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(130, 1)" end="(130, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(130, 3)" end="(130, 67)">
              <OtherNode start="(130, 3)" end="(130, 67)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(130, 3)" end="(130, 67)" kind="Lean.deprecated">
                  <AtomNode start="(130, 3)" end="(130, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(130, 14)" end="(130, 43)">
                    <IdentNode start="(130, 14)" end="(130, 43)" leading="" trailing=" " raw_val="findSome?_replicate_of_isSome" val="findSome?_replicate_of_isSome" full_name="Vector.findSome?_replicate_of_isSome" mod_name="Init.Data.Vector.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Find.lean" def_start="(126, 17)" def_end="(126, 46)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(130, 44)" end="(130, 67)">
                    <AtomNode start="(130, 44)" end="(130, 45)" leading="" trailing="" val="("/>
                    <AtomNode start="(130, 45)" end="(130, 50)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(130, 51)" end="(130, 53)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(130, 54)" end="(130, 66)" kind="str">
                      <AtomNode start="(130, 54)" end="(130, 66)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(130, 66)" end="(130, 67)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(130, 67)" end="(130, 68)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(131, 1)" end="(131, 70)" name="findSome?_mkVector_of_isSome">
        <AtomNode start="(131, 1)" end="(131, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(131, 8)" end="(131, 36)">
          <IdentNode start="(131, 8)" end="(131, 36)" leading="" trailing=" " raw_val="findSome?_mkVector_of_isSome" val="findSome?_mkVector_of_isSome"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(131, 37)" end="(131, 70)">
          <AtomNode start="(131, 37)" end="(131, 39)" leading="" trailing=" " val=":="/>
          <OtherNode start="(131, 40)" end="(131, 70)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(131, 40)" end="(131, 41)" leading="" trailing="" val="@"/>
            <IdentNode start="(131, 41)" end="(131, 70)" leading="" trailing="&#10;&#10;" raw_val="findSome?_replicate_of_isSome" val="findSome?_replicate_of_isSome" full_name="Vector.findSome?_replicate_of_isSome" mod_name="Init.Data.Vector.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Find.lean" def_start="(126, 17)" def_end="(126, 46)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(133, 1)" end="(136, 32)" name="findSome?_replicate_of_isNone" full_name="Vector.findSome?_replicate_of_isNone">
      <CommandDeclmodifiersNode start="(133, 1)" end="(133, 8)">
        <NullNode/>
        <NullNode start="(133, 1)" end="(133, 8)">
          <OtherNode start="(133, 1)" end="(133, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(133, 1)" end="(133, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(133, 3)" end="(133, 7)">
              <OtherNode start="(133, 3)" end="(133, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(133, 3)" end="(133, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(133, 3)" end="(133, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(133, 7)" end="(133, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(133, 9)" end="(136, 32)" name="findSome?_replicate_of_isNone" full_name="Vector.findSome?_replicate_of_isNone" _is_private_decl="False">
        <AtomNode start="(133, 9)" end="(133, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(133, 17)" end="(133, 46)">
          <IdentNode start="(133, 17)" end="(133, 46)" leading="" trailing=" " raw_val="findSome?_replicate_of_isNone" val="findSome?_replicate_of_isNone"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(133, 47)" end="(134, 39)">
          <NullNode start="(133, 47)" end="(133, 65)">
            <TermExplicitbinderNode start="(133, 47)" end="(133, 65)">
              <AtomNode start="(133, 47)" end="(133, 48)" leading="" trailing="" val="("/>
              <NullNode start="(133, 48)" end="(133, 49)">
                <IdentNode start="(133, 48)" end="(133, 49)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(133, 50)" end="(133, 64)">
                <AtomNode start="(133, 50)" end="(133, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(133, 52)" end="(133, 64)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(133, 52)" end="(133, 57)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(133, 52)" end="(133, 53)" leading="" trailing="" val="("/>
                    <OtherNode start="(133, 53)" end="(133, 56)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(133, 53)" end="(133, 54)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(133, 55)" end="(133, 56)">
                        <IdentNode start="(133, 55)" end="(133, 56)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(133, 56)" end="(133, 57)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(133, 57)" end="(133, 58)" leading="" trailing="" val="."/>
                  <IdentNode start="(133, 58)" end="(133, 64)" leading="" trailing="" raw_val="isNone" val="isNone" full_name="Option.isNone" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(133, 64)" end="(133, 65)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(133, 66)" end="(134, 39)">
            <AtomNode start="(133, 66)" end="(133, 67)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(134, 5)" end="(134, 39)" kind="«term_=_»">
              <OtherNode start="(134, 5)" end="(134, 32)" kind="Lean.Parser.Term.app">
                <IdentNode start="(134, 5)" end="(134, 14)" leading="" trailing=" " raw_val="findSome?" val="findSome?" full_name="Vector.findSome?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(134, 15)" end="(134, 32)">
                  <IdentNode start="(134, 15)" end="(134, 16)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(134, 17)" end="(134, 32)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(134, 17)" end="(134, 18)" leading="" trailing="" val="("/>
                    <OtherNode start="(134, 18)" end="(134, 31)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(134, 18)" end="(134, 27)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Vector.replicate" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                      <NullNode start="(134, 28)" end="(134, 31)">
                        <IdentNode start="(134, 28)" end="(134, 29)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(134, 30)" end="(134, 31)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(134, 31)" end="(134, 32)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(134, 33)" end="(134, 34)" leading="" trailing=" " val="="/>
              <IdentNode start="(134, 35)" end="(134, 39)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(134, 40)" end="(136, 32)">
          <AtomNode start="(134, 40)" end="(134, 42)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(134, 43)" end="(136, 32)">
            <AtomNode start="(134, 43)" end="(134, 45)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(135, 3)" end="(136, 32)">
              <TacticTacticseq1IndentedNode start="(135, 3)" end="(136, 32)">
                <NullNode start="(135, 3)" end="(136, 32)">
                  <OtherNode start="(135, 3)" end="(135, 38)" kind="Lean.Parser.Tactic.rwSeq" state_before="α✝¹ : Type u_1&#10;α✝ : Type u_2&#10;f : α✝¹ → Option α✝&#10;n : Nat&#10;a : α✝¹&#10;h : (f a).isNone = true&#10;⊢ findSome? f (replicate n a) = none" state_after="α✝¹ : Type u_1&#10;α✝ : Type u_2&#10;f : α✝¹ → Option α✝&#10;n : Nat&#10;a : α✝¹&#10;h : f a = none&#10;⊢ findSome? f (replicate n a) = none" tactic="rw [Option.isNone_iff_eq_none] at h">
                    <AtomNode start="(135, 3)" end="(135, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(135, 6)" end="(135, 33)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(135, 6)" end="(135, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(135, 7)" end="(135, 32)">
                        <OtherNode start="(135, 7)" end="(135, 32)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(135, 7)" end="(135, 32)" leading="" trailing="" raw_val="Option.isNone_iff_eq_none" val="Option.isNone_iff_eq_none" full_name="Option.isNone_iff_eq_none" mod_name="Init.Data.Option.Instances" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Instances.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(135, 32)" end="(135, 33)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                    <NullNode start="(135, 34)" end="(135, 38)">
                      <OtherNode start="(135, 34)" end="(135, 38)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(135, 34)" end="(135, 36)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(135, 37)" end="(135, 38)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(135, 37)" end="(135, 38)">
                            <IdentNode start="(135, 37)" end="(135, 38)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(136, 3)" end="(136, 32)" kind="Lean.Parser.Tactic.simp" state_before="α✝¹ : Type u_1&#10;α✝ : Type u_2&#10;f : α✝¹ → Option α✝&#10;n : Nat&#10;a : α✝¹&#10;h : f a = none&#10;⊢ findSome? f (replicate n a) = none" state_after="no goals" tactic="simp [findSome?_replicate, h]">
                    <AtomNode start="(136, 3)" end="(136, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(136, 8)" end="(136, 32)">
                      <AtomNode start="(136, 8)" end="(136, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(136, 9)" end="(136, 31)">
                        <OtherNode start="(136, 9)" end="(136, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(136, 9)" end="(136, 28)" leading="" trailing="" raw_val="findSome?_replicate" val="findSome?_replicate" full_name="Vector.findSome?_replicate" mod_name="Init.Data.Vector.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Find.lean" def_start="(113, 9)" def_end="(113, 28)"/>
                        </OtherNode>
                        <AtomNode start="(136, 28)" end="(136, 29)" leading="" trailing=" " val=","/>
                        <OtherNode start="(136, 30)" end="(136, 31)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(136, 30)" end="(136, 31)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(136, 31)" end="(136, 32)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(138, 1)" end="(139, 70)" name="findSome?_mkVector_of_isNone" full_name="Vector.findSome?_mkVector_of_isNone">
      <CommandDeclmodifiersNode start="(138, 1)" end="(138, 68)">
        <NullNode/>
        <NullNode start="(138, 1)" end="(138, 68)">
          <OtherNode start="(138, 1)" end="(138, 68)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(138, 1)" end="(138, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(138, 3)" end="(138, 67)">
              <OtherNode start="(138, 3)" end="(138, 67)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(138, 3)" end="(138, 67)" kind="Lean.deprecated">
                  <AtomNode start="(138, 3)" end="(138, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(138, 14)" end="(138, 43)">
                    <IdentNode start="(138, 14)" end="(138, 43)" leading="" trailing=" " raw_val="findSome?_replicate_of_isNone" val="findSome?_replicate_of_isNone" full_name="Vector.findSome?_replicate_of_isNone" mod_name="Init.Data.Vector.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Find.lean" def_start="(133, 17)" def_end="(133, 46)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(138, 44)" end="(138, 67)">
                    <AtomNode start="(138, 44)" end="(138, 45)" leading="" trailing="" val="("/>
                    <AtomNode start="(138, 45)" end="(138, 50)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(138, 51)" end="(138, 53)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(138, 54)" end="(138, 66)" kind="str">
                      <AtomNode start="(138, 54)" end="(138, 66)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(138, 66)" end="(138, 67)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(138, 67)" end="(138, 68)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(139, 1)" end="(139, 70)" name="findSome?_mkVector_of_isNone">
        <AtomNode start="(139, 1)" end="(139, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(139, 8)" end="(139, 36)">
          <IdentNode start="(139, 8)" end="(139, 36)" leading="" trailing=" " raw_val="findSome?_mkVector_of_isNone" val="findSome?_mkVector_of_isNone"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(139, 37)" end="(139, 70)">
          <AtomNode start="(139, 37)" end="(139, 39)" leading="" trailing=" " val=":="/>
          <OtherNode start="(139, 40)" end="(139, 70)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(139, 40)" end="(139, 41)" leading="" trailing="" val="@"/>
            <IdentNode start="(139, 41)" end="(139, 70)" leading="" trailing="&#10;&#10;" raw_val="findSome?_replicate_of_isNone" val="findSome?_replicate_of_isNone" full_name="Vector.findSome?_replicate_of_isNone" mod_name="Init.Data.Vector.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Find.lean" def_start="(133, 17)" def_end="(133, 46)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(141, 1)" end="(141, 17)" comment="### find? -/">
      <AtomNode start="(141, 1)" end="(141, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(141, 5)" end="(141, 17)" leading="" trailing="&#10;&#10;" val="### find? -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(143, 1)" end="(143, 57)" name="find?_empty" full_name="Vector.find?_empty">
      <CommandDeclmodifiersNode start="(143, 1)" end="(143, 8)">
        <NullNode/>
        <NullNode start="(143, 1)" end="(143, 8)">
          <OtherNode start="(143, 1)" end="(143, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(143, 1)" end="(143, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(143, 3)" end="(143, 7)">
              <OtherNode start="(143, 3)" end="(143, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(143, 3)" end="(143, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(143, 3)" end="(143, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(143, 7)" end="(143, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(143, 9)" end="(143, 57)" name="find?_empty" full_name="Vector.find?_empty" _is_private_decl="False">
        <AtomNode start="(143, 9)" end="(143, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(143, 17)" end="(143, 28)">
          <IdentNode start="(143, 17)" end="(143, 28)" leading="" trailing=" " raw_val="find?_empty" val="find?_empty"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(143, 29)" end="(143, 50)">
          <NullNode/>
          <TermTypespecNode start="(143, 29)" end="(143, 50)">
            <AtomNode start="(143, 29)" end="(143, 30)" leading="" trailing=" " val=":"/>
            <OtherNode start="(143, 31)" end="(143, 50)" kind="«term_=_»">
              <OtherNode start="(143, 31)" end="(143, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(143, 31)" end="(143, 36)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Vector.find?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(143, 37)" end="(143, 43)">
                  <IdentNode start="(143, 37)" end="(143, 38)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(143, 39)" end="(143, 43)" kind="Vector.«term#v[_,]»">
                    <AtomNode start="(143, 39)" end="(143, 42)" leading="" trailing="" val="#v["/>
                    <NullNode/>
                    <AtomNode start="(143, 42)" end="(143, 43)" leading="" trailing=" " val="]"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(143, 44)" end="(143, 45)" leading="" trailing=" " val="="/>
              <IdentNode start="(143, 46)" end="(143, 50)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(143, 51)" end="(143, 57)">
          <AtomNode start="(143, 51)" end="(143, 53)" leading="" trailing=" " val=":="/>
          <IdentNode start="(143, 54)" end="(143, 57)" leading="" trailing="&#10;&#10;" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(145, 1)" end="(147, 7)" name="find?_singleton" full_name="Vector.find?_singleton">
      <CommandDeclmodifiersNode start="(145, 1)" end="(145, 8)">
        <NullNode/>
        <NullNode start="(145, 1)" end="(145, 8)">
          <OtherNode start="(145, 1)" end="(145, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(145, 1)" end="(145, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(145, 3)" end="(145, 7)">
              <OtherNode start="(145, 3)" end="(145, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(145, 3)" end="(145, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(145, 3)" end="(145, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(145, 7)" end="(145, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(145, 9)" end="(147, 7)" name="find?_singleton" full_name="Vector.find?_singleton" _is_private_decl="False">
        <AtomNode start="(145, 9)" end="(145, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(145, 17)" end="(145, 32)">
          <IdentNode start="(145, 17)" end="(145, 32)" leading="" trailing=" " raw_val="find?_singleton" val="find?_singleton"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(145, 33)" end="(146, 49)">
          <NullNode start="(145, 33)" end="(145, 55)">
            <OtherNode start="(145, 33)" end="(145, 40)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(145, 33)" end="(145, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(145, 34)" end="(145, 35)">
                <IdentNode start="(145, 34)" end="(145, 35)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(145, 36)" end="(145, 39)">
                <AtomNode start="(145, 36)" end="(145, 37)" leading="" trailing=" " val=":"/>
                <IdentNode start="(145, 38)" end="(145, 39)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(145, 39)" end="(145, 40)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(145, 41)" end="(145, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(145, 41)" end="(145, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(145, 42)" end="(145, 43)">
                <IdentNode start="(145, 42)" end="(145, 43)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(145, 44)" end="(145, 54)">
                <AtomNode start="(145, 44)" end="(145, 45)" leading="" trailing=" " val=":"/>
                <OtherNode start="(145, 46)" end="(145, 54)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(145, 46)" end="(145, 47)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(145, 48)" end="(145, 49)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(145, 50)" end="(145, 54)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(145, 54)" end="(145, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(145, 56)" end="(146, 49)">
            <AtomNode start="(145, 56)" end="(145, 57)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(146, 5)" end="(146, 49)" kind="«term_=_»">
              <OtherNode start="(146, 5)" end="(146, 18)" kind="Lean.Parser.Term.app">
                <OtherNode start="(146, 5)" end="(146, 16)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(146, 5)" end="(146, 10)" kind="Vector.«term#v[_,]»">
                    <AtomNode start="(146, 5)" end="(146, 8)" leading="" trailing="" val="#v["/>
                    <NullNode start="(146, 8)" end="(146, 9)">
                      <IdentNode start="(146, 8)" end="(146, 9)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                    <AtomNode start="(146, 9)" end="(146, 10)" leading="" trailing="" val="]"/>
                  </OtherNode>
                  <AtomNode start="(146, 10)" end="(146, 11)" leading="" trailing="" val="."/>
                  <IdentNode start="(146, 11)" end="(146, 16)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Vector.find?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                </OtherNode>
                <NullNode start="(146, 17)" end="(146, 18)">
                  <IdentNode start="(146, 17)" end="(146, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(146, 19)" end="(146, 20)" leading="" trailing=" " val="="/>
              <OtherNode start="(146, 21)" end="(146, 49)" kind="termIfThenElse">
                <AtomNode start="(146, 21)" end="(146, 23)" leading="" trailing=" " val="if"/>
                <OtherNode start="(146, 24)" end="(146, 27)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(146, 24)" end="(146, 25)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(146, 26)" end="(146, 27)">
                    <IdentNode start="(146, 26)" end="(146, 27)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(146, 28)" end="(146, 32)" leading="" trailing=" " val="then"/>
                <OtherNode start="(146, 33)" end="(146, 39)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(146, 33)" end="(146, 37)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(146, 38)" end="(146, 39)">
                    <IdentNode start="(146, 38)" end="(146, 39)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(146, 40)" end="(146, 44)" leading="" trailing=" " val="else"/>
                <IdentNode start="(146, 45)" end="(146, 49)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(146, 50)" end="(147, 7)">
          <AtomNode start="(146, 50)" end="(146, 52)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(146, 53)" end="(147, 7)">
            <AtomNode start="(146, 53)" end="(146, 55)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(147, 3)" end="(147, 7)">
              <TacticTacticseq1IndentedNode start="(147, 3)" end="(147, 7)">
                <NullNode start="(147, 3)" end="(147, 7)">
                  <OtherNode start="(147, 3)" end="(147, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type&#10;a : α&#10;p : α → Bool&#10;⊢ find? p { toArray := #[a], size_toArray := ⋯ } = if p a = true then some a else none" state_after="no goals" tactic="simp">
                    <AtomNode start="(147, 3)" end="(147, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(149, 1)" end="(151, 21)" name="findRev?_push_of_pos" full_name="Vector.findRev?_push_of_pos">
      <CommandDeclmodifiersNode start="(149, 1)" end="(149, 8)">
        <NullNode/>
        <NullNode start="(149, 1)" end="(149, 8)">
          <OtherNode start="(149, 1)" end="(149, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(149, 1)" end="(149, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(149, 3)" end="(149, 7)">
              <OtherNode start="(149, 3)" end="(149, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(149, 3)" end="(149, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(149, 3)" end="(149, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(149, 7)" end="(149, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(149, 9)" end="(151, 21)" name="findRev?_push_of_pos" full_name="Vector.findRev?_push_of_pos" _is_private_decl="False">
        <AtomNode start="(149, 9)" end="(149, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(149, 17)" end="(149, 37)">
          <IdentNode start="(149, 17)" end="(149, 37)" leading="" trailing=" " raw_val="findRev?_push_of_pos" val="findRev?_push_of_pos"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(149, 38)" end="(150, 36)">
          <NullNode start="(149, 38)" end="(149, 65)">
            <OtherNode start="(149, 38)" end="(149, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(149, 38)" end="(149, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(149, 39)" end="(149, 41)">
                <IdentNode start="(149, 39)" end="(149, 41)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(149, 42)" end="(149, 54)">
                <AtomNode start="(149, 42)" end="(149, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(149, 44)" end="(149, 54)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(149, 44)" end="(149, 50)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(149, 51)" end="(149, 54)">
                    <IdentNode start="(149, 51)" end="(149, 52)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(149, 53)" end="(149, 54)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(149, 54)" end="(149, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(149, 56)" end="(149, 65)">
              <AtomNode start="(149, 56)" end="(149, 57)" leading="" trailing="" val="("/>
              <NullNode start="(149, 57)" end="(149, 58)">
                <IdentNode start="(149, 57)" end="(149, 58)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(149, 59)" end="(149, 64)">
                <AtomNode start="(149, 59)" end="(149, 60)" leading="" trailing=" " val=":"/>
                <OtherNode start="(149, 61)" end="(149, 64)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(149, 61)" end="(149, 62)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(149, 63)" end="(149, 64)">
                    <IdentNode start="(149, 63)" end="(149, 64)" leading="" trailing="" raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(149, 64)" end="(149, 65)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(149, 66)" end="(150, 36)">
            <AtomNode start="(149, 66)" end="(149, 67)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(150, 5)" end="(150, 36)" kind="«term_=_»">
              <OtherNode start="(150, 5)" end="(150, 27)" kind="Lean.Parser.Term.app">
                <IdentNode start="(150, 5)" end="(150, 13)" leading="" trailing=" " raw_val="findRev?" val="findRev?" full_name="Vector.findRev?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(150, 14)" end="(150, 27)">
                  <IdentNode start="(150, 14)" end="(150, 15)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(150, 16)" end="(150, 27)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(150, 16)" end="(150, 17)" leading="" trailing="" val="("/>
                    <OtherNode start="(150, 17)" end="(150, 26)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(150, 17)" end="(150, 24)" leading="" trailing=" " raw_val="xs.push" val="xs.push"/>
                      <NullNode start="(150, 25)" end="(150, 26)">
                        <IdentNode start="(150, 25)" end="(150, 26)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(150, 26)" end="(150, 27)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(150, 28)" end="(150, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(150, 30)" end="(150, 36)" kind="Lean.Parser.Term.app">
                <IdentNode start="(150, 30)" end="(150, 34)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode start="(150, 35)" end="(150, 36)">
                  <IdentNode start="(150, 35)" end="(150, 36)" leading="" trailing=" " raw_val="a" val="a"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(150, 37)" end="(151, 21)">
          <AtomNode start="(150, 37)" end="(150, 39)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(150, 40)" end="(151, 21)">
            <AtomNode start="(150, 40)" end="(150, 42)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(151, 3)" end="(151, 21)">
              <TacticTacticseq1IndentedNode start="(151, 3)" end="(151, 21)">
                <NullNode start="(151, 3)" end="(151, 21)">
                  <OtherNode start="(151, 3)" end="(151, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type&#10;n : Nat&#10;p : α → Bool&#10;a : α&#10;xs : Vector α n&#10;h : p a = true&#10;⊢ findRev? p (xs.push a) = some a" state_after="case mk&#10;α : Type&#10;n : Nat&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n&#10;⊢ findRev? p ({ toArray := toArray✝, size_toArray := size_toArray✝ }.push a) = some a" tactic="cases xs">
                    <AtomNode start="(151, 3)" end="(151, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(151, 9)" end="(151, 11)">
                      <OtherNode start="(151, 9)" end="(151, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(151, 9)" end="(151, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(151, 11)" end="(151, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(151, 13)" end="(151, 21)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type&#10;n : Nat&#10;p : α → Bool&#10;a : α&#10;h : p a = true&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n&#10;⊢ findRev? p ({ toArray := toArray✝, size_toArray := size_toArray✝ }.push a) = some a" state_after="no goals" tactic="simp [h]">
                    <AtomNode start="(151, 13)" end="(151, 17)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(151, 18)" end="(151, 21)">
                      <AtomNode start="(151, 18)" end="(151, 19)" leading="" trailing="" val="["/>
                      <NullNode start="(151, 19)" end="(151, 20)">
                        <OtherNode start="(151, 19)" end="(151, 20)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(151, 19)" end="(151, 20)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(151, 20)" end="(151, 21)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(153, 1)" end="(155, 21)" name="findRev?_cons_of_neg" full_name="Vector.findRev?_cons_of_neg">
      <CommandDeclmodifiersNode start="(153, 1)" end="(153, 8)">
        <NullNode/>
        <NullNode start="(153, 1)" end="(153, 8)">
          <OtherNode start="(153, 1)" end="(153, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(153, 1)" end="(153, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(153, 3)" end="(153, 7)">
              <OtherNode start="(153, 3)" end="(153, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(153, 3)" end="(153, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(153, 3)" end="(153, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(153, 7)" end="(153, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(153, 9)" end="(155, 21)" name="findRev?_cons_of_neg" full_name="Vector.findRev?_cons_of_neg" _is_private_decl="False">
        <AtomNode start="(153, 9)" end="(153, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(153, 17)" end="(153, 37)">
          <IdentNode start="(153, 17)" end="(153, 37)" leading="" trailing=" " raw_val="findRev?_cons_of_neg" val="findRev?_cons_of_neg"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(153, 38)" end="(154, 43)">
          <NullNode start="(153, 38)" end="(153, 66)">
            <OtherNode start="(153, 38)" end="(153, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(153, 38)" end="(153, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(153, 39)" end="(153, 41)">
                <IdentNode start="(153, 39)" end="(153, 41)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(153, 42)" end="(153, 54)">
                <AtomNode start="(153, 42)" end="(153, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(153, 44)" end="(153, 54)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(153, 44)" end="(153, 50)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(153, 51)" end="(153, 54)">
                    <IdentNode start="(153, 51)" end="(153, 52)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(153, 53)" end="(153, 54)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(153, 54)" end="(153, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(153, 56)" end="(153, 66)">
              <AtomNode start="(153, 56)" end="(153, 57)" leading="" trailing="" val="("/>
              <NullNode start="(153, 57)" end="(153, 58)">
                <IdentNode start="(153, 57)" end="(153, 58)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(153, 59)" end="(153, 65)">
                <AtomNode start="(153, 59)" end="(153, 60)" leading="" trailing=" " val=":"/>
                <OtherNode start="(153, 61)" end="(153, 65)" kind="«term¬_»">
                  <AtomNode start="(153, 61)" end="(153, 62)" leading="" trailing="" val="¬"/>
                  <OtherNode start="(153, 62)" end="(153, 65)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(153, 62)" end="(153, 63)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(153, 64)" end="(153, 65)">
                      <IdentNode start="(153, 64)" end="(153, 65)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(153, 65)" end="(153, 66)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(153, 67)" end="(154, 43)">
            <AtomNode start="(153, 67)" end="(153, 68)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(154, 5)" end="(154, 43)" kind="«term_=_»">
              <OtherNode start="(154, 5)" end="(154, 27)" kind="Lean.Parser.Term.app">
                <IdentNode start="(154, 5)" end="(154, 13)" leading="" trailing=" " raw_val="findRev?" val="findRev?" full_name="Vector.findRev?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(154, 14)" end="(154, 27)">
                  <IdentNode start="(154, 14)" end="(154, 15)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(154, 16)" end="(154, 27)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(154, 16)" end="(154, 17)" leading="" trailing="" val="("/>
                    <OtherNode start="(154, 17)" end="(154, 26)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(154, 17)" end="(154, 24)" leading="" trailing=" " raw_val="xs.push" val="xs.push"/>
                      <NullNode start="(154, 25)" end="(154, 26)">
                        <IdentNode start="(154, 25)" end="(154, 26)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(154, 26)" end="(154, 27)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(154, 28)" end="(154, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(154, 30)" end="(154, 43)" kind="Lean.Parser.Term.app">
                <IdentNode start="(154, 30)" end="(154, 38)" leading="" trailing=" " raw_val="findRev?" val="findRev?" full_name="Vector.findRev?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(154, 39)" end="(154, 43)">
                  <IdentNode start="(154, 39)" end="(154, 40)" leading="" trailing=" " raw_val="p" val="p"/>
                  <IdentNode start="(154, 41)" end="(154, 43)" leading="" trailing=" " raw_val="xs" val="xs"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(154, 44)" end="(155, 21)">
          <AtomNode start="(154, 44)" end="(154, 46)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(154, 47)" end="(155, 21)">
            <AtomNode start="(154, 47)" end="(154, 49)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(155, 3)" end="(155, 21)">
              <TacticTacticseq1IndentedNode start="(155, 3)" end="(155, 21)">
                <NullNode start="(155, 3)" end="(155, 21)">
                  <OtherNode start="(155, 3)" end="(155, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type&#10;n : Nat&#10;p : α → Bool&#10;a : α&#10;xs : Vector α n&#10;h : ¬p a = true&#10;⊢ findRev? p (xs.push a) = findRev? p xs" state_after="case mk&#10;α : Type&#10;n : Nat&#10;p : α → Bool&#10;a : α&#10;h : ¬p a = true&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n&#10;⊢ findRev? p ({ toArray := toArray✝, size_toArray := size_toArray✝ }.push a) =&#10;    findRev? p { toArray := toArray✝, size_toArray := size_toArray✝ }" tactic="cases xs">
                    <AtomNode start="(155, 3)" end="(155, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(155, 9)" end="(155, 11)">
                      <OtherNode start="(155, 9)" end="(155, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(155, 9)" end="(155, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(155, 11)" end="(155, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(155, 13)" end="(155, 21)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type&#10;n : Nat&#10;p : α → Bool&#10;a : α&#10;h : ¬p a = true&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n&#10;⊢ findRev? p ({ toArray := toArray✝, size_toArray := size_toArray✝ }.push a) =&#10;    findRev? p { toArray := toArray✝, size_toArray := size_toArray✝ }" state_after="no goals" tactic="simp [h]">
                    <AtomNode start="(155, 13)" end="(155, 17)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(155, 18)" end="(155, 21)">
                      <AtomNode start="(155, 18)" end="(155, 19)" leading="" trailing="" val="["/>
                      <NullNode start="(155, 19)" end="(155, 20)">
                        <OtherNode start="(155, 19)" end="(155, 20)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(155, 19)" end="(155, 20)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(155, 20)" end="(155, 21)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(157, 1)" end="(158, 16)" name="find?_eq_none" full_name="Vector.find?_eq_none">
      <CommandDeclmodifiersNode start="(157, 1)" end="(157, 8)">
        <NullNode/>
        <NullNode start="(157, 1)" end="(157, 8)">
          <OtherNode start="(157, 1)" end="(157, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(157, 1)" end="(157, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(157, 3)" end="(157, 7)">
              <OtherNode start="(157, 3)" end="(157, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(157, 3)" end="(157, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(157, 3)" end="(157, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(157, 7)" end="(157, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(157, 9)" end="(158, 16)" name="find?_eq_none" full_name="Vector.find?_eq_none" _is_private_decl="False">
        <AtomNode start="(157, 9)" end="(157, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(157, 17)" end="(157, 30)">
          <IdentNode start="(157, 17)" end="(157, 30)" leading="" trailing=" " raw_val="find?_eq_none" val="find?_eq_none"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(157, 31)" end="(157, 66)">
          <NullNode/>
          <TermTypespecNode start="(157, 31)" end="(157, 66)">
            <AtomNode start="(157, 31)" end="(157, 32)" leading="" trailing=" " val=":"/>
            <OtherNode start="(157, 33)" end="(157, 66)" kind="«term_↔_»">
              <OtherNode start="(157, 33)" end="(157, 49)" kind="«term_=_»">
                <OtherNode start="(157, 33)" end="(157, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(157, 33)" end="(157, 38)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Vector.find?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(157, 39)" end="(157, 42)">
                    <IdentNode start="(157, 39)" end="(157, 40)" leading="" trailing=" " raw_val="p" val="p"/>
                    <IdentNode start="(157, 41)" end="(157, 42)" leading="" trailing=" " raw_val="l" val="l"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(157, 43)" end="(157, 44)" leading="" trailing=" " val="="/>
                <IdentNode start="(157, 45)" end="(157, 49)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(157, 50)" end="(157, 51)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(157, 52)" end="(157, 66)" kind="Lean.«term∀__,_»">
                <AtomNode start="(157, 52)" end="(157, 53)" leading="" trailing=" " val="∀"/>
                <LeanBinderidentNode start="(157, 54)" end="(157, 55)">
                  <IdentNode start="(157, 54)" end="(157, 55)" leading="" trailing=" " raw_val="x" val="x"/>
                </LeanBinderidentNode>
                <OtherNode start="(157, 56)" end="(157, 59)" kind="Lean.«binderTerm∈_»">
                  <AtomNode start="(157, 56)" end="(157, 57)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(157, 58)" end="(157, 59)" leading="" trailing="" raw_val="l" val="l"/>
                </OtherNode>
                <AtomNode start="(157, 59)" end="(157, 60)" leading="" trailing=" " val=","/>
                <OtherNode start="(157, 61)" end="(157, 66)" kind="«term¬_»">
                  <AtomNode start="(157, 61)" end="(157, 62)" leading="" trailing=" " val="¬"/>
                  <OtherNode start="(157, 63)" end="(157, 66)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(157, 63)" end="(157, 64)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(157, 65)" end="(157, 66)">
                      <IdentNode start="(157, 65)" end="(157, 66)" leading="" trailing=" " raw_val="x" val="x"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(157, 67)" end="(158, 16)">
          <AtomNode start="(157, 67)" end="(157, 69)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(157, 70)" end="(158, 16)">
            <AtomNode start="(157, 70)" end="(157, 72)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(158, 3)" end="(158, 16)">
              <TacticTacticseq1IndentedNode start="(158, 3)" end="(158, 16)">
                <NullNode start="(158, 3)" end="(158, 16)">
                  <OtherNode start="(158, 3)" end="(158, 10)" kind="Lean.Parser.Tactic.cases" state_before="α✝ : Type&#10;p : α✝ → Bool&#10;n✝ : Nat&#10;l : Vector α✝ n✝&#10;⊢ find? p l = none ↔ ∀ (x : α✝), x ∈ l → ¬p x = true" state_after="case mk&#10;α✝ : Type&#10;p : α✝ → Bool&#10;n✝ : Nat&#10;toArray✝ : Array α✝&#10;size_toArray✝ : toArray✝.size = n✝&#10;⊢ find? p { toArray := toArray✝, size_toArray := size_toArray✝ } = none ↔&#10;    ∀ (x : α✝), x ∈ { toArray := toArray✝, size_toArray := size_toArray✝ } → ¬p x = true" tactic="cases l">
                    <AtomNode start="(158, 3)" end="(158, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(158, 9)" end="(158, 10)">
                      <OtherNode start="(158, 9)" end="(158, 10)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(158, 9)" end="(158, 10)" leading="" trailing="" raw_val="l" val="l"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(158, 10)" end="(158, 11)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(158, 12)" end="(158, 16)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α✝ : Type&#10;p : α✝ → Bool&#10;n✝ : Nat&#10;toArray✝ : Array α✝&#10;size_toArray✝ : toArray✝.size = n✝&#10;⊢ find? p { toArray := toArray✝, size_toArray := size_toArray✝ } = none ↔&#10;    ∀ (x : α✝), x ∈ { toArray := toArray✝, size_toArray := size_toArray✝ } → ¬p x = true" state_after="no goals" tactic="simp">
                    <AtomNode start="(158, 12)" end="(158, 16)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(160, 1)" end="(171, 71)" name="find?_eq_some_iff_append" full_name="Vector.find?_eq_some_iff_append">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(160, 1)" end="(171, 71)" name="find?_eq_some_iff_append" full_name="Vector.find?_eq_some_iff_append" _is_private_decl="False">
        <AtomNode start="(160, 1)" end="(160, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(160, 9)" end="(160, 33)">
          <IdentNode start="(160, 9)" end="(160, 33)" leading="" trailing=" " raw_val="find?_eq_some_iff_append" val="find?_eq_some_iff_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(160, 34)" end="(163, 60)">
          <NullNode start="(160, 34)" end="(160, 51)">
            <OtherNode start="(160, 34)" end="(160, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(160, 34)" end="(160, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(160, 35)" end="(160, 37)">
                <IdentNode start="(160, 35)" end="(160, 37)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(160, 38)" end="(160, 50)">
                <AtomNode start="(160, 38)" end="(160, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(160, 40)" end="(160, 50)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(160, 40)" end="(160, 46)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(160, 47)" end="(160, 50)">
                    <IdentNode start="(160, 47)" end="(160, 48)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(160, 49)" end="(160, 50)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(160, 50)" end="(160, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(160, 52)" end="(163, 60)">
            <AtomNode start="(160, 52)" end="(160, 53)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(161, 5)" end="(163, 60)" kind="«term_↔_»">
              <OtherNode start="(161, 5)" end="(161, 24)" kind="«term_=_»">
                <OtherNode start="(161, 5)" end="(161, 15)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(161, 5)" end="(161, 13)" leading="" trailing=" " raw_val="xs.find?" val="xs.find?"/>
                  <NullNode start="(161, 14)" end="(161, 15)">
                    <IdentNode start="(161, 14)" end="(161, 15)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(161, 16)" end="(161, 17)" leading="" trailing=" " val="="/>
                <OtherNode start="(161, 18)" end="(161, 24)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(161, 18)" end="(161, 22)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(161, 23)" end="(161, 24)">
                    <IdentNode start="(161, 23)" end="(161, 24)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(161, 25)" end="(161, 26)" leading="" trailing="&#10;      " val="↔"/>
              <OtherNode start="(162, 7)" end="(163, 60)" kind="«term_∧_»">
                <OtherNode start="(162, 7)" end="(162, 10)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(162, 7)" end="(162, 8)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(162, 9)" end="(162, 10)">
                    <IdentNode start="(162, 9)" end="(162, 10)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(162, 11)" end="(162, 12)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(162, 13)" end="(163, 60)" kind="«term∃_,_»">
                  <AtomNode start="(162, 13)" end="(162, 14)" leading="" trailing=" " val="∃"/>
                  <OtherNode start="(162, 15)" end="(162, 88)" kind="Lean.explicitBinders">
                    <NullNode start="(162, 15)" end="(162, 88)">
                      <OtherNode start="(162, 15)" end="(162, 28)" kind="Lean.bracketedExplicitBinders">
                        <AtomNode start="(162, 15)" end="(162, 16)" leading="" trailing="" val="("/>
                        <NullNode start="(162, 16)" end="(162, 21)">
                          <LeanBinderidentNode start="(162, 16)" end="(162, 18)">
                            <IdentNode start="(162, 16)" end="(162, 18)" leading="" trailing=" " raw_val="k₁" val="k₁"/>
                          </LeanBinderidentNode>
                          <LeanBinderidentNode start="(162, 19)" end="(162, 21)">
                            <IdentNode start="(162, 19)" end="(162, 21)" leading="" trailing=" " raw_val="k₂" val="k₂"/>
                          </LeanBinderidentNode>
                        </NullNode>
                        <AtomNode start="(162, 22)" end="(162, 23)" leading="" trailing=" " val=":"/>
                        <IdentNode start="(162, 24)" end="(162, 27)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <AtomNode start="(162, 27)" end="(162, 28)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                      <OtherNode start="(162, 29)" end="(162, 50)" kind="Lean.bracketedExplicitBinders">
                        <AtomNode start="(162, 29)" end="(162, 30)" leading="" trailing="" val="("/>
                        <NullNode start="(162, 30)" end="(162, 31)">
                          <LeanBinderidentNode start="(162, 30)" end="(162, 31)">
                            <IdentNode start="(162, 30)" end="(162, 31)" leading="" trailing=" " raw_val="w" val="w"/>
                          </LeanBinderidentNode>
                        </NullNode>
                        <AtomNode start="(162, 32)" end="(162, 33)" leading="" trailing=" " val=":"/>
                        <OtherNode start="(162, 34)" end="(162, 49)" kind="«term_=_»">
                          <IdentNode start="(162, 34)" end="(162, 35)" leading="" trailing=" " raw_val="n" val="n"/>
                          <AtomNode start="(162, 36)" end="(162, 37)" leading="" trailing=" " val="="/>
                          <OtherNode start="(162, 38)" end="(162, 49)" kind="«term_+_»">
                            <OtherNode start="(162, 38)" end="(162, 44)" kind="«term_+_»">
                              <IdentNode start="(162, 38)" end="(162, 40)" leading="" trailing=" " raw_val="k₁" val="k₁"/>
                              <AtomNode start="(162, 41)" end="(162, 42)" leading="" trailing=" " val="+"/>
                              <OtherNode start="(162, 43)" end="(162, 44)" kind="num">
                                <AtomNode start="(162, 43)" end="(162, 44)" leading="" trailing=" " val="1"/>
                              </OtherNode>
                            </OtherNode>
                            <AtomNode start="(162, 45)" end="(162, 46)" leading="" trailing=" " val="+"/>
                            <IdentNode start="(162, 47)" end="(162, 49)" leading="" trailing="" raw_val="k₂" val="k₂"/>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(162, 49)" end="(162, 50)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                      <OtherNode start="(162, 51)" end="(162, 69)" kind="Lean.bracketedExplicitBinders">
                        <AtomNode start="(162, 51)" end="(162, 52)" leading="" trailing="" val="("/>
                        <NullNode start="(162, 52)" end="(162, 54)">
                          <LeanBinderidentNode start="(162, 52)" end="(162, 54)">
                            <IdentNode start="(162, 52)" end="(162, 54)" leading="" trailing=" " raw_val="as" val="as"/>
                          </LeanBinderidentNode>
                        </NullNode>
                        <AtomNode start="(162, 55)" end="(162, 56)" leading="" trailing=" " val=":"/>
                        <OtherNode start="(162, 57)" end="(162, 68)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(162, 57)" end="(162, 63)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                          <NullNode start="(162, 64)" end="(162, 68)">
                            <IdentNode start="(162, 64)" end="(162, 65)" leading="" trailing=" " raw_val="α" val="α"/>
                            <IdentNode start="(162, 66)" end="(162, 68)" leading="" trailing="" raw_val="k₁" val="k₁"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(162, 68)" end="(162, 69)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                      <OtherNode start="(162, 70)" end="(162, 88)" kind="Lean.bracketedExplicitBinders">
                        <AtomNode start="(162, 70)" end="(162, 71)" leading="" trailing="" val="("/>
                        <NullNode start="(162, 71)" end="(162, 73)">
                          <LeanBinderidentNode start="(162, 71)" end="(162, 73)">
                            <IdentNode start="(162, 71)" end="(162, 73)" leading="" trailing=" " raw_val="bs" val="bs"/>
                          </LeanBinderidentNode>
                        </NullNode>
                        <AtomNode start="(162, 74)" end="(162, 75)" leading="" trailing=" " val=":"/>
                        <OtherNode start="(162, 76)" end="(162, 87)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(162, 76)" end="(162, 82)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                          <NullNode start="(162, 83)" end="(162, 87)">
                            <IdentNode start="(162, 83)" end="(162, 84)" leading="" trailing=" " raw_val="α" val="α"/>
                            <IdentNode start="(162, 85)" end="(162, 87)" leading="" trailing="" raw_val="k₂" val="k₂"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(162, 87)" end="(162, 88)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(162, 88)" end="(162, 89)" leading="" trailing="&#10;        " val=","/>
                  <OtherNode start="(163, 9)" end="(163, 60)" kind="«term_∧_»">
                    <OtherNode start="(163, 9)" end="(163, 43)" kind="«term_=_»">
                      <IdentNode start="(163, 9)" end="(163, 11)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(163, 12)" end="(163, 13)" leading="" trailing=" " val="="/>
                      <OtherNode start="(163, 14)" end="(163, 43)" kind="Lean.Parser.Term.app">
                        <OtherNode start="(163, 14)" end="(163, 36)" kind="Lean.Parser.Term.proj">
                          <OtherNode start="(163, 14)" end="(163, 31)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(163, 14)" end="(163, 15)" leading="" trailing="" val="("/>
                            <OtherNode start="(163, 15)" end="(163, 30)" kind="«term_++_»">
                              <OtherNode start="(163, 15)" end="(163, 24)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(163, 15)" end="(163, 22)" leading="" trailing=" " raw_val="as.push" val="as.push"/>
                                <NullNode start="(163, 23)" end="(163, 24)">
                                  <IdentNode start="(163, 23)" end="(163, 24)" leading="" trailing=" " raw_val="b" val="b"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(163, 25)" end="(163, 27)" leading="" trailing=" " val="++"/>
                              <IdentNode start="(163, 28)" end="(163, 30)" leading="" trailing="" raw_val="bs" val="bs"/>
                            </OtherNode>
                            <AtomNode start="(163, 30)" end="(163, 31)" leading="" trailing="" val=")"/>
                          </OtherNode>
                          <AtomNode start="(163, 31)" end="(163, 32)" leading="" trailing="" val="."/>
                          <IdentNode start="(163, 32)" end="(163, 36)" leading="" trailing=" " raw_val="cast" val="cast" full_name="Vector.cast" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                        </OtherNode>
                        <NullNode start="(163, 37)" end="(163, 43)">
                          <IdentNode start="(163, 37)" end="(163, 43)" leading="" trailing=" " raw_val="w.symm" val="w.symm"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(163, 44)" end="(163, 45)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(163, 46)" end="(163, 60)" kind="Lean.«term∀__,_»">
                      <AtomNode start="(163, 46)" end="(163, 47)" leading="" trailing=" " val="∀"/>
                      <LeanBinderidentNode start="(163, 48)" end="(163, 49)">
                        <IdentNode start="(163, 48)" end="(163, 49)" leading="" trailing=" " raw_val="a" val="a"/>
                      </LeanBinderidentNode>
                      <OtherNode start="(163, 50)" end="(163, 54)" kind="Lean.«binderTerm∈_»">
                        <AtomNode start="(163, 50)" end="(163, 51)" leading="" trailing=" " val="∈"/>
                        <IdentNode start="(163, 52)" end="(163, 54)" leading="" trailing="" raw_val="as" val="as"/>
                      </OtherNode>
                      <AtomNode start="(163, 54)" end="(163, 55)" leading="" trailing=" " val=","/>
                      <OtherNode start="(163, 56)" end="(163, 60)" kind="term!_">
                        <AtomNode start="(163, 56)" end="(163, 57)" leading="" trailing="" val="!"/>
                        <OtherNode start="(163, 57)" end="(163, 60)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(163, 57)" end="(163, 58)" leading="" trailing=" " raw_val="p" val="p"/>
                          <NullNode start="(163, 59)" end="(163, 60)">
                            <IdentNode start="(163, 59)" end="(163, 60)" leading="" trailing=" " raw_val="a" val="a"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(163, 61)" end="(171, 71)">
          <AtomNode start="(163, 61)" end="(163, 63)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(163, 64)" end="(171, 71)">
            <AtomNode start="(163, 64)" end="(163, 66)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(164, 3)" end="(171, 71)">
              <TacticTacticseq1IndentedNode start="(164, 3)" end="(171, 71)">
                <NullNode start="(164, 3)" end="(171, 71)">
                  <OtherNode start="(164, 3)" end="(164, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type&#10;n : Nat&#10;p : α → Bool&#10;b : α&#10;xs : Vector α n&#10;⊢ find? p xs = some b ↔&#10;    p b = true ∧ ∃ k₁ k₂ w as bs, xs = Vector.cast ⋯ (as.push b ++ bs) ∧ ∀ (a : α), a ∈ as → (!p a) = true" state_after="case mk&#10;α : Type&#10;p : α → Bool&#10;b : α&#10;xs : Array α&#10;⊢ find? p { toArray := xs, size_toArray := ⋯ } = some b ↔&#10;    p b = true ∧&#10;      ∃ k₁ k₂ w as bs,&#10;        { toArray := xs, size_toArray := ⋯ } = Vector.cast ⋯ (as.push b ++ bs) ∧ ∀ (a : α), a ∈ as → (!p a) = true" tactic="rcases xs with ⟨xs, rfl⟩">
                    <AtomNode start="(164, 3)" end="(164, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(164, 10)" end="(164, 12)">
                      <OtherNode start="(164, 10)" end="(164, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(164, 10)" end="(164, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(164, 13)" end="(164, 27)">
                      <AtomNode start="(164, 13)" end="(164, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(164, 18)" end="(164, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(164, 18)" end="(164, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(164, 18)" end="(164, 27)">
                            <OtherNode start="(164, 18)" end="(164, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(164, 18)" end="(164, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(164, 19)" end="(164, 26)">
                                <OtherNode start="(164, 19)" end="(164, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(164, 19)" end="(164, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(164, 19)" end="(164, 21)">
                                      <OtherNode start="(164, 19)" end="(164, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(164, 19)" end="(164, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(164, 21)" end="(164, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(164, 23)" end="(164, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(164, 23)" end="(164, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(164, 23)" end="(164, 26)">
                                      <OtherNode start="(164, 23)" end="(164, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(164, 23)" end="(164, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(164, 26)" end="(164, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(165, 3)" end="(166, 55)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type&#10;p : α → Bool&#10;b : α&#10;xs : Array α&#10;⊢ find? p { toArray := xs, size_toArray := ⋯ } = some b ↔&#10;    p b = true ∧&#10;      ∃ k₁ k₂ w as bs,&#10;        { toArray := xs, size_toArray := ⋯ } = Vector.cast ⋯ (as.push b ++ bs) ∧ ∀ (a : α), a ∈ as → (!p a) = true" state_after="case mk&#10;α : Type&#10;p : α → Bool&#10;b : α&#10;xs : Array α&#10;⊢ (p b = true ∧ ∃ as bs, xs = as.push b ++ bs ∧ ∀ (a : α), a ∈ as → (!p a) = true) ↔&#10;    p b = true ∧ ∃ k₁ k₂ h as bs, xs = as.push b ++ bs.toArray ∧ ∀ (a : α), a ∈ as → (!p a) = true" tactic="simp only [find?_mk, Array.find?_eq_some_iff_append,&#10;  mk_eq, toArray_cast, toArray_append, toArray_push]">
                    <AtomNode start="(165, 3)" end="(165, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(165, 8)" end="(165, 12)">
                      <AtomNode start="(165, 8)" end="(165, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(165, 13)" end="(166, 55)">
                      <AtomNode start="(165, 13)" end="(165, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(165, 14)" end="(166, 54)">
                        <OtherNode start="(165, 14)" end="(165, 22)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(165, 14)" end="(165, 22)" leading="" trailing="" raw_val="find?_mk" val="find?_mk" full_name="Vector.find?_mk" mod_name="Init.Data.Vector.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(165, 22)" end="(165, 23)" leading="" trailing=" " val=","/>
                        <OtherNode start="(165, 24)" end="(165, 54)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(165, 24)" end="(165, 54)" leading="" trailing="" raw_val="Array.find?_eq_some_iff_append" val="Array.find?_eq_some_iff_append" full_name="Array.find?_eq_some_iff_append" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean"/>
                        </OtherNode>
                        <AtomNode start="(165, 54)" end="(165, 55)" leading="" trailing="&#10;    " val=","/>
                        <OtherNode start="(166, 5)" end="(166, 10)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(166, 5)" end="(166, 10)" leading="" trailing="" raw_val="mk_eq" val="mk_eq" full_name="Vector.mk_eq" mod_name="Init.Data.Vector.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(166, 10)" end="(166, 11)" leading="" trailing=" " val=","/>
                        <OtherNode start="(166, 12)" end="(166, 24)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(166, 12)" end="(166, 24)" leading="" trailing="" raw_val="toArray_cast" val="toArray_cast" full_name="Vector.toArray_cast" mod_name="Init.Data.Vector.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(166, 24)" end="(166, 25)" leading="" trailing=" " val=","/>
                        <OtherNode start="(166, 26)" end="(166, 40)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(166, 26)" end="(166, 40)" leading="" trailing="" raw_val="toArray_append" val="toArray_append" full_name="Vector.toArray_append" mod_name="Init.Data.Vector.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(166, 40)" end="(166, 41)" leading="" trailing=" " val=","/>
                        <OtherNode start="(166, 42)" end="(166, 54)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(166, 42)" end="(166, 54)" leading="" trailing="" raw_val="toArray_push" val="toArray_push" full_name="Vector.toArray_push" mod_name="Init.Data.Vector.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(166, 54)" end="(166, 55)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(167, 3)" end="(167, 14)" kind="Lean.Parser.Tactic.constructor" state_before="case mk&#10;α : Type&#10;p : α → Bool&#10;b : α&#10;xs : Array α&#10;⊢ (p b = true ∧ ∃ as bs, xs = as.push b ++ bs ∧ ∀ (a : α), a ∈ as → (!p a) = true) ↔&#10;    p b = true ∧ ∃ k₁ k₂ h as bs, xs = as.push b ++ bs.toArray ∧ ∀ (a : α), a ∈ as → (!p a) = true" state_after="case mk.mp&#10;α : Type&#10;p : α → Bool&#10;b : α&#10;xs : Array α&#10;⊢ (p b = true ∧ ∃ as bs, xs = as.push b ++ bs ∧ ∀ (a : α), a ∈ as → (!p a) = true) →&#10;    p b = true ∧ ∃ k₁ k₂ h as bs, xs = as.push b ++ bs.toArray ∧ ∀ (a : α), a ∈ as → (!p a) = true&#10;&#10;case mk.mpr&#10;α : Type&#10;p : α → Bool&#10;b : α&#10;xs : Array α&#10;⊢ (p b = true ∧ ∃ k₁ k₂ h as bs, xs = as.push b ++ bs.toArray ∧ ∀ (a : α), a ∈ as → (!p a) = true) →&#10;    p b = true ∧ ∃ as bs, xs = as.push b ++ bs ∧ ∀ (a : α), a ∈ as → (!p a) = true" tactic="constructor">
                    <AtomNode start="(167, 3)" end="(167, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(168, 3)" end="(169, 90)" kind="Lean.cdot" state_before="case mk.mp&#10;α : Type&#10;p : α → Bool&#10;b : α&#10;xs : Array α&#10;⊢ (p b = true ∧ ∃ as bs, xs = as.push b ++ bs ∧ ∀ (a : α), a ∈ as → (!p a) = true) →&#10;    p b = true ∧ ∃ k₁ k₂ h as bs, xs = as.push b ++ bs.toArray ∧ ∀ (a : α), a ∈ as → (!p a) = true&#10;&#10;case mk.mpr&#10;α : Type&#10;p : α → Bool&#10;b : α&#10;xs : Array α&#10;⊢ (p b = true ∧ ∃ k₁ k₂ h as bs, xs = as.push b ++ bs.toArray ∧ ∀ (a : α), a ∈ as → (!p a) = true) →&#10;    p b = true ∧ ∃ as bs, xs = as.push b ++ bs ∧ ∀ (a : α), a ∈ as → (!p a) = true" state_after="case mk.mpr&#10;α : Type&#10;p : α → Bool&#10;b : α&#10;xs : Array α&#10;⊢ (p b = true ∧ ∃ k₁ k₂ h as bs, xs = as.push b ++ bs.toArray ∧ ∀ (a : α), a ∈ as → (!p a) = true) →&#10;    p b = true ∧ ∃ as bs, xs = as.push b ++ bs ∧ ∀ (a : α), a ∈ as → (!p a) = true" tactic="· rintro ⟨h, as, bs, rfl, w⟩&#10;  exact ⟨h, as.size, bs.size, by simp, ⟨as, rfl⟩, ⟨bs, rfl⟩, by simp, by simpa using w⟩">
                    <OtherNode start="(168, 3)" end="(168, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(168, 3)" end="(168, 4)" kind="patternIgnore">
                        <OtherNode start="(168, 3)" end="(168, 4)" kind="token.«· »">
                          <AtomNode start="(168, 3)" end="(168, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(168, 5)" end="(169, 90)">
                      <TacticTacticseq1IndentedNode start="(168, 5)" end="(169, 90)">
                        <NullNode start="(168, 5)" end="(169, 90)">
                          <OtherNode start="(168, 5)" end="(168, 31)" kind="Lean.Parser.Tactic.rintro" state_before="case mk.mp&#10;α : Type&#10;p : α → Bool&#10;b : α&#10;xs : Array α&#10;⊢ (p b = true ∧ ∃ as bs, xs = as.push b ++ bs ∧ ∀ (a : α), a ∈ as → (!p a) = true) →&#10;    p b = true ∧ ∃ k₁ k₂ h as bs, xs = as.push b ++ bs.toArray ∧ ∀ (a : α), a ∈ as → (!p a) = true" state_after="case mk.mp.intro.intro.intro.intro&#10;α : Type&#10;p : α → Bool&#10;b : α&#10;h : p b = true&#10;as bs : Array α&#10;w : ∀ (a : α), a ∈ as → (!p a) = true&#10;⊢ p b = true ∧ ∃ k₁ k₂ h as_1 bs_1, as.push b ++ bs = as_1.push b ++ bs_1.toArray ∧ ∀ (a : α), a ∈ as_1 → (!p a) = true" tactic="rintro ⟨h, as, bs, rfl, w⟩">
                            <AtomNode start="(168, 5)" end="(168, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(168, 12)" end="(168, 31)">
                              <OtherNode start="(168, 12)" end="(168, 31)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(168, 12)" end="(168, 31)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                  <AtomNode start="(168, 12)" end="(168, 13)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(168, 13)" end="(168, 30)">
                                    <OtherNode start="(168, 13)" end="(168, 14)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(168, 13)" end="(168, 14)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(168, 13)" end="(168, 14)">
                                          <OtherNode start="(168, 13)" end="(168, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(168, 13)" end="(168, 14)" leading="" trailing="" raw_val="h" val="h"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(168, 14)" end="(168, 15)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(168, 16)" end="(168, 18)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(168, 16)" end="(168, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(168, 16)" end="(168, 18)">
                                          <OtherNode start="(168, 16)" end="(168, 18)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(168, 16)" end="(168, 18)" leading="" trailing="" raw_val="as" val="as"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(168, 18)" end="(168, 19)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(168, 20)" end="(168, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(168, 20)" end="(168, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(168, 20)" end="(168, 22)">
                                          <OtherNode start="(168, 20)" end="(168, 22)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(168, 20)" end="(168, 22)" leading="" trailing="" raw_val="bs" val="bs"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(168, 22)" end="(168, 23)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(168, 24)" end="(168, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(168, 24)" end="(168, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(168, 24)" end="(168, 27)">
                                          <OtherNode start="(168, 24)" end="(168, 27)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(168, 24)" end="(168, 27)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(168, 27)" end="(168, 28)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(168, 29)" end="(168, 30)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(168, 29)" end="(168, 30)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(168, 29)" end="(168, 30)">
                                          <OtherNode start="(168, 29)" end="(168, 30)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(168, 29)" end="(168, 30)" leading="" trailing="" raw_val="w" val="w"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(168, 30)" end="(168, 31)" leading="" trailing="&#10;    " val="⟩"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(169, 5)" end="(169, 90)" kind="Lean.Parser.Tactic.exact" state_before="case mk.mp.intro.intro.intro.intro&#10;α : Type&#10;p : α → Bool&#10;b : α&#10;h : p b = true&#10;as bs : Array α&#10;w : ∀ (a : α), a ∈ as → (!p a) = true&#10;⊢ p b = true ∧ ∃ k₁ k₂ h as_1 bs_1, as.push b ++ bs = as_1.push b ++ bs_1.toArray ∧ ∀ (a : α), a ∈ as_1 → (!p a) = true" state_after="no goals" tactic="exact ⟨h, as.size, bs.size, by simp, ⟨as, rfl⟩, ⟨bs, rfl⟩, by simp, by simpa using w⟩">
                            <AtomNode start="(169, 5)" end="(169, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(169, 11)" end="(169, 90)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(169, 11)" end="(169, 12)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(169, 12)" end="(169, 89)">
                                <IdentNode start="(169, 12)" end="(169, 13)" leading="" trailing="" raw_val="h" val="h"/>
                                <AtomNode start="(169, 13)" end="(169, 14)" leading="" trailing=" " val=","/>
                                <IdentNode start="(169, 15)" end="(169, 22)" leading="" trailing="" raw_val="as.size" val="as.size"/>
                                <AtomNode start="(169, 22)" end="(169, 23)" leading="" trailing=" " val=","/>
                                <IdentNode start="(169, 24)" end="(169, 31)" leading="" trailing="" raw_val="bs.size" val="bs.size"/>
                                <AtomNode start="(169, 31)" end="(169, 32)" leading="" trailing=" " val=","/>
                                <TermBytacticNode start="(169, 33)" end="(169, 40)">
                                  <AtomNode start="(169, 33)" end="(169, 35)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(169, 36)" end="(169, 40)">
                                    <TacticTacticseq1IndentedNode start="(169, 36)" end="(169, 40)">
                                      <NullNode start="(169, 36)" end="(169, 40)">
                                        <OtherNode start="(169, 36)" end="(169, 40)" kind="Lean.Parser.Tactic.simp" state_before="α : Type&#10;p : α → Bool&#10;b : α&#10;h : p b = true&#10;as bs : Array α&#10;w : ∀ (a : α), a ∈ as → (!p a) = true&#10;⊢ (as.push b ++ bs).size = as.size + 1 + bs.size" state_after="no goals" tactic="simp">
                                          <AtomNode start="(169, 36)" end="(169, 40)" leading="" trailing="" val="simp"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                                <AtomNode start="(169, 40)" end="(169, 41)" leading="" trailing=" " val=","/>
                                <OtherNode start="(169, 42)" end="(169, 51)" kind="Lean.Parser.Term.anonymousCtor">
                                  <AtomNode start="(169, 42)" end="(169, 43)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(169, 43)" end="(169, 50)">
                                    <IdentNode start="(169, 43)" end="(169, 45)" leading="" trailing="" raw_val="as" val="as"/>
                                    <AtomNode start="(169, 45)" end="(169, 46)" leading="" trailing=" " val=","/>
                                    <IdentNode start="(169, 47)" end="(169, 50)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  </NullNode>
                                  <AtomNode start="(169, 50)" end="(169, 51)" leading="" trailing="" val="⟩"/>
                                </OtherNode>
                                <AtomNode start="(169, 51)" end="(169, 52)" leading="" trailing=" " val=","/>
                                <OtherNode start="(169, 53)" end="(169, 62)" kind="Lean.Parser.Term.anonymousCtor">
                                  <AtomNode start="(169, 53)" end="(169, 54)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(169, 54)" end="(169, 61)">
                                    <IdentNode start="(169, 54)" end="(169, 56)" leading="" trailing="" raw_val="bs" val="bs"/>
                                    <AtomNode start="(169, 56)" end="(169, 57)" leading="" trailing=" " val=","/>
                                    <IdentNode start="(169, 58)" end="(169, 61)" leading="" trailing="" raw_val="rfl" val="rfl" full_name="rfl" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                                  </NullNode>
                                  <AtomNode start="(169, 61)" end="(169, 62)" leading="" trailing="" val="⟩"/>
                                </OtherNode>
                                <AtomNode start="(169, 62)" end="(169, 63)" leading="" trailing=" " val=","/>
                                <TermBytacticNode start="(169, 64)" end="(169, 71)">
                                  <AtomNode start="(169, 64)" end="(169, 66)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(169, 67)" end="(169, 71)">
                                    <TacticTacticseq1IndentedNode start="(169, 67)" end="(169, 71)">
                                      <NullNode start="(169, 67)" end="(169, 71)">
                                        <OtherNode start="(169, 67)" end="(169, 71)" kind="Lean.Parser.Tactic.simp" state_before="α : Type&#10;p : α → Bool&#10;b : α&#10;h : p b = true&#10;as bs : Array α&#10;w : ∀ (a : α), a ∈ as → (!p a) = true&#10;⊢ as.push b ++ bs = { toArray := as, size_toArray := ⋯ }.push b ++ { toArray := bs, size_toArray := ⋯ }.toArray" state_after="no goals" tactic="simp">
                                          <AtomNode start="(169, 67)" end="(169, 71)" leading="" trailing="" val="simp"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                                <AtomNode start="(169, 71)" end="(169, 72)" leading="" trailing=" " val=","/>
                                <TermBytacticNode start="(169, 73)" end="(169, 89)">
                                  <AtomNode start="(169, 73)" end="(169, 75)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(169, 76)" end="(169, 89)">
                                    <TacticTacticseq1IndentedNode start="(169, 76)" end="(169, 89)">
                                      <NullNode start="(169, 76)" end="(169, 89)">
                                        <OtherNode start="(169, 76)" end="(169, 89)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type&#10;p : α → Bool&#10;b : α&#10;h : p b = true&#10;as bs : Array α&#10;w : ∀ (a : α), a ∈ as → (!p a) = true&#10;⊢ ∀ (a : α), a ∈ { toArray := as, size_toArray := ⋯ } → (!p a) = true" state_after="no goals" tactic="simpa using w">
                                          <AtomNode start="(169, 76)" end="(169, 81)" leading="" trailing=" " val="simpa"/>
                                          <NullNode/>
                                          <NullNode/>
                                          <OtherNode start="(169, 82)" end="(169, 89)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode start="(169, 82)" end="(169, 89)">
                                              <AtomNode start="(169, 82)" end="(169, 87)" leading="" trailing=" " val="using"/>
                                              <IdentNode start="(169, 88)" end="(169, 89)" leading="" trailing="" raw_val="w" val="w"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </NullNode>
                              <AtomNode start="(169, 89)" end="(169, 90)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(170, 3)" end="(171, 71)" kind="Lean.cdot" state_before="case mk.mpr&#10;α : Type&#10;p : α → Bool&#10;b : α&#10;xs : Array α&#10;⊢ (p b = true ∧ ∃ k₁ k₂ h as bs, xs = as.push b ++ bs.toArray ∧ ∀ (a : α), a ∈ as → (!p a) = true) →&#10;    p b = true ∧ ∃ as bs, xs = as.push b ++ bs ∧ ∀ (a : α), a ∈ as → (!p a) = true" state_after="no goals" tactic="· rintro ⟨h, k₁, k₂, w, as, bs, h', w'⟩&#10;  exact ⟨h, as.toArray, bs.toArray, by simp [h'], by simpa using w'⟩">
                    <OtherNode start="(170, 3)" end="(170, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(170, 3)" end="(170, 4)" kind="patternIgnore">
                        <OtherNode start="(170, 3)" end="(170, 4)" kind="token.«· »">
                          <AtomNode start="(170, 3)" end="(170, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(170, 5)" end="(171, 71)">
                      <TacticTacticseq1IndentedNode start="(170, 5)" end="(171, 71)">
                        <NullNode start="(170, 5)" end="(171, 71)">
                          <OtherNode start="(170, 5)" end="(170, 42)" kind="Lean.Parser.Tactic.rintro" state_before="case mk.mpr&#10;α : Type&#10;p : α → Bool&#10;b : α&#10;xs : Array α&#10;⊢ (p b = true ∧ ∃ k₁ k₂ h as bs, xs = as.push b ++ bs.toArray ∧ ∀ (a : α), a ∈ as → (!p a) = true) →&#10;    p b = true ∧ ∃ as bs, xs = as.push b ++ bs ∧ ∀ (a : α), a ∈ as → (!p a) = true" state_after="case mk.mpr.intro.intro.intro.intro.intro.intro.intro&#10;α : Type&#10;p : α → Bool&#10;b : α&#10;xs : Array α&#10;h : p b = true&#10;k₁ k₂ : Nat&#10;w : xs.size = k₁ + 1 + k₂&#10;as : Vector α k₁&#10;bs : Vector α k₂&#10;h' : xs = as.push b ++ bs.toArray&#10;w' : ∀ (a : α), a ∈ as → (!p a) = true&#10;⊢ p b = true ∧ ∃ as bs, xs = as.push b ++ bs ∧ ∀ (a : α), a ∈ as → (!p a) = true" tactic="rintro ⟨h, k₁, k₂, w, as, bs, h', w'⟩">
                            <AtomNode start="(170, 5)" end="(170, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(170, 12)" end="(170, 42)">
                              <OtherNode start="(170, 12)" end="(170, 42)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(170, 12)" end="(170, 42)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                  <AtomNode start="(170, 12)" end="(170, 13)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(170, 13)" end="(170, 41)">
                                    <OtherNode start="(170, 13)" end="(170, 14)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(170, 13)" end="(170, 14)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(170, 13)" end="(170, 14)">
                                          <OtherNode start="(170, 13)" end="(170, 14)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(170, 13)" end="(170, 14)" leading="" trailing="" raw_val="h" val="h"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(170, 14)" end="(170, 15)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(170, 16)" end="(170, 18)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(170, 16)" end="(170, 18)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(170, 16)" end="(170, 18)">
                                          <OtherNode start="(170, 16)" end="(170, 18)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(170, 16)" end="(170, 18)" leading="" trailing="" raw_val="k₁" val="k₁"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(170, 18)" end="(170, 19)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(170, 20)" end="(170, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(170, 20)" end="(170, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(170, 20)" end="(170, 22)">
                                          <OtherNode start="(170, 20)" end="(170, 22)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(170, 20)" end="(170, 22)" leading="" trailing="" raw_val="k₂" val="k₂"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(170, 22)" end="(170, 23)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(170, 24)" end="(170, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(170, 24)" end="(170, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(170, 24)" end="(170, 25)">
                                          <OtherNode start="(170, 24)" end="(170, 25)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(170, 24)" end="(170, 25)" leading="" trailing="" raw_val="w" val="w"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(170, 25)" end="(170, 26)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(170, 27)" end="(170, 29)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(170, 27)" end="(170, 29)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(170, 27)" end="(170, 29)">
                                          <OtherNode start="(170, 27)" end="(170, 29)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(170, 27)" end="(170, 29)" leading="" trailing="" raw_val="as" val="as"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(170, 29)" end="(170, 30)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(170, 31)" end="(170, 33)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(170, 31)" end="(170, 33)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(170, 31)" end="(170, 33)">
                                          <OtherNode start="(170, 31)" end="(170, 33)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(170, 31)" end="(170, 33)" leading="" trailing="" raw_val="bs" val="bs"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(170, 33)" end="(170, 34)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(170, 35)" end="(170, 37)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(170, 35)" end="(170, 37)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(170, 35)" end="(170, 37)">
                                          <OtherNode start="(170, 35)" end="(170, 37)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(170, 35)" end="(170, 37)" leading="" trailing="" raw_val="h'" val="h'"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(170, 37)" end="(170, 38)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(170, 39)" end="(170, 41)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(170, 39)" end="(170, 41)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(170, 39)" end="(170, 41)">
                                          <OtherNode start="(170, 39)" end="(170, 41)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(170, 39)" end="(170, 41)" leading="" trailing="" raw_val="w'" val="w'"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(170, 41)" end="(170, 42)" leading="" trailing="&#10;    " val="⟩"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(171, 5)" end="(171, 71)" kind="Lean.Parser.Tactic.exact" state_before="case mk.mpr.intro.intro.intro.intro.intro.intro.intro&#10;α : Type&#10;p : α → Bool&#10;b : α&#10;xs : Array α&#10;h : p b = true&#10;k₁ k₂ : Nat&#10;w : xs.size = k₁ + 1 + k₂&#10;as : Vector α k₁&#10;bs : Vector α k₂&#10;h' : xs = as.push b ++ bs.toArray&#10;w' : ∀ (a : α), a ∈ as → (!p a) = true&#10;⊢ p b = true ∧ ∃ as bs, xs = as.push b ++ bs ∧ ∀ (a : α), a ∈ as → (!p a) = true" state_after="no goals" tactic="exact ⟨h, as.toArray, bs.toArray, by simp [h'], by simpa using w'⟩">
                            <AtomNode start="(171, 5)" end="(171, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(171, 11)" end="(171, 71)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(171, 11)" end="(171, 12)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(171, 12)" end="(171, 70)">
                                <IdentNode start="(171, 12)" end="(171, 13)" leading="" trailing="" raw_val="h" val="h"/>
                                <AtomNode start="(171, 13)" end="(171, 14)" leading="" trailing=" " val=","/>
                                <IdentNode start="(171, 15)" end="(171, 25)" leading="" trailing="" raw_val="as.toArray" val="as.toArray"/>
                                <AtomNode start="(171, 25)" end="(171, 26)" leading="" trailing=" " val=","/>
                                <IdentNode start="(171, 27)" end="(171, 37)" leading="" trailing="" raw_val="bs.toArray" val="bs.toArray"/>
                                <AtomNode start="(171, 37)" end="(171, 38)" leading="" trailing=" " val=","/>
                                <TermBytacticNode start="(171, 39)" end="(171, 51)">
                                  <AtomNode start="(171, 39)" end="(171, 41)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(171, 42)" end="(171, 51)">
                                    <TacticTacticseq1IndentedNode start="(171, 42)" end="(171, 51)">
                                      <NullNode start="(171, 42)" end="(171, 51)">
                                        <OtherNode start="(171, 42)" end="(171, 51)" kind="Lean.Parser.Tactic.simp" state_before="α : Type&#10;p : α → Bool&#10;b : α&#10;xs : Array α&#10;h : p b = true&#10;k₁ k₂ : Nat&#10;w : xs.size = k₁ + 1 + k₂&#10;as : Vector α k₁&#10;bs : Vector α k₂&#10;h' : xs = as.push b ++ bs.toArray&#10;w' : ∀ (a : α), a ∈ as → (!p a) = true&#10;⊢ xs = as.push b ++ bs.toArray" state_after="no goals" tactic="simp [h']">
                                          <AtomNode start="(171, 42)" end="(171, 46)" leading="" trailing=" " val="simp"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode start="(171, 47)" end="(171, 51)">
                                            <AtomNode start="(171, 47)" end="(171, 48)" leading="" trailing="" val="["/>
                                            <NullNode start="(171, 48)" end="(171, 50)">
                                              <OtherNode start="(171, 48)" end="(171, 50)" kind="Lean.Parser.Tactic.simpLemma">
                                                <NullNode/>
                                                <NullNode/>
                                                <IdentNode start="(171, 48)" end="(171, 50)" leading="" trailing="" raw_val="h'" val="h'"/>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(171, 50)" end="(171, 51)" leading="" trailing="" val="]"/>
                                          </NullNode>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                                <AtomNode start="(171, 51)" end="(171, 52)" leading="" trailing=" " val=","/>
                                <TermBytacticNode start="(171, 53)" end="(171, 70)">
                                  <AtomNode start="(171, 53)" end="(171, 55)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(171, 56)" end="(171, 70)">
                                    <TacticTacticseq1IndentedNode start="(171, 56)" end="(171, 70)">
                                      <NullNode start="(171, 56)" end="(171, 70)">
                                        <OtherNode start="(171, 56)" end="(171, 70)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type&#10;p : α → Bool&#10;b : α&#10;xs : Array α&#10;h : p b = true&#10;k₁ k₂ : Nat&#10;w : xs.size = k₁ + 1 + k₂&#10;as : Vector α k₁&#10;bs : Vector α k₂&#10;h' : xs = as.push b ++ bs.toArray&#10;w' : ∀ (a : α), a ∈ as → (!p a) = true&#10;⊢ ∀ (a : α), a ∈ as.toArray → (!p a) = true" state_after="no goals" tactic="simpa using w'">
                                          <AtomNode start="(171, 56)" end="(171, 61)" leading="" trailing=" " val="simpa"/>
                                          <NullNode/>
                                          <NullNode/>
                                          <OtherNode start="(171, 62)" end="(171, 70)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode start="(171, 62)" end="(171, 70)">
                                              <AtomNode start="(171, 62)" end="(171, 67)" leading="" trailing=" " val="using"/>
                                              <IdentNode start="(171, 68)" end="(171, 70)" leading="" trailing="" raw_val="w'" val="w'"/>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </NullNode>
                              <AtomNode start="(171, 70)" end="(171, 71)" leading="" trailing="&#10;&#10;" val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(173, 1)" end="(175, 26)" name="find?_push" full_name="Vector.find?_push">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(173, 1)" end="(175, 26)" name="find?_push" full_name="Vector.find?_push" _is_private_decl="False">
        <AtomNode start="(173, 1)" end="(173, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(173, 9)" end="(173, 19)">
          <IdentNode start="(173, 9)" end="(173, 19)" leading="" trailing=" " raw_val="find?_push" val="find?_push"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(173, 20)" end="(173, 108)">
          <NullNode start="(173, 20)" end="(173, 37)">
            <OtherNode start="(173, 20)" end="(173, 37)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(173, 20)" end="(173, 21)" leading="" trailing="" val="{"/>
              <NullNode start="(173, 21)" end="(173, 23)">
                <IdentNode start="(173, 21)" end="(173, 23)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(173, 24)" end="(173, 36)">
                <AtomNode start="(173, 24)" end="(173, 25)" leading="" trailing=" " val=":"/>
                <OtherNode start="(173, 26)" end="(173, 36)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(173, 26)" end="(173, 32)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(173, 33)" end="(173, 36)">
                    <IdentNode start="(173, 33)" end="(173, 34)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(173, 35)" end="(173, 36)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(173, 36)" end="(173, 37)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(173, 38)" end="(173, 108)">
            <AtomNode start="(173, 38)" end="(173, 39)" leading="" trailing=" " val=":"/>
            <OtherNode start="(173, 40)" end="(173, 108)" kind="«term_=_»">
              <OtherNode start="(173, 40)" end="(173, 59)" kind="Lean.Parser.Term.app">
                <OtherNode start="(173, 40)" end="(173, 57)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(173, 40)" end="(173, 51)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(173, 40)" end="(173, 41)" leading="" trailing="" val="("/>
                    <OtherNode start="(173, 41)" end="(173, 50)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(173, 41)" end="(173, 48)" leading="" trailing=" " raw_val="xs.push" val="xs.push"/>
                      <NullNode start="(173, 49)" end="(173, 50)">
                        <IdentNode start="(173, 49)" end="(173, 50)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(173, 50)" end="(173, 51)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(173, 51)" end="(173, 52)" leading="" trailing="" val="."/>
                  <IdentNode start="(173, 52)" end="(173, 57)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Vector.find?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                </OtherNode>
                <NullNode start="(173, 58)" end="(173, 59)">
                  <IdentNode start="(173, 58)" end="(173, 59)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(173, 60)" end="(173, 61)" leading="" trailing=" " val="="/>
              <OtherNode start="(173, 62)" end="(173, 108)" kind="Lean.Parser.Term.app">
                <OtherNode start="(173, 62)" end="(173, 77)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(173, 62)" end="(173, 74)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(173, 62)" end="(173, 63)" leading="" trailing="" val="("/>
                    <OtherNode start="(173, 63)" end="(173, 73)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(173, 63)" end="(173, 71)" leading="" trailing=" " raw_val="xs.find?" val="xs.find?"/>
                      <NullNode start="(173, 72)" end="(173, 73)">
                        <IdentNode start="(173, 72)" end="(173, 73)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(173, 73)" end="(173, 74)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(173, 74)" end="(173, 75)" leading="" trailing="" val="."/>
                  <IdentNode start="(173, 75)" end="(173, 77)" leading="" trailing=" " raw_val="or" val="or" full_name="Option.or" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(173, 78)" end="(173, 108)">
                  <OtherNode start="(173, 78)" end="(173, 108)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(173, 78)" end="(173, 79)" leading="" trailing="" val="("/>
                    <OtherNode start="(173, 79)" end="(173, 107)" kind="termIfThenElse">
                      <AtomNode start="(173, 79)" end="(173, 81)" leading="" trailing=" " val="if"/>
                      <OtherNode start="(173, 82)" end="(173, 85)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(173, 82)" end="(173, 83)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(173, 84)" end="(173, 85)">
                          <IdentNode start="(173, 84)" end="(173, 85)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(173, 86)" end="(173, 90)" leading="" trailing=" " val="then"/>
                      <OtherNode start="(173, 91)" end="(173, 97)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(173, 91)" end="(173, 95)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(173, 96)" end="(173, 97)">
                          <IdentNode start="(173, 96)" end="(173, 97)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(173, 98)" end="(173, 102)" leading="" trailing=" " val="else"/>
                      <IdentNode start="(173, 103)" end="(173, 107)" leading="" trailing="" raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                    <AtomNode start="(173, 107)" end="(173, 108)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(173, 109)" end="(175, 26)">
          <AtomNode start="(173, 109)" end="(173, 111)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(173, 112)" end="(175, 26)">
            <AtomNode start="(173, 112)" end="(173, 114)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(174, 3)" end="(175, 26)">
              <TacticTacticseq1IndentedNode start="(174, 3)" end="(175, 26)">
                <NullNode start="(174, 3)" end="(175, 26)">
                  <OtherNode start="(174, 3)" end="(174, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type&#10;n : Nat&#10;a : α&#10;p : α → Bool&#10;xs : Vector α n&#10;⊢ find? p (xs.push a) = (find? p xs).or (if p a = true then some a else none)" state_after="case mk&#10;α : Type&#10;a : α&#10;p : α → Bool&#10;xs : Array α&#10;⊢ find? p ({ toArray := xs, size_toArray := ⋯ }.push a) =&#10;    (find? p { toArray := xs, size_toArray := ⋯ }).or (if p a = true then some a else none)" tactic="rcases xs with ⟨xs, rfl⟩">
                    <AtomNode start="(174, 3)" end="(174, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(174, 10)" end="(174, 12)">
                      <OtherNode start="(174, 10)" end="(174, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(174, 10)" end="(174, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(174, 13)" end="(174, 27)">
                      <AtomNode start="(174, 13)" end="(174, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(174, 18)" end="(174, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(174, 18)" end="(174, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(174, 18)" end="(174, 27)">
                            <OtherNode start="(174, 18)" end="(174, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(174, 18)" end="(174, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(174, 19)" end="(174, 26)">
                                <OtherNode start="(174, 19)" end="(174, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(174, 19)" end="(174, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(174, 19)" end="(174, 21)">
                                      <OtherNode start="(174, 19)" end="(174, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(174, 19)" end="(174, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(174, 21)" end="(174, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(174, 23)" end="(174, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(174, 23)" end="(174, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(174, 23)" end="(174, 26)">
                                      <OtherNode start="(174, 23)" end="(174, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(174, 23)" end="(174, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(174, 26)" end="(174, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(175, 3)" end="(175, 26)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type&#10;a : α&#10;p : α → Bool&#10;xs : Array α&#10;⊢ find? p ({ toArray := xs, size_toArray := ⋯ }.push a) =&#10;    (find? p { toArray := xs, size_toArray := ⋯ }).or (if p a = true then some a else none)" state_after="no goals" tactic="simp [Array.find?_push]">
                    <AtomNode start="(175, 3)" end="(175, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(175, 8)" end="(175, 26)">
                      <AtomNode start="(175, 8)" end="(175, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(175, 9)" end="(175, 25)">
                        <OtherNode start="(175, 9)" end="(175, 25)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(175, 9)" end="(175, 25)" leading="" trailing="" raw_val="Array.find?_push" val="Array.find?_push" full_name="Array.find?_push" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(175, 25)" end="(175, 26)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(177, 1)" end="(180, 17)" name="find?_push_eq_some" full_name="Vector.find?_push_eq_some">
      <CommandDeclmodifiersNode start="(177, 1)" end="(177, 8)">
        <NullNode/>
        <NullNode start="(177, 1)" end="(177, 8)">
          <OtherNode start="(177, 1)" end="(177, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(177, 1)" end="(177, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(177, 3)" end="(177, 7)">
              <OtherNode start="(177, 3)" end="(177, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(177, 3)" end="(177, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(177, 3)" end="(177, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(177, 7)" end="(177, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(178, 1)" end="(180, 17)" name="find?_push_eq_some" full_name="Vector.find?_push_eq_some" _is_private_decl="False">
        <AtomNode start="(178, 1)" end="(178, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(178, 9)" end="(178, 27)">
          <IdentNode start="(178, 9)" end="(178, 27)" leading="" trailing=" " raw_val="find?_push_eq_some" val="find?_push_eq_some"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(178, 28)" end="(179, 93)">
          <NullNode start="(178, 28)" end="(178, 45)">
            <OtherNode start="(178, 28)" end="(178, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(178, 28)" end="(178, 29)" leading="" trailing="" val="{"/>
              <NullNode start="(178, 29)" end="(178, 31)">
                <IdentNode start="(178, 29)" end="(178, 31)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(178, 32)" end="(178, 44)">
                <AtomNode start="(178, 32)" end="(178, 33)" leading="" trailing=" " val=":"/>
                <OtherNode start="(178, 34)" end="(178, 44)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(178, 34)" end="(178, 40)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(178, 41)" end="(178, 44)">
                    <IdentNode start="(178, 41)" end="(178, 42)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(178, 43)" end="(178, 44)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(178, 44)" end="(178, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(178, 46)" end="(179, 93)">
            <AtomNode start="(178, 46)" end="(178, 47)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(179, 5)" end="(179, 93)" kind="«term_↔_»">
              <OtherNode start="(179, 5)" end="(179, 33)" kind="«term_=_»">
                <OtherNode start="(179, 5)" end="(179, 24)" kind="Lean.Parser.Term.app">
                  <OtherNode start="(179, 5)" end="(179, 22)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(179, 5)" end="(179, 16)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(179, 5)" end="(179, 6)" leading="" trailing="" val="("/>
                      <OtherNode start="(179, 6)" end="(179, 15)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(179, 6)" end="(179, 13)" leading="" trailing=" " raw_val="xs.push" val="xs.push"/>
                        <NullNode start="(179, 14)" end="(179, 15)">
                          <IdentNode start="(179, 14)" end="(179, 15)" leading="" trailing="" raw_val="a" val="a"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(179, 15)" end="(179, 16)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(179, 16)" end="(179, 17)" leading="" trailing="" val="."/>
                    <IdentNode start="(179, 17)" end="(179, 22)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Vector.find?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  </OtherNode>
                  <NullNode start="(179, 23)" end="(179, 24)">
                    <IdentNode start="(179, 23)" end="(179, 24)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(179, 25)" end="(179, 26)" leading="" trailing=" " val="="/>
                <OtherNode start="(179, 27)" end="(179, 33)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(179, 27)" end="(179, 31)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(179, 32)" end="(179, 33)">
                    <IdentNode start="(179, 32)" end="(179, 33)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(179, 34)" end="(179, 35)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(179, 36)" end="(179, 93)" kind="«term_∨_»">
                <OtherNode start="(179, 36)" end="(179, 55)" kind="«term_=_»">
                  <OtherNode start="(179, 36)" end="(179, 46)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(179, 36)" end="(179, 44)" leading="" trailing=" " raw_val="xs.find?" val="xs.find?"/>
                    <NullNode start="(179, 45)" end="(179, 46)">
                      <IdentNode start="(179, 45)" end="(179, 46)" leading="" trailing=" " raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(179, 47)" end="(179, 48)" leading="" trailing=" " val="="/>
                  <OtherNode start="(179, 49)" end="(179, 55)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(179, 49)" end="(179, 53)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(179, 54)" end="(179, 55)">
                      <IdentNode start="(179, 54)" end="(179, 55)" leading="" trailing=" " raw_val="b" val="b"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(179, 56)" end="(179, 57)" leading="" trailing=" " val="∨"/>
                <OtherNode start="(179, 58)" end="(179, 93)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(179, 58)" end="(179, 59)" leading="" trailing="" val="("/>
                  <OtherNode start="(179, 59)" end="(179, 92)" kind="«term_∧_»">
                    <OtherNode start="(179, 59)" end="(179, 76)" kind="«term_=_»">
                      <OtherNode start="(179, 59)" end="(179, 69)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(179, 59)" end="(179, 67)" leading="" trailing=" " raw_val="xs.find?" val="xs.find?"/>
                        <NullNode start="(179, 68)" end="(179, 69)">
                          <IdentNode start="(179, 68)" end="(179, 69)" leading="" trailing=" " raw_val="p" val="p"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(179, 70)" end="(179, 71)" leading="" trailing=" " val="="/>
                      <IdentNode start="(179, 72)" end="(179, 76)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                    <AtomNode start="(179, 77)" end="(179, 78)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(179, 79)" end="(179, 92)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(179, 79)" end="(179, 80)" leading="" trailing="" val="("/>
                      <OtherNode start="(179, 80)" end="(179, 91)" kind="«term_∧_»">
                        <OtherNode start="(179, 80)" end="(179, 83)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(179, 80)" end="(179, 81)" leading="" trailing=" " raw_val="p" val="p"/>
                          <NullNode start="(179, 82)" end="(179, 83)">
                            <IdentNode start="(179, 82)" end="(179, 83)" leading="" trailing=" " raw_val="a" val="a"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(179, 84)" end="(179, 85)" leading="" trailing=" " val="∧"/>
                        <OtherNode start="(179, 86)" end="(179, 91)" kind="«term_=_»">
                          <IdentNode start="(179, 86)" end="(179, 87)" leading="" trailing=" " raw_val="a" val="a"/>
                          <AtomNode start="(179, 88)" end="(179, 89)" leading="" trailing=" " val="="/>
                          <IdentNode start="(179, 90)" end="(179, 91)" leading="" trailing="" raw_val="b" val="b"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(179, 91)" end="(179, 92)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(179, 92)" end="(179, 93)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(179, 94)" end="(180, 17)">
          <AtomNode start="(179, 94)" end="(179, 96)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(179, 97)" end="(180, 17)">
            <AtomNode start="(179, 97)" end="(179, 99)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(180, 3)" end="(180, 17)">
              <TacticTacticseq1IndentedNode start="(180, 3)" end="(180, 17)">
                <NullNode start="(180, 3)" end="(180, 17)">
                  <OtherNode start="(180, 3)" end="(180, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type&#10;n : Nat&#10;a : α&#10;p : α → Bool&#10;b : α&#10;xs : Vector α n&#10;⊢ find? p (xs.push a) = some b ↔ find? p xs = some b ∨ find? p xs = none ∧ p a = true ∧ a = b" state_after="case mk&#10;α : Type&#10;n : Nat&#10;a : α&#10;p : α → Bool&#10;b : α&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n&#10;⊢ find? p ({ toArray := toArray✝, size_toArray := size_toArray✝ }.push a) = some b ↔&#10;    find? p { toArray := toArray✝, size_toArray := size_toArray✝ } = some b ∨&#10;      find? p { toArray := toArray✝, size_toArray := size_toArray✝ } = none ∧ p a = true ∧ a = b" tactic="cases xs">
                    <AtomNode start="(180, 3)" end="(180, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(180, 9)" end="(180, 11)">
                      <OtherNode start="(180, 9)" end="(180, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(180, 9)" end="(180, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(180, 11)" end="(180, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(180, 13)" end="(180, 17)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type&#10;n : Nat&#10;a : α&#10;p : α → Bool&#10;b : α&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n&#10;⊢ find? p ({ toArray := toArray✝, size_toArray := size_toArray✝ }.push a) = some b ↔&#10;    find? p { toArray := toArray✝, size_toArray := size_toArray✝ } = some b ∨&#10;      find? p { toArray := toArray✝, size_toArray := size_toArray✝ } = none ∧ p a = true ∧ a = b" state_after="no goals" tactic="simp">
                    <AtomNode start="(180, 13)" end="(180, 17)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(182, 1)" end="(183, 17)" name="find?_isSome" full_name="Vector.find?_isSome">
      <CommandDeclmodifiersNode start="(182, 1)" end="(182, 8)">
        <NullNode/>
        <NullNode start="(182, 1)" end="(182, 8)">
          <OtherNode start="(182, 1)" end="(182, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(182, 1)" end="(182, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(182, 3)" end="(182, 7)">
              <OtherNode start="(182, 3)" end="(182, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(182, 3)" end="(182, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(182, 3)" end="(182, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(182, 7)" end="(182, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(182, 9)" end="(183, 17)" name="find?_isSome" full_name="Vector.find?_isSome" _is_private_decl="False">
        <AtomNode start="(182, 9)" end="(182, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(182, 17)" end="(182, 29)">
          <IdentNode start="(182, 17)" end="(182, 29)" leading="" trailing=" " raw_val="find?_isSome" val="find?_isSome"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(182, 30)" end="(182, 104)">
          <NullNode start="(182, 30)" end="(182, 62)">
            <OtherNode start="(182, 30)" end="(182, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(182, 30)" end="(182, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(182, 31)" end="(182, 33)">
                <IdentNode start="(182, 31)" end="(182, 33)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(182, 34)" end="(182, 46)">
                <AtomNode start="(182, 34)" end="(182, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(182, 36)" end="(182, 46)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(182, 36)" end="(182, 42)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(182, 43)" end="(182, 46)">
                    <IdentNode start="(182, 43)" end="(182, 44)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(182, 45)" end="(182, 46)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(182, 46)" end="(182, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(182, 48)" end="(182, 62)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(182, 48)" end="(182, 49)" leading="" trailing="" val="{"/>
              <NullNode start="(182, 49)" end="(182, 50)">
                <IdentNode start="(182, 49)" end="(182, 50)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(182, 51)" end="(182, 61)">
                <AtomNode start="(182, 51)" end="(182, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(182, 53)" end="(182, 61)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(182, 53)" end="(182, 54)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(182, 55)" end="(182, 56)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(182, 57)" end="(182, 61)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(182, 61)" end="(182, 62)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(182, 63)" end="(182, 104)">
            <AtomNode start="(182, 63)" end="(182, 64)" leading="" trailing=" " val=":"/>
            <OtherNode start="(182, 65)" end="(182, 104)" kind="«term_↔_»">
              <OtherNode start="(182, 65)" end="(182, 84)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(182, 65)" end="(182, 77)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(182, 65)" end="(182, 66)" leading="" trailing="" val="("/>
                  <OtherNode start="(182, 66)" end="(182, 76)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(182, 66)" end="(182, 74)" leading="" trailing=" " raw_val="xs.find?" val="xs.find?"/>
                    <NullNode start="(182, 75)" end="(182, 76)">
                      <IdentNode start="(182, 75)" end="(182, 76)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(182, 76)" end="(182, 77)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(182, 77)" end="(182, 78)" leading="" trailing="" val="."/>
                <IdentNode start="(182, 78)" end="(182, 84)" leading="" trailing=" " raw_val="isSome" val="isSome" full_name="Option.isSome" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(182, 85)" end="(182, 86)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(182, 87)" end="(182, 104)" kind="«term∃_,_»">
                <AtomNode start="(182, 87)" end="(182, 88)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(182, 89)" end="(182, 90)" kind="Lean.explicitBinders">
                  <OtherNode start="(182, 89)" end="(182, 90)" kind="Lean.unbracketedExplicitBinders">
                    <NullNode start="(182, 89)" end="(182, 90)">
                      <LeanBinderidentNode start="(182, 89)" end="(182, 90)">
                        <IdentNode start="(182, 89)" end="(182, 90)" leading="" trailing="" raw_val="x" val="x"/>
                      </LeanBinderidentNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(182, 90)" end="(182, 91)" leading="" trailing=" " val=","/>
                <OtherNode start="(182, 92)" end="(182, 104)" kind="«term_∧_»">
                  <OtherNode start="(182, 92)" end="(182, 98)" kind="«term_∈_»">
                    <IdentNode start="(182, 92)" end="(182, 93)" leading="" trailing=" " raw_val="x" val="x"/>
                    <AtomNode start="(182, 94)" end="(182, 95)" leading="" trailing=" " val="∈"/>
                    <IdentNode start="(182, 96)" end="(182, 98)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  </OtherNode>
                  <AtomNode start="(182, 99)" end="(182, 100)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(182, 101)" end="(182, 104)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(182, 101)" end="(182, 102)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(182, 103)" end="(182, 104)">
                      <IdentNode start="(182, 103)" end="(182, 104)" leading="" trailing=" " raw_val="x" val="x"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(182, 105)" end="(183, 17)">
          <AtomNode start="(182, 105)" end="(182, 107)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(182, 108)" end="(183, 17)">
            <AtomNode start="(182, 108)" end="(182, 110)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(183, 3)" end="(183, 17)">
              <TacticTacticseq1IndentedNode start="(183, 3)" end="(183, 17)">
                <NullNode start="(183, 3)" end="(183, 17)">
                  <OtherNode start="(183, 3)" end="(183, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type&#10;n : Nat&#10;xs : Vector α n&#10;p : α → Bool&#10;⊢ (find? p xs).isSome = true ↔ ∃ x, x ∈ xs ∧ p x = true" state_after="case mk&#10;α : Type&#10;n : Nat&#10;p : α → Bool&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n&#10;⊢ (find? p { toArray := toArray✝, size_toArray := size_toArray✝ }).isSome = true ↔&#10;    ∃ x, x ∈ { toArray := toArray✝, size_toArray := size_toArray✝ } ∧ p x = true" tactic="cases xs">
                    <AtomNode start="(183, 3)" end="(183, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(183, 9)" end="(183, 11)">
                      <OtherNode start="(183, 9)" end="(183, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(183, 9)" end="(183, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(183, 11)" end="(183, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(183, 13)" end="(183, 17)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type&#10;n : Nat&#10;p : α → Bool&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n&#10;⊢ (find? p { toArray := toArray✝, size_toArray := size_toArray✝ }).isSome = true ↔&#10;    ∃ x, x ∈ { toArray := toArray✝, size_toArray := size_toArray✝ } ∧ p x = true" state_after="no goals" tactic="simp">
                    <AtomNode start="(183, 13)" end="(183, 17)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(185, 1)" end="(188, 27)" name="find?_some" full_name="Vector.find?_some">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(185, 1)" end="(188, 27)" name="find?_some" full_name="Vector.find?_some" _is_private_decl="False">
        <AtomNode start="(185, 1)" end="(185, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(185, 9)" end="(185, 19)">
          <IdentNode start="(185, 9)" end="(185, 19)" leading="" trailing=" " raw_val="find?_some" val="find?_some"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(185, 20)" end="(185, 69)">
          <NullNode start="(185, 20)" end="(185, 63)">
            <OtherNode start="(185, 20)" end="(185, 37)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(185, 20)" end="(185, 21)" leading="" trailing="" val="{"/>
              <NullNode start="(185, 21)" end="(185, 23)">
                <IdentNode start="(185, 21)" end="(185, 23)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(185, 24)" end="(185, 36)">
                <AtomNode start="(185, 24)" end="(185, 25)" leading="" trailing=" " val=":"/>
                <OtherNode start="(185, 26)" end="(185, 36)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(185, 26)" end="(185, 32)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(185, 33)" end="(185, 36)">
                    <IdentNode start="(185, 33)" end="(185, 34)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(185, 35)" end="(185, 36)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(185, 36)" end="(185, 37)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(185, 38)" end="(185, 63)">
              <AtomNode start="(185, 38)" end="(185, 39)" leading="" trailing="" val="("/>
              <NullNode start="(185, 39)" end="(185, 40)">
                <IdentNode start="(185, 39)" end="(185, 40)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(185, 41)" end="(185, 62)">
                <AtomNode start="(185, 41)" end="(185, 42)" leading="" trailing=" " val=":"/>
                <OtherNode start="(185, 43)" end="(185, 62)" kind="«term_=_»">
                  <OtherNode start="(185, 43)" end="(185, 53)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(185, 43)" end="(185, 48)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Vector.find?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                    <NullNode start="(185, 49)" end="(185, 53)">
                      <IdentNode start="(185, 49)" end="(185, 50)" leading="" trailing=" " raw_val="p" val="p"/>
                      <IdentNode start="(185, 51)" end="(185, 53)" leading="" trailing=" " raw_val="xs" val="xs"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(185, 54)" end="(185, 55)" leading="" trailing=" " val="="/>
                  <OtherNode start="(185, 56)" end="(185, 62)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(185, 56)" end="(185, 60)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(185, 61)" end="(185, 62)">
                      <IdentNode start="(185, 61)" end="(185, 62)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(185, 62)" end="(185, 63)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(185, 64)" end="(185, 69)">
            <AtomNode start="(185, 64)" end="(185, 65)" leading="" trailing=" " val=":"/>
            <OtherNode start="(185, 66)" end="(185, 69)" kind="Lean.Parser.Term.app">
              <IdentNode start="(185, 66)" end="(185, 67)" leading="" trailing=" " raw_val="p" val="p"/>
              <NullNode start="(185, 68)" end="(185, 69)">
                <IdentNode start="(185, 68)" end="(185, 69)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(185, 70)" end="(188, 27)">
          <AtomNode start="(185, 70)" end="(185, 72)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(185, 73)" end="(188, 27)">
            <AtomNode start="(185, 73)" end="(185, 75)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(186, 3)" end="(188, 27)">
              <TacticTacticseq1IndentedNode start="(186, 3)" end="(188, 27)">
                <NullNode start="(186, 3)" end="(188, 27)">
                  <OtherNode start="(186, 3)" end="(186, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type&#10;n : Nat&#10;p : α → Bool&#10;a : α&#10;xs : Vector α n&#10;h : find? p xs = some a&#10;⊢ p a = true" state_after="case mk&#10;α : Type&#10;p : α → Bool&#10;a : α&#10;xs : Array α&#10;h : find? p { toArray := xs, size_toArray := ⋯ } = some a&#10;⊢ p a = true" tactic="rcases xs with ⟨xs, rfl⟩">
                    <AtomNode start="(186, 3)" end="(186, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(186, 10)" end="(186, 12)">
                      <OtherNode start="(186, 10)" end="(186, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(186, 10)" end="(186, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(186, 13)" end="(186, 27)">
                      <AtomNode start="(186, 13)" end="(186, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(186, 18)" end="(186, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(186, 18)" end="(186, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(186, 18)" end="(186, 27)">
                            <OtherNode start="(186, 18)" end="(186, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(186, 18)" end="(186, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(186, 19)" end="(186, 26)">
                                <OtherNode start="(186, 19)" end="(186, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(186, 19)" end="(186, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(186, 19)" end="(186, 21)">
                                      <OtherNode start="(186, 19)" end="(186, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(186, 19)" end="(186, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(186, 21)" end="(186, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(186, 23)" end="(186, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(186, 23)" end="(186, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(186, 23)" end="(186, 26)">
                                      <OtherNode start="(186, 23)" end="(186, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(186, 23)" end="(186, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(186, 26)" end="(186, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(187, 3)" end="(187, 12)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type&#10;p : α → Bool&#10;a : α&#10;xs : Array α&#10;h : find? p { toArray := xs, size_toArray := ⋯ } = some a&#10;⊢ p a = true" state_after="case mk&#10;α : Type&#10;p : α → Bool&#10;a : α&#10;xs : Array α&#10;h : Array.find? p xs = some a&#10;⊢ p a = true" tactic="simp at h">
                    <AtomNode start="(187, 3)" end="(187, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(187, 8)" end="(187, 12)">
                      <OtherNode start="(187, 8)" end="(187, 12)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(187, 8)" end="(187, 10)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(187, 11)" end="(187, 12)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(187, 11)" end="(187, 12)">
                            <IdentNode start="(187, 11)" end="(187, 12)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(188, 3)" end="(188, 27)" kind="Lean.Parser.Tactic.exact" state_before="case mk&#10;α : Type&#10;p : α → Bool&#10;a : α&#10;xs : Array α&#10;h : Array.find? p xs = some a&#10;⊢ p a = true" state_after="no goals" tactic="exact Array.find?_some h">
                    <AtomNode start="(188, 3)" end="(188, 8)" leading="" trailing=" " val="exact"/>
                    <OtherNode start="(188, 9)" end="(188, 27)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(188, 9)" end="(188, 25)" leading="" trailing=" " raw_val="Array.find?_some" val="Array.find?_some" full_name="Array.find?_some" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean"/>
                      <NullNode start="(188, 26)" end="(188, 27)">
                        <IdentNode start="(188, 26)" end="(188, 27)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(190, 1)" end="(193, 43)" name="mem_of_find?_eq_some" full_name="Vector.mem_of_find?_eq_some">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(190, 1)" end="(193, 43)" name="mem_of_find?_eq_some" full_name="Vector.mem_of_find?_eq_some" _is_private_decl="False">
        <AtomNode start="(190, 1)" end="(190, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(190, 9)" end="(190, 29)">
          <IdentNode start="(190, 9)" end="(190, 29)" leading="" trailing=" " raw_val="mem_of_find?_eq_some" val="mem_of_find?_eq_some"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(190, 30)" end="(190, 82)">
          <NullNode start="(190, 30)" end="(190, 73)">
            <OtherNode start="(190, 30)" end="(190, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(190, 30)" end="(190, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(190, 31)" end="(190, 33)">
                <IdentNode start="(190, 31)" end="(190, 33)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(190, 34)" end="(190, 46)">
                <AtomNode start="(190, 34)" end="(190, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(190, 36)" end="(190, 46)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(190, 36)" end="(190, 42)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(190, 43)" end="(190, 46)">
                    <IdentNode start="(190, 43)" end="(190, 44)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(190, 45)" end="(190, 46)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(190, 46)" end="(190, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(190, 48)" end="(190, 73)">
              <AtomNode start="(190, 48)" end="(190, 49)" leading="" trailing="" val="("/>
              <NullNode start="(190, 49)" end="(190, 50)">
                <IdentNode start="(190, 49)" end="(190, 50)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(190, 51)" end="(190, 72)">
                <AtomNode start="(190, 51)" end="(190, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(190, 53)" end="(190, 72)" kind="«term_=_»">
                  <OtherNode start="(190, 53)" end="(190, 63)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(190, 53)" end="(190, 58)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Vector.find?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                    <NullNode start="(190, 59)" end="(190, 63)">
                      <IdentNode start="(190, 59)" end="(190, 60)" leading="" trailing=" " raw_val="p" val="p"/>
                      <IdentNode start="(190, 61)" end="(190, 63)" leading="" trailing=" " raw_val="xs" val="xs"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(190, 64)" end="(190, 65)" leading="" trailing=" " val="="/>
                  <OtherNode start="(190, 66)" end="(190, 72)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(190, 66)" end="(190, 70)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(190, 71)" end="(190, 72)">
                      <IdentNode start="(190, 71)" end="(190, 72)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(190, 72)" end="(190, 73)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(190, 74)" end="(190, 82)">
            <AtomNode start="(190, 74)" end="(190, 75)" leading="" trailing=" " val=":"/>
            <OtherNode start="(190, 76)" end="(190, 82)" kind="«term_∈_»">
              <IdentNode start="(190, 76)" end="(190, 77)" leading="" trailing=" " raw_val="a" val="a"/>
              <AtomNode start="(190, 78)" end="(190, 79)" leading="" trailing=" " val="∈"/>
              <IdentNode start="(190, 80)" end="(190, 82)" leading="" trailing=" " raw_val="xs" val="xs"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(190, 83)" end="(193, 43)">
          <AtomNode start="(190, 83)" end="(190, 85)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(190, 86)" end="(193, 43)">
            <AtomNode start="(190, 86)" end="(190, 88)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(191, 3)" end="(193, 43)">
              <TacticTacticseq1IndentedNode start="(191, 3)" end="(193, 43)">
                <NullNode start="(191, 3)" end="(193, 43)">
                  <OtherNode start="(191, 3)" end="(191, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type&#10;n : Nat&#10;p : α → Bool&#10;a : α&#10;xs : Vector α n&#10;h : find? p xs = some a&#10;⊢ a ∈ xs" state_after="case mk&#10;α : Type&#10;n : Nat&#10;p : α → Bool&#10;a : α&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n&#10;h : find? p { toArray := toArray✝, size_toArray := size_toArray✝ } = some a&#10;⊢ a ∈ { toArray := toArray✝, size_toArray := size_toArray✝ }" tactic="cases xs">
                    <AtomNode start="(191, 3)" end="(191, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(191, 9)" end="(191, 11)">
                      <OtherNode start="(191, 9)" end="(191, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(191, 9)" end="(191, 11)" leading="" trailing="&#10;  " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(192, 3)" end="(192, 12)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type&#10;n : Nat&#10;p : α → Bool&#10;a : α&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n&#10;h : find? p { toArray := toArray✝, size_toArray := size_toArray✝ } = some a&#10;⊢ a ∈ { toArray := toArray✝, size_toArray := size_toArray✝ }" state_after="case mk&#10;α : Type&#10;n : Nat&#10;p : α → Bool&#10;a : α&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n&#10;h : Array.find? p toArray✝ = some a&#10;⊢ a ∈ { toArray := toArray✝, size_toArray := size_toArray✝ }" tactic="simp at h">
                    <AtomNode start="(192, 3)" end="(192, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(192, 8)" end="(192, 12)">
                      <OtherNode start="(192, 8)" end="(192, 12)" kind="Lean.Parser.Tactic.location">
                        <AtomNode start="(192, 8)" end="(192, 10)" leading="" trailing=" " val="at"/>
                        <OtherNode start="(192, 11)" end="(192, 12)" kind="Lean.Parser.Tactic.locationHyp">
                          <NullNode start="(192, 11)" end="(192, 12)">
                            <IdentNode start="(192, 11)" end="(192, 12)" leading="" trailing="&#10;  " raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(193, 3)" end="(193, 43)" kind="Lean.Parser.Tactic.simpa" state_before="case mk&#10;α : Type&#10;n : Nat&#10;p : α → Bool&#10;a : α&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n&#10;h : Array.find? p toArray✝ = some a&#10;⊢ a ∈ { toArray := toArray✝, size_toArray := size_toArray✝ }" state_after="no goals" tactic="simpa using Array.mem_of_find?_eq_some h">
                    <AtomNode start="(193, 3)" end="(193, 8)" leading="" trailing=" " val="simpa"/>
                    <NullNode/>
                    <NullNode/>
                    <OtherNode start="(193, 9)" end="(193, 43)" kind="Lean.Parser.Tactic.simpaArgsRest">
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(193, 9)" end="(193, 43)">
                        <AtomNode start="(193, 9)" end="(193, 14)" leading="" trailing=" " val="using"/>
                        <OtherNode start="(193, 15)" end="(193, 43)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(193, 15)" end="(193, 41)" leading="" trailing=" " raw_val="Array.mem_of_find?_eq_some" val="Array.mem_of_find?_eq_some" full_name="Array.mem_of_find?_eq_some" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean"/>
                          <NullNode start="(193, 42)" end="(193, 43)">
                            <IdentNode start="(193, 42)" end="(193, 43)" leading="" trailing="&#10;&#10;" raw_val="h" val="h"/>
                          </NullNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(195, 1)" end="(197, 29)" name="get_find?_mem" full_name="Vector.get_find?_mem">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(195, 1)" end="(197, 29)" name="get_find?_mem" full_name="Vector.get_find?_mem" _is_private_decl="False">
        <AtomNode start="(195, 1)" end="(195, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(195, 9)" end="(195, 22)">
          <IdentNode start="(195, 9)" end="(195, 22)" leading="" trailing=" " raw_val="get_find?_mem" val="get_find?_mem"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(195, 23)" end="(195, 70)">
          <NullNode start="(195, 23)" end="(195, 44)">
            <OtherNode start="(195, 23)" end="(195, 40)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(195, 23)" end="(195, 24)" leading="" trailing="" val="{"/>
              <NullNode start="(195, 24)" end="(195, 26)">
                <IdentNode start="(195, 24)" end="(195, 26)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(195, 27)" end="(195, 39)">
                <AtomNode start="(195, 27)" end="(195, 28)" leading="" trailing=" " val=":"/>
                <OtherNode start="(195, 29)" end="(195, 39)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(195, 29)" end="(195, 35)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(195, 36)" end="(195, 39)">
                    <IdentNode start="(195, 36)" end="(195, 37)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(195, 38)" end="(195, 39)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(195, 39)" end="(195, 40)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(195, 41)" end="(195, 44)">
              <AtomNode start="(195, 41)" end="(195, 42)" leading="" trailing="" val="("/>
              <NullNode start="(195, 42)" end="(195, 43)">
                <IdentNode start="(195, 42)" end="(195, 43)" leading="" trailing="" raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(195, 43)" end="(195, 44)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(195, 45)" end="(195, 70)">
            <AtomNode start="(195, 45)" end="(195, 46)" leading="" trailing=" " val=":"/>
            <OtherNode start="(195, 47)" end="(195, 70)" kind="«term_∈_»">
              <OtherNode start="(195, 47)" end="(195, 65)" kind="Lean.Parser.Term.app">
                <OtherNode start="(195, 47)" end="(195, 63)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(195, 47)" end="(195, 59)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(195, 47)" end="(195, 48)" leading="" trailing="" val="("/>
                    <OtherNode start="(195, 48)" end="(195, 58)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(195, 48)" end="(195, 56)" leading="" trailing=" " raw_val="xs.find?" val="xs.find?"/>
                      <NullNode start="(195, 57)" end="(195, 58)">
                        <IdentNode start="(195, 57)" end="(195, 58)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(195, 58)" end="(195, 59)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(195, 59)" end="(195, 60)" leading="" trailing="" val="."/>
                  <IdentNode start="(195, 60)" end="(195, 63)" leading="" trailing=" " raw_val="get" val="get" full_name="Option.get" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(195, 64)" end="(195, 65)">
                  <IdentNode start="(195, 64)" end="(195, 65)" leading="" trailing=" " raw_val="h" val="h"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(195, 66)" end="(195, 67)" leading="" trailing=" " val="∈"/>
              <IdentNode start="(195, 68)" end="(195, 70)" leading="" trailing=" " raw_val="xs" val="xs"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(195, 71)" end="(197, 29)">
          <AtomNode start="(195, 71)" end="(195, 73)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(195, 74)" end="(197, 29)">
            <AtomNode start="(195, 74)" end="(195, 76)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(196, 3)" end="(197, 29)">
              <TacticTacticseq1IndentedNode start="(196, 3)" end="(197, 29)">
                <NullNode start="(196, 3)" end="(197, 29)">
                  <OtherNode start="(196, 3)" end="(196, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type&#10;n : Nat&#10;p : α → Bool&#10;xs : Vector α n&#10;h : (find? p xs).isSome = true&#10;⊢ (find? p xs).get h ∈ xs" state_after="case mk&#10;α : Type&#10;n : Nat&#10;p : α → Bool&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n&#10;h : (find? p { toArray := toArray✝, size_toArray := size_toArray✝ }).isSome = true&#10;⊢ (find? p { toArray := toArray✝, size_toArray := size_toArray✝ }).get h ∈&#10;    { toArray := toArray✝, size_toArray := size_toArray✝ }" tactic="cases xs">
                    <AtomNode start="(196, 3)" end="(196, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(196, 9)" end="(196, 11)">
                      <OtherNode start="(196, 9)" end="(196, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(196, 9)" end="(196, 11)" leading="" trailing="&#10;  " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(197, 3)" end="(197, 29)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type&#10;n : Nat&#10;p : α → Bool&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n&#10;h : (find? p { toArray := toArray✝, size_toArray := size_toArray✝ }).isSome = true&#10;⊢ (find? p { toArray := toArray✝, size_toArray := size_toArray✝ }).get h ∈&#10;    { toArray := toArray✝, size_toArray := size_toArray✝ }" state_after="no goals" tactic="simp [Array.get_find?_mem]">
                    <AtomNode start="(197, 3)" end="(197, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(197, 8)" end="(197, 29)">
                      <AtomNode start="(197, 8)" end="(197, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(197, 9)" end="(197, 28)">
                        <OtherNode start="(197, 9)" end="(197, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(197, 9)" end="(197, 28)" leading="" trailing="" raw_val="Array.get_find?_mem" val="Array.get_find?_mem" full_name="Array.get_find?_mem" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(197, 28)" end="(197, 29)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(199, 1)" end="(201, 17)" name="find?_filter" full_name="Vector.find?_filter">
      <CommandDeclmodifiersNode start="(199, 1)" end="(199, 8)">
        <NullNode/>
        <NullNode start="(199, 1)" end="(199, 8)">
          <OtherNode start="(199, 1)" end="(199, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(199, 1)" end="(199, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(199, 3)" end="(199, 7)">
              <OtherNode start="(199, 3)" end="(199, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(199, 3)" end="(199, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(199, 3)" end="(199, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(199, 7)" end="(199, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(199, 9)" end="(201, 17)" name="find?_filter" full_name="Vector.find?_filter" _is_private_decl="False">
        <AtomNode start="(199, 9)" end="(199, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(199, 17)" end="(199, 29)">
          <IdentNode start="(199, 17)" end="(199, 29)" leading="" trailing=" " raw_val="find?_filter" val="find?_filter"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(199, 30)" end="(200, 58)">
          <NullNode start="(199, 30)" end="(199, 64)">
            <OtherNode start="(199, 30)" end="(199, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(199, 30)" end="(199, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(199, 31)" end="(199, 33)">
                <IdentNode start="(199, 31)" end="(199, 33)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(199, 34)" end="(199, 46)">
                <AtomNode start="(199, 34)" end="(199, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(199, 36)" end="(199, 46)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(199, 36)" end="(199, 42)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(199, 43)" end="(199, 46)">
                    <IdentNode start="(199, 43)" end="(199, 44)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(199, 45)" end="(199, 46)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(199, 46)" end="(199, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(199, 48)" end="(199, 64)">
              <AtomNode start="(199, 48)" end="(199, 49)" leading="" trailing="" val="("/>
              <NullNode start="(199, 49)" end="(199, 52)">
                <IdentNode start="(199, 49)" end="(199, 50)" leading="" trailing=" " raw_val="p" val="p"/>
                <IdentNode start="(199, 51)" end="(199, 52)" leading="" trailing=" " raw_val="q" val="q"/>
              </NullNode>
              <NullNode start="(199, 53)" end="(199, 63)">
                <AtomNode start="(199, 53)" end="(199, 54)" leading="" trailing=" " val=":"/>
                <OtherNode start="(199, 55)" end="(199, 63)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(199, 55)" end="(199, 56)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(199, 57)" end="(199, 58)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(199, 59)" end="(199, 63)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(199, 63)" end="(199, 64)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(199, 65)" end="(200, 58)">
            <AtomNode start="(199, 65)" end="(199, 66)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(200, 5)" end="(200, 58)" kind="«term_=_»">
              <OtherNode start="(200, 5)" end="(200, 26)" kind="Lean.Parser.Term.app">
                <OtherNode start="(200, 5)" end="(200, 24)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(200, 5)" end="(200, 18)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(200, 5)" end="(200, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(200, 6)" end="(200, 17)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(200, 6)" end="(200, 15)" leading="" trailing=" " raw_val="xs.filter" val="xs.filter"/>
                      <NullNode start="(200, 16)" end="(200, 17)">
                        <IdentNode start="(200, 16)" end="(200, 17)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(200, 17)" end="(200, 18)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(200, 18)" end="(200, 19)" leading="" trailing="" val="."/>
                  <IdentNode start="(200, 19)" end="(200, 24)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Array.find?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(200, 25)" end="(200, 26)">
                  <IdentNode start="(200, 25)" end="(200, 26)" leading="" trailing=" " raw_val="q" val="q"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(200, 27)" end="(200, 28)" leading="" trailing=" " val="="/>
              <OtherNode start="(200, 29)" end="(200, 58)" kind="Lean.Parser.Term.app">
                <IdentNode start="(200, 29)" end="(200, 37)" leading="" trailing=" " raw_val="xs.find?" val="xs.find?"/>
                <NullNode start="(200, 38)" end="(200, 58)">
                  <OtherNode start="(200, 38)" end="(200, 58)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(200, 38)" end="(200, 39)" leading="" trailing="" val="("/>
                    <OtherNode start="(200, 39)" end="(200, 57)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(200, 39)" end="(200, 42)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(200, 43)" end="(200, 57)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(200, 43)" end="(200, 44)">
                          <IdentNode start="(200, 43)" end="(200, 44)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(200, 45)" end="(200, 47)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(200, 48)" end="(200, 57)" kind="«term_∧_»">
                          <OtherNode start="(200, 48)" end="(200, 51)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(200, 48)" end="(200, 49)" leading="" trailing=" " raw_val="p" val="p"/>
                            <NullNode start="(200, 50)" end="(200, 51)">
                              <IdentNode start="(200, 50)" end="(200, 51)" leading="" trailing=" " raw_val="a" val="a"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(200, 52)" end="(200, 53)" leading="" trailing=" " val="∧"/>
                          <OtherNode start="(200, 54)" end="(200, 57)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(200, 54)" end="(200, 55)" leading="" trailing=" " raw_val="q" val="q"/>
                            <NullNode start="(200, 56)" end="(200, 57)">
                              <IdentNode start="(200, 56)" end="(200, 57)" leading="" trailing="" raw_val="a" val="a"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(200, 57)" end="(200, 58)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(200, 59)" end="(201, 17)">
          <AtomNode start="(200, 59)" end="(200, 61)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(200, 62)" end="(201, 17)">
            <AtomNode start="(200, 62)" end="(200, 64)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(201, 3)" end="(201, 17)">
              <TacticTacticseq1IndentedNode start="(201, 3)" end="(201, 17)">
                <NullNode start="(201, 3)" end="(201, 17)">
                  <OtherNode start="(201, 3)" end="(201, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type&#10;n : Nat&#10;xs : Vector α n&#10;p q : α → Bool&#10;⊢ Array.find? q (Array.filter p xs.toArray) = find? (fun a =&amp;gt; decide (p a = true ∧ q a = true)) xs" state_after="case mk&#10;α : Type&#10;n : Nat&#10;p q : α → Bool&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n&#10;⊢ Array.find? q (Array.filter p { toArray := toArray✝, size_toArray := size_toArray✝ }.toArray) =&#10;    find? (fun a =&amp;gt; decide (p a = true ∧ q a = true)) { toArray := toArray✝, size_toArray := size_toArray✝ }" tactic="cases xs">
                    <AtomNode start="(201, 3)" end="(201, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(201, 9)" end="(201, 11)">
                      <OtherNode start="(201, 9)" end="(201, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(201, 9)" end="(201, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(201, 11)" end="(201, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(201, 13)" end="(201, 17)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type&#10;n : Nat&#10;p q : α → Bool&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n&#10;⊢ Array.find? q (Array.filter p { toArray := toArray✝, size_toArray := size_toArray✝ }.toArray) =&#10;    find? (fun a =&amp;gt; decide (p a = true ∧ q a = true)) { toArray := toArray✝, size_toArray := size_toArray✝ }" state_after="no goals" tactic="simp">
                    <AtomNode start="(201, 13)" end="(201, 17)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(203, 1)" end="(205, 44)" name="getElem?_zero_filter" full_name="Vector.getElem?_zero_filter">
      <CommandDeclmodifiersNode start="(203, 1)" end="(203, 8)">
        <NullNode/>
        <NullNode start="(203, 1)" end="(203, 8)">
          <OtherNode start="(203, 1)" end="(203, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(203, 1)" end="(203, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(203, 3)" end="(203, 7)">
              <OtherNode start="(203, 3)" end="(203, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(203, 3)" end="(203, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(203, 3)" end="(203, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(203, 7)" end="(203, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(203, 9)" end="(205, 44)" name="getElem?_zero_filter" full_name="Vector.getElem?_zero_filter" _is_private_decl="False">
        <AtomNode start="(203, 9)" end="(203, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(203, 17)" end="(203, 37)">
          <IdentNode start="(203, 17)" end="(203, 37)" leading="" trailing=" " raw_val="getElem?_zero_filter" val="getElem?_zero_filter"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(203, 38)" end="(204, 35)">
          <NullNode start="(203, 38)" end="(203, 70)">
            <OtherNode start="(203, 38)" end="(203, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(203, 38)" end="(203, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(203, 39)" end="(203, 40)">
                <IdentNode start="(203, 39)" end="(203, 40)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(203, 41)" end="(203, 51)">
                <AtomNode start="(203, 41)" end="(203, 42)" leading="" trailing=" " val=":"/>
                <OtherNode start="(203, 43)" end="(203, 51)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(203, 43)" end="(203, 44)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(203, 45)" end="(203, 46)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(203, 47)" end="(203, 51)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(203, 51)" end="(203, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(203, 53)" end="(203, 70)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(203, 53)" end="(203, 54)" leading="" trailing="" val="{"/>
              <NullNode start="(203, 54)" end="(203, 56)">
                <IdentNode start="(203, 54)" end="(203, 56)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(203, 57)" end="(203, 69)">
                <AtomNode start="(203, 57)" end="(203, 58)" leading="" trailing=" " val=":"/>
                <OtherNode start="(203, 59)" end="(203, 69)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(203, 59)" end="(203, 65)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(203, 66)" end="(203, 69)">
                    <IdentNode start="(203, 66)" end="(203, 67)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(203, 68)" end="(203, 69)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(203, 69)" end="(203, 70)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(203, 71)" end="(204, 35)">
            <AtomNode start="(203, 71)" end="(203, 72)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(204, 5)" end="(204, 35)" kind="«term_=_»">
              <OtherNode start="(204, 5)" end="(204, 22)" kind="«term__[_]_?»">
                <OtherNode start="(204, 5)" end="(204, 18)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(204, 5)" end="(204, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(204, 6)" end="(204, 17)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(204, 6)" end="(204, 15)" leading="" trailing=" " raw_val="xs.filter" val="xs.filter"/>
                    <NullNode start="(204, 16)" end="(204, 17)">
                      <IdentNode start="(204, 16)" end="(204, 17)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(204, 17)" end="(204, 18)" leading="" trailing="" val=")"/>
                </OtherNode>
                <GroupNode/>
                <AtomNode start="(204, 18)" end="(204, 19)" leading="" trailing="" val="["/>
                <OtherNode start="(204, 19)" end="(204, 20)" kind="num">
                  <AtomNode start="(204, 19)" end="(204, 20)" leading="" trailing="" val="0"/>
                </OtherNode>
                <AtomNode start="(204, 20)" end="(204, 21)" leading="" trailing="" val="]"/>
                <GroupNode/>
                <AtomNode start="(204, 21)" end="(204, 22)" leading="" trailing=" " val="?"/>
              </OtherNode>
              <AtomNode start="(204, 23)" end="(204, 24)" leading="" trailing=" " val="="/>
              <OtherNode start="(204, 25)" end="(204, 35)" kind="Lean.Parser.Term.app">
                <IdentNode start="(204, 25)" end="(204, 33)" leading="" trailing=" " raw_val="xs.find?" val="xs.find?"/>
                <NullNode start="(204, 34)" end="(204, 35)">
                  <IdentNode start="(204, 34)" end="(204, 35)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(204, 36)" end="(205, 44)">
          <AtomNode start="(204, 36)" end="(204, 38)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(204, 39)" end="(205, 44)">
            <AtomNode start="(204, 39)" end="(204, 41)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(205, 3)" end="(205, 44)">
              <TacticTacticseq1IndentedNode start="(205, 3)" end="(205, 44)">
                <NullNode start="(205, 3)" end="(205, 44)">
                  <OtherNode start="(205, 3)" end="(205, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type&#10;n : Nat&#10;p : α → Bool&#10;xs : Vector α n&#10;⊢ (Array.filter p xs.toArray)[0]? = find? p xs" state_after="case mk&#10;α : Type&#10;n : Nat&#10;p : α → Bool&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n&#10;⊢ (Array.filter p { toArray := toArray✝, size_toArray := size_toArray✝ }.toArray)[0]? =&#10;    find? p { toArray := toArray✝, size_toArray := size_toArray✝ }" tactic="cases xs">
                    <AtomNode start="(205, 3)" end="(205, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(205, 9)" end="(205, 11)">
                      <OtherNode start="(205, 9)" end="(205, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(205, 9)" end="(205, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(205, 11)" end="(205, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(205, 13)" end="(205, 44)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type&#10;n : Nat&#10;p : α → Bool&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n&#10;⊢ (Array.filter p { toArray := toArray✝, size_toArray := size_toArray✝ }.toArray)[0]? =&#10;    find? p { toArray := toArray✝, size_toArray := size_toArray✝ }" state_after="no goals" tactic="simp [← List.head?_eq_getElem?]">
                    <AtomNode start="(205, 13)" end="(205, 17)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(205, 18)" end="(205, 44)">
                      <AtomNode start="(205, 18)" end="(205, 19)" leading="" trailing="" val="["/>
                      <NullNode start="(205, 19)" end="(205, 43)">
                        <OtherNode start="(205, 19)" end="(205, 43)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode start="(205, 19)" end="(205, 20)">
                            <OtherNode start="(205, 19)" end="(205, 20)" kind="patternIgnore">
                              <OtherNode start="(205, 19)" end="(205, 20)" kind="token.«← »">
                                <AtomNode start="(205, 19)" end="(205, 20)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(205, 21)" end="(205, 43)" leading="" trailing="" raw_val="List.head?_eq_getElem?" val="List.head?_eq_getElem?" full_name="List.head?_eq_getElem?" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(205, 43)" end="(205, 44)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(207, 1)" end="(211, 35)" name="getElem_zero_filter" full_name="Vector.getElem_zero_filter">
      <CommandDeclmodifiersNode start="(207, 1)" end="(207, 8)">
        <NullNode/>
        <NullNode start="(207, 1)" end="(207, 8)">
          <OtherNode start="(207, 1)" end="(207, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(207, 1)" end="(207, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(207, 3)" end="(207, 7)">
              <OtherNode start="(207, 3)" end="(207, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(207, 3)" end="(207, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(207, 3)" end="(207, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(207, 7)" end="(207, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(207, 9)" end="(211, 35)" name="getElem_zero_filter" full_name="Vector.getElem_zero_filter" _is_private_decl="False">
        <AtomNode start="(207, 9)" end="(207, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(207, 17)" end="(207, 36)">
          <IdentNode start="(207, 17)" end="(207, 36)" leading="" trailing=" " raw_val="getElem_zero_filter" val="getElem_zero_filter"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(207, 37)" end="(209, 84)">
          <NullNode start="(207, 37)" end="(207, 73)">
            <OtherNode start="(207, 37)" end="(207, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(207, 37)" end="(207, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(207, 38)" end="(207, 39)">
                <IdentNode start="(207, 38)" end="(207, 39)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(207, 40)" end="(207, 50)">
                <AtomNode start="(207, 40)" end="(207, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(207, 42)" end="(207, 50)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(207, 42)" end="(207, 43)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(207, 44)" end="(207, 45)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(207, 46)" end="(207, 50)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(207, 50)" end="(207, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(207, 52)" end="(207, 69)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(207, 52)" end="(207, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(207, 53)" end="(207, 55)">
                <IdentNode start="(207, 53)" end="(207, 55)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(207, 56)" end="(207, 68)">
                <AtomNode start="(207, 56)" end="(207, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(207, 58)" end="(207, 68)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(207, 58)" end="(207, 64)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(207, 65)" end="(207, 68)">
                    <IdentNode start="(207, 65)" end="(207, 66)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(207, 67)" end="(207, 68)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(207, 68)" end="(207, 69)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(207, 70)" end="(207, 73)">
              <AtomNode start="(207, 70)" end="(207, 71)" leading="" trailing="" val="("/>
              <NullNode start="(207, 71)" end="(207, 72)">
                <IdentNode start="(207, 71)" end="(207, 72)" leading="" trailing="" raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(207, 72)" end="(207, 73)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(207, 74)" end="(209, 84)">
            <AtomNode start="(207, 74)" end="(207, 75)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(208, 5)" end="(209, 84)" kind="«term_=_»">
              <OtherNode start="(208, 5)" end="(208, 21)" kind="«term__[_]»">
                <OtherNode start="(208, 5)" end="(208, 18)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(208, 5)" end="(208, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(208, 6)" end="(208, 17)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(208, 6)" end="(208, 15)" leading="" trailing=" " raw_val="xs.filter" val="xs.filter"/>
                    <NullNode start="(208, 16)" end="(208, 17)">
                      <IdentNode start="(208, 16)" end="(208, 17)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(208, 17)" end="(208, 18)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(208, 18)" end="(208, 19)" leading="" trailing="" val="["/>
                <OtherNode start="(208, 19)" end="(208, 20)" kind="num">
                  <AtomNode start="(208, 19)" end="(208, 20)" leading="" trailing="" val="0"/>
                </OtherNode>
                <AtomNode start="(208, 20)" end="(208, 21)" leading="" trailing=" " val="]"/>
              </OtherNode>
              <AtomNode start="(208, 22)" end="(208, 23)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(209, 7)" end="(209, 84)" kind="Lean.Parser.Term.app">
                <OtherNode start="(209, 7)" end="(209, 23)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(209, 7)" end="(209, 19)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(209, 7)" end="(209, 8)" leading="" trailing="" val="("/>
                    <OtherNode start="(209, 8)" end="(209, 18)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(209, 8)" end="(209, 16)" leading="" trailing=" " raw_val="xs.find?" val="xs.find?"/>
                      <NullNode start="(209, 17)" end="(209, 18)">
                        <IdentNode start="(209, 17)" end="(209, 18)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(209, 18)" end="(209, 19)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(209, 19)" end="(209, 20)" leading="" trailing="" val="."/>
                  <IdentNode start="(209, 20)" end="(209, 23)" leading="" trailing=" " raw_val="get" val="get" full_name="Option.get" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(209, 24)" end="(209, 84)">
                  <OtherNode start="(209, 24)" end="(209, 84)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(209, 24)" end="(209, 25)" leading="" trailing="" val="("/>
                    <TermBytacticNode start="(209, 25)" end="(209, 83)">
                      <AtomNode start="(209, 25)" end="(209, 27)" leading="" trailing=" " val="by"/>
                      <TacticTacticseqNode start="(209, 28)" end="(209, 83)">
                        <TacticTacticseq1IndentedNode start="(209, 28)" end="(209, 83)">
                          <NullNode start="(209, 28)" end="(209, 83)">
                            <OtherNode start="(209, 28)" end="(209, 36)" kind="Lean.Parser.Tactic.cases" state_before="α : Type&#10;n : Nat&#10;p : α → Bool&#10;xs : Vector α n&#10;h : 0 &amp;lt; (Array.filter p xs.toArray).size&#10;⊢ (find? p xs).isSome = true" state_after="case mk&#10;α : Type&#10;n : Nat&#10;p : α → Bool&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n&#10;h : 0 &amp;lt; (Array.filter p { toArray := toArray✝, size_toArray := size_toArray✝ }.toArray).size&#10;⊢ (find? p { toArray := toArray✝, size_toArray := size_toArray✝ }).isSome = true" tactic="cases xs">
                              <AtomNode start="(209, 28)" end="(209, 33)" leading="" trailing=" " val="cases"/>
                              <NullNode start="(209, 34)" end="(209, 36)">
                                <OtherNode start="(209, 34)" end="(209, 36)" kind="Lean.Parser.Tactic.elimTarget">
                                  <NullNode/>
                                  <IdentNode start="(209, 34)" end="(209, 36)" leading="" trailing="" raw_val="xs" val="xs"/>
                                </OtherNode>
                              </NullNode>
                              <NullNode/>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(209, 36)" end="(209, 37)" leading="" trailing=" " val=";"/>
                            <OtherNode start="(209, 38)" end="(209, 83)" kind="Lean.Parser.Tactic.simpa" state_before="case mk&#10;α : Type&#10;n : Nat&#10;p : α → Bool&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n&#10;h : 0 &amp;lt; (Array.filter p { toArray := toArray✝, size_toArray := size_toArray✝ }.toArray).size&#10;⊢ (find? p { toArray := toArray✝, size_toArray := size_toArray✝ }).isSome = true" state_after="no goals" tactic="simpa [← Array.countP_eq_size_filter] using h">
                              <AtomNode start="(209, 38)" end="(209, 43)" leading="" trailing=" " val="simpa"/>
                              <NullNode/>
                              <NullNode/>
                              <OtherNode start="(209, 44)" end="(209, 83)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                  <NullNode/>
                                </OtherNode>
                                <NullNode/>
                                <NullNode/>
                                <NullNode start="(209, 44)" end="(209, 75)">
                                  <OtherNode start="(209, 44)" end="(209, 75)" kind="Lean.Parser.Tactic.simpArgs">
                                    <AtomNode start="(209, 44)" end="(209, 45)" leading="" trailing="" val="["/>
                                    <NullNode start="(209, 45)" end="(209, 74)">
                                      <OtherNode start="(209, 45)" end="(209, 74)" kind="Lean.Parser.Tactic.simpLemma">
                                        <NullNode/>
                                        <NullNode start="(209, 45)" end="(209, 46)">
                                          <OtherNode start="(209, 45)" end="(209, 46)" kind="patternIgnore">
                                            <OtherNode start="(209, 45)" end="(209, 46)" kind="token.«← »">
                                              <AtomNode start="(209, 45)" end="(209, 46)" leading="" trailing=" " val="←"/>
                                            </OtherNode>
                                          </OtherNode>
                                        </NullNode>
                                        <IdentNode start="(209, 47)" end="(209, 74)" leading="" trailing="" raw_val="Array.countP_eq_size_filter" val="Array.countP_eq_size_filter" full_name="Array.countP_eq_size_filter" mod_name="Init.Data.Array.Count" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Count.lean"/>
                                      </OtherNode>
                                    </NullNode>
                                    <AtomNode start="(209, 74)" end="(209, 75)" leading="" trailing=" " val="]"/>
                                  </OtherNode>
                                </NullNode>
                                <NullNode start="(209, 76)" end="(209, 83)">
                                  <AtomNode start="(209, 76)" end="(209, 81)" leading="" trailing=" " val="using"/>
                                  <IdentNode start="(209, 82)" end="(209, 83)" leading="" trailing="" raw_val="h" val="h"/>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </TermBytacticNode>
                    <AtomNode start="(209, 83)" end="(209, 84)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(209, 85)" end="(211, 35)">
          <AtomNode start="(209, 85)" end="(209, 87)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(209, 88)" end="(211, 35)">
            <AtomNode start="(209, 88)" end="(209, 90)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(210, 3)" end="(211, 35)">
              <TacticTacticseq1IndentedNode start="(210, 3)" end="(211, 35)">
                <NullNode start="(210, 3)" end="(211, 35)">
                  <OtherNode start="(210, 3)" end="(210, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type&#10;n : Nat&#10;p : α → Bool&#10;xs : Vector α n&#10;h : 0 &amp;lt; (Array.filter p xs.toArray).size&#10;⊢ (Array.filter p xs.toArray)[0] = (find? p xs).get ⋯" state_after="case mk&#10;α : Type&#10;n : Nat&#10;p : α → Bool&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n&#10;h : 0 &amp;lt; (Array.filter p { toArray := toArray✝, size_toArray := size_toArray✝ }.toArray).size&#10;⊢ (Array.filter p { toArray := toArray✝, size_toArray := size_toArray✝ }.toArray)[0] =&#10;    (find? p { toArray := toArray✝, size_toArray := size_toArray✝ }).get ⋯" tactic="cases xs">
                    <AtomNode start="(210, 3)" end="(210, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(210, 9)" end="(210, 11)">
                      <OtherNode start="(210, 9)" end="(210, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(210, 9)" end="(210, 11)" leading="" trailing="&#10;  " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(211, 3)" end="(211, 35)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type&#10;n : Nat&#10;p : α → Bool&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n&#10;h : 0 &amp;lt; (Array.filter p { toArray := toArray✝, size_toArray := size_toArray✝ }.toArray).size&#10;⊢ (Array.filter p { toArray := toArray✝, size_toArray := size_toArray✝ }.toArray)[0] =&#10;    (find? p { toArray := toArray✝, size_toArray := size_toArray✝ }).get ⋯" state_after="no goals" tactic="simp [List.getElem_zero_eq_head]">
                    <AtomNode start="(211, 3)" end="(211, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(211, 8)" end="(211, 35)">
                      <AtomNode start="(211, 8)" end="(211, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(211, 9)" end="(211, 34)">
                        <OtherNode start="(211, 9)" end="(211, 34)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(211, 9)" end="(211, 34)" leading="" trailing="" raw_val="List.getElem_zero_eq_head" val="List.getElem_zero_eq_head" full_name="List.getElem_zero_eq_head" mod_name="Init.Data.List.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(211, 34)" end="(211, 35)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(213, 1)" end="(215, 17)" name="find?_map" full_name="Vector.find?_map">
      <CommandDeclmodifiersNode start="(213, 1)" end="(213, 8)">
        <NullNode/>
        <NullNode start="(213, 1)" end="(213, 8)">
          <OtherNode start="(213, 1)" end="(213, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(213, 1)" end="(213, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(213, 3)" end="(213, 7)">
              <OtherNode start="(213, 3)" end="(213, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(213, 3)" end="(213, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(213, 3)" end="(213, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(213, 7)" end="(213, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(213, 9)" end="(215, 17)" name="find?_map" full_name="Vector.find?_map" _is_private_decl="False">
        <AtomNode start="(213, 9)" end="(213, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(213, 17)" end="(213, 26)">
          <IdentNode start="(213, 17)" end="(213, 26)" leading="" trailing=" " raw_val="find?_map" val="find?_map"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(213, 27)" end="(214, 50)">
          <NullNode start="(213, 27)" end="(213, 56)">
            <OtherNode start="(213, 27)" end="(213, 38)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(213, 27)" end="(213, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(213, 28)" end="(213, 29)">
                <IdentNode start="(213, 28)" end="(213, 29)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(213, 30)" end="(213, 37)">
                <AtomNode start="(213, 30)" end="(213, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(213, 32)" end="(213, 37)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(213, 32)" end="(213, 33)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(213, 34)" end="(213, 35)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(213, 36)" end="(213, 37)" leading="" trailing="" raw_val="α" val="α"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(213, 37)" end="(213, 38)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(213, 39)" end="(213, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(213, 39)" end="(213, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(213, 40)" end="(213, 42)">
                <IdentNode start="(213, 40)" end="(213, 42)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(213, 43)" end="(213, 55)">
                <AtomNode start="(213, 43)" end="(213, 44)" leading="" trailing=" " val=":"/>
                <OtherNode start="(213, 45)" end="(213, 55)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(213, 45)" end="(213, 51)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(213, 52)" end="(213, 55)">
                    <IdentNode start="(213, 52)" end="(213, 53)" leading="" trailing=" " raw_val="β" val="β"/>
                    <IdentNode start="(213, 54)" end="(213, 55)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(213, 55)" end="(213, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(213, 57)" end="(214, 50)">
            <AtomNode start="(213, 57)" end="(213, 58)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(214, 5)" end="(214, 50)" kind="«term_=_»">
              <OtherNode start="(214, 5)" end="(214, 23)" kind="Lean.Parser.Term.app">
                <IdentNode start="(214, 5)" end="(214, 10)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Vector.find?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(214, 11)" end="(214, 23)">
                  <IdentNode start="(214, 11)" end="(214, 12)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(214, 13)" end="(214, 23)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(214, 13)" end="(214, 14)" leading="" trailing="" val="("/>
                    <OtherNode start="(214, 14)" end="(214, 22)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(214, 14)" end="(214, 20)" leading="" trailing=" " raw_val="xs.map" val="xs.map"/>
                      <NullNode start="(214, 21)" end="(214, 22)">
                        <IdentNode start="(214, 21)" end="(214, 22)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(214, 22)" end="(214, 23)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(214, 24)" end="(214, 25)" leading="" trailing=" " val="="/>
              <OtherNode start="(214, 26)" end="(214, 50)" kind="Lean.Parser.Term.app">
                <OtherNode start="(214, 26)" end="(214, 48)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(214, 26)" end="(214, 44)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(214, 26)" end="(214, 27)" leading="" trailing="" val="("/>
                    <OtherNode start="(214, 27)" end="(214, 43)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(214, 27)" end="(214, 35)" leading="" trailing=" " raw_val="xs.find?" val="xs.find?"/>
                      <NullNode start="(214, 36)" end="(214, 43)">
                        <OtherNode start="(214, 36)" end="(214, 43)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(214, 36)" end="(214, 37)" leading="" trailing="" val="("/>
                          <OtherNode start="(214, 37)" end="(214, 42)" kind="«term_∘_»">
                            <IdentNode start="(214, 37)" end="(214, 38)" leading="" trailing=" " raw_val="p" val="p"/>
                            <AtomNode start="(214, 39)" end="(214, 40)" leading="" trailing=" " val="∘"/>
                            <IdentNode start="(214, 41)" end="(214, 42)" leading="" trailing="" raw_val="f" val="f"/>
                          </OtherNode>
                          <AtomNode start="(214, 42)" end="(214, 43)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(214, 43)" end="(214, 44)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(214, 44)" end="(214, 45)" leading="" trailing="" val="."/>
                  <IdentNode start="(214, 45)" end="(214, 48)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(214, 49)" end="(214, 50)">
                  <IdentNode start="(214, 49)" end="(214, 50)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(214, 51)" end="(215, 17)">
          <AtomNode start="(214, 51)" end="(214, 53)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(214, 54)" end="(215, 17)">
            <AtomNode start="(214, 54)" end="(214, 56)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(215, 3)" end="(215, 17)">
              <TacticTacticseq1IndentedNode start="(215, 3)" end="(215, 17)">
                <NullNode start="(215, 3)" end="(215, 17)">
                  <OtherNode start="(215, 3)" end="(215, 11)" kind="Lean.Parser.Tactic.cases" state_before="β α : Type&#10;n : Nat&#10;p : α → Bool&#10;f : β → α&#10;xs : Vector β n&#10;⊢ find? p (map f xs) = Option.map f (find? (p ∘ f) xs)" state_after="case mk&#10;β α : Type&#10;n : Nat&#10;p : α → Bool&#10;f : β → α&#10;toArray✝ : Array β&#10;size_toArray✝ : toArray✝.size = n&#10;⊢ find? p (map f { toArray := toArray✝, size_toArray := size_toArray✝ }) =&#10;    Option.map f (find? (p ∘ f) { toArray := toArray✝, size_toArray := size_toArray✝ })" tactic="cases xs">
                    <AtomNode start="(215, 3)" end="(215, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(215, 9)" end="(215, 11)">
                      <OtherNode start="(215, 9)" end="(215, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(215, 9)" end="(215, 11)" leading="" trailing="" raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(215, 11)" end="(215, 12)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(215, 13)" end="(215, 17)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;β α : Type&#10;n : Nat&#10;p : α → Bool&#10;f : β → α&#10;toArray✝ : Array β&#10;size_toArray✝ : toArray✝.size = n&#10;⊢ find? p (map f { toArray := toArray✝, size_toArray := size_toArray✝ }) =&#10;    Option.map f (find? (p ∘ f) { toArray := toArray✝, size_toArray := size_toArray✝ })" state_after="no goals" tactic="simp">
                    <AtomNode start="(215, 13)" end="(215, 17)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(217, 1)" end="(221, 7)" name="find?_append" full_name="Vector.find?_append">
      <CommandDeclmodifiersNode start="(217, 1)" end="(217, 8)">
        <NullNode/>
        <NullNode start="(217, 1)" end="(217, 8)">
          <OtherNode start="(217, 1)" end="(217, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(217, 1)" end="(217, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(217, 3)" end="(217, 7)">
              <OtherNode start="(217, 3)" end="(217, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(217, 3)" end="(217, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(217, 3)" end="(217, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(217, 7)" end="(217, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(217, 9)" end="(221, 7)" name="find?_append" full_name="Vector.find?_append" _is_private_decl="False">
        <AtomNode start="(217, 9)" end="(217, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(217, 17)" end="(217, 29)">
          <IdentNode start="(217, 17)" end="(217, 29)" leading="" trailing=" " raw_val="find?_append" val="find?_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(217, 30)" end="(218, 54)">
          <NullNode start="(217, 30)" end="(217, 67)">
            <OtherNode start="(217, 30)" end="(217, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(217, 30)" end="(217, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(217, 31)" end="(217, 33)">
                <IdentNode start="(217, 31)" end="(217, 33)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(217, 34)" end="(217, 47)">
                <AtomNode start="(217, 34)" end="(217, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(217, 36)" end="(217, 47)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(217, 36)" end="(217, 42)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(217, 43)" end="(217, 47)">
                    <IdentNode start="(217, 43)" end="(217, 44)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(217, 45)" end="(217, 47)" leading="" trailing="" raw_val="n₁" val="n₁"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(217, 47)" end="(217, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(217, 49)" end="(217, 67)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(217, 49)" end="(217, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(217, 50)" end="(217, 52)">
                <IdentNode start="(217, 50)" end="(217, 52)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(217, 53)" end="(217, 66)">
                <AtomNode start="(217, 53)" end="(217, 54)" leading="" trailing=" " val=":"/>
                <OtherNode start="(217, 55)" end="(217, 66)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(217, 55)" end="(217, 61)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(217, 62)" end="(217, 66)">
                    <IdentNode start="(217, 62)" end="(217, 63)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(217, 64)" end="(217, 66)" leading="" trailing="" raw_val="n₂" val="n₂"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(217, 66)" end="(217, 67)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(217, 68)" end="(218, 54)">
            <AtomNode start="(217, 68)" end="(217, 69)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(218, 5)" end="(218, 54)" kind="«term_=_»">
              <OtherNode start="(218, 5)" end="(218, 23)" kind="Lean.Parser.Term.app">
                <OtherNode start="(218, 5)" end="(218, 21)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(218, 5)" end="(218, 15)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(218, 5)" end="(218, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(218, 6)" end="(218, 14)" kind="«term_++_»">
                      <IdentNode start="(218, 6)" end="(218, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(218, 9)" end="(218, 11)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(218, 12)" end="(218, 14)" leading="" trailing="" raw_val="ys" val="ys"/>
                    </OtherNode>
                    <AtomNode start="(218, 14)" end="(218, 15)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(218, 15)" end="(218, 16)" leading="" trailing="" val="."/>
                  <IdentNode start="(218, 16)" end="(218, 21)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Vector.find?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                </OtherNode>
                <NullNode start="(218, 22)" end="(218, 23)">
                  <IdentNode start="(218, 22)" end="(218, 23)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(218, 24)" end="(218, 25)" leading="" trailing=" " val="="/>
              <OtherNode start="(218, 26)" end="(218, 54)" kind="Lean.Parser.Term.app">
                <OtherNode start="(218, 26)" end="(218, 41)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(218, 26)" end="(218, 38)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(218, 26)" end="(218, 27)" leading="" trailing="" val="("/>
                    <OtherNode start="(218, 27)" end="(218, 37)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(218, 27)" end="(218, 35)" leading="" trailing=" " raw_val="xs.find?" val="xs.find?"/>
                      <NullNode start="(218, 36)" end="(218, 37)">
                        <IdentNode start="(218, 36)" end="(218, 37)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(218, 37)" end="(218, 38)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(218, 38)" end="(218, 39)" leading="" trailing="" val="."/>
                  <IdentNode start="(218, 39)" end="(218, 41)" leading="" trailing=" " raw_val="or" val="or" full_name="Option.or" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(218, 42)" end="(218, 54)">
                  <OtherNode start="(218, 42)" end="(218, 54)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(218, 42)" end="(218, 43)" leading="" trailing="" val="("/>
                    <OtherNode start="(218, 43)" end="(218, 53)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(218, 43)" end="(218, 51)" leading="" trailing=" " raw_val="ys.find?" val="ys.find?"/>
                      <NullNode start="(218, 52)" end="(218, 53)">
                        <IdentNode start="(218, 52)" end="(218, 53)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(218, 53)" end="(218, 54)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(218, 55)" end="(221, 7)">
          <AtomNode start="(218, 55)" end="(218, 57)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(218, 58)" end="(221, 7)">
            <AtomNode start="(218, 58)" end="(218, 60)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(219, 3)" end="(221, 7)">
              <TacticTacticseq1IndentedNode start="(219, 3)" end="(221, 7)">
                <NullNode start="(219, 3)" end="(221, 7)">
                  <OtherNode start="(219, 3)" end="(219, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type&#10;n₁ n₂ : Nat&#10;p : α → Bool&#10;xs : Vector α n₁&#10;ys : Vector α n₂&#10;⊢ find? p (xs ++ ys) = (find? p xs).or (find? p ys)" state_after="case mk&#10;α : Type&#10;n₁ n₂ : Nat&#10;p : α → Bool&#10;ys : Vector α n₂&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n₁&#10;⊢ find? p ({ toArray := toArray✝, size_toArray := size_toArray✝ } ++ ys) =&#10;    (find? p { toArray := toArray✝, size_toArray := size_toArray✝ }).or (find? p ys)" tactic="cases xs">
                    <AtomNode start="(219, 3)" end="(219, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(219, 9)" end="(219, 11)">
                      <OtherNode start="(219, 9)" end="(219, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(219, 9)" end="(219, 11)" leading="" trailing="&#10;  " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(220, 3)" end="(220, 11)" kind="Lean.Parser.Tactic.cases" state_before="case mk&#10;α : Type&#10;n₁ n₂ : Nat&#10;p : α → Bool&#10;ys : Vector α n₂&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n₁&#10;⊢ find? p ({ toArray := toArray✝, size_toArray := size_toArray✝ } ++ ys) =&#10;    (find? p { toArray := toArray✝, size_toArray := size_toArray✝ }).or (find? p ys)" state_after="case mk.mk&#10;α : Type&#10;n₁ n₂ : Nat&#10;p : α → Bool&#10;toArray✝¹ : Array α&#10;size_toArray✝¹ : toArray✝¹.size = n₁&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n₂&#10;⊢ find? p&#10;      ({ toArray := toArray✝¹, size_toArray := size_toArray✝¹ } ++&#10;        { toArray := toArray✝, size_toArray := size_toArray✝ }) =&#10;    (find? p { toArray := toArray✝¹, size_toArray := size_toArray✝¹ }).or&#10;      (find? p { toArray := toArray✝, size_toArray := size_toArray✝ })" tactic="cases ys">
                    <AtomNode start="(220, 3)" end="(220, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(220, 9)" end="(220, 11)">
                      <OtherNode start="(220, 9)" end="(220, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(220, 9)" end="(220, 11)" leading="" trailing="&#10;  " raw_val="ys" val="ys"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(221, 3)" end="(221, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α : Type&#10;n₁ n₂ : Nat&#10;p : α → Bool&#10;toArray✝¹ : Array α&#10;size_toArray✝¹ : toArray✝¹.size = n₁&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n₂&#10;⊢ find? p&#10;      ({ toArray := toArray✝¹, size_toArray := size_toArray✝¹ } ++&#10;        { toArray := toArray✝, size_toArray := size_toArray✝ }) =&#10;    (find? p { toArray := toArray✝¹, size_toArray := size_toArray✝¹ }).or&#10;      (find? p { toArray := toArray✝, size_toArray := size_toArray✝ })" state_after="no goals" tactic="simp">
                    <AtomNode start="(221, 3)" end="(221, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(223, 1)" end="(226, 48)" name="find?_flatten" full_name="Vector.find?_flatten">
      <CommandDeclmodifiersNode start="(223, 1)" end="(223, 8)">
        <NullNode/>
        <NullNode start="(223, 1)" end="(223, 8)">
          <OtherNode start="(223, 1)" end="(223, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(223, 1)" end="(223, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(223, 3)" end="(223, 7)">
              <OtherNode start="(223, 3)" end="(223, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(223, 3)" end="(223, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(223, 3)" end="(223, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(223, 7)" end="(223, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(223, 9)" end="(226, 48)" name="find?_flatten" full_name="Vector.find?_flatten" _is_private_decl="False">
        <AtomNode start="(223, 9)" end="(223, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(223, 17)" end="(223, 30)">
          <IdentNode start="(223, 17)" end="(223, 30)" leading="" trailing=" " raw_val="find?_flatten" val="find?_flatten"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(223, 31)" end="(224, 50)">
          <NullNode start="(223, 31)" end="(223, 74)">
            <OtherNode start="(223, 31)" end="(223, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(223, 31)" end="(223, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(223, 32)" end="(223, 34)">
                <IdentNode start="(223, 32)" end="(223, 34)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(223, 35)" end="(223, 58)">
                <AtomNode start="(223, 35)" end="(223, 36)" leading="" trailing=" " val=":"/>
                <OtherNode start="(223, 37)" end="(223, 58)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(223, 37)" end="(223, 43)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(223, 44)" end="(223, 58)">
                    <OtherNode start="(223, 44)" end="(223, 56)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(223, 44)" end="(223, 45)" leading="" trailing="" val="("/>
                      <OtherNode start="(223, 45)" end="(223, 55)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(223, 45)" end="(223, 51)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                        <NullNode start="(223, 52)" end="(223, 55)">
                          <IdentNode start="(223, 52)" end="(223, 53)" leading="" trailing=" " raw_val="α" val="α"/>
                          <IdentNode start="(223, 54)" end="(223, 55)" leading="" trailing="" raw_val="m" val="m"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(223, 55)" end="(223, 56)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <IdentNode start="(223, 57)" end="(223, 58)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(223, 58)" end="(223, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(223, 60)" end="(223, 74)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(223, 60)" end="(223, 61)" leading="" trailing="" val="{"/>
              <NullNode start="(223, 61)" end="(223, 62)">
                <IdentNode start="(223, 61)" end="(223, 62)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(223, 63)" end="(223, 73)">
                <AtomNode start="(223, 63)" end="(223, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(223, 65)" end="(223, 73)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(223, 65)" end="(223, 66)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(223, 67)" end="(223, 68)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(223, 69)" end="(223, 73)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(223, 73)" end="(223, 74)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(223, 75)" end="(224, 50)">
            <AtomNode start="(223, 75)" end="(223, 76)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(224, 5)" end="(224, 50)" kind="«term_=_»">
              <OtherNode start="(224, 5)" end="(224, 23)" kind="Lean.Parser.Term.app">
                <IdentNode start="(224, 5)" end="(224, 21)" leading="" trailing=" " raw_val="xs.flatten.find?" val="xs.flatten.find?"/>
                <NullNode start="(224, 22)" end="(224, 23)">
                  <IdentNode start="(224, 22)" end="(224, 23)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(224, 24)" end="(224, 25)" leading="" trailing=" " val="="/>
              <OtherNode start="(224, 26)" end="(224, 50)" kind="Lean.Parser.Term.app">
                <IdentNode start="(224, 26)" end="(224, 38)" leading="" trailing=" " raw_val="xs.findSome?" val="xs.findSome?"/>
                <NullNode start="(224, 39)" end="(224, 50)">
                  <OtherNode start="(224, 39)" end="(224, 50)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(224, 39)" end="(224, 40)" leading="" trailing="" val="("/>
                    <OtherNode start="(224, 40)" end="(224, 49)" kind="Lean.Parser.Term.app">
                      <OtherNode start="(224, 40)" end="(224, 47)" kind="Lean.Parser.Term.proj">
                        <OtherNode start="(224, 40)" end="(224, 41)" kind="Lean.Parser.Term.cdot">
                          <AtomNode start="(224, 40)" end="(224, 41)" leading="" trailing="" val="·"/>
                        </OtherNode>
                        <AtomNode start="(224, 41)" end="(224, 42)" leading="" trailing="" val="."/>
                        <IdentNode start="(224, 42)" end="(224, 47)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Vector.find?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                      </OtherNode>
                      <NullNode start="(224, 48)" end="(224, 49)">
                        <IdentNode start="(224, 48)" end="(224, 49)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(224, 49)" end="(224, 50)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(224, 51)" end="(226, 48)">
          <AtomNode start="(224, 51)" end="(224, 53)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(224, 54)" end="(226, 48)">
            <AtomNode start="(224, 54)" end="(224, 56)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(225, 3)" end="(226, 48)">
              <TacticTacticseq1IndentedNode start="(225, 3)" end="(226, 48)">
                <NullNode start="(225, 3)" end="(226, 48)">
                  <OtherNode start="(225, 3)" end="(225, 35)" kind="Lean.Parser.Tactic.cases" state_before="α : Type&#10;m n : Nat&#10;xs : Vector (Vector α m) n&#10;p : α → Bool&#10;⊢ find? p xs.flatten = findSome? (fun x =&amp;gt; find? p x) xs" state_after="case of&#10;α : Type&#10;m n : Nat&#10;p : α → Bool&#10;xss✝ : Array (Array α)&#10;h₁✝ : xss✝.size = n&#10;h₂✝ : ∀ (xs : Array α), xs ∈ xss✝ → xs.size = m&#10;⊢ find? p&#10;      {&#10;          toArray :=&#10;            Array.map&#10;              (fun x =&amp;gt;&#10;                match x with&#10;                | ⟨xs, m_1⟩ =&amp;gt; { toArray := xs, size_toArray := ⋯ })&#10;              xss✝.attach,&#10;          size_toArray := ⋯ }.flatten =&#10;    findSome? (fun x =&amp;gt; find? p x)&#10;      {&#10;        toArray :=&#10;          Array.map&#10;            (fun x =&amp;gt;&#10;              match x with&#10;              | ⟨xs, m_1⟩ =&amp;gt; { toArray := xs, size_toArray := ⋯ })&#10;            xss✝.attach,&#10;        size_toArray := ⋯ }" tactic="cases xs using vector₂_induction">
                    <AtomNode start="(225, 3)" end="(225, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(225, 9)" end="(225, 11)">
                      <OtherNode start="(225, 9)" end="(225, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(225, 9)" end="(225, 11)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(225, 12)" end="(225, 35)">
                      <AtomNode start="(225, 12)" end="(225, 17)" leading="" trailing=" " val="using"/>
                      <IdentNode start="(225, 18)" end="(225, 35)" leading="" trailing="&#10;  " raw_val="vector₂_induction" val="vector₂_induction" full_name="Vector.vector₂_induction" mod_name="Init.Data.Vector.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Lemmas.lean"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(226, 3)" end="(226, 48)" kind="Lean.Parser.Tactic.simp" state_before="case of&#10;α : Type&#10;m n : Nat&#10;p : α → Bool&#10;xss✝ : Array (Array α)&#10;h₁✝ : xss✝.size = n&#10;h₂✝ : ∀ (xs : Array α), xs ∈ xss✝ → xs.size = m&#10;⊢ find? p&#10;      {&#10;          toArray :=&#10;            Array.map&#10;              (fun x =&amp;gt;&#10;                match x with&#10;                | ⟨xs, m_1⟩ =&amp;gt; { toArray := xs, size_toArray := ⋯ })&#10;              xss✝.attach,&#10;          size_toArray := ⋯ }.flatten =&#10;    findSome? (fun x =&amp;gt; find? p x)&#10;      {&#10;        toArray :=&#10;          Array.map&#10;            (fun x =&amp;gt;&#10;              match x with&#10;              | ⟨xs, m_1⟩ =&amp;gt; { toArray := xs, size_toArray := ⋯ })&#10;            xss✝.attach,&#10;        size_toArray := ⋯ }" state_after="no goals" tactic="simp [Array.findSome?_map, Function.comp_def]">
                    <AtomNode start="(226, 3)" end="(226, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(226, 8)" end="(226, 48)">
                      <AtomNode start="(226, 8)" end="(226, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(226, 9)" end="(226, 47)">
                        <OtherNode start="(226, 9)" end="(226, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(226, 9)" end="(226, 28)" leading="" trailing="" raw_val="Array.findSome?_map" val="Array.findSome?_map" full_name="Array.findSome?_map" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean"/>
                        </OtherNode>
                        <AtomNode start="(226, 28)" end="(226, 29)" leading="" trailing=" " val=","/>
                        <OtherNode start="(226, 30)" end="(226, 47)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(226, 30)" end="(226, 47)" leading="" trailing="" raw_val="Function.comp_def" val="Function.comp_def" full_name="Function.comp_def" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(226, 47)" end="(226, 48)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(228, 1)" end="(230, 7)" name="find?_flatten_eq_none_iff" full_name="Vector.find?_flatten_eq_none_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(228, 1)" end="(230, 7)" name="find?_flatten_eq_none_iff" full_name="Vector.find?_flatten_eq_none_iff" _is_private_decl="False">
        <AtomNode start="(228, 1)" end="(228, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(228, 9)" end="(228, 34)">
          <IdentNode start="(228, 9)" end="(228, 34)" leading="" trailing=" " raw_val="find?_flatten_eq_none_iff" val="find?_flatten_eq_none_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(228, 35)" end="(229, 58)">
          <NullNode start="(228, 35)" end="(228, 78)">
            <OtherNode start="(228, 35)" end="(228, 63)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(228, 35)" end="(228, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(228, 36)" end="(228, 38)">
                <IdentNode start="(228, 36)" end="(228, 38)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(228, 39)" end="(228, 62)">
                <AtomNode start="(228, 39)" end="(228, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(228, 41)" end="(228, 62)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(228, 41)" end="(228, 47)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(228, 48)" end="(228, 62)">
                    <OtherNode start="(228, 48)" end="(228, 60)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(228, 48)" end="(228, 49)" leading="" trailing="" val="("/>
                      <OtherNode start="(228, 49)" end="(228, 59)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(228, 49)" end="(228, 55)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                        <NullNode start="(228, 56)" end="(228, 59)">
                          <IdentNode start="(228, 56)" end="(228, 57)" leading="" trailing=" " raw_val="α" val="α"/>
                          <IdentNode start="(228, 58)" end="(228, 59)" leading="" trailing="" raw_val="m" val="m"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(228, 59)" end="(228, 60)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <IdentNode start="(228, 61)" end="(228, 62)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(228, 62)" end="(228, 63)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(228, 64)" end="(228, 78)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(228, 64)" end="(228, 65)" leading="" trailing="" val="{"/>
              <NullNode start="(228, 65)" end="(228, 66)">
                <IdentNode start="(228, 65)" end="(228, 66)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(228, 67)" end="(228, 77)">
                <AtomNode start="(228, 67)" end="(228, 68)" leading="" trailing=" " val=":"/>
                <OtherNode start="(228, 69)" end="(228, 77)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(228, 69)" end="(228, 70)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(228, 71)" end="(228, 72)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(228, 73)" end="(228, 77)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(228, 77)" end="(228, 78)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(228, 79)" end="(229, 58)">
            <AtomNode start="(228, 79)" end="(228, 80)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(229, 5)" end="(229, 58)" kind="«term_↔_»">
              <OtherNode start="(229, 5)" end="(229, 30)" kind="«term_=_»">
                <OtherNode start="(229, 5)" end="(229, 23)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(229, 5)" end="(229, 21)" leading="" trailing=" " raw_val="xs.flatten.find?" val="xs.flatten.find?"/>
                  <NullNode start="(229, 22)" end="(229, 23)">
                    <IdentNode start="(229, 22)" end="(229, 23)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(229, 24)" end="(229, 25)" leading="" trailing=" " val="="/>
                <IdentNode start="(229, 26)" end="(229, 30)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(229, 31)" end="(229, 32)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(229, 33)" end="(229, 58)" kind="Lean.«term∀__,_»">
                <AtomNode start="(229, 33)" end="(229, 34)" leading="" trailing=" " val="∀"/>
                <LeanBinderidentNode start="(229, 35)" end="(229, 37)">
                  <IdentNode start="(229, 35)" end="(229, 37)" leading="" trailing=" " raw_val="ys" val="ys"/>
                </LeanBinderidentNode>
                <OtherNode start="(229, 38)" end="(229, 42)" kind="Lean.«binderTerm∈_»">
                  <AtomNode start="(229, 38)" end="(229, 39)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(229, 40)" end="(229, 42)" leading="" trailing="" raw_val="xs" val="xs"/>
                </OtherNode>
                <AtomNode start="(229, 42)" end="(229, 43)" leading="" trailing=" " val=","/>
                <OtherNode start="(229, 44)" end="(229, 58)" kind="Lean.«term∀__,_»">
                  <AtomNode start="(229, 44)" end="(229, 45)" leading="" trailing=" " val="∀"/>
                  <LeanBinderidentNode start="(229, 46)" end="(229, 47)">
                    <IdentNode start="(229, 46)" end="(229, 47)" leading="" trailing=" " raw_val="x" val="x"/>
                  </LeanBinderidentNode>
                  <OtherNode start="(229, 48)" end="(229, 52)" kind="Lean.«binderTerm∈_»">
                    <AtomNode start="(229, 48)" end="(229, 49)" leading="" trailing=" " val="∈"/>
                    <IdentNode start="(229, 50)" end="(229, 52)" leading="" trailing="" raw_val="ys" val="ys"/>
                  </OtherNode>
                  <AtomNode start="(229, 52)" end="(229, 53)" leading="" trailing=" " val=","/>
                  <OtherNode start="(229, 54)" end="(229, 58)" kind="term!_">
                    <AtomNode start="(229, 54)" end="(229, 55)" leading="" trailing="" val="!"/>
                    <OtherNode start="(229, 55)" end="(229, 58)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(229, 55)" end="(229, 56)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(229, 57)" end="(229, 58)">
                        <IdentNode start="(229, 57)" end="(229, 58)" leading="" trailing=" " raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(229, 59)" end="(230, 7)">
          <AtomNode start="(229, 59)" end="(229, 61)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(229, 62)" end="(230, 7)">
            <AtomNode start="(229, 62)" end="(229, 64)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(230, 3)" end="(230, 7)">
              <TacticTacticseq1IndentedNode start="(230, 3)" end="(230, 7)">
                <NullNode start="(230, 3)" end="(230, 7)">
                  <OtherNode start="(230, 3)" end="(230, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type&#10;m n : Nat&#10;xs : Vector (Vector α m) n&#10;p : α → Bool&#10;⊢ find? p xs.flatten = none ↔ ∀ (ys : Vector α m), ys ∈ xs → ∀ (x : α), x ∈ ys → (!p x) = true" state_after="no goals" tactic="simp">
                    <AtomNode start="(230, 3)" end="(230, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(232, 1)" end="(235, 52)" name="find?_flatMap" full_name="Vector.find?_flatMap">
      <CommandDeclmodifiersNode start="(232, 1)" end="(232, 8)">
        <NullNode/>
        <NullNode start="(232, 1)" end="(232, 8)">
          <OtherNode start="(232, 1)" end="(232, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(232, 1)" end="(232, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(232, 3)" end="(232, 7)">
              <OtherNode start="(232, 3)" end="(232, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(232, 3)" end="(232, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(232, 3)" end="(232, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(232, 7)" end="(232, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(232, 9)" end="(235, 52)" name="find?_flatMap" full_name="Vector.find?_flatMap" _is_private_decl="False">
        <AtomNode start="(232, 9)" end="(232, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(232, 17)" end="(232, 30)">
          <IdentNode start="(232, 17)" end="(232, 30)" leading="" trailing=" " raw_val="find?_flatMap" val="find?_flatMap"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(232, 31)" end="(233, 67)">
          <NullNode start="(232, 31)" end="(232, 84)">
            <OtherNode start="(232, 31)" end="(232, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(232, 31)" end="(232, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(232, 32)" end="(232, 34)">
                <IdentNode start="(232, 32)" end="(232, 34)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(232, 35)" end="(232, 47)">
                <AtomNode start="(232, 35)" end="(232, 36)" leading="" trailing=" " val=":"/>
                <OtherNode start="(232, 37)" end="(232, 47)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(232, 37)" end="(232, 43)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(232, 44)" end="(232, 47)">
                    <IdentNode start="(232, 44)" end="(232, 45)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(232, 46)" end="(232, 47)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(232, 47)" end="(232, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(232, 49)" end="(232, 69)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(232, 49)" end="(232, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(232, 50)" end="(232, 51)">
                <IdentNode start="(232, 50)" end="(232, 51)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(232, 52)" end="(232, 68)">
                <AtomNode start="(232, 52)" end="(232, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(232, 54)" end="(232, 68)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(232, 54)" end="(232, 55)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(232, 56)" end="(232, 57)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(232, 58)" end="(232, 68)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(232, 58)" end="(232, 64)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                    <NullNode start="(232, 65)" end="(232, 68)">
                      <IdentNode start="(232, 65)" end="(232, 66)" leading="" trailing=" " raw_val="β" val="β"/>
                      <IdentNode start="(232, 67)" end="(232, 68)" leading="" trailing="" raw_val="m" val="m"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(232, 68)" end="(232, 69)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(232, 70)" end="(232, 84)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(232, 70)" end="(232, 71)" leading="" trailing="" val="{"/>
              <NullNode start="(232, 71)" end="(232, 72)">
                <IdentNode start="(232, 71)" end="(232, 72)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(232, 73)" end="(232, 83)">
                <AtomNode start="(232, 73)" end="(232, 74)" leading="" trailing=" " val=":"/>
                <OtherNode start="(232, 75)" end="(232, 83)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(232, 75)" end="(232, 76)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(232, 77)" end="(232, 78)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(232, 79)" end="(232, 83)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(232, 83)" end="(232, 84)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(232, 85)" end="(233, 67)">
            <AtomNode start="(232, 85)" end="(232, 86)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(233, 5)" end="(233, 67)" kind="«term_=_»">
              <OtherNode start="(233, 5)" end="(233, 27)" kind="Lean.Parser.Term.app">
                <OtherNode start="(233, 5)" end="(233, 25)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(233, 5)" end="(233, 19)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(233, 5)" end="(233, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(233, 6)" end="(233, 18)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(233, 6)" end="(233, 16)" leading="" trailing=" " raw_val="xs.flatMap" val="xs.flatMap"/>
                      <NullNode start="(233, 17)" end="(233, 18)">
                        <IdentNode start="(233, 17)" end="(233, 18)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(233, 18)" end="(233, 19)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(233, 19)" end="(233, 20)" leading="" trailing="" val="."/>
                  <IdentNode start="(233, 20)" end="(233, 25)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Vector.find?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                </OtherNode>
                <NullNode start="(233, 26)" end="(233, 27)">
                  <IdentNode start="(233, 26)" end="(233, 27)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(233, 28)" end="(233, 29)" leading="" trailing=" " val="="/>
              <OtherNode start="(233, 30)" end="(233, 67)" kind="Lean.Parser.Term.app">
                <IdentNode start="(233, 30)" end="(233, 42)" leading="" trailing=" " raw_val="xs.findSome?" val="xs.findSome?"/>
                <NullNode start="(233, 43)" end="(233, 67)">
                  <OtherNode start="(233, 43)" end="(233, 67)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(233, 43)" end="(233, 44)" leading="" trailing="" val="("/>
                    <OtherNode start="(233, 44)" end="(233, 66)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(233, 44)" end="(233, 47)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(233, 48)" end="(233, 66)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(233, 48)" end="(233, 49)">
                          <IdentNode start="(233, 48)" end="(233, 49)" leading="" trailing=" " raw_val="x" val="x"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(233, 50)" end="(233, 52)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(233, 53)" end="(233, 66)" kind="Lean.Parser.Term.app">
                          <OtherNode start="(233, 53)" end="(233, 64)" kind="Lean.Parser.Term.proj">
                            <OtherNode start="(233, 53)" end="(233, 58)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(233, 53)" end="(233, 54)" leading="" trailing="" val="("/>
                              <OtherNode start="(233, 54)" end="(233, 57)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(233, 54)" end="(233, 55)" leading="" trailing=" " raw_val="f" val="f"/>
                                <NullNode start="(233, 56)" end="(233, 57)">
                                  <IdentNode start="(233, 56)" end="(233, 57)" leading="" trailing="" raw_val="x" val="x"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(233, 57)" end="(233, 58)" leading="" trailing="" val=")"/>
                            </OtherNode>
                            <AtomNode start="(233, 58)" end="(233, 59)" leading="" trailing="" val="."/>
                            <IdentNode start="(233, 59)" end="(233, 64)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Vector.find?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                          </OtherNode>
                          <NullNode start="(233, 65)" end="(233, 66)">
                            <IdentNode start="(233, 65)" end="(233, 66)" leading="" trailing="" raw_val="p" val="p"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(233, 66)" end="(233, 67)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(233, 68)" end="(235, 52)">
          <AtomNode start="(233, 68)" end="(233, 70)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(233, 71)" end="(235, 52)">
            <AtomNode start="(233, 71)" end="(233, 73)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(234, 3)" end="(235, 52)">
              <TacticTacticseq1IndentedNode start="(234, 3)" end="(235, 52)">
                <NullNode start="(234, 3)" end="(235, 52)">
                  <OtherNode start="(234, 3)" end="(234, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;n : Nat&#10;β : Type&#10;m : Nat&#10;xs : Vector α n&#10;f : α → Vector β m&#10;p : β → Bool&#10;⊢ find? p (xs.flatMap f) = findSome? (fun x =&amp;gt; find? p (f x)) xs" state_after="case mk&#10;α : Type u_1&#10;n : Nat&#10;β : Type&#10;m : Nat&#10;f : α → Vector β m&#10;p : β → Bool&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n&#10;⊢ find? p ({ toArray := toArray✝, size_toArray := size_toArray✝ }.flatMap f) =&#10;    findSome? (fun x =&amp;gt; find? p (f x)) { toArray := toArray✝, size_toArray := size_toArray✝ }" tactic="cases xs">
                    <AtomNode start="(234, 3)" end="(234, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(234, 9)" end="(234, 11)">
                      <OtherNode start="(234, 9)" end="(234, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(234, 9)" end="(234, 11)" leading="" trailing="&#10;  " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(235, 3)" end="(235, 52)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;n : Nat&#10;β : Type&#10;m : Nat&#10;f : α → Vector β m&#10;p : β → Bool&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n&#10;⊢ find? p ({ toArray := toArray✝, size_toArray := size_toArray✝ }.flatMap f) =&#10;    findSome? (fun x =&amp;gt; find? p (f x)) { toArray := toArray✝, size_toArray := size_toArray✝ }" state_after="no goals" tactic="simp [Array.find?_flatMap, Array.flatMap_toArray]">
                    <AtomNode start="(235, 3)" end="(235, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(235, 8)" end="(235, 52)">
                      <AtomNode start="(235, 8)" end="(235, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(235, 9)" end="(235, 51)">
                        <OtherNode start="(235, 9)" end="(235, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(235, 9)" end="(235, 28)" leading="" trailing="" raw_val="Array.find?_flatMap" val="Array.find?_flatMap" full_name="Array.find?_flatMap" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean"/>
                        </OtherNode>
                        <AtomNode start="(235, 28)" end="(235, 29)" leading="" trailing=" " val=","/>
                        <OtherNode start="(235, 30)" end="(235, 51)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(235, 30)" end="(235, 51)" leading="" trailing="" raw_val="Array.flatMap_toArray" val="Array.flatMap_toArray" full_name="Array.flatMap_toArray" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(235, 51)" end="(235, 52)" leading="" trailing="&#10;&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(238, 1)" end="(240, 7)" name="find?_flatMap_eq_none_iff" full_name="Vector.find?_flatMap_eq_none_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(238, 1)" end="(240, 7)" name="find?_flatMap_eq_none_iff" full_name="Vector.find?_flatMap_eq_none_iff" _is_private_decl="False">
        <AtomNode start="(238, 1)" end="(238, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(238, 9)" end="(238, 34)">
          <IdentNode start="(238, 9)" end="(238, 34)" leading="" trailing=" " raw_val="find?_flatMap_eq_none_iff" val="find?_flatMap_eq_none_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(238, 35)" end="(239, 62)">
          <NullNode start="(238, 35)" end="(238, 88)">
            <OtherNode start="(238, 35)" end="(238, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(238, 35)" end="(238, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(238, 36)" end="(238, 38)">
                <IdentNode start="(238, 36)" end="(238, 38)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(238, 39)" end="(238, 51)">
                <AtomNode start="(238, 39)" end="(238, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(238, 41)" end="(238, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(238, 41)" end="(238, 47)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(238, 48)" end="(238, 51)">
                    <IdentNode start="(238, 48)" end="(238, 49)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(238, 50)" end="(238, 51)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(238, 51)" end="(238, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(238, 53)" end="(238, 73)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(238, 53)" end="(238, 54)" leading="" trailing="" val="{"/>
              <NullNode start="(238, 54)" end="(238, 55)">
                <IdentNode start="(238, 54)" end="(238, 55)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(238, 56)" end="(238, 72)">
                <AtomNode start="(238, 56)" end="(238, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(238, 58)" end="(238, 72)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(238, 58)" end="(238, 59)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(238, 60)" end="(238, 61)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(238, 62)" end="(238, 72)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(238, 62)" end="(238, 68)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                    <NullNode start="(238, 69)" end="(238, 72)">
                      <IdentNode start="(238, 69)" end="(238, 70)" leading="" trailing=" " raw_val="β" val="β"/>
                      <IdentNode start="(238, 71)" end="(238, 72)" leading="" trailing="" raw_val="m" val="m"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(238, 72)" end="(238, 73)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(238, 74)" end="(238, 88)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(238, 74)" end="(238, 75)" leading="" trailing="" val="{"/>
              <NullNode start="(238, 75)" end="(238, 76)">
                <IdentNode start="(238, 75)" end="(238, 76)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(238, 77)" end="(238, 87)">
                <AtomNode start="(238, 77)" end="(238, 78)" leading="" trailing=" " val=":"/>
                <OtherNode start="(238, 79)" end="(238, 87)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(238, 79)" end="(238, 80)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(238, 81)" end="(238, 82)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(238, 83)" end="(238, 87)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(238, 87)" end="(238, 88)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(238, 89)" end="(239, 62)">
            <AtomNode start="(238, 89)" end="(238, 90)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(239, 5)" end="(239, 62)" kind="«term_↔_»">
              <OtherNode start="(239, 5)" end="(239, 34)" kind="«term_=_»">
                <OtherNode start="(239, 5)" end="(239, 27)" kind="Lean.Parser.Term.app">
                  <OtherNode start="(239, 5)" end="(239, 25)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(239, 5)" end="(239, 19)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(239, 5)" end="(239, 6)" leading="" trailing="" val="("/>
                      <OtherNode start="(239, 6)" end="(239, 18)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(239, 6)" end="(239, 16)" leading="" trailing=" " raw_val="xs.flatMap" val="xs.flatMap"/>
                        <NullNode start="(239, 17)" end="(239, 18)">
                          <IdentNode start="(239, 17)" end="(239, 18)" leading="" trailing="" raw_val="f" val="f"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(239, 18)" end="(239, 19)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(239, 19)" end="(239, 20)" leading="" trailing="" val="."/>
                    <IdentNode start="(239, 20)" end="(239, 25)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Vector.find?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  </OtherNode>
                  <NullNode start="(239, 26)" end="(239, 27)">
                    <IdentNode start="(239, 26)" end="(239, 27)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(239, 28)" end="(239, 29)" leading="" trailing=" " val="="/>
                <IdentNode start="(239, 30)" end="(239, 34)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(239, 35)" end="(239, 36)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(239, 37)" end="(239, 62)" kind="Lean.«term∀__,_»">
                <AtomNode start="(239, 37)" end="(239, 38)" leading="" trailing=" " val="∀"/>
                <LeanBinderidentNode start="(239, 39)" end="(239, 40)">
                  <IdentNode start="(239, 39)" end="(239, 40)" leading="" trailing=" " raw_val="x" val="x"/>
                </LeanBinderidentNode>
                <OtherNode start="(239, 41)" end="(239, 45)" kind="Lean.«binderTerm∈_»">
                  <AtomNode start="(239, 41)" end="(239, 42)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(239, 43)" end="(239, 45)" leading="" trailing="" raw_val="xs" val="xs"/>
                </OtherNode>
                <AtomNode start="(239, 45)" end="(239, 46)" leading="" trailing=" " val=","/>
                <OtherNode start="(239, 47)" end="(239, 62)" kind="Lean.«term∀__,_»">
                  <AtomNode start="(239, 47)" end="(239, 48)" leading="" trailing=" " val="∀"/>
                  <LeanBinderidentNode start="(239, 49)" end="(239, 50)">
                    <IdentNode start="(239, 49)" end="(239, 50)" leading="" trailing=" " raw_val="y" val="y"/>
                  </LeanBinderidentNode>
                  <OtherNode start="(239, 51)" end="(239, 56)" kind="Lean.«binderTerm∈_»">
                    <AtomNode start="(239, 51)" end="(239, 52)" leading="" trailing=" " val="∈"/>
                    <OtherNode start="(239, 53)" end="(239, 56)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(239, 53)" end="(239, 54)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(239, 55)" end="(239, 56)">
                        <IdentNode start="(239, 55)" end="(239, 56)" leading="" trailing="" raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(239, 56)" end="(239, 57)" leading="" trailing=" " val=","/>
                  <OtherNode start="(239, 58)" end="(239, 62)" kind="term!_">
                    <AtomNode start="(239, 58)" end="(239, 59)" leading="" trailing="" val="!"/>
                    <OtherNode start="(239, 59)" end="(239, 62)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(239, 59)" end="(239, 60)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(239, 61)" end="(239, 62)">
                        <IdentNode start="(239, 61)" end="(239, 62)" leading="" trailing=" " raw_val="y" val="y"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(239, 63)" end="(240, 7)">
          <AtomNode start="(239, 63)" end="(239, 65)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(239, 66)" end="(240, 7)">
            <AtomNode start="(239, 66)" end="(239, 68)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(240, 3)" end="(240, 7)">
              <TacticTacticseq1IndentedNode start="(240, 3)" end="(240, 7)">
                <NullNode start="(240, 3)" end="(240, 7)">
                  <OtherNode start="(240, 3)" end="(240, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;n : Nat&#10;β : Type&#10;m : Nat&#10;xs : Vector α n&#10;f : α → Vector β m&#10;p : β → Bool&#10;⊢ find? p (xs.flatMap f) = none ↔ ∀ (x : α), x ∈ xs → ∀ (y : β), y ∈ f x → (!p y) = true" state_after="no goals" tactic="simp">
                    <AtomNode start="(240, 3)" end="(240, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(242, 1)" end="(244, 66)" name="find?_replicate" full_name="Vector.find?_replicate">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(242, 1)" end="(244, 66)" name="find?_replicate" full_name="Vector.find?_replicate" _is_private_decl="False">
        <AtomNode start="(242, 1)" end="(242, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(242, 9)" end="(242, 24)">
          <IdentNode start="(242, 9)" end="(242, 24)" leading="" trailing=" " raw_val="find?_replicate" val="find?_replicate"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(242, 25)" end="(243, 83)">
          <NullNode/>
          <TermTypespecNode start="(242, 25)" end="(243, 83)">
            <AtomNode start="(242, 25)" end="(242, 26)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(243, 5)" end="(243, 83)" kind="«term_=_»">
              <OtherNode start="(243, 5)" end="(243, 28)" kind="Lean.Parser.Term.app">
                <IdentNode start="(243, 5)" end="(243, 10)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Vector.find?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(243, 11)" end="(243, 28)">
                  <IdentNode start="(243, 11)" end="(243, 12)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(243, 13)" end="(243, 28)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(243, 13)" end="(243, 14)" leading="" trailing="" val="("/>
                    <OtherNode start="(243, 14)" end="(243, 27)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(243, 14)" end="(243, 23)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Vector.replicate" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                      <NullNode start="(243, 24)" end="(243, 27)">
                        <IdentNode start="(243, 24)" end="(243, 25)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(243, 26)" end="(243, 27)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(243, 27)" end="(243, 28)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(243, 29)" end="(243, 30)" leading="" trailing=" " val="="/>
              <OtherNode start="(243, 31)" end="(243, 83)" kind="termIfThenElse">
                <AtomNode start="(243, 31)" end="(243, 33)" leading="" trailing=" " val="if"/>
                <OtherNode start="(243, 34)" end="(243, 39)" kind="«term_=_»">
                  <IdentNode start="(243, 34)" end="(243, 35)" leading="" trailing=" " raw_val="n" val="n"/>
                  <AtomNode start="(243, 36)" end="(243, 37)" leading="" trailing=" " val="="/>
                  <OtherNode start="(243, 38)" end="(243, 39)" kind="num">
                    <AtomNode start="(243, 38)" end="(243, 39)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(243, 40)" end="(243, 44)" leading="" trailing=" " val="then"/>
                <IdentNode start="(243, 45)" end="(243, 49)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <AtomNode start="(243, 50)" end="(243, 54)" leading="" trailing=" " val="else"/>
                <OtherNode start="(243, 55)" end="(243, 83)" kind="termIfThenElse">
                  <AtomNode start="(243, 55)" end="(243, 57)" leading="" trailing=" " val="if"/>
                  <OtherNode start="(243, 58)" end="(243, 61)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(243, 58)" end="(243, 59)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(243, 60)" end="(243, 61)">
                      <IdentNode start="(243, 60)" end="(243, 61)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(243, 62)" end="(243, 66)" leading="" trailing=" " val="then"/>
                  <OtherNode start="(243, 67)" end="(243, 73)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(243, 67)" end="(243, 71)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(243, 72)" end="(243, 73)">
                      <IdentNode start="(243, 72)" end="(243, 73)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(243, 74)" end="(243, 78)" leading="" trailing=" " val="else"/>
                  <IdentNode start="(243, 79)" end="(243, 83)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(243, 84)" end="(244, 66)">
          <AtomNode start="(243, 84)" end="(243, 86)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(243, 87)" end="(244, 66)">
            <AtomNode start="(243, 87)" end="(243, 89)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(244, 3)" end="(244, 66)">
              <TacticTacticseq1IndentedNode start="(244, 3)" end="(244, 66)">
                <NullNode start="(244, 3)" end="(244, 66)">
                  <OtherNode start="(244, 3)" end="(244, 66)" kind="Lean.Parser.Tactic.rwSeq" state_before="α✝ : Type&#10;p : α✝ → Bool&#10;n : Nat&#10;a : α✝&#10;⊢ find? p (replicate n a) = if n = 0 then none else if p a = true then some a else none" state_after="no goals" tactic="rw [replicate_eq_mk_replicate, find?_mk, Array.find?_replicate]">
                    <AtomNode start="(244, 3)" end="(244, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(244, 6)" end="(244, 66)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(244, 6)" end="(244, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(244, 7)" end="(244, 65)">
                        <OtherNode start="(244, 7)" end="(244, 32)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(244, 7)" end="(244, 32)" leading="" trailing="" raw_val="replicate_eq_mk_replicate" val="replicate_eq_mk_replicate" full_name="Vector.replicate_eq_mk_replicate" mod_name="Init.Data.Vector.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(244, 32)" end="(244, 33)" leading="" trailing=" " val=","/>
                        <OtherNode start="(244, 34)" end="(244, 42)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(244, 34)" end="(244, 42)" leading="" trailing="" raw_val="find?_mk" val="find?_mk" full_name="Vector.find?_mk" mod_name="Init.Data.Vector.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(244, 42)" end="(244, 43)" leading="" trailing=" " val=","/>
                        <OtherNode start="(244, 44)" end="(244, 65)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(244, 44)" end="(244, 65)" leading="" trailing="" raw_val="Array.find?_replicate" val="Array.find?_replicate" full_name="Array.find?_replicate" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(244, 65)" end="(244, 66)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(246, 1)" end="(247, 42)" name="find?_mkVector" full_name="Vector.find?_mkVector">
      <CommandDeclmodifiersNode start="(246, 1)" end="(246, 54)">
        <NullNode/>
        <NullNode start="(246, 1)" end="(246, 54)">
          <OtherNode start="(246, 1)" end="(246, 54)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(246, 1)" end="(246, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(246, 3)" end="(246, 53)">
              <OtherNode start="(246, 3)" end="(246, 53)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(246, 3)" end="(246, 53)" kind="Lean.deprecated">
                  <AtomNode start="(246, 3)" end="(246, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(246, 14)" end="(246, 29)">
                    <IdentNode start="(246, 14)" end="(246, 29)" leading="" trailing=" " raw_val="find?_replicate" val="find?_replicate" full_name="Vector.find?_replicate" mod_name="Init.Data.Vector.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Find.lean" def_start="(242, 9)" def_end="(242, 24)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(246, 30)" end="(246, 53)">
                    <AtomNode start="(246, 30)" end="(246, 31)" leading="" trailing="" val="("/>
                    <AtomNode start="(246, 31)" end="(246, 36)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(246, 37)" end="(246, 39)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(246, 40)" end="(246, 52)" kind="str">
                      <AtomNode start="(246, 40)" end="(246, 52)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(246, 52)" end="(246, 53)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(246, 53)" end="(246, 54)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(247, 1)" end="(247, 42)" name="find?_mkVector">
        <AtomNode start="(247, 1)" end="(247, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(247, 8)" end="(247, 22)">
          <IdentNode start="(247, 8)" end="(247, 22)" leading="" trailing=" " raw_val="find?_mkVector" val="find?_mkVector"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(247, 23)" end="(247, 42)">
          <AtomNode start="(247, 23)" end="(247, 25)" leading="" trailing=" " val=":="/>
          <OtherNode start="(247, 26)" end="(247, 42)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(247, 26)" end="(247, 27)" leading="" trailing="" val="@"/>
            <IdentNode start="(247, 27)" end="(247, 42)" leading="" trailing="&#10;&#10;" raw_val="find?_replicate" val="find?_replicate" full_name="Vector.find?_replicate" mod_name="Init.Data.Vector.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Find.lean" def_start="(242, 9)" def_end="(242, 24)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(249, 1)" end="(251, 41)" name="find?_replicate_of_size_pos" full_name="Vector.find?_replicate_of_size_pos">
      <CommandDeclmodifiersNode start="(249, 1)" end="(249, 8)">
        <NullNode/>
        <NullNode start="(249, 1)" end="(249, 8)">
          <OtherNode start="(249, 1)" end="(249, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(249, 1)" end="(249, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(249, 3)" end="(249, 7)">
              <OtherNode start="(249, 3)" end="(249, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(249, 3)" end="(249, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(249, 3)" end="(249, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(249, 7)" end="(249, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(249, 9)" end="(251, 41)" name="find?_replicate_of_size_pos" full_name="Vector.find?_replicate_of_size_pos" _is_private_decl="False">
        <AtomNode start="(249, 9)" end="(249, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(249, 17)" end="(249, 44)">
          <IdentNode start="(249, 17)" end="(249, 44)" leading="" trailing=" " raw_val="find?_replicate_of_size_pos" val="find?_replicate_of_size_pos"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(249, 45)" end="(250, 59)">
          <NullNode start="(249, 45)" end="(249, 56)">
            <TermExplicitbinderNode start="(249, 45)" end="(249, 56)">
              <AtomNode start="(249, 45)" end="(249, 46)" leading="" trailing="" val="("/>
              <NullNode start="(249, 46)" end="(249, 47)">
                <IdentNode start="(249, 46)" end="(249, 47)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(249, 48)" end="(249, 55)">
                <AtomNode start="(249, 48)" end="(249, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(249, 50)" end="(249, 55)" kind="«term_&amp;lt;_»">
                  <OtherNode start="(249, 50)" end="(249, 51)" kind="num">
                    <AtomNode start="(249, 50)" end="(249, 51)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                  <AtomNode start="(249, 52)" end="(249, 53)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(249, 54)" end="(249, 55)" leading="" trailing="" raw_val="n" val="n"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(249, 55)" end="(249, 56)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(249, 57)" end="(250, 59)">
            <AtomNode start="(249, 57)" end="(249, 58)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(250, 5)" end="(250, 59)" kind="«term_=_»">
              <OtherNode start="(250, 5)" end="(250, 28)" kind="Lean.Parser.Term.app">
                <IdentNode start="(250, 5)" end="(250, 10)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Vector.find?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(250, 11)" end="(250, 28)">
                  <IdentNode start="(250, 11)" end="(250, 12)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(250, 13)" end="(250, 28)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(250, 13)" end="(250, 14)" leading="" trailing="" val="("/>
                    <OtherNode start="(250, 14)" end="(250, 27)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(250, 14)" end="(250, 23)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Vector.replicate" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                      <NullNode start="(250, 24)" end="(250, 27)">
                        <IdentNode start="(250, 24)" end="(250, 25)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(250, 26)" end="(250, 27)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(250, 27)" end="(250, 28)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(250, 29)" end="(250, 30)" leading="" trailing=" " val="="/>
              <OtherNode start="(250, 31)" end="(250, 59)" kind="termIfThenElse">
                <AtomNode start="(250, 31)" end="(250, 33)" leading="" trailing=" " val="if"/>
                <OtherNode start="(250, 34)" end="(250, 37)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(250, 34)" end="(250, 35)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(250, 36)" end="(250, 37)">
                    <IdentNode start="(250, 36)" end="(250, 37)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(250, 38)" end="(250, 42)" leading="" trailing=" " val="then"/>
                <OtherNode start="(250, 43)" end="(250, 49)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(250, 43)" end="(250, 47)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(250, 48)" end="(250, 49)">
                    <IdentNode start="(250, 48)" end="(250, 49)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(250, 50)" end="(250, 54)" leading="" trailing=" " val="else"/>
                <IdentNode start="(250, 55)" end="(250, 59)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(250, 60)" end="(251, 41)">
          <AtomNode start="(250, 60)" end="(250, 62)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(250, 63)" end="(251, 41)">
            <AtomNode start="(250, 63)" end="(250, 65)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(251, 3)" end="(251, 41)">
              <TacticTacticseq1IndentedNode start="(251, 3)" end="(251, 41)">
                <NullNode start="(251, 3)" end="(251, 41)">
                  <OtherNode start="(251, 3)" end="(251, 41)" kind="Lean.Parser.Tactic.simp" state_before="n : Nat&#10;α✝ : Type&#10;p : α✝ → Bool&#10;a : α✝&#10;h : 0 &amp;lt; n&#10;⊢ find? p (replicate n a) = if p a = true then some a else none" state_after="no goals" tactic="simp [find?_replicate, Nat.ne_of_gt h]">
                    <AtomNode start="(251, 3)" end="(251, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(251, 8)" end="(251, 41)">
                      <AtomNode start="(251, 8)" end="(251, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(251, 9)" end="(251, 40)">
                        <OtherNode start="(251, 9)" end="(251, 24)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(251, 9)" end="(251, 24)" leading="" trailing="" raw_val="find?_replicate" val="find?_replicate" full_name="Vector.find?_replicate" mod_name="Init.Data.Vector.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Find.lean" def_start="(242, 9)" def_end="(242, 24)"/>
                        </OtherNode>
                        <AtomNode start="(251, 24)" end="(251, 25)" leading="" trailing=" " val=","/>
                        <OtherNode start="(251, 26)" end="(251, 40)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <OtherNode start="(251, 26)" end="(251, 40)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(251, 26)" end="(251, 38)" leading="" trailing=" " raw_val="Nat.ne_of_gt" val="Nat.ne_of_gt" full_name="Nat.ne_of_gt" mod_name="Init.Data.Nat.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Nat/Basic.lean"/>
                            <NullNode start="(251, 39)" end="(251, 40)">
                              <IdentNode start="(251, 39)" end="(251, 40)" leading="" trailing="" raw_val="h" val="h"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(251, 40)" end="(251, 41)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(253, 1)" end="(254, 68)" name="find?_mkVector_of_length_pos" full_name="Vector.find?_mkVector_of_length_pos">
      <CommandDeclmodifiersNode start="(253, 1)" end="(253, 66)">
        <NullNode/>
        <NullNode start="(253, 1)" end="(253, 66)">
          <OtherNode start="(253, 1)" end="(253, 66)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(253, 1)" end="(253, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(253, 3)" end="(253, 65)">
              <OtherNode start="(253, 3)" end="(253, 65)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(253, 3)" end="(253, 65)" kind="Lean.deprecated">
                  <AtomNode start="(253, 3)" end="(253, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(253, 14)" end="(253, 41)">
                    <IdentNode start="(253, 14)" end="(253, 41)" leading="" trailing=" " raw_val="find?_replicate_of_size_pos" val="find?_replicate_of_size_pos" full_name="Vector.find?_replicate_of_size_pos" mod_name="Init.Data.Vector.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Find.lean" def_start="(249, 17)" def_end="(249, 44)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(253, 42)" end="(253, 65)">
                    <AtomNode start="(253, 42)" end="(253, 43)" leading="" trailing="" val="("/>
                    <AtomNode start="(253, 43)" end="(253, 48)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(253, 49)" end="(253, 51)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(253, 52)" end="(253, 64)" kind="str">
                      <AtomNode start="(253, 52)" end="(253, 64)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(253, 64)" end="(253, 65)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(253, 65)" end="(253, 66)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(254, 1)" end="(254, 68)" name="find?_mkVector_of_length_pos">
        <AtomNode start="(254, 1)" end="(254, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(254, 8)" end="(254, 36)">
          <IdentNode start="(254, 8)" end="(254, 36)" leading="" trailing=" " raw_val="find?_mkVector_of_length_pos" val="find?_mkVector_of_length_pos"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(254, 37)" end="(254, 68)">
          <AtomNode start="(254, 37)" end="(254, 39)" leading="" trailing=" " val=":="/>
          <OtherNode start="(254, 40)" end="(254, 68)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(254, 40)" end="(254, 41)" leading="" trailing="" val="@"/>
            <IdentNode start="(254, 41)" end="(254, 68)" leading="" trailing="&#10;&#10;" raw_val="find?_replicate_of_size_pos" val="find?_replicate_of_size_pos" full_name="Vector.find?_replicate_of_size_pos" mod_name="Init.Data.Vector.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Find.lean" def_start="(249, 17)" def_end="(249, 44)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(256, 1)" end="(258, 28)" name="find?_replicate_of_pos" full_name="Vector.find?_replicate_of_pos">
      <CommandDeclmodifiersNode start="(256, 1)" end="(256, 8)">
        <NullNode/>
        <NullNode start="(256, 1)" end="(256, 8)">
          <OtherNode start="(256, 1)" end="(256, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(256, 1)" end="(256, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(256, 3)" end="(256, 7)">
              <OtherNode start="(256, 3)" end="(256, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(256, 3)" end="(256, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(256, 3)" end="(256, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(256, 7)" end="(256, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(256, 9)" end="(258, 28)" name="find?_replicate_of_pos" full_name="Vector.find?_replicate_of_pos" _is_private_decl="False">
        <AtomNode start="(256, 9)" end="(256, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(256, 17)" end="(256, 39)">
          <IdentNode start="(256, 17)" end="(256, 39)" leading="" trailing=" " raw_val="find?_replicate_of_pos" val="find?_replicate_of_pos"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(256, 40)" end="(257, 61)">
          <NullNode start="(256, 40)" end="(256, 49)">
            <TermExplicitbinderNode start="(256, 40)" end="(256, 49)">
              <AtomNode start="(256, 40)" end="(256, 41)" leading="" trailing="" val="("/>
              <NullNode start="(256, 41)" end="(256, 42)">
                <IdentNode start="(256, 41)" end="(256, 42)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(256, 43)" end="(256, 48)">
                <AtomNode start="(256, 43)" end="(256, 44)" leading="" trailing=" " val=":"/>
                <OtherNode start="(256, 45)" end="(256, 48)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(256, 45)" end="(256, 46)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(256, 47)" end="(256, 48)">
                    <IdentNode start="(256, 47)" end="(256, 48)" leading="" trailing="" raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(256, 48)" end="(256, 49)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(256, 50)" end="(257, 61)">
            <AtomNode start="(256, 50)" end="(256, 51)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(257, 5)" end="(257, 61)" kind="«term_=_»">
              <OtherNode start="(257, 5)" end="(257, 28)" kind="Lean.Parser.Term.app">
                <IdentNode start="(257, 5)" end="(257, 10)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Vector.find?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(257, 11)" end="(257, 28)">
                  <IdentNode start="(257, 11)" end="(257, 12)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(257, 13)" end="(257, 28)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(257, 13)" end="(257, 14)" leading="" trailing="" val="("/>
                    <OtherNode start="(257, 14)" end="(257, 27)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(257, 14)" end="(257, 23)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Vector.replicate" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                      <NullNode start="(257, 24)" end="(257, 27)">
                        <IdentNode start="(257, 24)" end="(257, 25)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(257, 26)" end="(257, 27)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(257, 27)" end="(257, 28)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(257, 29)" end="(257, 30)" leading="" trailing=" " val="="/>
              <OtherNode start="(257, 31)" end="(257, 61)" kind="termIfThenElse">
                <AtomNode start="(257, 31)" end="(257, 33)" leading="" trailing=" " val="if"/>
                <OtherNode start="(257, 34)" end="(257, 39)" kind="«term_=_»">
                  <IdentNode start="(257, 34)" end="(257, 35)" leading="" trailing=" " raw_val="n" val="n"/>
                  <AtomNode start="(257, 36)" end="(257, 37)" leading="" trailing=" " val="="/>
                  <OtherNode start="(257, 38)" end="(257, 39)" kind="num">
                    <AtomNode start="(257, 38)" end="(257, 39)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(257, 40)" end="(257, 44)" leading="" trailing=" " val="then"/>
                <IdentNode start="(257, 45)" end="(257, 49)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <AtomNode start="(257, 50)" end="(257, 54)" leading="" trailing=" " val="else"/>
                <OtherNode start="(257, 55)" end="(257, 61)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(257, 55)" end="(257, 59)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(257, 60)" end="(257, 61)">
                    <IdentNode start="(257, 60)" end="(257, 61)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(257, 62)" end="(258, 28)">
          <AtomNode start="(257, 62)" end="(257, 64)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(257, 65)" end="(258, 28)">
            <AtomNode start="(257, 65)" end="(257, 67)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(258, 3)" end="(258, 28)">
              <TacticTacticseq1IndentedNode start="(258, 3)" end="(258, 28)">
                <NullNode start="(258, 3)" end="(258, 28)">
                  <OtherNode start="(258, 3)" end="(258, 28)" kind="Lean.Parser.Tactic.simp" state_before="α✝ : Type&#10;p : α✝ → Bool&#10;n : Nat&#10;a : α✝&#10;h : p a = true&#10;⊢ find? p (replicate n a) = if n = 0 then none else some a" state_after="no goals" tactic="simp [find?_replicate, h]">
                    <AtomNode start="(258, 3)" end="(258, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(258, 8)" end="(258, 28)">
                      <AtomNode start="(258, 8)" end="(258, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(258, 9)" end="(258, 27)">
                        <OtherNode start="(258, 9)" end="(258, 24)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(258, 9)" end="(258, 24)" leading="" trailing="" raw_val="find?_replicate" val="find?_replicate" full_name="Vector.find?_replicate" mod_name="Init.Data.Vector.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Find.lean" def_start="(242, 9)" def_end="(242, 24)"/>
                        </OtherNode>
                        <AtomNode start="(258, 24)" end="(258, 25)" leading="" trailing=" " val=","/>
                        <OtherNode start="(258, 26)" end="(258, 27)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(258, 26)" end="(258, 27)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(258, 27)" end="(258, 28)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(260, 1)" end="(261, 56)" name="find?_mkVector_of_pos" full_name="Vector.find?_mkVector_of_pos">
      <CommandDeclmodifiersNode start="(260, 1)" end="(260, 61)">
        <NullNode/>
        <NullNode start="(260, 1)" end="(260, 61)">
          <OtherNode start="(260, 1)" end="(260, 61)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(260, 1)" end="(260, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(260, 3)" end="(260, 60)">
              <OtherNode start="(260, 3)" end="(260, 60)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(260, 3)" end="(260, 60)" kind="Lean.deprecated">
                  <AtomNode start="(260, 3)" end="(260, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(260, 14)" end="(260, 36)">
                    <IdentNode start="(260, 14)" end="(260, 36)" leading="" trailing=" " raw_val="find?_replicate_of_pos" val="find?_replicate_of_pos" full_name="Vector.find?_replicate_of_pos" mod_name="Init.Data.Vector.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Find.lean" def_start="(256, 17)" def_end="(256, 39)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(260, 37)" end="(260, 60)">
                    <AtomNode start="(260, 37)" end="(260, 38)" leading="" trailing="" val="("/>
                    <AtomNode start="(260, 38)" end="(260, 43)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(260, 44)" end="(260, 46)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(260, 47)" end="(260, 59)" kind="str">
                      <AtomNode start="(260, 47)" end="(260, 59)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(260, 59)" end="(260, 60)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(260, 60)" end="(260, 61)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(261, 1)" end="(261, 56)" name="find?_mkVector_of_pos">
        <AtomNode start="(261, 1)" end="(261, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(261, 8)" end="(261, 29)">
          <IdentNode start="(261, 8)" end="(261, 29)" leading="" trailing=" " raw_val="find?_mkVector_of_pos" val="find?_mkVector_of_pos"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(261, 30)" end="(261, 56)">
          <AtomNode start="(261, 30)" end="(261, 32)" leading="" trailing=" " val=":="/>
          <OtherNode start="(261, 33)" end="(261, 56)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(261, 33)" end="(261, 34)" leading="" trailing="" val="@"/>
            <IdentNode start="(261, 34)" end="(261, 56)" leading="" trailing="&#10;&#10;" raw_val="find?_replicate_of_pos" val="find?_replicate_of_pos" full_name="Vector.find?_replicate_of_pos" mod_name="Init.Data.Vector.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Find.lean" def_start="(256, 17)" def_end="(256, 39)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(263, 1)" end="(264, 28)" name="find?_replicate_of_neg" full_name="Vector.find?_replicate_of_neg">
      <CommandDeclmodifiersNode start="(263, 1)" end="(263, 8)">
        <NullNode/>
        <NullNode start="(263, 1)" end="(263, 8)">
          <OtherNode start="(263, 1)" end="(263, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(263, 1)" end="(263, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(263, 3)" end="(263, 7)">
              <OtherNode start="(263, 3)" end="(263, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(263, 3)" end="(263, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(263, 3)" end="(263, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(263, 7)" end="(263, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(263, 9)" end="(264, 28)" name="find?_replicate_of_neg" full_name="Vector.find?_replicate_of_neg" _is_private_decl="False">
        <AtomNode start="(263, 9)" end="(263, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(263, 17)" end="(263, 39)">
          <IdentNode start="(263, 17)" end="(263, 39)" leading="" trailing=" " raw_val="find?_replicate_of_neg" val="find?_replicate_of_neg"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(263, 40)" end="(263, 84)">
          <NullNode start="(263, 40)" end="(263, 51)">
            <TermExplicitbinderNode start="(263, 40)" end="(263, 51)">
              <AtomNode start="(263, 40)" end="(263, 41)" leading="" trailing="" val="("/>
              <NullNode start="(263, 41)" end="(263, 42)">
                <IdentNode start="(263, 41)" end="(263, 42)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(263, 43)" end="(263, 50)">
                <AtomNode start="(263, 43)" end="(263, 44)" leading="" trailing=" " val=":"/>
                <OtherNode start="(263, 45)" end="(263, 50)" kind="«term¬_»">
                  <AtomNode start="(263, 45)" end="(263, 46)" leading="" trailing=" " val="¬"/>
                  <OtherNode start="(263, 47)" end="(263, 50)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(263, 47)" end="(263, 48)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(263, 49)" end="(263, 50)">
                      <IdentNode start="(263, 49)" end="(263, 50)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(263, 50)" end="(263, 51)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(263, 52)" end="(263, 84)">
            <AtomNode start="(263, 52)" end="(263, 53)" leading="" trailing=" " val=":"/>
            <OtherNode start="(263, 54)" end="(263, 84)" kind="«term_=_»">
              <OtherNode start="(263, 54)" end="(263, 77)" kind="Lean.Parser.Term.app">
                <IdentNode start="(263, 54)" end="(263, 59)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Vector.find?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(263, 60)" end="(263, 77)">
                  <IdentNode start="(263, 60)" end="(263, 61)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(263, 62)" end="(263, 77)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(263, 62)" end="(263, 63)" leading="" trailing="" val="("/>
                    <OtherNode start="(263, 63)" end="(263, 76)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(263, 63)" end="(263, 72)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Vector.replicate" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                      <NullNode start="(263, 73)" end="(263, 76)">
                        <IdentNode start="(263, 73)" end="(263, 74)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(263, 75)" end="(263, 76)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(263, 76)" end="(263, 77)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(263, 78)" end="(263, 79)" leading="" trailing=" " val="="/>
              <IdentNode start="(263, 80)" end="(263, 84)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(263, 85)" end="(264, 28)">
          <AtomNode start="(263, 85)" end="(263, 87)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(263, 88)" end="(264, 28)">
            <AtomNode start="(263, 88)" end="(263, 90)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(264, 3)" end="(264, 28)">
              <TacticTacticseq1IndentedNode start="(264, 3)" end="(264, 28)">
                <NullNode start="(264, 3)" end="(264, 28)">
                  <OtherNode start="(264, 3)" end="(264, 28)" kind="Lean.Parser.Tactic.simp" state_before="α✝ : Type&#10;p : α✝ → Bool&#10;n : Nat&#10;a : α✝&#10;h : ¬p a = true&#10;⊢ find? p (replicate n a) = none" state_after="no goals" tactic="simp [find?_replicate, h]">
                    <AtomNode start="(264, 3)" end="(264, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(264, 8)" end="(264, 28)">
                      <AtomNode start="(264, 8)" end="(264, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(264, 9)" end="(264, 27)">
                        <OtherNode start="(264, 9)" end="(264, 24)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(264, 9)" end="(264, 24)" leading="" trailing="" raw_val="find?_replicate" val="find?_replicate" full_name="Vector.find?_replicate" mod_name="Init.Data.Vector.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Find.lean" def_start="(242, 9)" def_end="(242, 24)"/>
                        </OtherNode>
                        <AtomNode start="(264, 24)" end="(264, 25)" leading="" trailing=" " val=","/>
                        <OtherNode start="(264, 26)" end="(264, 27)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(264, 26)" end="(264, 27)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(264, 27)" end="(264, 28)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(266, 1)" end="(267, 56)" name="find?_mkVector_of_neg" full_name="Vector.find?_mkVector_of_neg">
      <CommandDeclmodifiersNode start="(266, 1)" end="(266, 61)">
        <NullNode/>
        <NullNode start="(266, 1)" end="(266, 61)">
          <OtherNode start="(266, 1)" end="(266, 61)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(266, 1)" end="(266, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(266, 3)" end="(266, 60)">
              <OtherNode start="(266, 3)" end="(266, 60)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(266, 3)" end="(266, 60)" kind="Lean.deprecated">
                  <AtomNode start="(266, 3)" end="(266, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(266, 14)" end="(266, 36)">
                    <IdentNode start="(266, 14)" end="(266, 36)" leading="" trailing=" " raw_val="find?_replicate_of_neg" val="find?_replicate_of_neg" full_name="Vector.find?_replicate_of_neg" mod_name="Init.Data.Vector.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Find.lean" def_start="(263, 17)" def_end="(263, 39)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(266, 37)" end="(266, 60)">
                    <AtomNode start="(266, 37)" end="(266, 38)" leading="" trailing="" val="("/>
                    <AtomNode start="(266, 38)" end="(266, 43)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(266, 44)" end="(266, 46)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(266, 47)" end="(266, 59)" kind="str">
                      <AtomNode start="(266, 47)" end="(266, 59)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(266, 59)" end="(266, 60)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(266, 60)" end="(266, 61)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(267, 1)" end="(267, 56)" name="find?_mkVector_of_neg">
        <AtomNode start="(267, 1)" end="(267, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(267, 8)" end="(267, 29)">
          <IdentNode start="(267, 8)" end="(267, 29)" leading="" trailing=" " raw_val="find?_mkVector_of_neg" val="find?_mkVector_of_neg"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(267, 30)" end="(267, 56)">
          <AtomNode start="(267, 30)" end="(267, 32)" leading="" trailing=" " val=":="/>
          <OtherNode start="(267, 33)" end="(267, 56)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(267, 33)" end="(267, 34)" leading="" trailing="" val="@"/>
            <IdentNode start="(267, 34)" end="(267, 56)" leading="" trailing="&#10;&#10;-- This isn't a `@[simp]` lemma since there is already a lemma for `l.find? p = none` for any `l`.&#10;" raw_val="find?_replicate_of_neg" val="find?_replicate_of_neg" full_name="Vector.find?_replicate_of_neg" mod_name="Init.Data.Vector.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Find.lean" def_start="(263, 17)" def_end="(263, 39)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(270, 1)" end="(272, 39)" name="find?_replicate_eq_none_iff" full_name="Vector.find?_replicate_eq_none_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(270, 1)" end="(272, 39)" name="find?_replicate_eq_none_iff" full_name="Vector.find?_replicate_eq_none_iff" _is_private_decl="False">
        <AtomNode start="(270, 1)" end="(270, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(270, 9)" end="(270, 36)">
          <IdentNode start="(270, 9)" end="(270, 36)" leading="" trailing=" " raw_val="find?_replicate_eq_none_iff" val="find?_replicate_eq_none_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(270, 37)" end="(271, 50)">
          <NullNode start="(270, 37)" end="(270, 69)">
            <OtherNode start="(270, 37)" end="(270, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(270, 37)" end="(270, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(270, 38)" end="(270, 39)">
                <IdentNode start="(270, 38)" end="(270, 39)" leading="" trailing=" " raw_val="n" val="n"/>
              </NullNode>
              <NullNode start="(270, 40)" end="(270, 45)">
                <AtomNode start="(270, 40)" end="(270, 41)" leading="" trailing=" " val=":"/>
                <IdentNode start="(270, 42)" end="(270, 45)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(270, 45)" end="(270, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(270, 47)" end="(270, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(270, 47)" end="(270, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(270, 48)" end="(270, 49)">
                <IdentNode start="(270, 48)" end="(270, 49)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(270, 50)" end="(270, 53)">
                <AtomNode start="(270, 50)" end="(270, 51)" leading="" trailing=" " val=":"/>
                <IdentNode start="(270, 52)" end="(270, 53)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(270, 53)" end="(270, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(270, 55)" end="(270, 69)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(270, 55)" end="(270, 56)" leading="" trailing="" val="{"/>
              <NullNode start="(270, 56)" end="(270, 57)">
                <IdentNode start="(270, 56)" end="(270, 57)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(270, 58)" end="(270, 68)">
                <AtomNode start="(270, 58)" end="(270, 59)" leading="" trailing=" " val=":"/>
                <OtherNode start="(270, 60)" end="(270, 68)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(270, 60)" end="(270, 61)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(270, 62)" end="(270, 63)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(270, 64)" end="(270, 68)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(270, 68)" end="(270, 69)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(270, 70)" end="(271, 50)">
            <AtomNode start="(270, 70)" end="(270, 71)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(271, 5)" end="(271, 50)" kind="«term_↔_»">
              <OtherNode start="(271, 5)" end="(271, 35)" kind="«term_=_»">
                <OtherNode start="(271, 5)" end="(271, 28)" kind="Lean.Parser.Term.app">
                  <OtherNode start="(271, 5)" end="(271, 26)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(271, 5)" end="(271, 20)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(271, 5)" end="(271, 6)" leading="" trailing="" val="("/>
                      <OtherNode start="(271, 6)" end="(271, 19)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(271, 6)" end="(271, 15)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Vector.replicate" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                        <NullNode start="(271, 16)" end="(271, 19)">
                          <IdentNode start="(271, 16)" end="(271, 17)" leading="" trailing=" " raw_val="n" val="n"/>
                          <IdentNode start="(271, 18)" end="(271, 19)" leading="" trailing="" raw_val="a" val="a"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(271, 19)" end="(271, 20)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(271, 20)" end="(271, 21)" leading="" trailing="" val="."/>
                    <IdentNode start="(271, 21)" end="(271, 26)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Vector.find?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  </OtherNode>
                  <NullNode start="(271, 27)" end="(271, 28)">
                    <IdentNode start="(271, 27)" end="(271, 28)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(271, 29)" end="(271, 30)" leading="" trailing=" " val="="/>
                <IdentNode start="(271, 31)" end="(271, 35)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(271, 36)" end="(271, 37)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(271, 38)" end="(271, 50)" kind="«term_∨_»">
                <OtherNode start="(271, 38)" end="(271, 43)" kind="«term_=_»">
                  <IdentNode start="(271, 38)" end="(271, 39)" leading="" trailing=" " raw_val="n" val="n"/>
                  <AtomNode start="(271, 40)" end="(271, 41)" leading="" trailing=" " val="="/>
                  <OtherNode start="(271, 42)" end="(271, 43)" kind="num">
                    <AtomNode start="(271, 42)" end="(271, 43)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(271, 44)" end="(271, 45)" leading="" trailing=" " val="∨"/>
                <OtherNode start="(271, 46)" end="(271, 50)" kind="term!_">
                  <AtomNode start="(271, 46)" end="(271, 47)" leading="" trailing="" val="!"/>
                  <OtherNode start="(271, 47)" end="(271, 50)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(271, 47)" end="(271, 48)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(271, 49)" end="(271, 50)">
                      <IdentNode start="(271, 49)" end="(271, 50)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(271, 51)" end="(272, 39)">
          <AtomNode start="(271, 51)" end="(271, 53)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(271, 54)" end="(272, 39)">
            <AtomNode start="(271, 54)" end="(271, 56)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(272, 3)" end="(272, 39)">
              <TacticTacticseq1IndentedNode start="(272, 3)" end="(272, 39)">
                <NullNode start="(272, 3)" end="(272, 39)">
                  <OtherNode start="(272, 3)" end="(272, 39)" kind="Lean.Parser.Tactic.simp" state_before="α : Type&#10;n : Nat&#10;a : α&#10;p : α → Bool&#10;⊢ find? p (replicate n a) = none ↔ n = 0 ∨ (!p a) = true" state_after="no goals" tactic="simp [Classical.or_iff_not_imp_left]">
                    <AtomNode start="(272, 3)" end="(272, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(272, 8)" end="(272, 39)">
                      <AtomNode start="(272, 8)" end="(272, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(272, 9)" end="(272, 38)">
                        <OtherNode start="(272, 9)" end="(272, 38)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(272, 9)" end="(272, 38)" leading="" trailing="" raw_val="Classical.or_iff_not_imp_left" val="Classical.or_iff_not_imp_left" full_name="Classical.or_iff_not_imp_left" mod_name="Init.Classical" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Classical.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(272, 38)" end="(272, 39)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(274, 1)" end="(275, 66)" name="find?_mkVector_eq_none_iff" full_name="Vector.find?_mkVector_eq_none_iff">
      <CommandDeclmodifiersNode start="(274, 1)" end="(274, 66)">
        <NullNode/>
        <NullNode start="(274, 1)" end="(274, 66)">
          <OtherNode start="(274, 1)" end="(274, 66)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(274, 1)" end="(274, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(274, 3)" end="(274, 65)">
              <OtherNode start="(274, 3)" end="(274, 65)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(274, 3)" end="(274, 65)" kind="Lean.deprecated">
                  <AtomNode start="(274, 3)" end="(274, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(274, 14)" end="(274, 41)">
                    <IdentNode start="(274, 14)" end="(274, 41)" leading="" trailing=" " raw_val="find?_replicate_eq_none_iff" val="find?_replicate_eq_none_iff" full_name="Vector.find?_replicate_eq_none_iff" mod_name="Init.Data.Vector.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Find.lean" def_start="(270, 9)" def_end="(270, 36)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(274, 42)" end="(274, 65)">
                    <AtomNode start="(274, 42)" end="(274, 43)" leading="" trailing="" val="("/>
                    <AtomNode start="(274, 43)" end="(274, 48)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(274, 49)" end="(274, 51)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(274, 52)" end="(274, 64)" kind="str">
                      <AtomNode start="(274, 52)" end="(274, 64)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(274, 64)" end="(274, 65)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(274, 65)" end="(274, 66)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(275, 1)" end="(275, 66)" name="find?_mkVector_eq_none_iff">
        <AtomNode start="(275, 1)" end="(275, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(275, 8)" end="(275, 34)">
          <IdentNode start="(275, 8)" end="(275, 34)" leading="" trailing=" " raw_val="find?_mkVector_eq_none_iff" val="find?_mkVector_eq_none_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(275, 35)" end="(275, 66)">
          <AtomNode start="(275, 35)" end="(275, 37)" leading="" trailing=" " val=":="/>
          <OtherNode start="(275, 38)" end="(275, 66)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(275, 38)" end="(275, 39)" leading="" trailing="" val="@"/>
            <IdentNode start="(275, 39)" end="(275, 66)" leading="" trailing="&#10;&#10;" raw_val="find?_replicate_eq_none_iff" val="find?_replicate_eq_none_iff" full_name="Vector.find?_replicate_eq_none_iff" mod_name="Init.Data.Vector.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Find.lean" def_start="(270, 9)" def_end="(270, 36)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(277, 1)" end="(280, 7)" name="find?_replicate_eq_some_iff" full_name="Vector.find?_replicate_eq_some_iff">
      <CommandDeclmodifiersNode start="(277, 1)" end="(277, 8)">
        <NullNode/>
        <NullNode start="(277, 1)" end="(277, 8)">
          <OtherNode start="(277, 1)" end="(277, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(277, 1)" end="(277, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(277, 3)" end="(277, 7)">
              <OtherNode start="(277, 3)" end="(277, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(277, 3)" end="(277, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(277, 3)" end="(277, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(277, 7)" end="(277, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(277, 9)" end="(280, 7)" name="find?_replicate_eq_some_iff" full_name="Vector.find?_replicate_eq_some_iff" _is_private_decl="False">
        <AtomNode start="(277, 9)" end="(277, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(277, 17)" end="(277, 44)">
          <IdentNode start="(277, 17)" end="(277, 44)" leading="" trailing=" " raw_val="find?_replicate_eq_some_iff" val="find?_replicate_eq_some_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(277, 45)" end="(278, 59)">
          <NullNode start="(277, 45)" end="(277, 79)">
            <OtherNode start="(277, 45)" end="(277, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(277, 45)" end="(277, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(277, 46)" end="(277, 47)">
                <IdentNode start="(277, 46)" end="(277, 47)" leading="" trailing=" " raw_val="n" val="n"/>
              </NullNode>
              <NullNode start="(277, 48)" end="(277, 53)">
                <AtomNode start="(277, 48)" end="(277, 49)" leading="" trailing=" " val=":"/>
                <IdentNode start="(277, 50)" end="(277, 53)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(277, 53)" end="(277, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(277, 55)" end="(277, 64)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(277, 55)" end="(277, 56)" leading="" trailing="" val="{"/>
              <NullNode start="(277, 56)" end="(277, 59)">
                <IdentNode start="(277, 56)" end="(277, 57)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(277, 58)" end="(277, 59)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(277, 60)" end="(277, 63)">
                <AtomNode start="(277, 60)" end="(277, 61)" leading="" trailing=" " val=":"/>
                <IdentNode start="(277, 62)" end="(277, 63)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(277, 63)" end="(277, 64)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(277, 65)" end="(277, 79)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(277, 65)" end="(277, 66)" leading="" trailing="" val="{"/>
              <NullNode start="(277, 66)" end="(277, 67)">
                <IdentNode start="(277, 66)" end="(277, 67)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(277, 68)" end="(277, 78)">
                <AtomNode start="(277, 68)" end="(277, 69)" leading="" trailing=" " val=":"/>
                <OtherNode start="(277, 70)" end="(277, 78)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(277, 70)" end="(277, 71)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(277, 72)" end="(277, 73)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(277, 74)" end="(277, 78)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(277, 78)" end="(277, 79)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(277, 80)" end="(278, 59)">
            <AtomNode start="(277, 80)" end="(277, 81)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(278, 5)" end="(278, 59)" kind="«term_↔_»">
              <OtherNode start="(278, 5)" end="(278, 37)" kind="«term_=_»">
                <OtherNode start="(278, 5)" end="(278, 28)" kind="Lean.Parser.Term.app">
                  <OtherNode start="(278, 5)" end="(278, 26)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(278, 5)" end="(278, 20)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(278, 5)" end="(278, 6)" leading="" trailing="" val="("/>
                      <OtherNode start="(278, 6)" end="(278, 19)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(278, 6)" end="(278, 15)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Vector.replicate" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                        <NullNode start="(278, 16)" end="(278, 19)">
                          <IdentNode start="(278, 16)" end="(278, 17)" leading="" trailing=" " raw_val="n" val="n"/>
                          <IdentNode start="(278, 18)" end="(278, 19)" leading="" trailing="" raw_val="a" val="a"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(278, 19)" end="(278, 20)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(278, 20)" end="(278, 21)" leading="" trailing="" val="."/>
                    <IdentNode start="(278, 21)" end="(278, 26)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Vector.find?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  </OtherNode>
                  <NullNode start="(278, 27)" end="(278, 28)">
                    <IdentNode start="(278, 27)" end="(278, 28)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(278, 29)" end="(278, 30)" leading="" trailing=" " val="="/>
                <OtherNode start="(278, 31)" end="(278, 37)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(278, 31)" end="(278, 35)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(278, 36)" end="(278, 37)">
                    <IdentNode start="(278, 36)" end="(278, 37)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(278, 38)" end="(278, 39)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(278, 40)" end="(278, 59)" kind="«term_∧_»">
                <OtherNode start="(278, 40)" end="(278, 45)" kind="«term_≠_»">
                  <IdentNode start="(278, 40)" end="(278, 41)" leading="" trailing=" " raw_val="n" val="n"/>
                  <AtomNode start="(278, 42)" end="(278, 43)" leading="" trailing=" " val="≠"/>
                  <OtherNode start="(278, 44)" end="(278, 45)" kind="num">
                    <AtomNode start="(278, 44)" end="(278, 45)" leading="" trailing=" " val="0"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(278, 46)" end="(278, 47)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(278, 48)" end="(278, 59)" kind="«term_∧_»">
                  <OtherNode start="(278, 48)" end="(278, 51)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(278, 48)" end="(278, 49)" leading="" trailing=" " raw_val="p" val="p"/>
                    <NullNode start="(278, 50)" end="(278, 51)">
                      <IdentNode start="(278, 50)" end="(278, 51)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(278, 52)" end="(278, 53)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(278, 54)" end="(278, 59)" kind="«term_=_»">
                    <IdentNode start="(278, 54)" end="(278, 55)" leading="" trailing=" " raw_val="a" val="a"/>
                    <AtomNode start="(278, 56)" end="(278, 57)" leading="" trailing=" " val="="/>
                    <IdentNode start="(278, 58)" end="(278, 59)" leading="" trailing=" " raw_val="b" val="b"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(278, 60)" end="(280, 7)">
          <AtomNode start="(278, 60)" end="(278, 62)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(278, 63)" end="(280, 7)">
            <AtomNode start="(278, 63)" end="(278, 65)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(279, 3)" end="(280, 7)">
              <TacticTacticseq1IndentedNode start="(279, 3)" end="(280, 7)">
                <NullNode start="(279, 3)" end="(280, 7)">
                  <OtherNode start="(279, 3)" end="(279, 43)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type&#10;n : Nat&#10;a b : α&#10;p : α → Bool&#10;⊢ find? p (replicate n a) = some b ↔ n ≠ 0 ∧ p a = true ∧ a = b" state_after="α : Type&#10;n : Nat&#10;a b : α&#10;p : α → Bool&#10;⊢ Array.find? p (Array.replicate n a) = some b ↔ n ≠ 0 ∧ p a = true ∧ a = b" tactic="rw [replicate_eq_mk_replicate, find?_mk]">
                    <AtomNode start="(279, 3)" end="(279, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(279, 6)" end="(279, 43)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(279, 6)" end="(279, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(279, 7)" end="(279, 42)">
                        <OtherNode start="(279, 7)" end="(279, 32)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(279, 7)" end="(279, 32)" leading="" trailing="" raw_val="replicate_eq_mk_replicate" val="replicate_eq_mk_replicate" full_name="Vector.replicate_eq_mk_replicate" mod_name="Init.Data.Vector.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(279, 32)" end="(279, 33)" leading="" trailing=" " val=","/>
                        <OtherNode start="(279, 34)" end="(279, 42)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(279, 34)" end="(279, 42)" leading="" trailing="" raw_val="find?_mk" val="find?_mk" full_name="Vector.find?_mk" mod_name="Init.Data.Vector.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(279, 42)" end="(279, 43)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(280, 3)" end="(280, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type&#10;n : Nat&#10;a b : α&#10;p : α → Bool&#10;⊢ Array.find? p (Array.replicate n a) = some b ↔ n ≠ 0 ∧ p a = true ∧ a = b" state_after="no goals" tactic="simp">
                    <AtomNode start="(280, 3)" end="(280, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(282, 1)" end="(283, 66)" name="find?_mkVector_eq_some_iff" full_name="Vector.find?_mkVector_eq_some_iff">
      <CommandDeclmodifiersNode start="(282, 1)" end="(282, 66)">
        <NullNode/>
        <NullNode start="(282, 1)" end="(282, 66)">
          <OtherNode start="(282, 1)" end="(282, 66)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(282, 1)" end="(282, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(282, 3)" end="(282, 65)">
              <OtherNode start="(282, 3)" end="(282, 65)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(282, 3)" end="(282, 65)" kind="Lean.deprecated">
                  <AtomNode start="(282, 3)" end="(282, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(282, 14)" end="(282, 41)">
                    <IdentNode start="(282, 14)" end="(282, 41)" leading="" trailing=" " raw_val="find?_replicate_eq_some_iff" val="find?_replicate_eq_some_iff" full_name="Vector.find?_replicate_eq_some_iff" mod_name="Init.Data.Vector.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Find.lean" def_start="(277, 17)" def_end="(277, 44)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(282, 42)" end="(282, 65)">
                    <AtomNode start="(282, 42)" end="(282, 43)" leading="" trailing="" val="("/>
                    <AtomNode start="(282, 43)" end="(282, 48)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(282, 49)" end="(282, 51)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(282, 52)" end="(282, 64)" kind="str">
                      <AtomNode start="(282, 52)" end="(282, 64)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(282, 64)" end="(282, 65)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(282, 65)" end="(282, 66)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(283, 1)" end="(283, 66)" name="find?_mkVector_eq_some_iff">
        <AtomNode start="(283, 1)" end="(283, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(283, 8)" end="(283, 34)">
          <IdentNode start="(283, 8)" end="(283, 34)" leading="" trailing=" " raw_val="find?_mkVector_eq_some_iff" val="find?_mkVector_eq_some_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(283, 35)" end="(283, 66)">
          <AtomNode start="(283, 35)" end="(283, 37)" leading="" trailing=" " val=":="/>
          <OtherNode start="(283, 38)" end="(283, 66)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(283, 38)" end="(283, 39)" leading="" trailing="" val="@"/>
            <IdentNode start="(283, 39)" end="(283, 66)" leading="" trailing="&#10;&#10;" raw_val="find?_replicate_eq_some_iff" val="find?_replicate_eq_some_iff" full_name="Vector.find?_replicate_eq_some_iff" mod_name="Init.Data.Vector.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Find.lean" def_start="(277, 17)" def_end="(277, 44)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(285, 1)" end="(288, 7)" name="get_find?_replicate" full_name="Vector.get_find?_replicate">
      <CommandDeclmodifiersNode start="(285, 1)" end="(285, 8)">
        <NullNode/>
        <NullNode start="(285, 1)" end="(285, 8)">
          <OtherNode start="(285, 1)" end="(285, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(285, 1)" end="(285, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(285, 3)" end="(285, 7)">
              <OtherNode start="(285, 3)" end="(285, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(285, 3)" end="(285, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(285, 3)" end="(285, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(285, 7)" end="(285, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(285, 9)" end="(288, 7)" name="get_find?_replicate" full_name="Vector.get_find?_replicate" _is_private_decl="False">
        <AtomNode start="(285, 9)" end="(285, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(285, 17)" end="(285, 36)">
          <IdentNode start="(285, 17)" end="(285, 36)" leading="" trailing=" " raw_val="get_find?_replicate" val="get_find?_replicate"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(285, 37)" end="(286, 40)">
          <NullNode start="(285, 37)" end="(285, 73)">
            <OtherNode start="(285, 37)" end="(285, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(285, 37)" end="(285, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(285, 38)" end="(285, 39)">
                <IdentNode start="(285, 38)" end="(285, 39)" leading="" trailing=" " raw_val="n" val="n"/>
              </NullNode>
              <NullNode start="(285, 40)" end="(285, 45)">
                <AtomNode start="(285, 40)" end="(285, 41)" leading="" trailing=" " val=":"/>
                <IdentNode start="(285, 42)" end="(285, 45)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(285, 45)" end="(285, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(285, 47)" end="(285, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(285, 47)" end="(285, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(285, 48)" end="(285, 49)">
                <IdentNode start="(285, 48)" end="(285, 49)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(285, 50)" end="(285, 53)">
                <AtomNode start="(285, 50)" end="(285, 51)" leading="" trailing=" " val=":"/>
                <IdentNode start="(285, 52)" end="(285, 53)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(285, 53)" end="(285, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(285, 55)" end="(285, 69)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(285, 55)" end="(285, 56)" leading="" trailing="" val="{"/>
              <NullNode start="(285, 56)" end="(285, 57)">
                <IdentNode start="(285, 56)" end="(285, 57)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(285, 58)" end="(285, 68)">
                <AtomNode start="(285, 58)" end="(285, 59)" leading="" trailing=" " val=":"/>
                <OtherNode start="(285, 60)" end="(285, 68)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(285, 60)" end="(285, 61)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(285, 62)" end="(285, 63)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(285, 64)" end="(285, 68)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(285, 68)" end="(285, 69)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(285, 70)" end="(285, 73)">
              <AtomNode start="(285, 70)" end="(285, 71)" leading="" trailing="" val="("/>
              <NullNode start="(285, 71)" end="(285, 72)">
                <IdentNode start="(285, 71)" end="(285, 72)" leading="" trailing="" raw_val="h" val="h"/>
              </NullNode>
              <NullNode/>
              <NullNode/>
              <AtomNode start="(285, 72)" end="(285, 73)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(285, 74)" end="(286, 40)">
            <AtomNode start="(285, 74)" end="(285, 75)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(286, 5)" end="(286, 40)" kind="«term_=_»">
              <OtherNode start="(286, 5)" end="(286, 36)" kind="Lean.Parser.Term.app">
                <OtherNode start="(286, 5)" end="(286, 34)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(286, 5)" end="(286, 30)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(286, 5)" end="(286, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(286, 6)" end="(286, 29)" kind="Lean.Parser.Term.app">
                      <OtherNode start="(286, 6)" end="(286, 27)" kind="Lean.Parser.Term.proj">
                        <OtherNode start="(286, 6)" end="(286, 21)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(286, 6)" end="(286, 7)" leading="" trailing="" val="("/>
                          <OtherNode start="(286, 7)" end="(286, 20)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(286, 7)" end="(286, 16)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Vector.replicate" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                            <NullNode start="(286, 17)" end="(286, 20)">
                              <IdentNode start="(286, 17)" end="(286, 18)" leading="" trailing=" " raw_val="n" val="n"/>
                              <IdentNode start="(286, 19)" end="(286, 20)" leading="" trailing="" raw_val="a" val="a"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(286, 20)" end="(286, 21)" leading="" trailing="" val=")"/>
                        </OtherNode>
                        <AtomNode start="(286, 21)" end="(286, 22)" leading="" trailing="" val="."/>
                        <IdentNode start="(286, 22)" end="(286, 27)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Vector.find?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                      </OtherNode>
                      <NullNode start="(286, 28)" end="(286, 29)">
                        <IdentNode start="(286, 28)" end="(286, 29)" leading="" trailing="" raw_val="p" val="p"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(286, 29)" end="(286, 30)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(286, 30)" end="(286, 31)" leading="" trailing="" val="."/>
                  <IdentNode start="(286, 31)" end="(286, 34)" leading="" trailing=" " raw_val="get" val="get" full_name="Option.get" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(286, 35)" end="(286, 36)">
                  <IdentNode start="(286, 35)" end="(286, 36)" leading="" trailing=" " raw_val="h" val="h"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(286, 37)" end="(286, 38)" leading="" trailing=" " val="="/>
              <IdentNode start="(286, 39)" end="(286, 40)" leading="" trailing=" " raw_val="a" val="a"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(286, 41)" end="(288, 7)">
          <AtomNode start="(286, 41)" end="(286, 43)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(286, 44)" end="(288, 7)">
            <AtomNode start="(286, 44)" end="(286, 46)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(287, 3)" end="(288, 7)">
              <TacticTacticseq1IndentedNode start="(287, 3)" end="(288, 7)">
                <NullNode start="(287, 3)" end="(288, 7)">
                  <OtherNode start="(287, 3)" end="(287, 50)" kind="Lean.Parser.Tactic.simp" state_before="α : Type&#10;n : Nat&#10;a : α&#10;p : α → Bool&#10;h : (find? p (replicate n a)).isSome = true&#10;⊢ (find? p (replicate n a)).get h = a" state_after="α : Type&#10;n : Nat&#10;a : α&#10;p : α → Bool&#10;h : (find? p (replicate n a)).isSome = true&#10;⊢ (Array.find? p (Array.replicate n a)).get ⋯ = a" tactic="simp only [replicate_eq_mk_replicate, find?_mk]">
                    <AtomNode start="(287, 3)" end="(287, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(287, 8)" end="(287, 12)">
                      <AtomNode start="(287, 8)" end="(287, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(287, 13)" end="(287, 50)">
                      <AtomNode start="(287, 13)" end="(287, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(287, 14)" end="(287, 49)">
                        <OtherNode start="(287, 14)" end="(287, 39)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(287, 14)" end="(287, 39)" leading="" trailing="" raw_val="replicate_eq_mk_replicate" val="replicate_eq_mk_replicate" full_name="Vector.replicate_eq_mk_replicate" mod_name="Init.Data.Vector.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(287, 39)" end="(287, 40)" leading="" trailing=" " val=","/>
                        <OtherNode start="(287, 41)" end="(287, 49)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(287, 41)" end="(287, 49)" leading="" trailing="" raw_val="find?_mk" val="find?_mk" full_name="Vector.find?_mk" mod_name="Init.Data.Vector.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(287, 49)" end="(287, 50)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(288, 3)" end="(288, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type&#10;n : Nat&#10;a : α&#10;p : α → Bool&#10;h : (find? p (replicate n a)).isSome = true&#10;⊢ (Array.find? p (Array.replicate n a)).get ⋯ = a" state_after="no goals" tactic="simp">
                    <AtomNode start="(288, 3)" end="(288, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(290, 1)" end="(291, 50)" name="get_find?_mkVector" full_name="Vector.get_find?_mkVector">
      <CommandDeclmodifiersNode start="(290, 1)" end="(290, 58)">
        <NullNode/>
        <NullNode start="(290, 1)" end="(290, 58)">
          <OtherNode start="(290, 1)" end="(290, 58)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(290, 1)" end="(290, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(290, 3)" end="(290, 57)">
              <OtherNode start="(290, 3)" end="(290, 57)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(290, 3)" end="(290, 57)" kind="Lean.deprecated">
                  <AtomNode start="(290, 3)" end="(290, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(290, 14)" end="(290, 33)">
                    <IdentNode start="(290, 14)" end="(290, 33)" leading="" trailing=" " raw_val="get_find?_replicate" val="get_find?_replicate" full_name="Vector.get_find?_replicate" mod_name="Init.Data.Vector.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Find.lean" def_start="(285, 17)" def_end="(285, 36)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(290, 34)" end="(290, 57)">
                    <AtomNode start="(290, 34)" end="(290, 35)" leading="" trailing="" val="("/>
                    <AtomNode start="(290, 35)" end="(290, 40)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(290, 41)" end="(290, 43)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(290, 44)" end="(290, 56)" kind="str">
                      <AtomNode start="(290, 44)" end="(290, 56)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(290, 56)" end="(290, 57)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(290, 57)" end="(290, 58)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(291, 1)" end="(291, 50)" name="get_find?_mkVector">
        <AtomNode start="(291, 1)" end="(291, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(291, 8)" end="(291, 26)">
          <IdentNode start="(291, 8)" end="(291, 26)" leading="" trailing=" " raw_val="get_find?_mkVector" val="get_find?_mkVector"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(291, 27)" end="(291, 50)">
          <AtomNode start="(291, 27)" end="(291, 29)" leading="" trailing=" " val=":="/>
          <OtherNode start="(291, 30)" end="(291, 50)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(291, 30)" end="(291, 31)" leading="" trailing="" val="@"/>
            <IdentNode start="(291, 31)" end="(291, 50)" leading="" trailing="&#10;&#10;" raw_val="get_find?_replicate" val="get_find?_replicate" full_name="Vector.get_find?_replicate" mod_name="Init.Data.Vector.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Find.lean" def_start="(285, 17)" def_end="(285, 36)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(293, 1)" end="(297, 6)" name="find?_pmap" full_name="Vector.find?_pmap">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(293, 1)" end="(297, 6)" name="find?_pmap" full_name="Vector.find?_pmap" _is_private_decl="False">
        <AtomNode start="(293, 1)" end="(293, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(293, 9)" end="(293, 19)">
          <IdentNode start="(293, 9)" end="(293, 19)" leading="" trailing=" " raw_val="find?_pmap" val="find?_pmap"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(293, 20)" end="(295, 108)">
          <NullNode start="(293, 20)" end="(294, 49)">
            <OtherNode start="(293, 20)" end="(293, 34)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(293, 20)" end="(293, 21)" leading="" trailing="" val="{"/>
              <NullNode start="(293, 21)" end="(293, 22)">
                <IdentNode start="(293, 21)" end="(293, 22)" leading="" trailing=" " raw_val="P" val="P"/>
              </NullNode>
              <NullNode start="(293, 23)" end="(293, 33)">
                <AtomNode start="(293, 23)" end="(293, 24)" leading="" trailing=" " val=":"/>
                <OtherNode start="(293, 25)" end="(293, 33)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(293, 25)" end="(293, 26)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(293, 27)" end="(293, 28)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(293, 29)" end="(293, 33)" kind="Lean.Parser.Term.prop">
                    <AtomNode start="(293, 29)" end="(293, 33)" leading="" trailing="" val="Prop"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(293, 33)" end="(293, 34)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(293, 35)" end="(293, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(293, 35)" end="(293, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(293, 36)" end="(293, 37)">
                <IdentNode start="(293, 36)" end="(293, 37)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(293, 38)" end="(293, 57)">
                <AtomNode start="(293, 38)" end="(293, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(293, 40)" end="(293, 57)" kind="Lean.Parser.Term.depArrow">
                  <TermExplicitbinderNode start="(293, 40)" end="(293, 47)">
                    <AtomNode start="(293, 40)" end="(293, 41)" leading="" trailing="" val="("/>
                    <NullNode start="(293, 41)" end="(293, 42)">
                      <IdentNode start="(293, 41)" end="(293, 42)" leading="" trailing=" " raw_val="a" val="a"/>
                    </NullNode>
                    <NullNode start="(293, 43)" end="(293, 46)">
                      <AtomNode start="(293, 43)" end="(293, 44)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(293, 45)" end="(293, 46)" leading="" trailing="" raw_val="α" val="α"/>
                    </NullNode>
                    <NullNode/>
                    <AtomNode start="(293, 46)" end="(293, 47)" leading="" trailing=" " val=")"/>
                  </TermExplicitbinderNode>
                  <AtomNode start="(293, 48)" end="(293, 49)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(293, 50)" end="(293, 57)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(293, 50)" end="(293, 53)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(293, 50)" end="(293, 51)" leading="" trailing=" " raw_val="P" val="P"/>
                      <NullNode start="(293, 52)" end="(293, 53)">
                        <IdentNode start="(293, 52)" end="(293, 53)" leading="" trailing=" " raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(293, 54)" end="(293, 55)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(293, 56)" end="(293, 57)" leading="" trailing="" raw_val="β" val="β"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(293, 57)" end="(293, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(293, 59)" end="(293, 76)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(293, 59)" end="(293, 60)" leading="" trailing="" val="{"/>
              <NullNode start="(293, 60)" end="(293, 62)">
                <IdentNode start="(293, 60)" end="(293, 62)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(293, 63)" end="(293, 75)">
                <AtomNode start="(293, 63)" end="(293, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(293, 65)" end="(293, 75)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(293, 65)" end="(293, 71)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(293, 72)" end="(293, 75)">
                    <IdentNode start="(293, 72)" end="(293, 73)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(293, 74)" end="(293, 75)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(293, 75)" end="(293, 76)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(294, 5)" end="(294, 34)">
              <AtomNode start="(294, 5)" end="(294, 6)" leading="" trailing="" val="("/>
              <NullNode start="(294, 6)" end="(294, 7)">
                <IdentNode start="(294, 6)" end="(294, 7)" leading="" trailing=" " raw_val="H" val="H"/>
              </NullNode>
              <NullNode start="(294, 8)" end="(294, 33)">
                <AtomNode start="(294, 8)" end="(294, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(294, 10)" end="(294, 33)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(294, 10)" end="(294, 11)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(294, 12)" end="(294, 19)">
                    <TermExplicitbinderNode start="(294, 12)" end="(294, 19)">
                      <AtomNode start="(294, 12)" end="(294, 13)" leading="" trailing="" val="("/>
                      <NullNode start="(294, 13)" end="(294, 14)">
                        <IdentNode start="(294, 13)" end="(294, 14)" leading="" trailing=" " raw_val="a" val="a"/>
                      </NullNode>
                      <NullNode start="(294, 15)" end="(294, 18)">
                        <AtomNode start="(294, 15)" end="(294, 16)" leading="" trailing=" " val=":"/>
                        <IdentNode start="(294, 17)" end="(294, 18)" leading="" trailing="" raw_val="α" val="α"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(294, 18)" end="(294, 19)" leading="" trailing="" val=")"/>
                    </TermExplicitbinderNode>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(294, 19)" end="(294, 20)" leading="" trailing=" " val=","/>
                  <OtherNode start="(294, 21)" end="(294, 33)" kind="Lean.Parser.Term.arrow">
                    <OtherNode start="(294, 21)" end="(294, 27)" kind="«term_∈_»">
                      <IdentNode start="(294, 21)" end="(294, 22)" leading="" trailing=" " raw_val="a" val="a"/>
                      <AtomNode start="(294, 23)" end="(294, 24)" leading="" trailing=" " val="∈"/>
                      <IdentNode start="(294, 25)" end="(294, 27)" leading="" trailing=" " raw_val="xs" val="xs"/>
                    </OtherNode>
                    <AtomNode start="(294, 28)" end="(294, 29)" leading="" trailing=" " val="→"/>
                    <OtherNode start="(294, 30)" end="(294, 33)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(294, 30)" end="(294, 31)" leading="" trailing=" " raw_val="P" val="P"/>
                      <NullNode start="(294, 32)" end="(294, 33)">
                        <IdentNode start="(294, 32)" end="(294, 33)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(294, 33)" end="(294, 34)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(294, 35)" end="(294, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(294, 35)" end="(294, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(294, 36)" end="(294, 37)">
                <IdentNode start="(294, 36)" end="(294, 37)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(294, 38)" end="(294, 48)">
                <AtomNode start="(294, 38)" end="(294, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(294, 40)" end="(294, 48)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(294, 40)" end="(294, 41)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(294, 42)" end="(294, 43)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(294, 44)" end="(294, 48)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(294, 48)" end="(294, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(294, 50)" end="(295, 108)">
            <AtomNode start="(294, 50)" end="(294, 51)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(295, 5)" end="(295, 108)" kind="«term_=_»">
              <OtherNode start="(295, 5)" end="(295, 26)" kind="Lean.Parser.Term.app">
                <OtherNode start="(295, 5)" end="(295, 24)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(295, 5)" end="(295, 18)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(295, 5)" end="(295, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(295, 6)" end="(295, 17)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(295, 6)" end="(295, 13)" leading="" trailing=" " raw_val="xs.pmap" val="xs.pmap"/>
                      <NullNode start="(295, 14)" end="(295, 17)">
                        <IdentNode start="(295, 14)" end="(295, 15)" leading="" trailing=" " raw_val="f" val="f"/>
                        <IdentNode start="(295, 16)" end="(295, 17)" leading="" trailing="" raw_val="H" val="H"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(295, 17)" end="(295, 18)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(295, 18)" end="(295, 19)" leading="" trailing="" val="."/>
                  <IdentNode start="(295, 19)" end="(295, 24)" leading="" trailing=" " raw_val="find?" val="find?" full_name="Vector.find?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                </OtherNode>
                <NullNode start="(295, 25)" end="(295, 26)">
                  <IdentNode start="(295, 25)" end="(295, 26)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(295, 27)" end="(295, 28)" leading="" trailing=" " val="="/>
              <OtherNode start="(295, 29)" end="(295, 108)" kind="Lean.Parser.Term.app">
                <OtherNode start="(295, 29)" end="(295, 82)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(295, 29)" end="(295, 78)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(295, 29)" end="(295, 30)" leading="" trailing="" val="("/>
                    <OtherNode start="(295, 30)" end="(295, 77)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(295, 30)" end="(295, 45)" leading="" trailing=" " raw_val="xs.attach.find?" val="xs.attach.find?"/>
                      <NullNode start="(295, 46)" end="(295, 77)">
                        <OtherNode start="(295, 46)" end="(295, 77)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(295, 46)" end="(295, 47)" leading="" trailing="" val="("/>
                          <OtherNode start="(295, 47)" end="(295, 76)" kind="Lean.Parser.Term.fun">
                            <AtomNode start="(295, 47)" end="(295, 50)" leading="" trailing=" " val="fun"/>
                            <OtherNode start="(295, 51)" end="(295, 76)" kind="Lean.Parser.Term.basicFun">
                              <NullNode start="(295, 51)" end="(295, 57)">
                                <OtherNode start="(295, 51)" end="(295, 57)" kind="Lean.Parser.Term.anonymousCtor">
                                  <AtomNode start="(295, 51)" end="(295, 52)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(295, 52)" end="(295, 56)">
                                    <IdentNode start="(295, 52)" end="(295, 53)" leading="" trailing="" raw_val="a" val="a"/>
                                    <AtomNode start="(295, 53)" end="(295, 54)" leading="" trailing=" " val=","/>
                                    <IdentNode start="(295, 55)" end="(295, 56)" leading="" trailing="" raw_val="m" val="m"/>
                                  </NullNode>
                                  <AtomNode start="(295, 56)" end="(295, 57)" leading="" trailing=" " val="⟩"/>
                                </OtherNode>
                              </NullNode>
                              <NullNode/>
                              <AtomNode start="(295, 58)" end="(295, 60)" leading="" trailing=" " val="=&amp;gt;"/>
                              <OtherNode start="(295, 61)" end="(295, 76)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(295, 61)" end="(295, 62)" leading="" trailing=" " raw_val="p" val="p"/>
                                <NullNode start="(295, 63)" end="(295, 76)">
                                  <OtherNode start="(295, 63)" end="(295, 76)" kind="Lean.Parser.Term.paren">
                                    <AtomNode start="(295, 63)" end="(295, 64)" leading="" trailing="" val="("/>
                                    <OtherNode start="(295, 64)" end="(295, 75)" kind="Lean.Parser.Term.app">
                                      <IdentNode start="(295, 64)" end="(295, 65)" leading="" trailing=" " raw_val="f" val="f"/>
                                      <NullNode start="(295, 66)" end="(295, 75)">
                                        <IdentNode start="(295, 66)" end="(295, 67)" leading="" trailing=" " raw_val="a" val="a"/>
                                        <OtherNode start="(295, 68)" end="(295, 75)" kind="Lean.Parser.Term.paren">
                                          <AtomNode start="(295, 68)" end="(295, 69)" leading="" trailing="" val="("/>
                                          <OtherNode start="(295, 69)" end="(295, 74)" kind="Lean.Parser.Term.app">
                                            <IdentNode start="(295, 69)" end="(295, 70)" leading="" trailing=" " raw_val="H" val="H"/>
                                            <NullNode start="(295, 71)" end="(295, 74)">
                                              <IdentNode start="(295, 71)" end="(295, 72)" leading="" trailing=" " raw_val="a" val="a"/>
                                              <IdentNode start="(295, 73)" end="(295, 74)" leading="" trailing="" raw_val="m" val="m"/>
                                            </NullNode>
                                          </OtherNode>
                                          <AtomNode start="(295, 74)" end="(295, 75)" leading="" trailing="" val=")"/>
                                        </OtherNode>
                                      </NullNode>
                                    </OtherNode>
                                    <AtomNode start="(295, 75)" end="(295, 76)" leading="" trailing="" val=")"/>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </OtherNode>
                          </OtherNode>
                          <AtomNode start="(295, 76)" end="(295, 77)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(295, 77)" end="(295, 78)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(295, 78)" end="(295, 79)" leading="" trailing="" val="."/>
                  <IdentNode start="(295, 79)" end="(295, 82)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
                <NullNode start="(295, 83)" end="(295, 108)">
                  <OtherNode start="(295, 83)" end="(295, 108)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(295, 83)" end="(295, 86)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(295, 87)" end="(295, 108)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(295, 87)" end="(295, 93)">
                        <OtherNode start="(295, 87)" end="(295, 93)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(295, 87)" end="(295, 88)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(295, 88)" end="(295, 92)">
                            <IdentNode start="(295, 88)" end="(295, 89)" leading="" trailing="" raw_val="a" val="a"/>
                            <AtomNode start="(295, 89)" end="(295, 90)" leading="" trailing=" " val=","/>
                            <IdentNode start="(295, 91)" end="(295, 92)" leading="" trailing="" raw_val="m" val="m"/>
                          </NullNode>
                          <AtomNode start="(295, 92)" end="(295, 93)" leading="" trailing=" " val="⟩"/>
                        </OtherNode>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(295, 94)" end="(295, 96)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(295, 97)" end="(295, 108)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(295, 97)" end="(295, 98)" leading="" trailing=" " raw_val="f" val="f"/>
                        <NullNode start="(295, 99)" end="(295, 108)">
                          <IdentNode start="(295, 99)" end="(295, 100)" leading="" trailing=" " raw_val="a" val="a"/>
                          <OtherNode start="(295, 101)" end="(295, 108)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(295, 101)" end="(295, 102)" leading="" trailing="" val="("/>
                            <OtherNode start="(295, 102)" end="(295, 107)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(295, 102)" end="(295, 103)" leading="" trailing=" " raw_val="H" val="H"/>
                              <NullNode start="(295, 104)" end="(295, 107)">
                                <IdentNode start="(295, 104)" end="(295, 105)" leading="" trailing=" " raw_val="a" val="a"/>
                                <IdentNode start="(295, 106)" end="(295, 107)" leading="" trailing="" raw_val="m" val="m"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(295, 107)" end="(295, 108)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(295, 109)" end="(297, 6)">
          <AtomNode start="(295, 109)" end="(295, 111)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(295, 112)" end="(297, 6)">
            <AtomNode start="(295, 112)" end="(295, 114)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(296, 3)" end="(297, 6)">
              <TacticTacticseq1IndentedNode start="(296, 3)" end="(297, 6)">
                <NullNode start="(296, 3)" end="(297, 6)">
                  <OtherNode start="(296, 3)" end="(296, 44)" kind="Lean.Parser.Tactic.simp" state_before="α β : Type&#10;n : Nat&#10;P : α → Prop&#10;f : (a : α) → P a → β&#10;xs : Vector α n&#10;H : ∀ (a : α), a ∈ xs → P a&#10;p : β → Bool&#10;⊢ find? p (pmap f xs H) =&#10;    Option.map&#10;      (fun x =&amp;gt;&#10;        match x with&#10;        | ⟨a, m⟩ =&amp;gt; f a ⋯)&#10;      (find?&#10;        (fun x =&amp;gt;&#10;          match x with&#10;          | ⟨a, m⟩ =&amp;gt; p (f a ⋯))&#10;        xs.attach)" state_after="α β : Type&#10;n : Nat&#10;P : α → Prop&#10;f : (a : α) → P a → β&#10;xs : Vector α n&#10;H : ∀ (a : α), a ∈ xs → P a&#10;p : β → Bool&#10;⊢ Option.map (fun x =&amp;gt; f x.val ⋯) (find? (p ∘ fun x =&amp;gt; f x.val ⋯) xs.attach) =&#10;    Option.map (fun x =&amp;gt; f x.val ⋯) (find? (fun x =&amp;gt; p (f x.val ⋯)) xs.attach)" tactic="simp only [pmap_eq_map_attach, find?_map]">
                    <AtomNode start="(296, 3)" end="(296, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(296, 8)" end="(296, 12)">
                      <AtomNode start="(296, 8)" end="(296, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(296, 13)" end="(296, 44)">
                      <AtomNode start="(296, 13)" end="(296, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(296, 14)" end="(296, 43)">
                        <OtherNode start="(296, 14)" end="(296, 32)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(296, 14)" end="(296, 32)" leading="" trailing="" raw_val="pmap_eq_map_attach" val="pmap_eq_map_attach" full_name="Vector.pmap_eq_map_attach" mod_name="Init.Data.Vector.Attach" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Attach.lean"/>
                        </OtherNode>
                        <AtomNode start="(296, 32)" end="(296, 33)" leading="" trailing=" " val=","/>
                        <OtherNode start="(296, 34)" end="(296, 43)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(296, 34)" end="(296, 43)" leading="" trailing="" raw_val="find?_map" val="find?_map" full_name="Vector.find?_map" mod_name="Init.Data.Vector.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Find.lean" def_start="(213, 17)" def_end="(213, 26)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(296, 43)" end="(296, 44)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(297, 3)" end="(297, 6)" kind="Lean.Parser.Tactic.tacticRfl" state_before="α β : Type&#10;n : Nat&#10;P : α → Prop&#10;f : (a : α) → P a → β&#10;xs : Vector α n&#10;H : ∀ (a : α), a ∈ xs → P a&#10;p : β → Bool&#10;⊢ Option.map (fun x =&amp;gt; f x.val ⋯) (find? (p ∘ fun x =&amp;gt; f x.val ⋯) xs.attach) =&#10;    Option.map (fun x =&amp;gt; f x.val ⋯) (find? (fun x =&amp;gt; p (f x.val ⋯)) xs.attach)" state_after="no goals" tactic="rfl">
                    <AtomNode start="(297, 3)" end="(297, 6)" leading="" trailing="&#10;&#10;" val="rfl"/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(299, 1)" end="(302, 41)" name="find?_eq_some_iff_getElem" full_name="Vector.find?_eq_some_iff_getElem">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(299, 1)" end="(302, 41)" name="find?_eq_some_iff_getElem" full_name="Vector.find?_eq_some_iff_getElem" _is_private_decl="False">
        <AtomNode start="(299, 1)" end="(299, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(299, 9)" end="(299, 34)">
          <IdentNode start="(299, 9)" end="(299, 34)" leading="" trailing=" " raw_val="find?_eq_some_iff_getElem" val="find?_eq_some_iff_getElem"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(299, 35)" end="(300, 86)">
          <NullNode start="(299, 35)" end="(299, 75)">
            <OtherNode start="(299, 35)" end="(299, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(299, 35)" end="(299, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(299, 36)" end="(299, 38)">
                <IdentNode start="(299, 36)" end="(299, 38)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(299, 39)" end="(299, 51)">
                <AtomNode start="(299, 39)" end="(299, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(299, 41)" end="(299, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(299, 41)" end="(299, 47)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(299, 48)" end="(299, 51)">
                    <IdentNode start="(299, 48)" end="(299, 49)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(299, 50)" end="(299, 51)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(299, 51)" end="(299, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(299, 53)" end="(299, 67)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(299, 53)" end="(299, 54)" leading="" trailing="" val="{"/>
              <NullNode start="(299, 54)" end="(299, 55)">
                <IdentNode start="(299, 54)" end="(299, 55)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(299, 56)" end="(299, 66)">
                <AtomNode start="(299, 56)" end="(299, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(299, 58)" end="(299, 66)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(299, 58)" end="(299, 59)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(299, 60)" end="(299, 61)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(299, 62)" end="(299, 66)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(299, 66)" end="(299, 67)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(299, 68)" end="(299, 75)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(299, 68)" end="(299, 69)" leading="" trailing="" val="{"/>
              <NullNode start="(299, 69)" end="(299, 70)">
                <IdentNode start="(299, 69)" end="(299, 70)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(299, 71)" end="(299, 74)">
                <AtomNode start="(299, 71)" end="(299, 72)" leading="" trailing=" " val=":"/>
                <IdentNode start="(299, 73)" end="(299, 74)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(299, 74)" end="(299, 75)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(299, 76)" end="(300, 86)">
            <AtomNode start="(299, 76)" end="(299, 77)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(300, 5)" end="(300, 86)" kind="«term_↔_»">
              <OtherNode start="(300, 5)" end="(300, 24)" kind="«term_=_»">
                <OtherNode start="(300, 5)" end="(300, 15)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(300, 5)" end="(300, 13)" leading="" trailing=" " raw_val="xs.find?" val="xs.find?"/>
                  <NullNode start="(300, 14)" end="(300, 15)">
                    <IdentNode start="(300, 14)" end="(300, 15)" leading="" trailing=" " raw_val="p" val="p"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(300, 16)" end="(300, 17)" leading="" trailing=" " val="="/>
                <OtherNode start="(300, 18)" end="(300, 24)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(300, 18)" end="(300, 22)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(300, 23)" end="(300, 24)">
                    <IdentNode start="(300, 23)" end="(300, 24)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(300, 25)" end="(300, 26)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(300, 27)" end="(300, 86)" kind="«term_∧_»">
                <OtherNode start="(300, 27)" end="(300, 30)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(300, 27)" end="(300, 28)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(300, 29)" end="(300, 30)">
                    <IdentNode start="(300, 29)" end="(300, 30)" leading="" trailing=" " raw_val="b" val="b"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(300, 31)" end="(300, 32)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(300, 33)" end="(300, 86)" kind="«term∃_,_»">
                  <AtomNode start="(300, 33)" end="(300, 34)" leading="" trailing=" " val="∃"/>
                  <OtherNode start="(300, 35)" end="(300, 38)" kind="Lean.explicitBinders">
                    <OtherNode start="(300, 35)" end="(300, 38)" kind="Lean.unbracketedExplicitBinders">
                      <NullNode start="(300, 35)" end="(300, 38)">
                        <LeanBinderidentNode start="(300, 35)" end="(300, 36)">
                          <IdentNode start="(300, 35)" end="(300, 36)" leading="" trailing=" " raw_val="i" val="i"/>
                        </LeanBinderidentNode>
                        <LeanBinderidentNode start="(300, 37)" end="(300, 38)">
                          <IdentNode start="(300, 37)" end="(300, 38)" leading="" trailing="" raw_val="h" val="h"/>
                        </LeanBinderidentNode>
                      </NullNode>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(300, 38)" end="(300, 39)" leading="" trailing=" " val=","/>
                  <OtherNode start="(300, 40)" end="(300, 86)" kind="«term_∧_»">
                    <OtherNode start="(300, 40)" end="(300, 49)" kind="«term_=_»">
                      <OtherNode start="(300, 40)" end="(300, 45)" kind="«term__[_]»">
                        <IdentNode start="(300, 40)" end="(300, 42)" leading="" trailing="" raw_val="xs" val="xs"/>
                        <AtomNode start="(300, 42)" end="(300, 43)" leading="" trailing="" val="["/>
                        <IdentNode start="(300, 43)" end="(300, 44)" leading="" trailing="" raw_val="i" val="i"/>
                        <AtomNode start="(300, 44)" end="(300, 45)" leading="" trailing=" " val="]"/>
                      </OtherNode>
                      <AtomNode start="(300, 46)" end="(300, 47)" leading="" trailing=" " val="="/>
                      <IdentNode start="(300, 48)" end="(300, 49)" leading="" trailing=" " raw_val="b" val="b"/>
                    </OtherNode>
                    <AtomNode start="(300, 50)" end="(300, 51)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(300, 52)" end="(300, 86)" kind="Lean.Parser.Term.forall">
                      <AtomNode start="(300, 52)" end="(300, 53)" leading="" trailing=" " val="∀"/>
                      <NullNode start="(300, 54)" end="(300, 55)">
                        <IdentNode start="(300, 54)" end="(300, 55)" leading="" trailing=" " raw_val="j" val="j"/>
                      </NullNode>
                      <NullNode start="(300, 56)" end="(300, 61)">
                        <TermTypespecNode start="(300, 56)" end="(300, 61)">
                          <AtomNode start="(300, 56)" end="(300, 57)" leading="" trailing=" " val=":"/>
                          <IdentNode start="(300, 58)" end="(300, 61)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        </TermTypespecNode>
                      </NullNode>
                      <AtomNode start="(300, 61)" end="(300, 62)" leading="" trailing=" " val=","/>
                      <OtherNode start="(300, 63)" end="(300, 86)" kind="Lean.Parser.Term.depArrow">
                        <TermExplicitbinderNode start="(300, 63)" end="(300, 75)">
                          <AtomNode start="(300, 63)" end="(300, 64)" leading="" trailing="" val="("/>
                          <NullNode start="(300, 64)" end="(300, 66)">
                            <IdentNode start="(300, 64)" end="(300, 66)" leading="" trailing=" " raw_val="hj" val="hj"/>
                          </NullNode>
                          <NullNode start="(300, 67)" end="(300, 74)">
                            <AtomNode start="(300, 67)" end="(300, 68)" leading="" trailing=" " val=":"/>
                            <OtherNode start="(300, 69)" end="(300, 74)" kind="«term_&amp;lt;_»">
                              <IdentNode start="(300, 69)" end="(300, 70)" leading="" trailing=" " raw_val="j" val="j"/>
                              <AtomNode start="(300, 71)" end="(300, 72)" leading="" trailing=" " val="&amp;lt;"/>
                              <IdentNode start="(300, 73)" end="(300, 74)" leading="" trailing="" raw_val="i" val="i"/>
                            </OtherNode>
                          </NullNode>
                          <NullNode/>
                          <AtomNode start="(300, 74)" end="(300, 75)" leading="" trailing=" " val=")"/>
                        </TermExplicitbinderNode>
                        <AtomNode start="(300, 76)" end="(300, 77)" leading="" trailing=" " val="→"/>
                        <OtherNode start="(300, 78)" end="(300, 86)" kind="term!_">
                          <AtomNode start="(300, 78)" end="(300, 79)" leading="" trailing="" val="!"/>
                          <OtherNode start="(300, 79)" end="(300, 86)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(300, 79)" end="(300, 80)" leading="" trailing=" " raw_val="p" val="p"/>
                            <NullNode start="(300, 81)" end="(300, 86)">
                              <OtherNode start="(300, 81)" end="(300, 86)" kind="«term__[_]»">
                                <IdentNode start="(300, 81)" end="(300, 83)" leading="" trailing="" raw_val="xs" val="xs"/>
                                <AtomNode start="(300, 83)" end="(300, 84)" leading="" trailing="" val="["/>
                                <IdentNode start="(300, 84)" end="(300, 85)" leading="" trailing="" raw_val="j" val="j"/>
                                <AtomNode start="(300, 85)" end="(300, 86)" leading="" trailing=" " val="]"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(300, 87)" end="(302, 41)">
          <AtomNode start="(300, 87)" end="(300, 89)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(300, 90)" end="(302, 41)">
            <AtomNode start="(300, 90)" end="(300, 92)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(301, 3)" end="(302, 41)">
              <TacticTacticseq1IndentedNode start="(301, 3)" end="(302, 41)">
                <NullNode start="(301, 3)" end="(302, 41)">
                  <OtherNode start="(301, 3)" end="(301, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type&#10;n : Nat&#10;xs : Vector α n&#10;p : α → Bool&#10;b : α&#10;⊢ find? p xs = some b ↔ p b = true ∧ ∃ i h, xs[i] = b ∧ ∀ (j : Nat) (hj : j &amp;lt; i), (!p xs[j]) = true" state_after="case mk&#10;α : Type&#10;p : α → Bool&#10;b : α&#10;xs : Array α&#10;⊢ find? p { toArray := xs, size_toArray := ⋯ } = some b ↔&#10;    p b = true ∧&#10;      ∃ i h,&#10;        { toArray := xs, size_toArray := ⋯ }[i] = b ∧&#10;          ∀ (j : Nat) (hj : j &amp;lt; i), (!p { toArray := xs, size_toArray := ⋯ }[j]) = true" tactic="rcases xs with ⟨xs, rfl⟩">
                    <AtomNode start="(301, 3)" end="(301, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(301, 10)" end="(301, 12)">
                      <OtherNode start="(301, 10)" end="(301, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(301, 10)" end="(301, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(301, 13)" end="(301, 27)">
                      <AtomNode start="(301, 13)" end="(301, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(301, 18)" end="(301, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(301, 18)" end="(301, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(301, 18)" end="(301, 27)">
                            <OtherNode start="(301, 18)" end="(301, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(301, 18)" end="(301, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(301, 19)" end="(301, 26)">
                                <OtherNode start="(301, 19)" end="(301, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(301, 19)" end="(301, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(301, 19)" end="(301, 21)">
                                      <OtherNode start="(301, 19)" end="(301, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(301, 19)" end="(301, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(301, 21)" end="(301, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(301, 23)" end="(301, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(301, 23)" end="(301, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(301, 23)" end="(301, 26)">
                                      <OtherNode start="(301, 23)" end="(301, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(301, 23)" end="(301, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(301, 26)" end="(301, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(302, 3)" end="(302, 41)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type&#10;p : α → Bool&#10;b : α&#10;xs : Array α&#10;⊢ find? p { toArray := xs, size_toArray := ⋯ } = some b ↔&#10;    p b = true ∧&#10;      ∃ i h,&#10;        { toArray := xs, size_toArray := ⋯ }[i] = b ∧&#10;          ∀ (j : Nat) (hj : j &amp;lt; i), (!p { toArray := xs, size_toArray := ⋯ }[j]) = true" state_after="no goals" tactic="simp [Array.find?_eq_some_iff_getElem]">
                    <AtomNode start="(302, 3)" end="(302, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(302, 8)" end="(302, 41)">
                      <AtomNode start="(302, 8)" end="(302, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(302, 9)" end="(302, 40)">
                        <OtherNode start="(302, 9)" end="(302, 40)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(302, 9)" end="(302, 40)" leading="" trailing="" raw_val="Array.find?_eq_some_iff_getElem" val="Array.find?_eq_some_iff_getElem" full_name="Array.find?_eq_some_iff_getElem" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(302, 40)" end="(302, 41)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(304, 1)" end="(304, 23)" comment="### findFinIdx? -/">
      <AtomNode start="(304, 1)" end="(304, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(304, 5)" end="(304, 23)" leading="" trailing="&#10;&#10;" val="### findFinIdx? -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(306, 1)" end="(306, 103)" name="findFinIdx?_empty" full_name="Vector.findFinIdx?_empty">
      <CommandDeclmodifiersNode start="(306, 1)" end="(306, 8)">
        <NullNode/>
        <NullNode start="(306, 1)" end="(306, 8)">
          <OtherNode start="(306, 1)" end="(306, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(306, 1)" end="(306, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(306, 3)" end="(306, 7)">
              <OtherNode start="(306, 3)" end="(306, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(306, 3)" end="(306, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(306, 3)" end="(306, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(306, 7)" end="(306, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(306, 9)" end="(306, 103)" name="findFinIdx?_empty" full_name="Vector.findFinIdx?_empty" _is_private_decl="False">
        <AtomNode start="(306, 9)" end="(306, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(306, 17)" end="(306, 34)">
          <IdentNode start="(306, 17)" end="(306, 34)" leading="" trailing=" " raw_val="findFinIdx?_empty" val="findFinIdx?_empty"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(306, 35)" end="(306, 92)">
          <NullNode start="(306, 35)" end="(306, 49)">
            <OtherNode start="(306, 35)" end="(306, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(306, 35)" end="(306, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(306, 36)" end="(306, 37)">
                <IdentNode start="(306, 36)" end="(306, 37)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(306, 38)" end="(306, 48)">
                <AtomNode start="(306, 38)" end="(306, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(306, 40)" end="(306, 48)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(306, 40)" end="(306, 41)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(306, 42)" end="(306, 43)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(306, 44)" end="(306, 48)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(306, 48)" end="(306, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(306, 50)" end="(306, 92)">
            <AtomNode start="(306, 50)" end="(306, 51)" leading="" trailing=" " val=":"/>
            <OtherNode start="(306, 52)" end="(306, 92)" kind="«term_=_»">
              <OtherNode start="(306, 52)" end="(306, 85)" kind="Lean.Parser.Term.app">
                <IdentNode start="(306, 52)" end="(306, 63)" leading="" trailing=" " raw_val="findFinIdx?" val="findFinIdx?" full_name="Vector.findFinIdx?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(306, 64)" end="(306, 85)">
                  <IdentNode start="(306, 64)" end="(306, 65)" leading="" trailing=" " raw_val="p" val="p"/>
                  <OtherNode start="(306, 66)" end="(306, 85)" kind="Lean.Parser.Term.typeAscription">
                    <AtomNode start="(306, 66)" end="(306, 67)" leading="" trailing="" val="("/>
                    <OtherNode start="(306, 67)" end="(306, 71)" kind="Vector.«term#v[_,]»">
                      <AtomNode start="(306, 67)" end="(306, 70)" leading="" trailing="" val="#v["/>
                      <NullNode/>
                      <AtomNode start="(306, 70)" end="(306, 71)" leading="" trailing=" " val="]"/>
                    </OtherNode>
                    <AtomNode start="(306, 72)" end="(306, 73)" leading="" trailing=" " val=":"/>
                    <NullNode start="(306, 74)" end="(306, 84)">
                      <OtherNode start="(306, 74)" end="(306, 84)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(306, 74)" end="(306, 80)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                        <NullNode start="(306, 81)" end="(306, 84)">
                          <IdentNode start="(306, 81)" end="(306, 82)" leading="" trailing=" " raw_val="α" val="α"/>
                          <OtherNode start="(306, 83)" end="(306, 84)" kind="num">
                            <AtomNode start="(306, 83)" end="(306, 84)" leading="" trailing="" val="0"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(306, 84)" end="(306, 85)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(306, 86)" end="(306, 87)" leading="" trailing=" " val="="/>
              <IdentNode start="(306, 88)" end="(306, 92)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(306, 93)" end="(306, 103)">
          <AtomNode start="(306, 93)" end="(306, 95)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(306, 96)" end="(306, 103)">
            <AtomNode start="(306, 96)" end="(306, 98)" leading="" trailing=" " val="by"/>
            <TacticTacticseqNode start="(306, 99)" end="(306, 103)">
              <TacticTacticseq1IndentedNode start="(306, 99)" end="(306, 103)">
                <NullNode start="(306, 99)" end="(306, 103)">
                  <OtherNode start="(306, 99)" end="(306, 103)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;p : α → Bool&#10;⊢ findFinIdx? p { toArray := #[], size_toArray := ⋯ } = none" state_after="no goals" tactic="simp">
                    <AtomNode start="(306, 99)" end="(306, 103)" leading="" trailing="&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(307, 1)" end="(309, 7)" name="findFinIdx?_singleton" full_name="Vector.findFinIdx?_singleton">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(307, 1)" end="(309, 7)" name="findFinIdx?_singleton" full_name="Vector.findFinIdx?_singleton" _is_private_decl="False">
        <AtomNode start="(307, 1)" end="(307, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(307, 9)" end="(307, 30)">
          <IdentNode start="(307, 9)" end="(307, 30)" leading="" trailing=" " raw_val="findFinIdx?_singleton" val="findFinIdx?_singleton"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(307, 31)" end="(308, 65)">
          <NullNode start="(307, 31)" end="(307, 53)">
            <OtherNode start="(307, 31)" end="(307, 38)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(307, 31)" end="(307, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(307, 32)" end="(307, 33)">
                <IdentNode start="(307, 32)" end="(307, 33)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(307, 34)" end="(307, 37)">
                <AtomNode start="(307, 34)" end="(307, 35)" leading="" trailing=" " val=":"/>
                <IdentNode start="(307, 36)" end="(307, 37)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(307, 37)" end="(307, 38)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(307, 39)" end="(307, 53)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(307, 39)" end="(307, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(307, 40)" end="(307, 41)">
                <IdentNode start="(307, 40)" end="(307, 41)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(307, 42)" end="(307, 52)">
                <AtomNode start="(307, 42)" end="(307, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(307, 44)" end="(307, 52)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(307, 44)" end="(307, 45)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(307, 46)" end="(307, 47)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(307, 48)" end="(307, 52)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(307, 52)" end="(307, 53)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(307, 54)" end="(308, 65)">
            <AtomNode start="(307, 54)" end="(307, 55)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(308, 5)" end="(308, 65)" kind="«term_=_»">
              <OtherNode start="(308, 5)" end="(308, 23)" kind="Lean.Parser.Term.app">
                <OtherNode start="(308, 5)" end="(308, 21)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(308, 5)" end="(308, 9)" kind="«term#[_,]»">
                    <AtomNode start="(308, 5)" end="(308, 7)" leading="" trailing="" val="#["/>
                    <NullNode start="(308, 7)" end="(308, 8)">
                      <IdentNode start="(308, 7)" end="(308, 8)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                    <AtomNode start="(308, 8)" end="(308, 9)" leading="" trailing="" val="]"/>
                  </OtherNode>
                  <AtomNode start="(308, 9)" end="(308, 10)" leading="" trailing="" val="."/>
                  <IdentNode start="(308, 10)" end="(308, 21)" leading="" trailing=" " raw_val="findFinIdx?" val="findFinIdx?" full_name="Array.findFinIdx?" mod_name="Init.Data.Array.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Basic.lean"/>
                </OtherNode>
                <NullNode start="(308, 22)" end="(308, 23)">
                  <IdentNode start="(308, 22)" end="(308, 23)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(308, 24)" end="(308, 25)" leading="" trailing=" " val="="/>
              <OtherNode start="(308, 26)" end="(308, 65)" kind="termIfThenElse">
                <AtomNode start="(308, 26)" end="(308, 28)" leading="" trailing=" " val="if"/>
                <OtherNode start="(308, 29)" end="(308, 32)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(308, 29)" end="(308, 30)" leading="" trailing=" " raw_val="p" val="p"/>
                  <NullNode start="(308, 31)" end="(308, 32)">
                    <IdentNode start="(308, 31)" end="(308, 32)" leading="" trailing=" " raw_val="a" val="a"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(308, 33)" end="(308, 37)" leading="" trailing=" " val="then"/>
                <OtherNode start="(308, 38)" end="(308, 55)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(308, 38)" end="(308, 42)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(308, 43)" end="(308, 55)">
                    <OtherNode start="(308, 43)" end="(308, 55)" kind="Lean.Parser.Term.anonymousCtor">
                      <AtomNode start="(308, 43)" end="(308, 44)" leading="" trailing="" val="⟨"/>
                      <NullNode start="(308, 44)" end="(308, 54)">
                        <OtherNode start="(308, 44)" end="(308, 45)" kind="num">
                          <AtomNode start="(308, 44)" end="(308, 45)" leading="" trailing="" val="0"/>
                        </OtherNode>
                        <AtomNode start="(308, 45)" end="(308, 46)" leading="" trailing=" " val=","/>
                        <TermBytacticNode start="(308, 47)" end="(308, 54)">
                          <AtomNode start="(308, 47)" end="(308, 49)" leading="" trailing=" " val="by"/>
                          <TacticTacticseqNode start="(308, 50)" end="(308, 54)">
                            <TacticTacticseq1IndentedNode start="(308, 50)" end="(308, 54)">
                              <NullNode start="(308, 50)" end="(308, 54)">
                                <OtherNode start="(308, 50)" end="(308, 54)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.55862&#10;a : α&#10;p : α → Bool&#10;⊢ 0 &amp;lt; #[a].size" state_after="no goals" tactic="simp">
                                  <AtomNode start="(308, 50)" end="(308, 54)" leading="" trailing="" val="simp"/>
                                  <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                    <NullNode/>
                                  </OtherNode>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </TermBytacticNode>
                      </NullNode>
                      <AtomNode start="(308, 54)" end="(308, 55)" leading="" trailing=" " val="⟩"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(308, 56)" end="(308, 60)" leading="" trailing=" " val="else"/>
                <IdentNode start="(308, 61)" end="(308, 65)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(308, 66)" end="(309, 7)">
          <AtomNode start="(308, 66)" end="(308, 68)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(308, 69)" end="(309, 7)">
            <AtomNode start="(308, 69)" end="(308, 71)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(309, 3)" end="(309, 7)">
              <TacticTacticseq1IndentedNode start="(309, 3)" end="(309, 7)">
                <NullNode start="(309, 3)" end="(309, 7)">
                  <OtherNode start="(309, 3)" end="(309, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;a : α&#10;p : α → Bool&#10;⊢ Array.findFinIdx? p #[a] = if p a = true then some ⟨0, ⋯⟩ else none" state_after="no goals" tactic="simp">
                    <AtomNode start="(309, 3)" end="(309, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(311, 1)" end="(314, 7)" name="findFinIdx?_congr" full_name="Vector.findFinIdx?_congr">
      <CommandDeclmodifiersNode start="(311, 1)" end="(311, 9)">
        <NullNode/>
        <NullNode start="(311, 1)" end="(311, 9)">
          <OtherNode start="(311, 1)" end="(311, 9)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(311, 1)" end="(311, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(311, 3)" end="(311, 8)">
              <OtherNode start="(311, 3)" end="(311, 8)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(311, 3)" end="(311, 8)" kind="Lean.Parser.Attr.simple">
                  <IdentNode start="(311, 3)" end="(311, 8)" leading="" trailing="" raw_val="congr" val="congr"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(311, 8)" end="(311, 9)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(311, 10)" end="(314, 7)" name="findFinIdx?_congr" full_name="Vector.findFinIdx?_congr" _is_private_decl="False">
        <AtomNode start="(311, 10)" end="(311, 17)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(311, 18)" end="(311, 35)">
          <IdentNode start="(311, 18)" end="(311, 35)" leading="" trailing=" " raw_val="findFinIdx?_congr" val="findFinIdx?_congr"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(311, 36)" end="(312, 40)">
          <NullNode start="(311, 36)" end="(311, 100)">
            <OtherNode start="(311, 36)" end="(311, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(311, 36)" end="(311, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(311, 37)" end="(311, 38)">
                <IdentNode start="(311, 37)" end="(311, 38)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(311, 39)" end="(311, 49)">
                <AtomNode start="(311, 39)" end="(311, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(311, 41)" end="(311, 49)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(311, 41)" end="(311, 42)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(311, 43)" end="(311, 44)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(311, 45)" end="(311, 49)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(311, 49)" end="(311, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(311, 51)" end="(311, 68)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(311, 51)" end="(311, 52)" leading="" trailing="" val="{"/>
              <NullNode start="(311, 52)" end="(311, 54)">
                <IdentNode start="(311, 52)" end="(311, 54)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(311, 55)" end="(311, 67)">
                <AtomNode start="(311, 55)" end="(311, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(311, 57)" end="(311, 67)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(311, 57)" end="(311, 63)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(311, 64)" end="(311, 67)">
                    <IdentNode start="(311, 64)" end="(311, 65)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(311, 66)" end="(311, 67)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(311, 67)" end="(311, 68)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(311, 69)" end="(311, 86)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(311, 69)" end="(311, 70)" leading="" trailing="" val="{"/>
              <NullNode start="(311, 70)" end="(311, 72)">
                <IdentNode start="(311, 70)" end="(311, 72)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(311, 73)" end="(311, 85)">
                <AtomNode start="(311, 73)" end="(311, 74)" leading="" trailing=" " val=":"/>
                <OtherNode start="(311, 75)" end="(311, 85)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(311, 75)" end="(311, 81)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(311, 82)" end="(311, 85)">
                    <IdentNode start="(311, 82)" end="(311, 83)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(311, 84)" end="(311, 85)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(311, 85)" end="(311, 86)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(311, 87)" end="(311, 100)">
              <AtomNode start="(311, 87)" end="(311, 88)" leading="" trailing="" val="("/>
              <NullNode start="(311, 88)" end="(311, 89)">
                <IdentNode start="(311, 88)" end="(311, 89)" leading="" trailing=" " raw_val="w" val="w"/>
              </NullNode>
              <NullNode start="(311, 90)" end="(311, 99)">
                <AtomNode start="(311, 90)" end="(311, 91)" leading="" trailing=" " val=":"/>
                <OtherNode start="(311, 92)" end="(311, 99)" kind="«term_=_»">
                  <IdentNode start="(311, 92)" end="(311, 94)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <AtomNode start="(311, 95)" end="(311, 96)" leading="" trailing=" " val="="/>
                  <IdentNode start="(311, 97)" end="(311, 99)" leading="" trailing="" raw_val="ys" val="ys"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(311, 99)" end="(311, 100)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(311, 101)" end="(312, 40)">
            <AtomNode start="(311, 101)" end="(311, 102)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(312, 5)" end="(312, 40)" kind="«term_=_»">
              <OtherNode start="(312, 5)" end="(312, 21)" kind="Lean.Parser.Term.app">
                <IdentNode start="(312, 5)" end="(312, 16)" leading="" trailing=" " raw_val="findFinIdx?" val="findFinIdx?" full_name="Vector.findFinIdx?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(312, 17)" end="(312, 21)">
                  <IdentNode start="(312, 17)" end="(312, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                  <IdentNode start="(312, 19)" end="(312, 21)" leading="" trailing=" " raw_val="xs" val="xs"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(312, 22)" end="(312, 23)" leading="" trailing=" " val="="/>
              <OtherNode start="(312, 24)" end="(312, 40)" kind="Lean.Parser.Term.app">
                <IdentNode start="(312, 24)" end="(312, 35)" leading="" trailing=" " raw_val="findFinIdx?" val="findFinIdx?" full_name="Vector.findFinIdx?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(312, 36)" end="(312, 40)">
                  <IdentNode start="(312, 36)" end="(312, 37)" leading="" trailing=" " raw_val="p" val="p"/>
                  <IdentNode start="(312, 38)" end="(312, 40)" leading="" trailing=" " raw_val="ys" val="ys"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(312, 41)" end="(314, 7)">
          <AtomNode start="(312, 41)" end="(312, 43)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(312, 44)" end="(314, 7)">
            <AtomNode start="(312, 44)" end="(312, 46)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(313, 3)" end="(314, 7)">
              <TacticTacticseq1IndentedNode start="(313, 3)" end="(314, 7)">
                <NullNode start="(313, 3)" end="(314, 7)">
                  <OtherNode start="(313, 3)" end="(313, 10)" kind="Lean.Parser.Tactic.subst" state_before="α : Type u_1&#10;n : Nat&#10;p : α → Bool&#10;xs ys : Vector α n&#10;w : xs = ys&#10;⊢ findFinIdx? p xs = findFinIdx? p ys" state_after="α : Type u_1&#10;n : Nat&#10;p : α → Bool&#10;xs : Vector α n&#10;⊢ findFinIdx? p xs = findFinIdx? p xs" tactic="subst w">
                    <AtomNode start="(313, 3)" end="(313, 8)" leading="" trailing=" " val="subst"/>
                    <NullNode start="(313, 9)" end="(313, 10)">
                      <IdentNode start="(313, 9)" end="(313, 10)" leading="" trailing="&#10;  " raw_val="w" val="w"/>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(314, 3)" end="(314, 7)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;n : Nat&#10;p : α → Bool&#10;xs : Vector α n&#10;⊢ findFinIdx? p xs = findFinIdx? p xs" state_after="no goals" tactic="simp">
                    <AtomNode start="(314, 3)" end="(314, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(316, 1)" end="(321, 8)" name="findFinIdx?_push" full_name="Vector.findFinIdx?_push">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(316, 1)" end="(321, 8)" name="findFinIdx?_push" full_name="Vector.findFinIdx?_push" _is_private_decl="False">
        <AtomNode start="(316, 1)" end="(316, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(316, 9)" end="(316, 25)">
          <IdentNode start="(316, 9)" end="(316, 25)" leading="" trailing=" " raw_val="findFinIdx?_push" val="findFinIdx?_push"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(316, 26)" end="(318, 89)">
          <NullNode start="(316, 26)" end="(316, 66)">
            <OtherNode start="(316, 26)" end="(316, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(316, 26)" end="(316, 27)" leading="" trailing="" val="{"/>
              <NullNode start="(316, 27)" end="(316, 29)">
                <IdentNode start="(316, 27)" end="(316, 29)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(316, 30)" end="(316, 42)">
                <AtomNode start="(316, 30)" end="(316, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(316, 32)" end="(316, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(316, 32)" end="(316, 38)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(316, 39)" end="(316, 42)">
                    <IdentNode start="(316, 39)" end="(316, 40)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(316, 41)" end="(316, 42)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(316, 42)" end="(316, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(316, 44)" end="(316, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(316, 44)" end="(316, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(316, 45)" end="(316, 46)">
                <IdentNode start="(316, 45)" end="(316, 46)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(316, 47)" end="(316, 50)">
                <AtomNode start="(316, 47)" end="(316, 48)" leading="" trailing=" " val=":"/>
                <IdentNode start="(316, 49)" end="(316, 50)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(316, 50)" end="(316, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(316, 52)" end="(316, 66)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(316, 52)" end="(316, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(316, 53)" end="(316, 54)">
                <IdentNode start="(316, 53)" end="(316, 54)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(316, 55)" end="(316, 65)">
                <AtomNode start="(316, 55)" end="(316, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(316, 57)" end="(316, 65)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(316, 57)" end="(316, 58)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(316, 59)" end="(316, 60)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(316, 61)" end="(316, 65)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(316, 65)" end="(316, 66)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(316, 67)" end="(318, 89)">
            <AtomNode start="(316, 67)" end="(316, 68)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(317, 5)" end="(318, 89)" kind="«term_=_»">
              <OtherNode start="(317, 5)" end="(317, 30)" kind="Lean.Parser.Term.app">
                <OtherNode start="(317, 5)" end="(317, 28)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(317, 5)" end="(317, 16)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(317, 5)" end="(317, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(317, 6)" end="(317, 15)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(317, 6)" end="(317, 13)" leading="" trailing=" " raw_val="xs.push" val="xs.push"/>
                      <NullNode start="(317, 14)" end="(317, 15)">
                        <IdentNode start="(317, 14)" end="(317, 15)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(317, 15)" end="(317, 16)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(317, 16)" end="(317, 17)" leading="" trailing="" val="."/>
                  <IdentNode start="(317, 17)" end="(317, 28)" leading="" trailing=" " raw_val="findFinIdx?" val="findFinIdx?" full_name="Vector.findFinIdx?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                </OtherNode>
                <NullNode start="(317, 29)" end="(317, 30)">
                  <IdentNode start="(317, 29)" end="(317, 30)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(317, 31)" end="(317, 32)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(318, 7)" end="(318, 89)" kind="Lean.Parser.Term.app">
                <OtherNode start="(318, 7)" end="(318, 47)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(318, 7)" end="(318, 44)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(318, 7)" end="(318, 8)" leading="" trailing="" val="("/>
                    <OtherNode start="(318, 8)" end="(318, 43)" kind="Lean.Parser.Term.app">
                      <OtherNode start="(318, 8)" end="(318, 30)" kind="Lean.Parser.Term.proj">
                        <OtherNode start="(318, 8)" end="(318, 26)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(318, 8)" end="(318, 9)" leading="" trailing="" val="("/>
                          <OtherNode start="(318, 9)" end="(318, 25)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(318, 9)" end="(318, 23)" leading="" trailing=" " raw_val="xs.findFinIdx?" val="xs.findFinIdx?"/>
                            <NullNode start="(318, 24)" end="(318, 25)">
                              <IdentNode start="(318, 24)" end="(318, 25)" leading="" trailing="" raw_val="p" val="p"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(318, 25)" end="(318, 26)" leading="" trailing="" val=")"/>
                        </OtherNode>
                        <AtomNode start="(318, 26)" end="(318, 27)" leading="" trailing="" val="."/>
                        <IdentNode start="(318, 27)" end="(318, 30)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </OtherNode>
                      <NullNode start="(318, 31)" end="(318, 43)">
                        <IdentNode start="(318, 31)" end="(318, 43)" leading="" trailing="" raw_val="Fin.castSucc" val="Fin.castSucc" full_name="Fin.castSucc" mod_name="Init.Data.Fin.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Fin/Basic.lean"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(318, 43)" end="(318, 44)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(318, 44)" end="(318, 45)" leading="" trailing="" val="."/>
                  <IdentNode start="(318, 45)" end="(318, 47)" leading="" trailing=" " raw_val="or" val="or" full_name="Option.or" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(318, 48)" end="(318, 89)">
                  <OtherNode start="(318, 48)" end="(318, 89)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(318, 48)" end="(318, 49)" leading="" trailing="" val="("/>
                    <OtherNode start="(318, 49)" end="(318, 88)" kind="termIfThenElse">
                      <AtomNode start="(318, 49)" end="(318, 51)" leading="" trailing=" " val="if"/>
                      <OtherNode start="(318, 52)" end="(318, 55)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(318, 52)" end="(318, 53)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(318, 54)" end="(318, 55)">
                          <IdentNode start="(318, 54)" end="(318, 55)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(318, 56)" end="(318, 60)" leading="" trailing=" " val="then"/>
                      <OtherNode start="(318, 61)" end="(318, 78)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(318, 61)" end="(318, 65)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(318, 66)" end="(318, 78)">
                          <OtherNode start="(318, 66)" end="(318, 78)" kind="Lean.Parser.Term.anonymousCtor">
                            <AtomNode start="(318, 66)" end="(318, 67)" leading="" trailing="" val="⟨"/>
                            <NullNode start="(318, 67)" end="(318, 77)">
                              <IdentNode start="(318, 67)" end="(318, 68)" leading="" trailing="" raw_val="n" val="n"/>
                              <AtomNode start="(318, 68)" end="(318, 69)" leading="" trailing=" " val=","/>
                              <TermBytacticNode start="(318, 70)" end="(318, 77)">
                                <AtomNode start="(318, 70)" end="(318, 72)" leading="" trailing=" " val="by"/>
                                <TacticTacticseqNode start="(318, 73)" end="(318, 77)">
                                  <TacticTacticseq1IndentedNode start="(318, 73)" end="(318, 77)">
                                    <NullNode start="(318, 73)" end="(318, 77)">
                                      <OtherNode start="(318, 73)" end="(318, 77)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.56744&#10;n : Nat&#10;xs : Vector α n&#10;a : α&#10;p : α → Bool&#10;⊢ n &amp;lt; n + 1" state_after="no goals" tactic="simp">
                                        <AtomNode start="(318, 73)" end="(318, 77)" leading="" trailing="" val="simp"/>
                                        <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                          <NullNode/>
                                        </OtherNode>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                        <NullNode/>
                                      </OtherNode>
                                    </NullNode>
                                  </TacticTacticseq1IndentedNode>
                                </TacticTacticseqNode>
                              </TermBytacticNode>
                            </NullNode>
                            <AtomNode start="(318, 77)" end="(318, 78)" leading="" trailing=" " val="⟩"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(318, 79)" end="(318, 83)" leading="" trailing=" " val="else"/>
                      <IdentNode start="(318, 84)" end="(318, 88)" leading="" trailing="" raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                    <AtomNode start="(318, 88)" end="(318, 89)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(318, 90)" end="(321, 8)">
          <AtomNode start="(318, 90)" end="(318, 92)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(318, 93)" end="(321, 8)">
            <AtomNode start="(318, 93)" end="(318, 95)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(319, 3)" end="(321, 8)">
              <TacticTacticseq1IndentedNode start="(319, 3)" end="(321, 8)">
                <NullNode start="(319, 3)" end="(321, 8)">
                  <OtherNode start="(319, 3)" end="(319, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;n : Nat&#10;xs : Vector α n&#10;a : α&#10;p : α → Bool&#10;⊢ findFinIdx? p (xs.push a) = (Option.map Fin.castSucc (findFinIdx? p xs)).or (if p a = true then some ⟨n, ⋯⟩ else none)" state_after="case mk&#10;α : Type u_1&#10;a : α&#10;p : α → Bool&#10;xs : Array α&#10;⊢ findFinIdx? p ({ toArray := xs, size_toArray := ⋯ }.push a) =&#10;    (Option.map Fin.castSucc (findFinIdx? p { toArray := xs, size_toArray := ⋯ })).or&#10;      (if p a = true then some ⟨xs.size, ⋯⟩ else none)" tactic="rcases xs with ⟨xs, rfl⟩">
                    <AtomNode start="(319, 3)" end="(319, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(319, 10)" end="(319, 12)">
                      <OtherNode start="(319, 10)" end="(319, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(319, 10)" end="(319, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(319, 13)" end="(319, 27)">
                      <AtomNode start="(319, 13)" end="(319, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(319, 18)" end="(319, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(319, 18)" end="(319, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(319, 18)" end="(319, 27)">
                            <OtherNode start="(319, 18)" end="(319, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(319, 18)" end="(319, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(319, 19)" end="(319, 26)">
                                <OtherNode start="(319, 19)" end="(319, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(319, 19)" end="(319, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(319, 19)" end="(319, 21)">
                                      <OtherNode start="(319, 19)" end="(319, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(319, 19)" end="(319, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(319, 21)" end="(319, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(319, 23)" end="(319, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(319, 23)" end="(319, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(319, 23)" end="(319, 26)">
                                      <OtherNode start="(319, 23)" end="(319, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(319, 23)" end="(319, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(319, 26)" end="(319, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(320, 3)" end="(320, 66)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;a : α&#10;p : α → Bool&#10;xs : Array α&#10;⊢ findFinIdx? p ({ toArray := xs, size_toArray := ⋯ }.push a) =&#10;    (Option.map Fin.castSucc (findFinIdx? p { toArray := xs, size_toArray := ⋯ })).or&#10;      (if p a = true then some ⟨xs.size, ⋯⟩ else none)" state_after="case mk&#10;α : Type u_1&#10;a : α&#10;p : α → Bool&#10;xs : Array α&#10;⊢ (Option.map (fun x =&amp;gt; Fin.castLE ⋯ x) (Array.findFinIdx? p xs)).or (if p a = true then some ⟨xs.size, ⋯⟩ else none) =&#10;    (Option.map Fin.castSucc (Array.findFinIdx? p xs)).or (if p a = true then some ⟨xs.size, ⋯⟩ else none)" tactic="simp [Array.findFinIdx?_push, Option.map_or, Function.comp_def]">
                    <AtomNode start="(320, 3)" end="(320, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(320, 8)" end="(320, 66)">
                      <AtomNode start="(320, 8)" end="(320, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(320, 9)" end="(320, 65)">
                        <OtherNode start="(320, 9)" end="(320, 31)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(320, 9)" end="(320, 31)" leading="" trailing="" raw_val="Array.findFinIdx?_push" val="Array.findFinIdx?_push" full_name="Array.findFinIdx?_push" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean"/>
                        </OtherNode>
                        <AtomNode start="(320, 31)" end="(320, 32)" leading="" trailing=" " val=","/>
                        <OtherNode start="(320, 33)" end="(320, 46)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(320, 33)" end="(320, 46)" leading="" trailing="" raw_val="Option.map_or" val="Option.map_or" full_name="Option.map_or" mod_name="Init.Data.Option.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(320, 46)" end="(320, 47)" leading="" trailing=" " val=","/>
                        <OtherNode start="(320, 48)" end="(320, 65)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(320, 48)" end="(320, 65)" leading="" trailing="" raw_val="Function.comp_def" val="Function.comp_def" full_name="Function.comp_def" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(320, 65)" end="(320, 66)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(321, 3)" end="(321, 8)" kind="Lean.Parser.Tactic.congr" state_before="case mk&#10;α : Type u_1&#10;a : α&#10;p : α → Bool&#10;xs : Array α&#10;⊢ (Option.map (fun x =&amp;gt; Fin.castLE ⋯ x) (Array.findFinIdx? p xs)).or (if p a = true then some ⟨xs.size, ⋯⟩ else none) =&#10;    (Option.map Fin.castSucc (Array.findFinIdx? p xs)).or (if p a = true then some ⟨xs.size, ⋯⟩ else none)" state_after="no goals" tactic="congr">
                    <AtomNode start="(321, 3)" end="(321, 8)" leading="" trailing="&#10;&#10;" val="congr"/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(323, 1)" end="(329, 68)" name="findFinIdx?_append" full_name="Vector.findFinIdx?_append">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(323, 1)" end="(329, 68)" name="findFinIdx?_append" full_name="Vector.findFinIdx?_append" _is_private_decl="False">
        <AtomNode start="(323, 1)" end="(323, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(323, 9)" end="(323, 27)">
          <IdentNode start="(323, 9)" end="(323, 27)" leading="" trailing=" " raw_val="findFinIdx?_append" val="findFinIdx?_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(323, 28)" end="(326, 82)">
          <NullNode start="(323, 28)" end="(323, 80)">
            <OtherNode start="(323, 28)" end="(323, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(323, 28)" end="(323, 29)" leading="" trailing="" val="{"/>
              <NullNode start="(323, 29)" end="(323, 31)">
                <IdentNode start="(323, 29)" end="(323, 31)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(323, 32)" end="(323, 45)">
                <AtomNode start="(323, 32)" end="(323, 33)" leading="" trailing=" " val=":"/>
                <OtherNode start="(323, 34)" end="(323, 45)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(323, 34)" end="(323, 40)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(323, 41)" end="(323, 45)">
                    <IdentNode start="(323, 41)" end="(323, 42)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(323, 43)" end="(323, 45)" leading="" trailing="" raw_val="n₁" val="n₁"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(323, 45)" end="(323, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(323, 47)" end="(323, 65)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(323, 47)" end="(323, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(323, 48)" end="(323, 50)">
                <IdentNode start="(323, 48)" end="(323, 50)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(323, 51)" end="(323, 64)">
                <AtomNode start="(323, 51)" end="(323, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(323, 53)" end="(323, 64)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(323, 53)" end="(323, 59)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(323, 60)" end="(323, 64)">
                    <IdentNode start="(323, 60)" end="(323, 61)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(323, 62)" end="(323, 64)" leading="" trailing="" raw_val="n₂" val="n₂"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(323, 64)" end="(323, 65)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(323, 66)" end="(323, 80)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(323, 66)" end="(323, 67)" leading="" trailing="" val="{"/>
              <NullNode start="(323, 67)" end="(323, 68)">
                <IdentNode start="(323, 67)" end="(323, 68)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(323, 69)" end="(323, 79)">
                <AtomNode start="(323, 69)" end="(323, 70)" leading="" trailing=" " val=":"/>
                <OtherNode start="(323, 71)" end="(323, 79)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(323, 71)" end="(323, 72)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(323, 73)" end="(323, 74)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(323, 75)" end="(323, 79)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(323, 79)" end="(323, 80)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(323, 81)" end="(326, 82)">
            <AtomNode start="(323, 81)" end="(323, 82)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(324, 5)" end="(326, 82)" kind="«term_=_»">
              <OtherNode start="(324, 5)" end="(324, 29)" kind="Lean.Parser.Term.app">
                <OtherNode start="(324, 5)" end="(324, 27)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(324, 5)" end="(324, 15)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(324, 5)" end="(324, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(324, 6)" end="(324, 14)" kind="«term_++_»">
                      <IdentNode start="(324, 6)" end="(324, 8)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      <AtomNode start="(324, 9)" end="(324, 11)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(324, 12)" end="(324, 14)" leading="" trailing="" raw_val="ys" val="ys"/>
                    </OtherNode>
                    <AtomNode start="(324, 14)" end="(324, 15)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(324, 15)" end="(324, 16)" leading="" trailing="" val="."/>
                  <IdentNode start="(324, 16)" end="(324, 27)" leading="" trailing=" " raw_val="findFinIdx?" val="findFinIdx?" full_name="Vector.findFinIdx?" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                </OtherNode>
                <NullNode start="(324, 28)" end="(324, 29)">
                  <IdentNode start="(324, 28)" end="(324, 29)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(324, 30)" end="(324, 31)" leading="" trailing="&#10;      " val="="/>
              <OtherNode start="(325, 7)" end="(326, 82)" kind="Lean.Parser.Term.app">
                <OtherNode start="(325, 7)" end="(325, 57)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(325, 7)" end="(325, 54)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(325, 7)" end="(325, 8)" leading="" trailing="" val="("/>
                    <OtherNode start="(325, 8)" end="(325, 53)" kind="Lean.Parser.Term.app">
                      <OtherNode start="(325, 8)" end="(325, 30)" kind="Lean.Parser.Term.proj">
                        <OtherNode start="(325, 8)" end="(325, 26)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(325, 8)" end="(325, 9)" leading="" trailing="" val="("/>
                          <OtherNode start="(325, 9)" end="(325, 25)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(325, 9)" end="(325, 23)" leading="" trailing=" " raw_val="xs.findFinIdx?" val="xs.findFinIdx?"/>
                            <NullNode start="(325, 24)" end="(325, 25)">
                              <IdentNode start="(325, 24)" end="(325, 25)" leading="" trailing="" raw_val="p" val="p"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(325, 25)" end="(325, 26)" leading="" trailing="" val=")"/>
                        </OtherNode>
                        <AtomNode start="(325, 26)" end="(325, 27)" leading="" trailing="" val="."/>
                        <IdentNode start="(325, 27)" end="(325, 30)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </OtherNode>
                      <NullNode start="(325, 31)" end="(325, 53)">
                        <OtherNode start="(325, 31)" end="(325, 53)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(325, 31)" end="(325, 32)" leading="" trailing="" val="("/>
                          <OtherNode start="(325, 32)" end="(325, 52)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(325, 32)" end="(325, 42)" leading="" trailing=" " raw_val="Fin.castLE" val="Fin.castLE" full_name="Fin.castLE" mod_name="Init.Data.Fin.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Fin/Basic.lean"/>
                            <NullNode start="(325, 43)" end="(325, 52)">
                              <OtherNode start="(325, 43)" end="(325, 52)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(325, 43)" end="(325, 44)" leading="" trailing="" val="("/>
                                <TermBytacticNode start="(325, 44)" end="(325, 51)">
                                  <AtomNode start="(325, 44)" end="(325, 46)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(325, 47)" end="(325, 51)">
                                    <TacticTacticseq1IndentedNode start="(325, 47)" end="(325, 51)">
                                      <NullNode start="(325, 47)" end="(325, 51)">
                                        <OtherNode start="(325, 47)" end="(325, 51)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.58480&#10;n₁ n₂ : Nat&#10;xs : Vector α n₁&#10;ys : Vector α n₂&#10;p : α → Bool&#10;⊢ n₁ ≤ n₁ + n₂" state_after="no goals" tactic="simp">
                                          <AtomNode start="(325, 47)" end="(325, 51)" leading="" trailing="" val="simp"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                                <AtomNode start="(325, 51)" end="(325, 52)" leading="" trailing="" val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(325, 52)" end="(325, 53)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(325, 53)" end="(325, 54)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(325, 54)" end="(325, 55)" leading="" trailing="" val="."/>
                  <IdentNode start="(325, 55)" end="(325, 57)" leading="" trailing="&#10;        " raw_val="or" val="or" full_name="Option.or" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(326, 9)" end="(326, 82)">
                  <OtherNode start="(326, 9)" end="(326, 82)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(326, 9)" end="(326, 10)" leading="" trailing="" val="("/>
                    <OtherNode start="(326, 10)" end="(326, 81)" kind="Lean.Parser.Term.pipeProj">
                      <OtherNode start="(326, 10)" end="(326, 53)" kind="Lean.Parser.Term.app">
                        <OtherNode start="(326, 10)" end="(326, 32)" kind="Lean.Parser.Term.proj">
                          <OtherNode start="(326, 10)" end="(326, 28)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(326, 10)" end="(326, 11)" leading="" trailing="" val="("/>
                            <OtherNode start="(326, 11)" end="(326, 27)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(326, 11)" end="(326, 25)" leading="" trailing=" " raw_val="ys.findFinIdx?" val="ys.findFinIdx?"/>
                              <NullNode start="(326, 26)" end="(326, 27)">
                                <IdentNode start="(326, 26)" end="(326, 27)" leading="" trailing="" raw_val="p" val="p"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(326, 27)" end="(326, 28)" leading="" trailing="" val=")"/>
                          </OtherNode>
                          <AtomNode start="(326, 28)" end="(326, 29)" leading="" trailing="" val="."/>
                          <IdentNode start="(326, 29)" end="(326, 32)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        </OtherNode>
                        <NullNode start="(326, 33)" end="(326, 53)">
                          <OtherNode start="(326, 33)" end="(326, 53)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(326, 33)" end="(326, 34)" leading="" trailing="" val="("/>
                            <OtherNode start="(326, 34)" end="(326, 52)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(326, 34)" end="(326, 44)" leading="" trailing=" " raw_val="Fin.natAdd" val="Fin.natAdd" full_name="Fin.natAdd" mod_name="Init.Data.Fin.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Fin/Basic.lean"/>
                              <NullNode start="(326, 45)" end="(326, 52)">
                                <IdentNode start="(326, 45)" end="(326, 52)" leading="" trailing="" raw_val="xs.size" val="xs.size"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(326, 52)" end="(326, 53)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(326, 54)" end="(326, 57)" leading="" trailing="" val="|&amp;gt;."/>
                      <IdentNode start="(326, 57)" end="(326, 60)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(326, 61)" end="(326, 81)">
                        <OtherNode start="(326, 61)" end="(326, 81)" kind="Lean.Parser.Term.paren">
                          <AtomNode start="(326, 61)" end="(326, 62)" leading="" trailing="" val="("/>
                          <OtherNode start="(326, 62)" end="(326, 80)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(326, 62)" end="(326, 70)" leading="" trailing=" " raw_val="Fin.cast" val="Fin.cast" full_name="Fin.cast" mod_name="Init.Data.Fin.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Fin/Basic.lean"/>
                            <NullNode start="(326, 71)" end="(326, 80)">
                              <OtherNode start="(326, 71)" end="(326, 80)" kind="Lean.Parser.Term.paren">
                                <AtomNode start="(326, 71)" end="(326, 72)" leading="" trailing="" val="("/>
                                <TermBytacticNode start="(326, 72)" end="(326, 79)">
                                  <AtomNode start="(326, 72)" end="(326, 74)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(326, 75)" end="(326, 79)">
                                    <TacticTacticseq1IndentedNode start="(326, 75)" end="(326, 79)">
                                      <NullNode start="(326, 75)" end="(326, 79)">
                                        <OtherNode start="(326, 75)" end="(326, 79)" kind="Lean.Parser.Tactic.simp" state_before="α : Type ?u.58480&#10;n₁ n₂ : Nat&#10;xs : Vector α n₁&#10;ys : Vector α n₂&#10;p : α → Bool&#10;⊢ xs.size + n₂ = n₁ + n₂" state_after="no goals" tactic="simp">
                                          <AtomNode start="(326, 75)" end="(326, 79)" leading="" trailing="" val="simp"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                                <AtomNode start="(326, 79)" end="(326, 80)" leading="" trailing="" val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(326, 80)" end="(326, 81)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(326, 81)" end="(326, 82)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(326, 83)" end="(329, 68)">
          <AtomNode start="(326, 83)" end="(326, 85)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(326, 86)" end="(329, 68)">
            <AtomNode start="(326, 86)" end="(326, 88)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(327, 3)" end="(329, 68)">
              <TacticTacticseq1IndentedNode start="(327, 3)" end="(329, 68)">
                <NullNode start="(327, 3)" end="(329, 68)">
                  <OtherNode start="(327, 3)" end="(327, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;n₁ n₂ : Nat&#10;xs : Vector α n₁&#10;ys : Vector α n₂&#10;p : α → Bool&#10;⊢ findFinIdx? p (xs ++ ys) =&#10;    (Option.map (Fin.castLE ⋯) (findFinIdx? p xs)).or&#10;      (Option.map (Fin.cast ⋯) (Option.map (Fin.natAdd xs.size) (findFinIdx? p ys)))" state_after="case mk&#10;α : Type u_1&#10;n₂ : Nat&#10;ys : Vector α n₂&#10;p : α → Bool&#10;xs : Array α&#10;⊢ findFinIdx? p ({ toArray := xs, size_toArray := ⋯ } ++ ys) =&#10;    (Option.map (Fin.castLE ⋯) (findFinIdx? p { toArray := xs, size_toArray := ⋯ })).or&#10;      (Option.map (Fin.cast ⋯) (Option.map (Fin.natAdd { toArray := xs, size_toArray := ⋯ }.size) (findFinIdx? p ys)))" tactic="rcases xs with ⟨xs, rfl⟩">
                    <AtomNode start="(327, 3)" end="(327, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(327, 10)" end="(327, 12)">
                      <OtherNode start="(327, 10)" end="(327, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(327, 10)" end="(327, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(327, 13)" end="(327, 27)">
                      <AtomNode start="(327, 13)" end="(327, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(327, 18)" end="(327, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(327, 18)" end="(327, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(327, 18)" end="(327, 27)">
                            <OtherNode start="(327, 18)" end="(327, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(327, 18)" end="(327, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(327, 19)" end="(327, 26)">
                                <OtherNode start="(327, 19)" end="(327, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(327, 19)" end="(327, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(327, 19)" end="(327, 21)">
                                      <OtherNode start="(327, 19)" end="(327, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(327, 19)" end="(327, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(327, 21)" end="(327, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(327, 23)" end="(327, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(327, 23)" end="(327, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(327, 23)" end="(327, 26)">
                                      <OtherNode start="(327, 23)" end="(327, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(327, 23)" end="(327, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(327, 26)" end="(327, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(328, 3)" end="(328, 27)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α : Type u_1&#10;n₂ : Nat&#10;ys : Vector α n₂&#10;p : α → Bool&#10;xs : Array α&#10;⊢ findFinIdx? p ({ toArray := xs, size_toArray := ⋯ } ++ ys) =&#10;    (Option.map (Fin.castLE ⋯) (findFinIdx? p { toArray := xs, size_toArray := ⋯ })).or&#10;      (Option.map (Fin.cast ⋯) (Option.map (Fin.natAdd { toArray := xs, size_toArray := ⋯ }.size) (findFinIdx? p ys)))" state_after="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs ys : Array α&#10;⊢ findFinIdx? p ({ toArray := xs, size_toArray := ⋯ } ++ { toArray := ys, size_toArray := ⋯ }) =&#10;    (Option.map (Fin.castLE ⋯) (findFinIdx? p { toArray := xs, size_toArray := ⋯ })).or&#10;      (Option.map (Fin.cast ⋯)&#10;        (Option.map (Fin.natAdd { toArray := xs, size_toArray := ⋯ }.size)&#10;          (findFinIdx? p { toArray := ys, size_toArray := ⋯ })))" tactic="rcases ys with ⟨ys, rfl⟩">
                    <AtomNode start="(328, 3)" end="(328, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(328, 10)" end="(328, 12)">
                      <OtherNode start="(328, 10)" end="(328, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(328, 10)" end="(328, 12)" leading="" trailing=" " raw_val="ys" val="ys"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(328, 13)" end="(328, 27)">
                      <AtomNode start="(328, 13)" end="(328, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(328, 18)" end="(328, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(328, 18)" end="(328, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(328, 18)" end="(328, 27)">
                            <OtherNode start="(328, 18)" end="(328, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(328, 18)" end="(328, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(328, 19)" end="(328, 26)">
                                <OtherNode start="(328, 19)" end="(328, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(328, 19)" end="(328, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(328, 19)" end="(328, 21)">
                                      <OtherNode start="(328, 19)" end="(328, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(328, 19)" end="(328, 21)" leading="" trailing="" raw_val="ys" val="ys"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(328, 21)" end="(328, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(328, 23)" end="(328, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(328, 23)" end="(328, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(328, 23)" end="(328, 26)">
                                      <OtherNode start="(328, 23)" end="(328, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(328, 23)" end="(328, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(328, 26)" end="(328, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(329, 3)" end="(329, 68)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs ys : Array α&#10;⊢ findFinIdx? p ({ toArray := xs, size_toArray := ⋯ } ++ { toArray := ys, size_toArray := ⋯ }) =&#10;    (Option.map (Fin.castLE ⋯) (findFinIdx? p { toArray := xs, size_toArray := ⋯ })).or&#10;      (Option.map (Fin.cast ⋯)&#10;        (Option.map (Fin.natAdd { toArray := xs, size_toArray := ⋯ }.size)&#10;          (findFinIdx? p { toArray := ys, size_toArray := ⋯ })))" state_after="no goals" tactic="simp [Array.findFinIdx?_append, Option.map_or, Function.comp_def]">
                    <AtomNode start="(329, 3)" end="(329, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(329, 8)" end="(329, 68)">
                      <AtomNode start="(329, 8)" end="(329, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(329, 9)" end="(329, 67)">
                        <OtherNode start="(329, 9)" end="(329, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(329, 9)" end="(329, 33)" leading="" trailing="" raw_val="Array.findFinIdx?_append" val="Array.findFinIdx?_append" full_name="Array.findFinIdx?_append" mod_name="Init.Data.Array.Find" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Find.lean"/>
                        </OtherNode>
                        <AtomNode start="(329, 33)" end="(329, 34)" leading="" trailing=" " val=","/>
                        <OtherNode start="(329, 35)" end="(329, 48)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(329, 35)" end="(329, 48)" leading="" trailing="" raw_val="Option.map_or" val="Option.map_or" full_name="Option.map_or" mod_name="Init.Data.Option.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(329, 48)" end="(329, 49)" leading="" trailing=" " val=","/>
                        <OtherNode start="(329, 50)" end="(329, 67)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(329, 50)" end="(329, 67)" leading="" trailing="" raw_val="Function.comp_def" val="Function.comp_def" full_name="Function.comp_def" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(329, 67)" end="(329, 68)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(331, 1)" end="(335, 7)" name="isSome_findFinIdx?" full_name="Vector.isSome_findFinIdx?">
      <CommandDeclmodifiersNode start="(331, 1)" end="(331, 8)">
        <NullNode/>
        <NullNode start="(331, 1)" end="(331, 8)">
          <OtherNode start="(331, 1)" end="(331, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(331, 1)" end="(331, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(331, 3)" end="(331, 7)">
              <OtherNode start="(331, 3)" end="(331, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(331, 3)" end="(331, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(331, 3)" end="(331, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(331, 7)" end="(331, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(332, 1)" end="(335, 7)" name="isSome_findFinIdx?" full_name="Vector.isSome_findFinIdx?" _is_private_decl="False">
        <AtomNode start="(332, 1)" end="(332, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(332, 9)" end="(332, 27)">
          <IdentNode start="(332, 9)" end="(332, 27)" leading="" trailing=" " raw_val="isSome_findFinIdx?" val="isSome_findFinIdx?"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(332, 28)" end="(333, 41)">
          <NullNode start="(332, 28)" end="(332, 60)">
            <OtherNode start="(332, 28)" end="(332, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(332, 28)" end="(332, 29)" leading="" trailing="" val="{"/>
              <NullNode start="(332, 29)" end="(332, 31)">
                <IdentNode start="(332, 29)" end="(332, 31)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(332, 32)" end="(332, 44)">
                <AtomNode start="(332, 32)" end="(332, 33)" leading="" trailing=" " val=":"/>
                <OtherNode start="(332, 34)" end="(332, 44)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(332, 34)" end="(332, 40)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(332, 41)" end="(332, 44)">
                    <IdentNode start="(332, 41)" end="(332, 42)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(332, 43)" end="(332, 44)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(332, 44)" end="(332, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(332, 46)" end="(332, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(332, 46)" end="(332, 47)" leading="" trailing="" val="{"/>
              <NullNode start="(332, 47)" end="(332, 48)">
                <IdentNode start="(332, 47)" end="(332, 48)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(332, 49)" end="(332, 59)">
                <AtomNode start="(332, 49)" end="(332, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(332, 51)" end="(332, 59)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(332, 51)" end="(332, 52)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(332, 53)" end="(332, 54)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(332, 55)" end="(332, 59)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(332, 59)" end="(332, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(332, 61)" end="(333, 41)">
            <AtomNode start="(332, 61)" end="(332, 62)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(333, 5)" end="(333, 41)" kind="«term_=_»">
              <OtherNode start="(333, 5)" end="(333, 30)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(333, 5)" end="(333, 23)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(333, 5)" end="(333, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(333, 6)" end="(333, 22)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(333, 6)" end="(333, 20)" leading="" trailing=" " raw_val="xs.findFinIdx?" val="xs.findFinIdx?"/>
                    <NullNode start="(333, 21)" end="(333, 22)">
                      <IdentNode start="(333, 21)" end="(333, 22)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(333, 22)" end="(333, 23)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(333, 23)" end="(333, 24)" leading="" trailing="" val="."/>
                <IdentNode start="(333, 24)" end="(333, 30)" leading="" trailing=" " raw_val="isSome" val="isSome" full_name="Option.isSome" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(333, 31)" end="(333, 32)" leading="" trailing=" " val="="/>
              <OtherNode start="(333, 33)" end="(333, 41)" kind="Lean.Parser.Term.app">
                <IdentNode start="(333, 33)" end="(333, 39)" leading="" trailing=" " raw_val="xs.any" val="xs.any"/>
                <NullNode start="(333, 40)" end="(333, 41)">
                  <IdentNode start="(333, 40)" end="(333, 41)" leading="" trailing=" " raw_val="p" val="p"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(333, 42)" end="(335, 7)">
          <AtomNode start="(333, 42)" end="(333, 44)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(333, 45)" end="(335, 7)">
            <AtomNode start="(333, 45)" end="(333, 47)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(334, 3)" end="(335, 7)">
              <TacticTacticseq1IndentedNode start="(334, 3)" end="(335, 7)">
                <NullNode start="(334, 3)" end="(335, 7)">
                  <OtherNode start="(334, 3)" end="(334, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;n : Nat&#10;xs : Vector α n&#10;p : α → Bool&#10;⊢ (findFinIdx? p xs).isSome = xs.any p" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;⊢ (findFinIdx? p { toArray := xs, size_toArray := ⋯ }).isSome = { toArray := xs, size_toArray := ⋯ }.any p" tactic="rcases xs with ⟨xs, rfl⟩">
                    <AtomNode start="(334, 3)" end="(334, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(334, 10)" end="(334, 12)">
                      <OtherNode start="(334, 10)" end="(334, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(334, 10)" end="(334, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(334, 13)" end="(334, 27)">
                      <AtomNode start="(334, 13)" end="(334, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(334, 18)" end="(334, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(334, 18)" end="(334, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(334, 18)" end="(334, 27)">
                            <OtherNode start="(334, 18)" end="(334, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(334, 18)" end="(334, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(334, 19)" end="(334, 26)">
                                <OtherNode start="(334, 19)" end="(334, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(334, 19)" end="(334, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(334, 19)" end="(334, 21)">
                                      <OtherNode start="(334, 19)" end="(334, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(334, 19)" end="(334, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(334, 21)" end="(334, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(334, 23)" end="(334, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(334, 23)" end="(334, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(334, 23)" end="(334, 26)">
                                      <OtherNode start="(334, 23)" end="(334, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(334, 23)" end="(334, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(334, 26)" end="(334, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(335, 3)" end="(335, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;⊢ (findFinIdx? p { toArray := xs, size_toArray := ⋯ }).isSome = { toArray := xs, size_toArray := ⋯ }.any p" state_after="no goals" tactic="simp">
                    <AtomNode start="(335, 3)" end="(335, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(337, 1)" end="(341, 7)" name="isNone_findFinIdx?" full_name="Vector.isNone_findFinIdx?">
      <CommandDeclmodifiersNode start="(337, 1)" end="(337, 8)">
        <NullNode/>
        <NullNode start="(337, 1)" end="(337, 8)">
          <OtherNode start="(337, 1)" end="(337, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(337, 1)" end="(337, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(337, 3)" end="(337, 7)">
              <OtherNode start="(337, 3)" end="(337, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(337, 3)" end="(337, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(337, 3)" end="(337, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(337, 7)" end="(337, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(338, 1)" end="(341, 7)" name="isNone_findFinIdx?" full_name="Vector.isNone_findFinIdx?" _is_private_decl="False">
        <AtomNode start="(338, 1)" end="(338, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(338, 9)" end="(338, 27)">
          <IdentNode start="(338, 9)" end="(338, 27)" leading="" trailing=" " raw_val="isNone_findFinIdx?" val="isNone_findFinIdx?"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(338, 28)" end="(339, 56)">
          <NullNode start="(338, 28)" end="(338, 60)">
            <OtherNode start="(338, 28)" end="(338, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(338, 28)" end="(338, 29)" leading="" trailing="" val="{"/>
              <NullNode start="(338, 29)" end="(338, 31)">
                <IdentNode start="(338, 29)" end="(338, 31)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(338, 32)" end="(338, 44)">
                <AtomNode start="(338, 32)" end="(338, 33)" leading="" trailing=" " val=":"/>
                <OtherNode start="(338, 34)" end="(338, 44)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(338, 34)" end="(338, 40)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(338, 41)" end="(338, 44)">
                    <IdentNode start="(338, 41)" end="(338, 42)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(338, 43)" end="(338, 44)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(338, 44)" end="(338, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(338, 46)" end="(338, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(338, 46)" end="(338, 47)" leading="" trailing="" val="{"/>
              <NullNode start="(338, 47)" end="(338, 48)">
                <IdentNode start="(338, 47)" end="(338, 48)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(338, 49)" end="(338, 59)">
                <AtomNode start="(338, 49)" end="(338, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(338, 51)" end="(338, 59)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(338, 51)" end="(338, 52)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(338, 53)" end="(338, 54)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(338, 55)" end="(338, 59)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(338, 59)" end="(338, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(338, 61)" end="(339, 56)">
            <AtomNode start="(338, 61)" end="(338, 62)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(339, 5)" end="(339, 56)" kind="«term_=_»">
              <OtherNode start="(339, 5)" end="(339, 30)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(339, 5)" end="(339, 23)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(339, 5)" end="(339, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(339, 6)" end="(339, 22)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(339, 6)" end="(339, 20)" leading="" trailing=" " raw_val="xs.findFinIdx?" val="xs.findFinIdx?"/>
                    <NullNode start="(339, 21)" end="(339, 22)">
                      <IdentNode start="(339, 21)" end="(339, 22)" leading="" trailing="" raw_val="p" val="p"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(339, 22)" end="(339, 23)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(339, 23)" end="(339, 24)" leading="" trailing="" val="."/>
                <IdentNode start="(339, 24)" end="(339, 30)" leading="" trailing=" " raw_val="isNone" val="isNone" full_name="Option.isNone" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(339, 31)" end="(339, 32)" leading="" trailing=" " val="="/>
              <OtherNode start="(339, 33)" end="(339, 56)" kind="Lean.Parser.Term.app">
                <IdentNode start="(339, 33)" end="(339, 39)" leading="" trailing=" " raw_val="xs.all" val="xs.all"/>
                <NullNode start="(339, 40)" end="(339, 56)">
                  <OtherNode start="(339, 40)" end="(339, 56)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(339, 40)" end="(339, 41)" leading="" trailing="" val="("/>
                    <OtherNode start="(339, 41)" end="(339, 55)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(339, 41)" end="(339, 44)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(339, 45)" end="(339, 55)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(339, 45)" end="(339, 46)">
                          <IdentNode start="(339, 45)" end="(339, 46)" leading="" trailing=" " raw_val="x" val="x"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(339, 47)" end="(339, 49)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(339, 50)" end="(339, 55)" kind="«term¬_»">
                          <AtomNode start="(339, 50)" end="(339, 51)" leading="" trailing=" " val="¬"/>
                          <OtherNode start="(339, 52)" end="(339, 55)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(339, 52)" end="(339, 53)" leading="" trailing=" " raw_val="p" val="p"/>
                            <NullNode start="(339, 54)" end="(339, 55)">
                              <IdentNode start="(339, 54)" end="(339, 55)" leading="" trailing="" raw_val="x" val="x"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(339, 55)" end="(339, 56)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(339, 57)" end="(341, 7)">
          <AtomNode start="(339, 57)" end="(339, 59)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(339, 60)" end="(341, 7)">
            <AtomNode start="(339, 60)" end="(339, 62)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(340, 3)" end="(341, 7)">
              <TacticTacticseq1IndentedNode start="(340, 3)" end="(341, 7)">
                <NullNode start="(340, 3)" end="(341, 7)">
                  <OtherNode start="(340, 3)" end="(340, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;n : Nat&#10;xs : Vector α n&#10;p : α → Bool&#10;⊢ (findFinIdx? p xs).isNone = xs.all fun x =&amp;gt; decide ¬p x = true" state_after="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;⊢ (findFinIdx? p { toArray := xs, size_toArray := ⋯ }).isNone =&#10;    { toArray := xs, size_toArray := ⋯ }.all fun x =&amp;gt; decide ¬p x = true" tactic="rcases xs with ⟨xs, rfl⟩">
                    <AtomNode start="(340, 3)" end="(340, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(340, 10)" end="(340, 12)">
                      <OtherNode start="(340, 10)" end="(340, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(340, 10)" end="(340, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(340, 13)" end="(340, 27)">
                      <AtomNode start="(340, 13)" end="(340, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(340, 18)" end="(340, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(340, 18)" end="(340, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(340, 18)" end="(340, 27)">
                            <OtherNode start="(340, 18)" end="(340, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(340, 18)" end="(340, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(340, 19)" end="(340, 26)">
                                <OtherNode start="(340, 19)" end="(340, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(340, 19)" end="(340, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(340, 19)" end="(340, 21)">
                                      <OtherNode start="(340, 19)" end="(340, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(340, 19)" end="(340, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(340, 21)" end="(340, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(340, 23)" end="(340, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(340, 23)" end="(340, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(340, 23)" end="(340, 26)">
                                      <OtherNode start="(340, 23)" end="(340, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(340, 23)" end="(340, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(340, 26)" end="(340, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(341, 3)" end="(341, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p : α → Bool&#10;xs : Array α&#10;⊢ (findFinIdx? p { toArray := xs, size_toArray := ⋯ }).isNone =&#10;    { toArray := xs, size_toArray := ⋯ }.all fun x =&amp;gt; decide ¬p x = true" state_after="no goals" tactic="simp">
                    <AtomNode start="(341, 3)" end="(341, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(343, 1)" end="(347, 31)" name="findFinIdx?_subtype" full_name="Vector.findFinIdx?_subtype">
      <CommandDeclmodifiersNode start="(343, 1)" end="(343, 8)">
        <NullNode/>
        <NullNode start="(343, 1)" end="(343, 8)">
          <OtherNode start="(343, 1)" end="(343, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(343, 1)" end="(343, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(343, 3)" end="(343, 7)">
              <OtherNode start="(343, 3)" end="(343, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(343, 3)" end="(343, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(343, 3)" end="(343, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(343, 7)" end="(343, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(343, 9)" end="(347, 31)" name="findFinIdx?_subtype" full_name="Vector.findFinIdx?_subtype" _is_private_decl="False">
        <AtomNode start="(343, 9)" end="(343, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(343, 17)" end="(343, 36)">
          <IdentNode start="(343, 17)" end="(343, 36)" leading="" trailing=" " raw_val="findFinIdx?_subtype" val="findFinIdx?_subtype"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(343, 37)" end="(345, 49)">
          <NullNode start="(343, 37)" end="(344, 74)">
            <OtherNode start="(343, 37)" end="(343, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(343, 37)" end="(343, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(343, 38)" end="(343, 39)">
                <IdentNode start="(343, 38)" end="(343, 39)" leading="" trailing=" " raw_val="p" val="p"/>
              </NullNode>
              <NullNode start="(343, 40)" end="(343, 50)">
                <AtomNode start="(343, 40)" end="(343, 41)" leading="" trailing=" " val=":"/>
                <OtherNode start="(343, 42)" end="(343, 50)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(343, 42)" end="(343, 43)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(343, 44)" end="(343, 45)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(343, 46)" end="(343, 50)" kind="Lean.Parser.Term.prop">
                    <AtomNode start="(343, 46)" end="(343, 50)" leading="" trailing="" val="Prop"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(343, 50)" end="(343, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(343, 52)" end="(343, 80)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(343, 52)" end="(343, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(343, 53)" end="(343, 55)">
                <IdentNode start="(343, 53)" end="(343, 55)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(343, 56)" end="(343, 79)">
                <AtomNode start="(343, 56)" end="(343, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(343, 58)" end="(343, 79)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(343, 58)" end="(343, 64)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(343, 65)" end="(343, 79)">
                    <OtherNode start="(343, 65)" end="(343, 77)" kind="«term{_:_//_}»">
                      <AtomNode start="(343, 65)" end="(343, 66)" leading="" trailing=" " val="{"/>
                      <IdentNode start="(343, 67)" end="(343, 68)" leading="" trailing=" " raw_val="x" val="x"/>
                      <NullNode/>
                      <AtomNode start="(343, 69)" end="(343, 71)" leading="" trailing=" " val="//"/>
                      <OtherNode start="(343, 72)" end="(343, 75)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(343, 72)" end="(343, 73)" leading="" trailing=" " raw_val="p" val="p"/>
                        <NullNode start="(343, 74)" end="(343, 75)">
                          <IdentNode start="(343, 74)" end="(343, 75)" leading="" trailing=" " raw_val="x" val="x"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(343, 76)" end="(343, 77)" leading="" trailing=" " val="}"/>
                    </OtherNode>
                    <IdentNode start="(343, 78)" end="(343, 79)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(343, 79)" end="(343, 80)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <OtherNode start="(344, 5)" end="(344, 30)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(344, 5)" end="(344, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(344, 6)" end="(344, 7)">
                <IdentNode start="(344, 6)" end="(344, 7)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(344, 8)" end="(344, 29)">
                <AtomNode start="(344, 8)" end="(344, 9)" leading="" trailing=" " val=":"/>
                <OtherNode start="(344, 10)" end="(344, 29)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(344, 10)" end="(344, 22)" kind="«term{_:_//_}»">
                    <AtomNode start="(344, 10)" end="(344, 11)" leading="" trailing=" " val="{"/>
                    <IdentNode start="(344, 12)" end="(344, 13)" leading="" trailing=" " raw_val="x" val="x"/>
                    <NullNode/>
                    <AtomNode start="(344, 14)" end="(344, 16)" leading="" trailing=" " val="//"/>
                    <OtherNode start="(344, 17)" end="(344, 20)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(344, 17)" end="(344, 18)" leading="" trailing=" " raw_val="p" val="p"/>
                      <NullNode start="(344, 19)" end="(344, 20)">
                        <IdentNode start="(344, 19)" end="(344, 20)" leading="" trailing=" " raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(344, 21)" end="(344, 22)" leading="" trailing=" " val="}"/>
                  </OtherNode>
                  <AtomNode start="(344, 23)" end="(344, 24)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(344, 25)" end="(344, 29)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(344, 29)" end="(344, 30)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(344, 31)" end="(344, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(344, 31)" end="(344, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(344, 32)" end="(344, 33)">
                <IdentNode start="(344, 32)" end="(344, 33)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(344, 34)" end="(344, 44)">
                <AtomNode start="(344, 34)" end="(344, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(344, 36)" end="(344, 44)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(344, 36)" end="(344, 37)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(344, 38)" end="(344, 39)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(344, 40)" end="(344, 44)" leading="" trailing="" raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(344, 44)" end="(344, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(344, 46)" end="(344, 74)">
              <AtomNode start="(344, 46)" end="(344, 47)" leading="" trailing="" val="("/>
              <NullNode start="(344, 47)" end="(344, 49)">
                <IdentNode start="(344, 47)" end="(344, 49)" leading="" trailing=" " raw_val="hf" val="hf"/>
              </NullNode>
              <NullNode start="(344, 50)" end="(344, 73)">
                <AtomNode start="(344, 50)" end="(344, 51)" leading="" trailing=" " val=":"/>
                <OtherNode start="(344, 52)" end="(344, 73)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(344, 52)" end="(344, 53)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(344, 54)" end="(344, 57)">
                    <IdentNode start="(344, 54)" end="(344, 55)" leading="" trailing=" " raw_val="x" val="x"/>
                    <IdentNode start="(344, 56)" end="(344, 57)" leading="" trailing="" raw_val="h" val="h"/>
                  </NullNode>
                  <NullNode/>
                  <AtomNode start="(344, 57)" end="(344, 58)" leading="" trailing=" " val=","/>
                  <OtherNode start="(344, 59)" end="(344, 73)" kind="«term_=_»">
                    <OtherNode start="(344, 59)" end="(344, 67)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(344, 59)" end="(344, 60)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(344, 61)" end="(344, 67)">
                        <OtherNode start="(344, 61)" end="(344, 67)" kind="Lean.Parser.Term.anonymousCtor">
                          <AtomNode start="(344, 61)" end="(344, 62)" leading="" trailing="" val="⟨"/>
                          <NullNode start="(344, 62)" end="(344, 66)">
                            <IdentNode start="(344, 62)" end="(344, 63)" leading="" trailing="" raw_val="x" val="x"/>
                            <AtomNode start="(344, 63)" end="(344, 64)" leading="" trailing=" " val=","/>
                            <IdentNode start="(344, 65)" end="(344, 66)" leading="" trailing="" raw_val="h" val="h"/>
                          </NullNode>
                          <AtomNode start="(344, 66)" end="(344, 67)" leading="" trailing=" " val="⟩"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(344, 68)" end="(344, 69)" leading="" trailing=" " val="="/>
                    <OtherNode start="(344, 70)" end="(344, 73)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(344, 70)" end="(344, 71)" leading="" trailing=" " raw_val="g" val="g"/>
                      <NullNode start="(344, 72)" end="(344, 73)">
                        <IdentNode start="(344, 72)" end="(344, 73)" leading="" trailing="" raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(344, 73)" end="(344, 74)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(344, 75)" end="(345, 49)">
            <AtomNode start="(344, 75)" end="(344, 76)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(345, 5)" end="(345, 49)" kind="«term_=_»">
              <OtherNode start="(345, 5)" end="(345, 21)" kind="Lean.Parser.Term.app">
                <IdentNode start="(345, 5)" end="(345, 19)" leading="" trailing=" " raw_val="xs.findFinIdx?" val="xs.findFinIdx?"/>
                <NullNode start="(345, 20)" end="(345, 21)">
                  <IdentNode start="(345, 20)" end="(345, 21)" leading="" trailing=" " raw_val="f" val="f"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(345, 22)" end="(345, 23)" leading="" trailing=" " val="="/>
              <OtherNode start="(345, 24)" end="(345, 49)" kind="Lean.Parser.Term.app">
                <IdentNode start="(345, 24)" end="(345, 47)" leading="" trailing=" " raw_val="xs.unattach.findFinIdx?" val="xs.unattach.findFinIdx?"/>
                <NullNode start="(345, 48)" end="(345, 49)">
                  <IdentNode start="(345, 48)" end="(345, 49)" leading="" trailing=" " raw_val="g" val="g"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(345, 50)" end="(347, 31)">
          <AtomNode start="(345, 50)" end="(345, 52)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(345, 53)" end="(347, 31)">
            <AtomNode start="(345, 53)" end="(345, 55)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(346, 3)" end="(347, 31)">
              <TacticTacticseq1IndentedNode start="(346, 3)" end="(347, 31)">
                <NullNode start="(346, 3)" end="(347, 31)">
                  <OtherNode start="(346, 3)" end="(346, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;n : Nat&#10;p : α → Prop&#10;xs : Vector { x // p x } n&#10;f : { x // p x } → Bool&#10;g : α → Bool&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;⊢ findFinIdx? f xs = findFinIdx? g xs.unattach" state_after="case mk&#10;α : Type u_1&#10;p : α → Prop&#10;f : { x // p x } → Bool&#10;g : α → Bool&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;xs : Array { x // p x }&#10;⊢ findFinIdx? f { toArray := xs, size_toArray := ⋯ } = findFinIdx? g { toArray := xs, size_toArray := ⋯ }.unattach" tactic="rcases xs with ⟨xs, rfl⟩">
                    <AtomNode start="(346, 3)" end="(346, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(346, 10)" end="(346, 12)">
                      <OtherNode start="(346, 10)" end="(346, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(346, 10)" end="(346, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(346, 13)" end="(346, 27)">
                      <AtomNode start="(346, 13)" end="(346, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(346, 18)" end="(346, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(346, 18)" end="(346, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(346, 18)" end="(346, 27)">
                            <OtherNode start="(346, 18)" end="(346, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(346, 18)" end="(346, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(346, 19)" end="(346, 26)">
                                <OtherNode start="(346, 19)" end="(346, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(346, 19)" end="(346, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(346, 19)" end="(346, 21)">
                                      <OtherNode start="(346, 19)" end="(346, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(346, 19)" end="(346, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(346, 21)" end="(346, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(346, 23)" end="(346, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(346, 23)" end="(346, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(346, 23)" end="(346, 26)">
                                      <OtherNode start="(346, 23)" end="(346, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(346, 23)" end="(346, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(346, 26)" end="(346, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(347, 3)" end="(347, 31)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;p : α → Prop&#10;f : { x // p x } → Bool&#10;g : α → Bool&#10;hf : ∀ (x : α) (h : p x), f ⟨x, h⟩ = g x&#10;xs : Array { x // p x }&#10;⊢ findFinIdx? f { toArray := xs, size_toArray := ⋯ } = findFinIdx? g { toArray := xs, size_toArray := ⋯ }.unattach" state_after="no goals" tactic="simp [hf, Function.comp_def]">
                    <AtomNode start="(347, 3)" end="(347, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(347, 8)" end="(347, 31)">
                      <AtomNode start="(347, 8)" end="(347, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(347, 9)" end="(347, 30)">
                        <OtherNode start="(347, 9)" end="(347, 11)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(347, 9)" end="(347, 11)" leading="" trailing="" raw_val="hf" val="hf"/>
                        </OtherNode>
                        <AtomNode start="(347, 11)" end="(347, 12)" leading="" trailing=" " val=","/>
                        <OtherNode start="(347, 13)" end="(347, 30)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(347, 13)" end="(347, 30)" leading="" trailing="" raw_val="Function.comp_def" val="Function.comp_def" full_name="Function.comp_def" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(347, 30)" end="(347, 31)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandEndNode start="(349, 1)" end="(349, 11)" name="Vector">
      <AtomNode start="(349, 1)" end="(349, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(349, 5)" end="(349, 11)">
        <IdentNode start="(349, 5)" end="(349, 11)" leading="" trailing="&#10;" raw_val="Vector" val="Vector"/>
      </NullNode>
    </CommandEndNode>
  </FileNode>
  <Comments>
    <Comment start="(14, 1)" end="(18, 3)" text="# Lemmas about `Vector.findSome?`, `Vector.find?`, `Vector.findFinIdx?`.&#10;&#10;We are still missing results about `idxOf?`, `findIdx`, and `findIdx?`.&#10;-/"/>
    <Comment start="(20, 38)" end="(21, 1)" text="-- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;"/>
    <Comment start="(21, 39)" end="(23, 1)" text="-- Enforce naming conventions for index variables.&#10;&#10;"/>
    <Comment start="(27, 1)" end="(27, 21)" text="### findSome? -/"/>
    <Comment start="(125, 1)" end="(126, 1)" text="-- Argument is unused, but used to decide whether `simp` should unfold.&#10;"/>
    <Comment start="(141, 1)" end="(141, 17)" text="### find? -/"/>
    <Comment start="(269, 1)" end="(270, 1)" text="-- This isn't a `@[simp]` lemma since there is already a lemma for `l.find? p = none` for any `l`.&#10;"/>
    <Comment start="(304, 1)" end="(304, 23)" text="### findFinIdx? -/"/>
  </Comments>
</TracedFile>
