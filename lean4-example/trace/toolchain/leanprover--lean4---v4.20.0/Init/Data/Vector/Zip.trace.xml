<TracedFile path="src/lean/Init/Data/Vector/Zip.lean" md5="95c229e4f89b0ceb910d741ddb9a5e8c">
  <FileNode start="(1, 1)" end="(304, 11)">
    <ModuleHeaderNode start="(6, 1)" end="(10, 31)">
      <NullNode start="(6, 1)" end="(6, 7)">
        <OtherNode start="(6, 1)" end="(6, 7)" kind="Lean.Parser.Module.moduleTk">
          <AtomNode start="(6, 1)" end="(6, 7)" leading="" trailing="&#10;&#10;" val="module"/>
        </OtherNode>
      </NullNode>
      <NullNode start="(8, 1)" end="(8, 8)">
        <ModulePreludeNode start="(8, 1)" end="(8, 8)">
          <AtomNode start="(8, 1)" end="(8, 8)" leading="" trailing="&#10;" val="prelude"/>
        </ModulePreludeNode>
      </NullNode>
      <NullNode start="(9, 1)" end="(10, 31)">
        <ModuleImportNode start="(9, 1)" end="(9, 27)" module="Init.Data.Array.Zip" path="src/lean/Init/Data/Array/Zip.lean">
          <NullNode/>
          <AtomNode start="(9, 1)" end="(9, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(9, 8)" end="(9, 27)" leading="" trailing="&#10;" raw_val="Init.Data.Array.Zip" val="Init.Data.Array.Zip"/>
          <NullNode/>
        </ModuleImportNode>
        <ModuleImportNode start="(10, 1)" end="(10, 31)" module="Init.Data.Vector.Lemmas" path="src/lean/Init/Data/Vector/Lemmas.lean">
          <NullNode/>
          <AtomNode start="(10, 1)" end="(10, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(10, 8)" end="(10, 31)" leading="" trailing="&#10;&#10;" raw_val="Init.Data.Vector.Lemmas" val="Init.Data.Vector.Lemmas"/>
          <NullNode/>
        </ModuleImportNode>
      </NullNode>
    </ModuleHeaderNode>
    <CommandModuledocNode start="(12, 1)" end="(14, 3)" comment="# Lemmas about `Vector.zip`, `Vector.zipWith`, `Vector.zipWithAll`, and `Vector.unzip`.&#10;-/">
      <AtomNode start="(12, 1)" end="(12, 4)" leading="" trailing="&#10;" val="/-!"/>
      <AtomNode start="(13, 1)" end="(14, 3)" leading="" trailing="&#10;&#10;" val="# Lemmas about `Vector.zip`, `Vector.zipWith`, `Vector.zipWithAll`, and `Vector.unzip`.&#10;-/"/>
    </CommandModuledocNode>
    <OtherNode start="(16, 1)" end="(16, 37)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(16, 1)" end="(16, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(16, 12)" end="(16, 32)" leading="" trailing=" " raw_val="linter.listVariables" val="linter.listVariables"/>
      <NullNode/>
      <AtomNode start="(16, 33)" end="(16, 37)" leading="" trailing=" -- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;" val="true"/>
    </OtherNode>
    <OtherNode start="(17, 1)" end="(17, 38)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(17, 1)" end="(17, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(17, 12)" end="(17, 33)" leading="" trailing=" " raw_val="linter.indexVariables" val="linter.indexVariables"/>
      <NullNode/>
      <AtomNode start="(17, 34)" end="(17, 38)" leading="" trailing=" -- Enforce naming conventions for index variables.&#10;&#10;" val="true"/>
    </OtherNode>
    <CommandNamespaceNode start="(19, 1)" end="(19, 17)" name="Vector">
      <AtomNode start="(19, 1)" end="(19, 10)" leading="" trailing=" " val="namespace"/>
      <IdentNode start="(19, 11)" end="(19, 17)" leading="" trailing="&#10;&#10;" raw_val="Vector" val="Vector"/>
    </CommandNamespaceNode>
    <CommandOpenNode start="(21, 1)" end="(21, 9)">
      <AtomNode start="(21, 1)" end="(21, 5)" leading="" trailing=" " val="open"/>
      <OtherNode start="(21, 6)" end="(21, 9)" kind="Lean.Parser.Command.openSimple">
        <NullNode start="(21, 6)" end="(21, 9)">
          <IdentNode start="(21, 6)" end="(21, 9)" leading="" trailing="&#10;&#10;" raw_val="Nat" val="Nat"/>
        </NullNode>
      </OtherNode>
    </CommandOpenNode>
    <CommandModuledocNode start="(23, 1)" end="(23, 18)" comment="## Zippers -/">
      <AtomNode start="(23, 1)" end="(23, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(23, 5)" end="(23, 18)" leading="" trailing="&#10;&#10;" val="## Zippers -/"/>
    </CommandModuledocNode>
    <CommandModuledocNode start="(25, 1)" end="(25, 19)" comment="### zipWith -/">
      <AtomNode start="(25, 1)" end="(25, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(25, 5)" end="(25, 19)" leading="" trailing="&#10;&#10;" val="### zipWith -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(27, 1)" end="(31, 33)" name="zipWith_comm" full_name="Vector.zipWith_comm">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(27, 1)" end="(31, 33)" name="zipWith_comm" full_name="Vector.zipWith_comm" _is_private_decl="False">
        <AtomNode start="(27, 1)" end="(27, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(27, 9)" end="(27, 21)">
          <IdentNode start="(27, 9)" end="(27, 21)" leading="" trailing=" " raw_val="zipWith_comm" val="zipWith_comm"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(27, 22)" end="(28, 55)">
          <NullNode start="(27, 22)" end="(27, 73)">
            <OtherNode start="(27, 22)" end="(27, 37)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(27, 22)" end="(27, 23)" leading="" trailing="" val="{"/>
              <NullNode start="(27, 23)" end="(27, 24)">
                <IdentNode start="(27, 23)" end="(27, 24)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(27, 25)" end="(27, 36)">
                <AtomNode start="(27, 25)" end="(27, 26)" leading="" trailing=" " val=":"/>
                <OtherNode start="(27, 27)" end="(27, 36)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(27, 27)" end="(27, 28)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(27, 29)" end="(27, 30)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(27, 31)" end="(27, 36)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(27, 31)" end="(27, 32)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(27, 33)" end="(27, 34)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(27, 35)" end="(27, 36)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(27, 36)" end="(27, 37)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(27, 38)" end="(27, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(27, 38)" end="(27, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(27, 39)" end="(27, 41)">
                <IdentNode start="(27, 39)" end="(27, 41)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(27, 42)" end="(27, 54)">
                <AtomNode start="(27, 42)" end="(27, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(27, 44)" end="(27, 54)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(27, 44)" end="(27, 50)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(27, 51)" end="(27, 54)">
                    <IdentNode start="(27, 51)" end="(27, 52)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(27, 53)" end="(27, 54)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(27, 54)" end="(27, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(27, 56)" end="(27, 73)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(27, 56)" end="(27, 57)" leading="" trailing="" val="{"/>
              <NullNode start="(27, 57)" end="(27, 59)">
                <IdentNode start="(27, 57)" end="(27, 59)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(27, 60)" end="(27, 72)">
                <AtomNode start="(27, 60)" end="(27, 61)" leading="" trailing=" " val=":"/>
                <OtherNode start="(27, 62)" end="(27, 72)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(27, 62)" end="(27, 68)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(27, 69)" end="(27, 72)">
                    <IdentNode start="(27, 69)" end="(27, 70)" leading="" trailing=" " raw_val="β" val="β"/>
                    <IdentNode start="(27, 71)" end="(27, 72)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(27, 72)" end="(27, 73)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(27, 74)" end="(28, 55)">
            <AtomNode start="(27, 74)" end="(27, 75)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(28, 5)" end="(28, 55)" kind="«term_=_»">
              <OtherNode start="(28, 5)" end="(28, 20)" kind="Lean.Parser.Term.app">
                <IdentNode start="(28, 5)" end="(28, 12)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="Vector.zipWith" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(28, 13)" end="(28, 20)">
                  <IdentNode start="(28, 13)" end="(28, 14)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(28, 15)" end="(28, 17)" leading="" trailing=" " raw_val="as" val="as"/>
                  <IdentNode start="(28, 18)" end="(28, 20)" leading="" trailing=" " raw_val="bs" val="bs"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(28, 21)" end="(28, 22)" leading="" trailing=" " val="="/>
              <OtherNode start="(28, 23)" end="(28, 55)" kind="Lean.Parser.Term.app">
                <IdentNode start="(28, 23)" end="(28, 30)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="Vector.zipWith" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(28, 31)" end="(28, 55)">
                  <OtherNode start="(28, 31)" end="(28, 49)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(28, 31)" end="(28, 32)" leading="" trailing="" val="("/>
                    <OtherNode start="(28, 32)" end="(28, 48)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(28, 32)" end="(28, 35)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(28, 36)" end="(28, 48)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(28, 36)" end="(28, 39)">
                          <IdentNode start="(28, 36)" end="(28, 37)" leading="" trailing=" " raw_val="b" val="b"/>
                          <IdentNode start="(28, 38)" end="(28, 39)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(28, 40)" end="(28, 42)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(28, 43)" end="(28, 48)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(28, 43)" end="(28, 44)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode start="(28, 45)" end="(28, 48)">
                            <IdentNode start="(28, 45)" end="(28, 46)" leading="" trailing=" " raw_val="a" val="a"/>
                            <IdentNode start="(28, 47)" end="(28, 48)" leading="" trailing="" raw_val="b" val="b"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(28, 48)" end="(28, 49)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(28, 50)" end="(28, 52)" leading="" trailing=" " raw_val="bs" val="bs"/>
                  <IdentNode start="(28, 53)" end="(28, 55)" leading="" trailing=" " raw_val="as" val="as"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(28, 56)" end="(31, 33)">
          <AtomNode start="(28, 56)" end="(28, 58)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(28, 59)" end="(31, 33)">
            <AtomNode start="(28, 59)" end="(28, 61)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(29, 3)" end="(31, 33)">
              <TacticTacticseq1IndentedNode start="(29, 3)" end="(31, 33)">
                <NullNode start="(29, 3)" end="(31, 33)">
                  <OtherNode start="(29, 3)" end="(29, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;n : Nat&#10;f : α → β → γ&#10;as : Vector α n&#10;bs : Vector β n&#10;⊢ zipWith f as bs = zipWith (fun b a =&amp;gt; f a b) bs as" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ zipWith f { toArray := as, size_toArray := ⋯ } bs = zipWith (fun b a =&amp;gt; f a b) bs { toArray := as, size_toArray := ⋯ }" tactic="rcases as with ⟨as, rfl⟩">
                    <AtomNode start="(29, 3)" end="(29, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(29, 10)" end="(29, 12)">
                      <OtherNode start="(29, 10)" end="(29, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(29, 10)" end="(29, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(29, 13)" end="(29, 27)">
                      <AtomNode start="(29, 13)" end="(29, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(29, 18)" end="(29, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(29, 18)" end="(29, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(29, 18)" end="(29, 27)">
                            <OtherNode start="(29, 18)" end="(29, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(29, 18)" end="(29, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(29, 19)" end="(29, 26)">
                                <OtherNode start="(29, 19)" end="(29, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(29, 19)" end="(29, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(29, 19)" end="(29, 21)">
                                      <OtherNode start="(29, 19)" end="(29, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(29, 19)" end="(29, 21)" leading="" trailing="" raw_val="as" val="as"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(29, 21)" end="(29, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(29, 23)" end="(29, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(29, 23)" end="(29, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(29, 23)" end="(29, 26)">
                                      <OtherNode start="(29, 23)" end="(29, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(29, 23)" end="(29, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(29, 26)" end="(29, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(30, 3)" end="(30, 25)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ zipWith f { toArray := as, size_toArray := ⋯ } bs = zipWith (fun b a =&amp;gt; f a b) bs { toArray := as, size_toArray := ⋯ }" state_after="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ zipWith f { toArray := as, size_toArray := ⋯ } { toArray := bs, size_toArray := h } =&#10;    zipWith (fun b a =&amp;gt; f a b) { toArray := bs, size_toArray := h } { toArray := as, size_toArray := ⋯ }" tactic="rcases bs with ⟨bs, h⟩">
                    <AtomNode start="(30, 3)" end="(30, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(30, 10)" end="(30, 12)">
                      <OtherNode start="(30, 10)" end="(30, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(30, 10)" end="(30, 12)" leading="" trailing=" " raw_val="bs" val="bs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(30, 13)" end="(30, 25)">
                      <AtomNode start="(30, 13)" end="(30, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(30, 18)" end="(30, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(30, 18)" end="(30, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(30, 18)" end="(30, 25)">
                            <OtherNode start="(30, 18)" end="(30, 25)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(30, 18)" end="(30, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(30, 19)" end="(30, 24)">
                                <OtherNode start="(30, 19)" end="(30, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(30, 19)" end="(30, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(30, 19)" end="(30, 21)">
                                      <OtherNode start="(30, 19)" end="(30, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(30, 19)" end="(30, 21)" leading="" trailing="" raw_val="bs" val="bs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(30, 21)" end="(30, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(30, 23)" end="(30, 24)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(30, 23)" end="(30, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(30, 23)" end="(30, 24)">
                                      <OtherNode start="(30, 23)" end="(30, 24)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(30, 23)" end="(30, 24)" leading="" trailing="" raw_val="h" val="h"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(30, 24)" end="(30, 25)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(31, 3)" end="(31, 33)" kind="Lean.Parser.Tactic.simpa" state_before="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ zipWith f { toArray := as, size_toArray := ⋯ } { toArray := bs, size_toArray := h } =&#10;    zipWith (fun b a =&amp;gt; f a b) { toArray := bs, size_toArray := h } { toArray := as, size_toArray := ⋯ }" state_after="no goals" tactic="simpa using Array.zipWith_comm">
                    <AtomNode start="(31, 3)" end="(31, 8)" leading="" trailing=" " val="simpa"/>
                    <NullNode/>
                    <NullNode/>
                    <OtherNode start="(31, 9)" end="(31, 33)" kind="Lean.Parser.Tactic.simpaArgsRest">
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(31, 9)" end="(31, 33)">
                        <AtomNode start="(31, 9)" end="(31, 14)" leading="" trailing=" " val="using"/>
                        <IdentNode start="(31, 15)" end="(31, 33)" leading="" trailing="&#10;&#10;" raw_val="Array.zipWith_comm" val="Array.zipWith_comm" full_name="Array.zipWith_comm" mod_name="Init.Data.Array.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Zip.lean"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(33, 1)" end="(36, 19)" name="zipWith_comm_of_comm" full_name="Vector.zipWith_comm_of_comm">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(33, 1)" end="(36, 19)" name="zipWith_comm_of_comm" full_name="Vector.zipWith_comm_of_comm" _is_private_decl="False">
        <AtomNode start="(33, 1)" end="(33, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(33, 9)" end="(33, 29)">
          <IdentNode start="(33, 9)" end="(33, 29)" leading="" trailing=" " raw_val="zipWith_comm_of_comm" val="zipWith_comm_of_comm"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(33, 30)" end="(34, 38)">
          <NullNode start="(33, 30)" end="(33, 100)">
            <OtherNode start="(33, 30)" end="(33, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(33, 30)" end="(33, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(33, 31)" end="(33, 32)">
                <IdentNode start="(33, 31)" end="(33, 32)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(33, 33)" end="(33, 44)">
                <AtomNode start="(33, 33)" end="(33, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(33, 35)" end="(33, 44)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(33, 35)" end="(33, 36)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(33, 37)" end="(33, 38)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(33, 39)" end="(33, 44)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(33, 39)" end="(33, 40)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(33, 41)" end="(33, 42)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(33, 43)" end="(33, 44)" leading="" trailing="" raw_val="β" val="β"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(33, 44)" end="(33, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(33, 46)" end="(33, 79)">
              <AtomNode start="(33, 46)" end="(33, 47)" leading="" trailing="" val="("/>
              <NullNode start="(33, 47)" end="(33, 51)">
                <IdentNode start="(33, 47)" end="(33, 51)" leading="" trailing=" " raw_val="comm" val="comm"/>
              </NullNode>
              <NullNode start="(33, 52)" end="(33, 78)">
                <AtomNode start="(33, 52)" end="(33, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(33, 54)" end="(33, 78)" kind="Lean.Parser.Term.forall">
                  <AtomNode start="(33, 54)" end="(33, 55)" leading="" trailing=" " val="∀"/>
                  <NullNode start="(33, 56)" end="(33, 59)">
                    <IdentNode start="(33, 56)" end="(33, 57)" leading="" trailing=" " raw_val="x" val="x"/>
                    <IdentNode start="(33, 58)" end="(33, 59)" leading="" trailing=" " raw_val="y" val="y"/>
                  </NullNode>
                  <NullNode start="(33, 60)" end="(33, 63)">
                    <TermTypespecNode start="(33, 60)" end="(33, 63)">
                      <AtomNode start="(33, 60)" end="(33, 61)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(33, 62)" end="(33, 63)" leading="" trailing="" raw_val="α" val="α"/>
                    </TermTypespecNode>
                  </NullNode>
                  <AtomNode start="(33, 63)" end="(33, 64)" leading="" trailing=" " val=","/>
                  <OtherNode start="(33, 65)" end="(33, 78)" kind="«term_=_»">
                    <OtherNode start="(33, 65)" end="(33, 70)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(33, 65)" end="(33, 66)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(33, 67)" end="(33, 70)">
                        <IdentNode start="(33, 67)" end="(33, 68)" leading="" trailing=" " raw_val="x" val="x"/>
                        <IdentNode start="(33, 69)" end="(33, 70)" leading="" trailing=" " raw_val="y" val="y"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(33, 71)" end="(33, 72)" leading="" trailing=" " val="="/>
                    <OtherNode start="(33, 73)" end="(33, 78)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(33, 73)" end="(33, 74)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(33, 75)" end="(33, 78)">
                        <IdentNode start="(33, 75)" end="(33, 76)" leading="" trailing=" " raw_val="y" val="y"/>
                        <IdentNode start="(33, 77)" end="(33, 78)" leading="" trailing="" raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(33, 78)" end="(33, 79)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(33, 80)" end="(33, 100)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(33, 80)" end="(33, 81)" leading="" trailing="" val="{"/>
              <NullNode start="(33, 81)" end="(33, 86)">
                <IdentNode start="(33, 81)" end="(33, 83)" leading="" trailing=" " raw_val="xs" val="xs"/>
                <IdentNode start="(33, 84)" end="(33, 86)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(33, 87)" end="(33, 99)">
                <AtomNode start="(33, 87)" end="(33, 88)" leading="" trailing=" " val=":"/>
                <OtherNode start="(33, 89)" end="(33, 99)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(33, 89)" end="(33, 95)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(33, 96)" end="(33, 99)">
                    <IdentNode start="(33, 96)" end="(33, 97)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(33, 98)" end="(33, 99)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(33, 99)" end="(33, 100)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(33, 101)" end="(34, 38)">
            <AtomNode start="(33, 101)" end="(33, 102)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(34, 5)" end="(34, 38)" kind="«term_=_»">
              <OtherNode start="(34, 5)" end="(34, 20)" kind="Lean.Parser.Term.app">
                <IdentNode start="(34, 5)" end="(34, 12)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="Vector.zipWith" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(34, 13)" end="(34, 20)">
                  <IdentNode start="(34, 13)" end="(34, 14)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(34, 15)" end="(34, 17)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <IdentNode start="(34, 18)" end="(34, 20)" leading="" trailing=" " raw_val="ys" val="ys"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(34, 21)" end="(34, 22)" leading="" trailing=" " val="="/>
              <OtherNode start="(34, 23)" end="(34, 38)" kind="Lean.Parser.Term.app">
                <IdentNode start="(34, 23)" end="(34, 30)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="Vector.zipWith" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(34, 31)" end="(34, 38)">
                  <IdentNode start="(34, 31)" end="(34, 32)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(34, 33)" end="(34, 35)" leading="" trailing=" " raw_val="ys" val="ys"/>
                  <IdentNode start="(34, 36)" end="(34, 38)" leading="" trailing=" " raw_val="xs" val="xs"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(34, 39)" end="(36, 19)">
          <AtomNode start="(34, 39)" end="(34, 41)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(34, 42)" end="(36, 19)">
            <AtomNode start="(34, 42)" end="(34, 44)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(35, 3)" end="(36, 19)">
              <TacticTacticseq1IndentedNode start="(35, 3)" end="(36, 19)">
                <NullNode start="(35, 3)" end="(36, 19)">
                  <OtherNode start="(35, 3)" end="(35, 20)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;β : Type u_2&#10;n : Nat&#10;f : α → α → β&#10;comm : ∀ (x y : α), f x y = f y x&#10;xs ys : Vector α n&#10;⊢ zipWith f xs ys = zipWith f ys xs" state_after="α : Type u_1&#10;β : Type u_2&#10;n : Nat&#10;f : α → α → β&#10;comm : ∀ (x y : α), f x y = f y x&#10;xs ys : Vector α n&#10;⊢ zipWith (fun b a =&amp;gt; f a b) ys xs = zipWith f ys xs" tactic="rw [zipWith_comm]">
                    <AtomNode start="(35, 3)" end="(35, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(35, 6)" end="(35, 20)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(35, 6)" end="(35, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(35, 7)" end="(35, 19)">
                        <OtherNode start="(35, 7)" end="(35, 19)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(35, 7)" end="(35, 19)" leading="" trailing="" raw_val="zipWith_comm" val="zipWith_comm" full_name="Vector.zipWith_comm" mod_name="Init.Data.Vector.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Zip.lean" def_start="(27, 9)" def_end="(27, 21)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(35, 19)" end="(35, 20)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(36, 3)" end="(36, 19)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;n : Nat&#10;f : α → α → β&#10;comm : ∀ (x y : α), f x y = f y x&#10;xs ys : Vector α n&#10;⊢ zipWith (fun b a =&amp;gt; f a b) ys xs = zipWith f ys xs" state_after="no goals" tactic="simp only [comm]">
                    <AtomNode start="(36, 3)" end="(36, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(36, 8)" end="(36, 12)">
                      <AtomNode start="(36, 8)" end="(36, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(36, 13)" end="(36, 19)">
                      <AtomNode start="(36, 13)" end="(36, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(36, 14)" end="(36, 18)">
                        <OtherNode start="(36, 14)" end="(36, 18)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(36, 14)" end="(36, 18)" leading="" trailing="" raw_val="comm" val="comm"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(36, 18)" end="(36, 19)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(38, 1)" end="(41, 7)" name="zipWith_self" full_name="Vector.zipWith_self">
      <CommandDeclmodifiersNode start="(38, 1)" end="(38, 8)">
        <NullNode/>
        <NullNode start="(38, 1)" end="(38, 8)">
          <OtherNode start="(38, 1)" end="(38, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(38, 1)" end="(38, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(38, 3)" end="(38, 7)">
              <OtherNode start="(38, 3)" end="(38, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(38, 3)" end="(38, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(38, 3)" end="(38, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(38, 7)" end="(38, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(39, 1)" end="(41, 7)" name="zipWith_self" full_name="Vector.zipWith_self" _is_private_decl="False">
        <AtomNode start="(39, 1)" end="(39, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(39, 9)" end="(39, 21)">
          <IdentNode start="(39, 9)" end="(39, 21)" leading="" trailing=" " raw_val="zipWith_self" val="zipWith_self"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(39, 22)" end="(39, 97)">
          <NullNode start="(39, 22)" end="(39, 55)">
            <OtherNode start="(39, 22)" end="(39, 37)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(39, 22)" end="(39, 23)" leading="" trailing="" val="{"/>
              <NullNode start="(39, 23)" end="(39, 24)">
                <IdentNode start="(39, 23)" end="(39, 24)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(39, 25)" end="(39, 36)">
                <AtomNode start="(39, 25)" end="(39, 26)" leading="" trailing=" " val=":"/>
                <OtherNode start="(39, 27)" end="(39, 36)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(39, 27)" end="(39, 28)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(39, 29)" end="(39, 30)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(39, 31)" end="(39, 36)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(39, 31)" end="(39, 32)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(39, 33)" end="(39, 34)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(39, 35)" end="(39, 36)" leading="" trailing="" raw_val="δ" val="δ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(39, 36)" end="(39, 37)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(39, 38)" end="(39, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(39, 38)" end="(39, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(39, 39)" end="(39, 41)">
                <IdentNode start="(39, 39)" end="(39, 41)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(39, 42)" end="(39, 54)">
                <AtomNode start="(39, 42)" end="(39, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(39, 44)" end="(39, 54)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(39, 44)" end="(39, 50)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(39, 51)" end="(39, 54)">
                    <IdentNode start="(39, 51)" end="(39, 52)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(39, 53)" end="(39, 54)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(39, 54)" end="(39, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(39, 56)" end="(39, 97)">
            <AtomNode start="(39, 56)" end="(39, 57)" leading="" trailing=" " val=":"/>
            <OtherNode start="(39, 58)" end="(39, 97)" kind="«term_=_»">
              <OtherNode start="(39, 58)" end="(39, 73)" kind="Lean.Parser.Term.app">
                <IdentNode start="(39, 58)" end="(39, 65)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="Vector.zipWith" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(39, 66)" end="(39, 73)">
                  <IdentNode start="(39, 66)" end="(39, 67)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(39, 68)" end="(39, 70)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <IdentNode start="(39, 71)" end="(39, 73)" leading="" trailing=" " raw_val="xs" val="xs"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(39, 74)" end="(39, 75)" leading="" trailing=" " val="="/>
              <OtherNode start="(39, 76)" end="(39, 97)" kind="Lean.Parser.Term.app">
                <IdentNode start="(39, 76)" end="(39, 82)" leading="" trailing=" " raw_val="xs.map" val="xs.map"/>
                <NullNode start="(39, 83)" end="(39, 97)">
                  <OtherNode start="(39, 83)" end="(39, 97)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(39, 83)" end="(39, 86)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(39, 87)" end="(39, 97)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(39, 87)" end="(39, 88)">
                        <IdentNode start="(39, 87)" end="(39, 88)" leading="" trailing=" " raw_val="a" val="a"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(39, 89)" end="(39, 91)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(39, 92)" end="(39, 97)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(39, 92)" end="(39, 93)" leading="" trailing=" " raw_val="f" val="f"/>
                        <NullNode start="(39, 94)" end="(39, 97)">
                          <IdentNode start="(39, 94)" end="(39, 95)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(39, 96)" end="(39, 97)" leading="" trailing=" " raw_val="a" val="a"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(39, 98)" end="(41, 7)">
          <AtomNode start="(39, 98)" end="(39, 100)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(39, 101)" end="(41, 7)">
            <AtomNode start="(39, 101)" end="(39, 103)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(40, 3)" end="(41, 7)">
              <TacticTacticseq1IndentedNode start="(40, 3)" end="(41, 7)">
                <NullNode start="(40, 3)" end="(41, 7)">
                  <OtherNode start="(40, 3)" end="(40, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;δ : Type u_2&#10;n : Nat&#10;f : α → α → δ&#10;xs : Vector α n&#10;⊢ zipWith f xs xs = map (fun a =&amp;gt; f a a) xs" state_after="case mk&#10;α : Type u_1&#10;δ : Type u_2&#10;n : Nat&#10;f : α → α → δ&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n&#10;⊢ zipWith f { toArray := toArray✝, size_toArray := size_toArray✝ }&#10;      { toArray := toArray✝, size_toArray := size_toArray✝ } =&#10;    map (fun a =&amp;gt; f a a) { toArray := toArray✝, size_toArray := size_toArray✝ }" tactic="cases xs">
                    <AtomNode start="(40, 3)" end="(40, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(40, 9)" end="(40, 11)">
                      <OtherNode start="(40, 9)" end="(40, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(40, 9)" end="(40, 11)" leading="" trailing="&#10;  " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(41, 3)" end="(41, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;δ : Type u_2&#10;n : Nat&#10;f : α → α → δ&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n&#10;⊢ zipWith f { toArray := toArray✝, size_toArray := size_toArray✝ }&#10;      { toArray := toArray✝, size_toArray := size_toArray✝ } =&#10;    map (fun a =&amp;gt; f a a) { toArray := toArray✝, size_toArray := size_toArray✝ }" state_after="no goals" tactic="simp">
                    <AtomNode start="(41, 3)" end="(41, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(43, 1)" end="(53, 6)" name="getElem?_zipWith" full_name="Vector.getElem?_zipWith">
      <CommandDeclmodifiersNode start="(43, 1)" end="(46, 3)">
        <NullNode start="(43, 1)" end="(46, 3)">
          <CommandDoccommentNode start="(43, 1)" end="(46, 3)" comment="See also `getElem?_zipWith'` for a variant&#10;using `Option.map` and `Option.bind` rather than a `match`.&#10;-/">
            <AtomNode start="(43, 1)" end="(43, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(44, 1)" end="(46, 3)" leading="" trailing="&#10;" val="See also `getElem?_zipWith'` for a variant&#10;using `Option.map` and `Option.bind` rather than a `match`.&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(47, 1)" end="(53, 6)" name="getElem?_zipWith" full_name="Vector.getElem?_zipWith" _is_private_decl="False">
        <AtomNode start="(47, 1)" end="(47, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(47, 9)" end="(47, 25)">
          <IdentNode start="(47, 9)" end="(47, 25)" leading="" trailing=" " raw_val="getElem?_zipWith" val="getElem?_zipWith"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(47, 26)" end="(49, 54)">
          <NullNode start="(47, 26)" end="(47, 51)">
            <OtherNode start="(47, 26)" end="(47, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(47, 26)" end="(47, 27)" leading="" trailing="" val="{"/>
              <NullNode start="(47, 27)" end="(47, 28)">
                <IdentNode start="(47, 27)" end="(47, 28)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(47, 29)" end="(47, 40)">
                <AtomNode start="(47, 29)" end="(47, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(47, 31)" end="(47, 40)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(47, 31)" end="(47, 32)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(47, 33)" end="(47, 34)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(47, 35)" end="(47, 40)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(47, 35)" end="(47, 36)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(47, 37)" end="(47, 38)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(47, 39)" end="(47, 40)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(47, 40)" end="(47, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(47, 42)" end="(47, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(47, 42)" end="(47, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(47, 43)" end="(47, 44)">
                <IdentNode start="(47, 43)" end="(47, 44)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(47, 45)" end="(47, 50)">
                <AtomNode start="(47, 45)" end="(47, 46)" leading="" trailing=" " val=":"/>
                <IdentNode start="(47, 47)" end="(47, 50)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(47, 50)" end="(47, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(47, 52)" end="(49, 54)">
            <AtomNode start="(47, 52)" end="(47, 53)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(48, 5)" end="(49, 54)" kind="«term_=_»">
              <OtherNode start="(48, 5)" end="(48, 26)" kind="«term__[_]_?»">
                <OtherNode start="(48, 5)" end="(48, 22)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(48, 5)" end="(48, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(48, 6)" end="(48, 21)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(48, 6)" end="(48, 13)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="Vector.zipWith" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                    <NullNode start="(48, 14)" end="(48, 21)">
                      <IdentNode start="(48, 14)" end="(48, 15)" leading="" trailing=" " raw_val="f" val="f"/>
                      <IdentNode start="(48, 16)" end="(48, 18)" leading="" trailing=" " raw_val="as" val="as"/>
                      <IdentNode start="(48, 19)" end="(48, 21)" leading="" trailing="" raw_val="bs" val="bs"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(48, 21)" end="(48, 22)" leading="" trailing="" val=")"/>
                </OtherNode>
                <GroupNode/>
                <AtomNode start="(48, 22)" end="(48, 23)" leading="" trailing="" val="["/>
                <IdentNode start="(48, 23)" end="(48, 24)" leading="" trailing="" raw_val="i" val="i"/>
                <AtomNode start="(48, 24)" end="(48, 25)" leading="" trailing="" val="]"/>
                <GroupNode/>
                <AtomNode start="(48, 25)" end="(48, 26)" leading="" trailing=" " val="?"/>
              </OtherNode>
              <AtomNode start="(48, 27)" end="(48, 28)" leading="" trailing=" " val="="/>
              <OtherNode start="(48, 29)" end="(49, 54)" kind="Lean.Parser.Term.match">
                <AtomNode start="(48, 29)" end="(48, 34)" leading="" trailing=" " val="match"/>
                <NullNode/>
                <NullNode/>
                <NullNode start="(48, 35)" end="(48, 49)">
                  <OtherNode start="(48, 35)" end="(48, 41)" kind="Lean.Parser.Term.matchDiscr">
                    <NullNode/>
                    <OtherNode start="(48, 35)" end="(48, 41)" kind="«term__[_]_?»">
                      <IdentNode start="(48, 35)" end="(48, 37)" leading="" trailing="" raw_val="as" val="as"/>
                      <GroupNode/>
                      <AtomNode start="(48, 37)" end="(48, 38)" leading="" trailing="" val="["/>
                      <IdentNode start="(48, 38)" end="(48, 39)" leading="" trailing="" raw_val="i" val="i"/>
                      <AtomNode start="(48, 39)" end="(48, 40)" leading="" trailing="" val="]"/>
                      <GroupNode/>
                      <AtomNode start="(48, 40)" end="(48, 41)" leading="" trailing="" val="?"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(48, 41)" end="(48, 42)" leading="" trailing=" " val=","/>
                  <OtherNode start="(48, 43)" end="(48, 49)" kind="Lean.Parser.Term.matchDiscr">
                    <NullNode/>
                    <OtherNode start="(48, 43)" end="(48, 49)" kind="«term__[_]_?»">
                      <IdentNode start="(48, 43)" end="(48, 45)" leading="" trailing="" raw_val="bs" val="bs"/>
                      <GroupNode/>
                      <AtomNode start="(48, 45)" end="(48, 46)" leading="" trailing="" val="["/>
                      <IdentNode start="(48, 46)" end="(48, 47)" leading="" trailing="" raw_val="i" val="i"/>
                      <AtomNode start="(48, 47)" end="(48, 48)" leading="" trailing="" val="]"/>
                      <GroupNode/>
                      <AtomNode start="(48, 48)" end="(48, 49)" leading="" trailing=" " val="?"/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
                <AtomNode start="(48, 50)" end="(48, 54)" leading="" trailing="&#10;      " val="with"/>
                <OtherNode start="(49, 7)" end="(49, 54)" kind="Lean.Parser.Term.matchAlts">
                  <NullNode start="(49, 7)" end="(49, 54)">
                    <OtherNode start="(49, 7)" end="(49, 39)" kind="Lean.Parser.Term.matchAlt">
                      <AtomNode start="(49, 7)" end="(49, 8)" leading="" trailing=" " val="|"/>
                      <NullNode start="(49, 9)" end="(49, 23)">
                        <NullNode start="(49, 9)" end="(49, 23)">
                          <OtherNode start="(49, 9)" end="(49, 15)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(49, 9)" end="(49, 13)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            <NullNode start="(49, 14)" end="(49, 15)">
                              <IdentNode start="(49, 14)" end="(49, 15)" leading="" trailing="" raw_val="a" val="a"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(49, 15)" end="(49, 16)" leading="" trailing=" " val=","/>
                          <OtherNode start="(49, 17)" end="(49, 23)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(49, 17)" end="(49, 21)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            <NullNode start="(49, 22)" end="(49, 23)">
                              <IdentNode start="(49, 22)" end="(49, 23)" leading="" trailing=" " raw_val="b" val="b"/>
                            </NullNode>
                          </OtherNode>
                        </NullNode>
                      </NullNode>
                      <AtomNode start="(49, 24)" end="(49, 26)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(49, 27)" end="(49, 39)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(49, 27)" end="(49, 31)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(49, 32)" end="(49, 39)">
                          <OtherNode start="(49, 32)" end="(49, 39)" kind="Lean.Parser.Term.paren">
                            <AtomNode start="(49, 32)" end="(49, 33)" leading="" trailing="" val="("/>
                            <OtherNode start="(49, 33)" end="(49, 38)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(49, 33)" end="(49, 34)" leading="" trailing=" " raw_val="f" val="f"/>
                              <NullNode start="(49, 35)" end="(49, 38)">
                                <IdentNode start="(49, 35)" end="(49, 36)" leading="" trailing=" " raw_val="a" val="a"/>
                                <IdentNode start="(49, 37)" end="(49, 38)" leading="" trailing="" raw_val="b" val="b"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(49, 38)" end="(49, 39)" leading="" trailing=" " val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                    <OtherNode start="(49, 40)" end="(49, 54)" kind="Lean.Parser.Term.matchAlt">
                      <AtomNode start="(49, 40)" end="(49, 41)" leading="" trailing=" " val="|"/>
                      <NullNode start="(49, 42)" end="(49, 46)">
                        <NullNode start="(49, 42)" end="(49, 46)">
                          <TermHoleNode start="(49, 42)" end="(49, 43)">
                            <AtomNode start="(49, 42)" end="(49, 43)" leading="" trailing="" val="_"/>
                          </TermHoleNode>
                          <AtomNode start="(49, 43)" end="(49, 44)" leading="" trailing=" " val=","/>
                          <TermHoleNode start="(49, 45)" end="(49, 46)">
                            <AtomNode start="(49, 45)" end="(49, 46)" leading="" trailing=" " val="_"/>
                          </TermHoleNode>
                        </NullNode>
                      </NullNode>
                      <AtomNode start="(49, 47)" end="(49, 49)" leading="" trailing=" " val="=&amp;gt;"/>
                      <IdentNode start="(49, 50)" end="(49, 54)" leading="" trailing=" " raw_val="none" val="none" full_name="Option.none" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(49, 55)" end="(53, 6)">
          <AtomNode start="(49, 55)" end="(49, 57)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(49, 58)" end="(53, 6)">
            <AtomNode start="(49, 58)" end="(49, 60)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(50, 3)" end="(53, 6)">
              <TacticTacticseq1IndentedNode start="(50, 3)" end="(53, 6)">
                <NullNode start="(50, 3)" end="(53, 6)">
                  <OtherNode start="(50, 3)" end="(50, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;n✝ : Nat&#10;as : Vector α n✝&#10;bs : Vector β n✝&#10;f : α → β → γ&#10;i : Nat&#10;⊢ (zipWith f as bs)[i]? =&#10;    match as[i]?, bs[i]? with&#10;    | some a, some b =&amp;gt; some (f a b)&#10;    | x, x_1 =&amp;gt; none" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;n✝ : Nat&#10;bs : Vector β n✝&#10;f : α → β → γ&#10;i : Nat&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n✝&#10;⊢ (zipWith f { toArray := toArray✝, size_toArray := size_toArray✝ } bs)[i]? =&#10;    match { toArray := toArray✝, size_toArray := size_toArray✝ }[i]?, bs[i]? with&#10;    | some a, some b =&amp;gt; some (f a b)&#10;    | x, x_1 =&amp;gt; none" tactic="cases as">
                    <AtomNode start="(50, 3)" end="(50, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(50, 9)" end="(50, 11)">
                      <OtherNode start="(50, 9)" end="(50, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(50, 9)" end="(50, 11)" leading="" trailing="&#10;  " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(51, 3)" end="(51, 11)" kind="Lean.Parser.Tactic.cases" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;n✝ : Nat&#10;bs : Vector β n✝&#10;f : α → β → γ&#10;i : Nat&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n✝&#10;⊢ (zipWith f { toArray := toArray✝, size_toArray := size_toArray✝ } bs)[i]? =&#10;    match { toArray := toArray✝, size_toArray := size_toArray✝ }[i]?, bs[i]? with&#10;    | some a, some b =&amp;gt; some (f a b)&#10;    | x, x_1 =&amp;gt; none" state_after="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;n✝ : Nat&#10;f : α → β → γ&#10;i : Nat&#10;toArray✝¹ : Array α&#10;size_toArray✝¹ : toArray✝¹.size = n✝&#10;toArray✝ : Array β&#10;size_toArray✝ : toArray✝.size = n✝&#10;⊢ (zipWith f { toArray := toArray✝¹, size_toArray := size_toArray✝¹ }&#10;        { toArray := toArray✝, size_toArray := size_toArray✝ })[i]? =&#10;    match { toArray := toArray✝¹, size_toArray := size_toArray✝¹ }[i]?,&#10;      { toArray := toArray✝, size_toArray := size_toArray✝ }[i]? with&#10;    | some a, some b =&amp;gt; some (f a b)&#10;    | x, x_1 =&amp;gt; none" tactic="cases bs">
                    <AtomNode start="(51, 3)" end="(51, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(51, 9)" end="(51, 11)">
                      <OtherNode start="(51, 9)" end="(51, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(51, 9)" end="(51, 11)" leading="" trailing="&#10;  " raw_val="bs" val="bs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(52, 3)" end="(52, 32)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;n✝ : Nat&#10;f : α → β → γ&#10;i : Nat&#10;toArray✝¹ : Array α&#10;size_toArray✝¹ : toArray✝¹.size = n✝&#10;toArray✝ : Array β&#10;size_toArray✝ : toArray✝.size = n✝&#10;⊢ (zipWith f { toArray := toArray✝¹, size_toArray := size_toArray✝¹ }&#10;        { toArray := toArray✝, size_toArray := size_toArray✝ })[i]? =&#10;    match { toArray := toArray✝¹, size_toArray := size_toArray✝¹ }[i]?,&#10;      { toArray := toArray✝, size_toArray := size_toArray✝ }[i]? with&#10;    | some a, some b =&amp;gt; some (f a b)&#10;    | x, x_1 =&amp;gt; none" state_after="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;n✝ : Nat&#10;f : α → β → γ&#10;i : Nat&#10;toArray✝¹ : Array α&#10;size_toArray✝¹ : toArray✝¹.size = n✝&#10;toArray✝ : Array β&#10;size_toArray✝ : toArray✝.size = n✝&#10;⊢ (match toArray✝¹[i]?, toArray✝[i]? with&#10;    | some a, some b =&amp;gt; some (f a b)&#10;    | x, x_1 =&amp;gt; none) =&#10;    match toArray✝¹[i]?, toArray✝[i]? with&#10;    | some a, some b =&amp;gt; some (f a b)&#10;    | x, x_1 =&amp;gt; none" tactic="simp [Array.getElem?_zipWith]">
                    <AtomNode start="(52, 3)" end="(52, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(52, 8)" end="(52, 32)">
                      <AtomNode start="(52, 8)" end="(52, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(52, 9)" end="(52, 31)">
                        <OtherNode start="(52, 9)" end="(52, 31)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(52, 9)" end="(52, 31)" leading="" trailing="" raw_val="Array.getElem?_zipWith" val="Array.getElem?_zipWith" full_name="Array.getElem?_zipWith" mod_name="Init.Data.Array.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Zip.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(52, 31)" end="(52, 32)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(53, 3)" end="(53, 6)" kind="Lean.Parser.Tactic.tacticRfl" state_before="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;n✝ : Nat&#10;f : α → β → γ&#10;i : Nat&#10;toArray✝¹ : Array α&#10;size_toArray✝¹ : toArray✝¹.size = n✝&#10;toArray✝ : Array β&#10;size_toArray✝ : toArray✝.size = n✝&#10;⊢ (match toArray✝¹[i]?, toArray✝[i]? with&#10;    | some a, some b =&amp;gt; some (f a b)&#10;    | x, x_1 =&amp;gt; none) =&#10;    match toArray✝¹[i]?, toArray✝[i]? with&#10;    | some a, some b =&amp;gt; some (f a b)&#10;    | x, x_1 =&amp;gt; none" state_after="no goals" tactic="rfl">
                    <AtomNode start="(53, 3)" end="(53, 6)" leading="" trailing="&#10;&#10;" val="rfl"/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(55, 1)" end="(60, 33)" name="getElem?_zipWith'" full_name="Vector.getElem?_zipWith'">
      <CommandDeclmodifiersNode start="(55, 1)" end="(55, 97)">
        <NullNode start="(55, 1)" end="(55, 97)">
          <CommandDoccommentNode start="(55, 1)" end="(55, 97)" comment="Variant of `getElem?_zipWith` using `Option.map` and `Option.bind` rather than a `match`. -/">
            <AtomNode start="(55, 1)" end="(55, 4)" leading="" trailing=" " val="/--"/>
            <AtomNode start="(55, 5)" end="(55, 97)" leading="" trailing="&#10;" val="Variant of `getElem?_zipWith` using `Option.map` and `Option.bind` rather than a `match`. -/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(56, 1)" end="(60, 33)" name="getElem?_zipWith'" full_name="Vector.getElem?_zipWith'" _is_private_decl="False">
        <AtomNode start="(56, 1)" end="(56, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(56, 9)" end="(56, 26)">
          <IdentNode start="(56, 9)" end="(56, 26)" leading="" trailing=" " raw_val="getElem?_zipWith'" val="getElem?_zipWith'"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(56, 27)" end="(57, 70)">
          <NullNode start="(56, 27)" end="(56, 52)">
            <OtherNode start="(56, 27)" end="(56, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(56, 27)" end="(56, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(56, 28)" end="(56, 29)">
                <IdentNode start="(56, 28)" end="(56, 29)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(56, 30)" end="(56, 41)">
                <AtomNode start="(56, 30)" end="(56, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(56, 32)" end="(56, 41)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(56, 32)" end="(56, 33)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(56, 34)" end="(56, 35)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(56, 36)" end="(56, 41)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(56, 36)" end="(56, 37)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(56, 38)" end="(56, 39)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(56, 40)" end="(56, 41)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(56, 41)" end="(56, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(56, 43)" end="(56, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(56, 43)" end="(56, 44)" leading="" trailing="" val="{"/>
              <NullNode start="(56, 44)" end="(56, 45)">
                <IdentNode start="(56, 44)" end="(56, 45)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(56, 46)" end="(56, 51)">
                <AtomNode start="(56, 46)" end="(56, 47)" leading="" trailing=" " val=":"/>
                <IdentNode start="(56, 48)" end="(56, 51)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(56, 51)" end="(56, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(56, 53)" end="(57, 70)">
            <AtomNode start="(56, 53)" end="(56, 54)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(57, 5)" end="(57, 70)" kind="«term_=_»">
              <OtherNode start="(57, 5)" end="(57, 26)" kind="«term__[_]_?»">
                <OtherNode start="(57, 5)" end="(57, 22)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(57, 5)" end="(57, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(57, 6)" end="(57, 21)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(57, 6)" end="(57, 13)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="Vector.zipWith" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                    <NullNode start="(57, 14)" end="(57, 21)">
                      <IdentNode start="(57, 14)" end="(57, 15)" leading="" trailing=" " raw_val="f" val="f"/>
                      <IdentNode start="(57, 16)" end="(57, 18)" leading="" trailing=" " raw_val="as" val="as"/>
                      <IdentNode start="(57, 19)" end="(57, 21)" leading="" trailing="" raw_val="bs" val="bs"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(57, 21)" end="(57, 22)" leading="" trailing="" val=")"/>
                </OtherNode>
                <GroupNode/>
                <AtomNode start="(57, 22)" end="(57, 23)" leading="" trailing="" val="["/>
                <IdentNode start="(57, 23)" end="(57, 24)" leading="" trailing="" raw_val="i" val="i"/>
                <AtomNode start="(57, 24)" end="(57, 25)" leading="" trailing="" val="]"/>
                <GroupNode/>
                <AtomNode start="(57, 25)" end="(57, 26)" leading="" trailing=" " val="?"/>
              </OtherNode>
              <AtomNode start="(57, 27)" end="(57, 28)" leading="" trailing=" " val="="/>
              <OtherNode start="(57, 29)" end="(57, 70)" kind="Lean.Parser.Term.app">
                <OtherNode start="(57, 29)" end="(57, 48)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(57, 29)" end="(57, 43)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(57, 29)" end="(57, 30)" leading="" trailing="" val="("/>
                    <OtherNode start="(57, 30)" end="(57, 42)" kind="Lean.Parser.Term.app">
                      <OtherNode start="(57, 30)" end="(57, 40)" kind="Lean.Parser.Term.proj">
                        <OtherNode start="(57, 30)" end="(57, 36)" kind="«term__[_]_?»">
                          <IdentNode start="(57, 30)" end="(57, 32)" leading="" trailing="" raw_val="as" val="as"/>
                          <GroupNode/>
                          <AtomNode start="(57, 32)" end="(57, 33)" leading="" trailing="" val="["/>
                          <IdentNode start="(57, 33)" end="(57, 34)" leading="" trailing="" raw_val="i" val="i"/>
                          <AtomNode start="(57, 34)" end="(57, 35)" leading="" trailing="" val="]"/>
                          <GroupNode/>
                          <AtomNode start="(57, 35)" end="(57, 36)" leading="" trailing="" val="?"/>
                        </OtherNode>
                        <AtomNode start="(57, 36)" end="(57, 37)" leading="" trailing="" val="."/>
                        <IdentNode start="(57, 37)" end="(57, 40)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </OtherNode>
                      <NullNode start="(57, 41)" end="(57, 42)">
                        <IdentNode start="(57, 41)" end="(57, 42)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(57, 42)" end="(57, 43)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(57, 43)" end="(57, 44)" leading="" trailing="" val="."/>
                  <IdentNode start="(57, 44)" end="(57, 48)" leading="" trailing=" " raw_val="bind" val="bind" full_name="Option.bind" mod_name="Init.Data.Option.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Option/Basic.lean"/>
                </OtherNode>
                <NullNode start="(57, 49)" end="(57, 70)">
                  <OtherNode start="(57, 49)" end="(57, 70)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(57, 49)" end="(57, 52)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(57, 53)" end="(57, 70)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(57, 53)" end="(57, 54)">
                        <IdentNode start="(57, 53)" end="(57, 54)" leading="" trailing=" " raw_val="g" val="g"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(57, 55)" end="(57, 57)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(57, 58)" end="(57, 70)" kind="Lean.Parser.Term.app">
                        <OtherNode start="(57, 58)" end="(57, 68)" kind="Lean.Parser.Term.proj">
                          <OtherNode start="(57, 58)" end="(57, 64)" kind="«term__[_]_?»">
                            <IdentNode start="(57, 58)" end="(57, 60)" leading="" trailing="" raw_val="bs" val="bs"/>
                            <GroupNode/>
                            <AtomNode start="(57, 60)" end="(57, 61)" leading="" trailing="" val="["/>
                            <IdentNode start="(57, 61)" end="(57, 62)" leading="" trailing="" raw_val="i" val="i"/>
                            <AtomNode start="(57, 62)" end="(57, 63)" leading="" trailing="" val="]"/>
                            <GroupNode/>
                            <AtomNode start="(57, 63)" end="(57, 64)" leading="" trailing="" val="?"/>
                          </OtherNode>
                          <AtomNode start="(57, 64)" end="(57, 65)" leading="" trailing="" val="."/>
                          <IdentNode start="(57, 65)" end="(57, 68)" leading="" trailing=" " raw_val="map" val="map" full_name="Option.map" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        </OtherNode>
                        <NullNode start="(57, 69)" end="(57, 70)">
                          <IdentNode start="(57, 69)" end="(57, 70)" leading="" trailing=" " raw_val="g" val="g"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(57, 71)" end="(60, 33)">
          <AtomNode start="(57, 71)" end="(57, 73)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(57, 74)" end="(60, 33)">
            <AtomNode start="(57, 74)" end="(57, 76)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(58, 3)" end="(60, 33)">
              <TacticTacticseq1IndentedNode start="(58, 3)" end="(60, 33)">
                <NullNode start="(58, 3)" end="(60, 33)">
                  <OtherNode start="(58, 3)" end="(58, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;n✝ : Nat&#10;as : Vector α n✝&#10;bs : Vector β n✝&#10;f : α → β → γ&#10;i : Nat&#10;⊢ (zipWith f as bs)[i]? = (Option.map f as[i]?).bind fun g =&amp;gt; Option.map g bs[i]?" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;n✝ : Nat&#10;bs : Vector β n✝&#10;f : α → β → γ&#10;i : Nat&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n✝&#10;⊢ (zipWith f { toArray := toArray✝, size_toArray := size_toArray✝ } bs)[i]? =&#10;    (Option.map f { toArray := toArray✝, size_toArray := size_toArray✝ }[i]?).bind fun g =&amp;gt; Option.map g bs[i]?" tactic="cases as">
                    <AtomNode start="(58, 3)" end="(58, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(58, 9)" end="(58, 11)">
                      <OtherNode start="(58, 9)" end="(58, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(58, 9)" end="(58, 11)" leading="" trailing="&#10;  " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(59, 3)" end="(59, 11)" kind="Lean.Parser.Tactic.cases" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;n✝ : Nat&#10;bs : Vector β n✝&#10;f : α → β → γ&#10;i : Nat&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n✝&#10;⊢ (zipWith f { toArray := toArray✝, size_toArray := size_toArray✝ } bs)[i]? =&#10;    (Option.map f { toArray := toArray✝, size_toArray := size_toArray✝ }[i]?).bind fun g =&amp;gt; Option.map g bs[i]?" state_after="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;n✝ : Nat&#10;f : α → β → γ&#10;i : Nat&#10;toArray✝¹ : Array α&#10;size_toArray✝¹ : toArray✝¹.size = n✝&#10;toArray✝ : Array β&#10;size_toArray✝ : toArray✝.size = n✝&#10;⊢ (zipWith f { toArray := toArray✝¹, size_toArray := size_toArray✝¹ }&#10;        { toArray := toArray✝, size_toArray := size_toArray✝ })[i]? =&#10;    (Option.map f { toArray := toArray✝¹, size_toArray := size_toArray✝¹ }[i]?).bind fun g =&amp;gt;&#10;      Option.map g { toArray := toArray✝, size_toArray := size_toArray✝ }[i]?" tactic="cases bs">
                    <AtomNode start="(59, 3)" end="(59, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(59, 9)" end="(59, 11)">
                      <OtherNode start="(59, 9)" end="(59, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(59, 9)" end="(59, 11)" leading="" trailing="&#10;  " raw_val="bs" val="bs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(60, 3)" end="(60, 33)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;n✝ : Nat&#10;f : α → β → γ&#10;i : Nat&#10;toArray✝¹ : Array α&#10;size_toArray✝¹ : toArray✝¹.size = n✝&#10;toArray✝ : Array β&#10;size_toArray✝ : toArray✝.size = n✝&#10;⊢ (zipWith f { toArray := toArray✝¹, size_toArray := size_toArray✝¹ }&#10;        { toArray := toArray✝, size_toArray := size_toArray✝ })[i]? =&#10;    (Option.map f { toArray := toArray✝¹, size_toArray := size_toArray✝¹ }[i]?).bind fun g =&amp;gt;&#10;      Option.map g { toArray := toArray✝, size_toArray := size_toArray✝ }[i]?" state_after="no goals" tactic="simp [Array.getElem?_zipWith']">
                    <AtomNode start="(60, 3)" end="(60, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(60, 8)" end="(60, 33)">
                      <AtomNode start="(60, 8)" end="(60, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(60, 9)" end="(60, 32)">
                        <OtherNode start="(60, 9)" end="(60, 32)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(60, 9)" end="(60, 32)" leading="" trailing="" raw_val="Array.getElem?_zipWith'" val="Array.getElem?_zipWith'" full_name="Array.getElem?_zipWith'" mod_name="Init.Data.Array.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Zip.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(60, 32)" end="(60, 33)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(62, 1)" end="(67, 40)" name="getElem?_zipWith_eq_some" full_name="Vector.getElem?_zipWith_eq_some">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(62, 1)" end="(67, 40)" name="getElem?_zipWith_eq_some" full_name="Vector.getElem?_zipWith_eq_some" _is_private_decl="False">
        <AtomNode start="(62, 1)" end="(62, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(62, 9)" end="(62, 33)">
          <IdentNode start="(62, 9)" end="(62, 33)" leading="" trailing=" " raw_val="getElem?_zipWith_eq_some" val="getElem?_zipWith_eq_some"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(62, 34)" end="(64, 59)">
          <NullNode start="(62, 34)" end="(62, 103)">
            <OtherNode start="(62, 34)" end="(62, 49)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(62, 34)" end="(62, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(62, 35)" end="(62, 36)">
                <IdentNode start="(62, 35)" end="(62, 36)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(62, 37)" end="(62, 48)">
                <AtomNode start="(62, 37)" end="(62, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(62, 39)" end="(62, 48)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(62, 39)" end="(62, 40)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(62, 41)" end="(62, 42)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(62, 43)" end="(62, 48)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(62, 43)" end="(62, 44)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(62, 45)" end="(62, 46)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(62, 47)" end="(62, 48)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(62, 48)" end="(62, 49)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(62, 50)" end="(62, 67)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(62, 50)" end="(62, 51)" leading="" trailing="" val="{"/>
              <NullNode start="(62, 51)" end="(62, 53)">
                <IdentNode start="(62, 51)" end="(62, 53)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(62, 54)" end="(62, 66)">
                <AtomNode start="(62, 54)" end="(62, 55)" leading="" trailing=" " val=":"/>
                <OtherNode start="(62, 56)" end="(62, 66)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(62, 56)" end="(62, 62)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(62, 63)" end="(62, 66)">
                    <IdentNode start="(62, 63)" end="(62, 64)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(62, 65)" end="(62, 66)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(62, 66)" end="(62, 67)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(62, 68)" end="(62, 85)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(62, 68)" end="(62, 69)" leading="" trailing="" val="{"/>
              <NullNode start="(62, 69)" end="(62, 71)">
                <IdentNode start="(62, 69)" end="(62, 71)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(62, 72)" end="(62, 84)">
                <AtomNode start="(62, 72)" end="(62, 73)" leading="" trailing=" " val=":"/>
                <OtherNode start="(62, 74)" end="(62, 84)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(62, 74)" end="(62, 80)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(62, 81)" end="(62, 84)">
                    <IdentNode start="(62, 81)" end="(62, 82)" leading="" trailing=" " raw_val="β" val="β"/>
                    <IdentNode start="(62, 83)" end="(62, 84)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(62, 84)" end="(62, 85)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(62, 86)" end="(62, 93)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(62, 86)" end="(62, 87)" leading="" trailing="" val="{"/>
              <NullNode start="(62, 87)" end="(62, 88)">
                <IdentNode start="(62, 87)" end="(62, 88)" leading="" trailing=" " raw_val="z" val="z"/>
              </NullNode>
              <NullNode start="(62, 89)" end="(62, 92)">
                <AtomNode start="(62, 89)" end="(62, 90)" leading="" trailing=" " val=":"/>
                <IdentNode start="(62, 91)" end="(62, 92)" leading="" trailing="" raw_val="γ" val="γ"/>
              </NullNode>
              <AtomNode start="(62, 92)" end="(62, 93)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(62, 94)" end="(62, 103)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(62, 94)" end="(62, 95)" leading="" trailing="" val="{"/>
              <NullNode start="(62, 95)" end="(62, 96)">
                <IdentNode start="(62, 95)" end="(62, 96)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(62, 97)" end="(62, 102)">
                <AtomNode start="(62, 97)" end="(62, 98)" leading="" trailing=" " val=":"/>
                <IdentNode start="(62, 99)" end="(62, 102)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(62, 102)" end="(62, 103)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(62, 104)" end="(64, 59)">
            <AtomNode start="(62, 104)" end="(62, 105)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(63, 5)" end="(64, 59)" kind="«term_↔_»">
              <OtherNode start="(63, 5)" end="(63, 35)" kind="«term_=_»">
                <OtherNode start="(63, 5)" end="(63, 26)" kind="«term__[_]_?»">
                  <OtherNode start="(63, 5)" end="(63, 22)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(63, 5)" end="(63, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(63, 6)" end="(63, 21)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(63, 6)" end="(63, 13)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="Vector.zipWith" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                      <NullNode start="(63, 14)" end="(63, 21)">
                        <IdentNode start="(63, 14)" end="(63, 15)" leading="" trailing=" " raw_val="f" val="f"/>
                        <IdentNode start="(63, 16)" end="(63, 18)" leading="" trailing=" " raw_val="as" val="as"/>
                        <IdentNode start="(63, 19)" end="(63, 21)" leading="" trailing="" raw_val="bs" val="bs"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(63, 21)" end="(63, 22)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <GroupNode/>
                  <AtomNode start="(63, 22)" end="(63, 23)" leading="" trailing="" val="["/>
                  <IdentNode start="(63, 23)" end="(63, 24)" leading="" trailing="" raw_val="i" val="i"/>
                  <AtomNode start="(63, 24)" end="(63, 25)" leading="" trailing="" val="]"/>
                  <GroupNode/>
                  <AtomNode start="(63, 25)" end="(63, 26)" leading="" trailing=" " val="?"/>
                </OtherNode>
                <AtomNode start="(63, 27)" end="(63, 28)" leading="" trailing=" " val="="/>
                <OtherNode start="(63, 29)" end="(63, 35)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(63, 29)" end="(63, 33)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(63, 34)" end="(63, 35)">
                    <IdentNode start="(63, 34)" end="(63, 35)" leading="" trailing=" " raw_val="z" val="z"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(63, 36)" end="(63, 37)" leading="" trailing="&#10;      " val="↔"/>
              <OtherNode start="(64, 7)" end="(64, 59)" kind="«term∃_,_»">
                <AtomNode start="(64, 7)" end="(64, 8)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(64, 9)" end="(64, 12)" kind="Lean.explicitBinders">
                  <OtherNode start="(64, 9)" end="(64, 12)" kind="Lean.unbracketedExplicitBinders">
                    <NullNode start="(64, 9)" end="(64, 12)">
                      <LeanBinderidentNode start="(64, 9)" end="(64, 10)">
                        <IdentNode start="(64, 9)" end="(64, 10)" leading="" trailing=" " raw_val="x" val="x"/>
                      </LeanBinderidentNode>
                      <LeanBinderidentNode start="(64, 11)" end="(64, 12)">
                        <IdentNode start="(64, 11)" end="(64, 12)" leading="" trailing="" raw_val="y" val="y"/>
                      </LeanBinderidentNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(64, 12)" end="(64, 13)" leading="" trailing=" " val=","/>
                <OtherNode start="(64, 14)" end="(64, 59)" kind="«term_∧_»">
                  <OtherNode start="(64, 14)" end="(64, 29)" kind="«term_=_»">
                    <OtherNode start="(64, 14)" end="(64, 20)" kind="«term__[_]_?»">
                      <IdentNode start="(64, 14)" end="(64, 16)" leading="" trailing="" raw_val="as" val="as"/>
                      <GroupNode/>
                      <AtomNode start="(64, 16)" end="(64, 17)" leading="" trailing="" val="["/>
                      <IdentNode start="(64, 17)" end="(64, 18)" leading="" trailing="" raw_val="i" val="i"/>
                      <AtomNode start="(64, 18)" end="(64, 19)" leading="" trailing="" val="]"/>
                      <GroupNode/>
                      <AtomNode start="(64, 19)" end="(64, 20)" leading="" trailing=" " val="?"/>
                    </OtherNode>
                    <AtomNode start="(64, 21)" end="(64, 22)" leading="" trailing=" " val="="/>
                    <OtherNode start="(64, 23)" end="(64, 29)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(64, 23)" end="(64, 27)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode start="(64, 28)" end="(64, 29)">
                        <IdentNode start="(64, 28)" end="(64, 29)" leading="" trailing=" " raw_val="x" val="x"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(64, 30)" end="(64, 31)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(64, 32)" end="(64, 59)" kind="«term_∧_»">
                    <OtherNode start="(64, 32)" end="(64, 47)" kind="«term_=_»">
                      <OtherNode start="(64, 32)" end="(64, 38)" kind="«term__[_]_?»">
                        <IdentNode start="(64, 32)" end="(64, 34)" leading="" trailing="" raw_val="bs" val="bs"/>
                        <GroupNode/>
                        <AtomNode start="(64, 34)" end="(64, 35)" leading="" trailing="" val="["/>
                        <IdentNode start="(64, 35)" end="(64, 36)" leading="" trailing="" raw_val="i" val="i"/>
                        <AtomNode start="(64, 36)" end="(64, 37)" leading="" trailing="" val="]"/>
                        <GroupNode/>
                        <AtomNode start="(64, 37)" end="(64, 38)" leading="" trailing=" " val="?"/>
                      </OtherNode>
                      <AtomNode start="(64, 39)" end="(64, 40)" leading="" trailing=" " val="="/>
                      <OtherNode start="(64, 41)" end="(64, 47)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(64, 41)" end="(64, 45)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(64, 46)" end="(64, 47)">
                          <IdentNode start="(64, 46)" end="(64, 47)" leading="" trailing=" " raw_val="y" val="y"/>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(64, 48)" end="(64, 49)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(64, 50)" end="(64, 59)" kind="«term_=_»">
                      <OtherNode start="(64, 50)" end="(64, 55)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(64, 50)" end="(64, 51)" leading="" trailing=" " raw_val="f" val="f"/>
                        <NullNode start="(64, 52)" end="(64, 55)">
                          <IdentNode start="(64, 52)" end="(64, 53)" leading="" trailing=" " raw_val="x" val="x"/>
                          <IdentNode start="(64, 54)" end="(64, 55)" leading="" trailing=" " raw_val="y" val="y"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(64, 56)" end="(64, 57)" leading="" trailing=" " val="="/>
                      <IdentNode start="(64, 58)" end="(64, 59)" leading="" trailing=" " raw_val="z" val="z"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(64, 60)" end="(67, 40)">
          <AtomNode start="(64, 60)" end="(64, 62)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(64, 63)" end="(67, 40)">
            <AtomNode start="(64, 63)" end="(64, 65)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(65, 3)" end="(67, 40)">
              <TacticTacticseq1IndentedNode start="(65, 3)" end="(67, 40)">
                <NullNode start="(65, 3)" end="(67, 40)">
                  <OtherNode start="(65, 3)" end="(65, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;n : Nat&#10;f : α → β → γ&#10;as : Vector α n&#10;bs : Vector β n&#10;z : γ&#10;i : Nat&#10;⊢ (zipWith f as bs)[i]? = some z ↔ ∃ x y, as[i]? = some x ∧ bs[i]? = some y ∧ f x y = z" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;n : Nat&#10;f : α → β → γ&#10;bs : Vector β n&#10;z : γ&#10;i : Nat&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n&#10;⊢ (zipWith f { toArray := toArray✝, size_toArray := size_toArray✝ } bs)[i]? = some z ↔&#10;    ∃ x y, { toArray := toArray✝, size_toArray := size_toArray✝ }[i]? = some x ∧ bs[i]? = some y ∧ f x y = z" tactic="cases as">
                    <AtomNode start="(65, 3)" end="(65, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(65, 9)" end="(65, 11)">
                      <OtherNode start="(65, 9)" end="(65, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(65, 9)" end="(65, 11)" leading="" trailing="&#10;  " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(66, 3)" end="(66, 11)" kind="Lean.Parser.Tactic.cases" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;n : Nat&#10;f : α → β → γ&#10;bs : Vector β n&#10;z : γ&#10;i : Nat&#10;toArray✝ : Array α&#10;size_toArray✝ : toArray✝.size = n&#10;⊢ (zipWith f { toArray := toArray✝, size_toArray := size_toArray✝ } bs)[i]? = some z ↔&#10;    ∃ x y, { toArray := toArray✝, size_toArray := size_toArray✝ }[i]? = some x ∧ bs[i]? = some y ∧ f x y = z" state_after="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;n : Nat&#10;f : α → β → γ&#10;z : γ&#10;i : Nat&#10;toArray✝¹ : Array α&#10;size_toArray✝¹ : toArray✝¹.size = n&#10;toArray✝ : Array β&#10;size_toArray✝ : toArray✝.size = n&#10;⊢ (zipWith f { toArray := toArray✝¹, size_toArray := size_toArray✝¹ }&#10;          { toArray := toArray✝, size_toArray := size_toArray✝ })[i]? =&#10;      some z ↔&#10;    ∃ x y,&#10;      { toArray := toArray✝¹, size_toArray := size_toArray✝¹ }[i]? = some x ∧&#10;        { toArray := toArray✝, size_toArray := size_toArray✝ }[i]? = some y ∧ f x y = z" tactic="cases bs">
                    <AtomNode start="(66, 3)" end="(66, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(66, 9)" end="(66, 11)">
                      <OtherNode start="(66, 9)" end="(66, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(66, 9)" end="(66, 11)" leading="" trailing="&#10;  " raw_val="bs" val="bs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(67, 3)" end="(67, 40)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;n : Nat&#10;f : α → β → γ&#10;z : γ&#10;i : Nat&#10;toArray✝¹ : Array α&#10;size_toArray✝¹ : toArray✝¹.size = n&#10;toArray✝ : Array β&#10;size_toArray✝ : toArray✝.size = n&#10;⊢ (zipWith f { toArray := toArray✝¹, size_toArray := size_toArray✝¹ }&#10;          { toArray := toArray✝, size_toArray := size_toArray✝ })[i]? =&#10;      some z ↔&#10;    ∃ x y,&#10;      { toArray := toArray✝¹, size_toArray := size_toArray✝¹ }[i]? = some x ∧&#10;        { toArray := toArray✝, size_toArray := size_toArray✝ }[i]? = some y ∧ f x y = z" state_after="no goals" tactic="simp [Array.getElem?_zipWith_eq_some]">
                    <AtomNode start="(67, 3)" end="(67, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(67, 8)" end="(67, 40)">
                      <AtomNode start="(67, 8)" end="(67, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(67, 9)" end="(67, 39)">
                        <OtherNode start="(67, 9)" end="(67, 39)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(67, 9)" end="(67, 39)" leading="" trailing="" raw_val="Array.getElem?_zipWith_eq_some" val="Array.getElem?_zipWith_eq_some" full_name="Array.getElem?_zipWith_eq_some" mod_name="Init.Data.Array.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Zip.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(67, 39)" end="(67, 40)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(69, 1)" end="(73, 36)" name="getElem?_zip_eq_some" full_name="Vector.getElem?_zip_eq_some">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(69, 1)" end="(73, 36)" name="getElem?_zip_eq_some" full_name="Vector.getElem?_zip_eq_some" _is_private_decl="False">
        <AtomNode start="(69, 1)" end="(69, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(69, 9)" end="(69, 29)">
          <IdentNode start="(69, 9)" end="(69, 29)" leading="" trailing=" " raw_val="getElem?_zip_eq_some" val="getElem?_zip_eq_some"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(69, 30)" end="(70, 69)">
          <NullNode start="(69, 30)" end="(69, 87)">
            <OtherNode start="(69, 30)" end="(69, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(69, 30)" end="(69, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(69, 31)" end="(69, 33)">
                <IdentNode start="(69, 31)" end="(69, 33)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(69, 34)" end="(69, 46)">
                <AtomNode start="(69, 34)" end="(69, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(69, 36)" end="(69, 46)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(69, 36)" end="(69, 42)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(69, 43)" end="(69, 46)">
                    <IdentNode start="(69, 43)" end="(69, 44)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(69, 45)" end="(69, 46)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(69, 46)" end="(69, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(69, 48)" end="(69, 65)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(69, 48)" end="(69, 49)" leading="" trailing="" val="{"/>
              <NullNode start="(69, 49)" end="(69, 51)">
                <IdentNode start="(69, 49)" end="(69, 51)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(69, 52)" end="(69, 64)">
                <AtomNode start="(69, 52)" end="(69, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(69, 54)" end="(69, 64)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(69, 54)" end="(69, 60)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(69, 61)" end="(69, 64)">
                    <IdentNode start="(69, 61)" end="(69, 62)" leading="" trailing=" " raw_val="β" val="β"/>
                    <IdentNode start="(69, 63)" end="(69, 64)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(69, 64)" end="(69, 65)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(69, 66)" end="(69, 77)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(69, 66)" end="(69, 67)" leading="" trailing="" val="{"/>
              <NullNode start="(69, 67)" end="(69, 68)">
                <IdentNode start="(69, 67)" end="(69, 68)" leading="" trailing=" " raw_val="z" val="z"/>
              </NullNode>
              <NullNode start="(69, 69)" end="(69, 76)">
                <AtomNode start="(69, 69)" end="(69, 70)" leading="" trailing=" " val=":"/>
                <OtherNode start="(69, 71)" end="(69, 76)" kind="«term_×_»">
                  <IdentNode start="(69, 71)" end="(69, 72)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(69, 73)" end="(69, 74)" leading="" trailing=" " val="×"/>
                  <IdentNode start="(69, 75)" end="(69, 76)" leading="" trailing="" raw_val="β" val="β"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(69, 76)" end="(69, 77)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(69, 78)" end="(69, 87)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(69, 78)" end="(69, 79)" leading="" trailing="" val="{"/>
              <NullNode start="(69, 79)" end="(69, 80)">
                <IdentNode start="(69, 79)" end="(69, 80)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(69, 81)" end="(69, 86)">
                <AtomNode start="(69, 81)" end="(69, 82)" leading="" trailing=" " val=":"/>
                <IdentNode start="(69, 83)" end="(69, 86)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(69, 86)" end="(69, 87)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(69, 88)" end="(70, 69)">
            <AtomNode start="(69, 88)" end="(69, 89)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(70, 5)" end="(70, 69)" kind="«term_↔_»">
              <OtherNode start="(70, 5)" end="(70, 29)" kind="«term_=_»">
                <OtherNode start="(70, 5)" end="(70, 20)" kind="«term__[_]_?»">
                  <OtherNode start="(70, 5)" end="(70, 16)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(70, 5)" end="(70, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(70, 6)" end="(70, 15)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(70, 6)" end="(70, 9)" leading="" trailing=" " raw_val="zip" val="zip" full_name="Vector.zip" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                      <NullNode start="(70, 10)" end="(70, 15)">
                        <IdentNode start="(70, 10)" end="(70, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                        <IdentNode start="(70, 13)" end="(70, 15)" leading="" trailing="" raw_val="bs" val="bs"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(70, 15)" end="(70, 16)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <GroupNode/>
                  <AtomNode start="(70, 16)" end="(70, 17)" leading="" trailing="" val="["/>
                  <IdentNode start="(70, 17)" end="(70, 18)" leading="" trailing="" raw_val="i" val="i"/>
                  <AtomNode start="(70, 18)" end="(70, 19)" leading="" trailing="" val="]"/>
                  <GroupNode/>
                  <AtomNode start="(70, 19)" end="(70, 20)" leading="" trailing=" " val="?"/>
                </OtherNode>
                <AtomNode start="(70, 21)" end="(70, 22)" leading="" trailing=" " val="="/>
                <OtherNode start="(70, 23)" end="(70, 29)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(70, 23)" end="(70, 27)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode start="(70, 28)" end="(70, 29)">
                    <IdentNode start="(70, 28)" end="(70, 29)" leading="" trailing=" " raw_val="z" val="z"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(70, 30)" end="(70, 31)" leading="" trailing=" " val="↔"/>
              <OtherNode start="(70, 32)" end="(70, 69)" kind="«term_∧_»">
                <OtherNode start="(70, 32)" end="(70, 49)" kind="«term_=_»">
                  <OtherNode start="(70, 32)" end="(70, 38)" kind="«term__[_]_?»">
                    <IdentNode start="(70, 32)" end="(70, 34)" leading="" trailing="" raw_val="as" val="as"/>
                    <GroupNode/>
                    <AtomNode start="(70, 34)" end="(70, 35)" leading="" trailing="" val="["/>
                    <IdentNode start="(70, 35)" end="(70, 36)" leading="" trailing="" raw_val="i" val="i"/>
                    <AtomNode start="(70, 36)" end="(70, 37)" leading="" trailing="" val="]"/>
                    <GroupNode/>
                    <AtomNode start="(70, 37)" end="(70, 38)" leading="" trailing=" " val="?"/>
                  </OtherNode>
                  <AtomNode start="(70, 39)" end="(70, 40)" leading="" trailing=" " val="="/>
                  <OtherNode start="(70, 41)" end="(70, 49)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(70, 41)" end="(70, 45)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(70, 46)" end="(70, 49)">
                      <OtherNode start="(70, 46)" end="(70, 49)" kind="Lean.Parser.Term.proj">
                        <IdentNode start="(70, 46)" end="(70, 47)" leading="" trailing="" raw_val="z" val="z"/>
                        <AtomNode start="(70, 47)" end="(70, 48)" leading="" trailing="" val="."/>
                        <OtherNode start="(70, 48)" end="(70, 49)" kind="fieldIdx">
                          <AtomNode start="(70, 48)" end="(70, 49)" leading="" trailing=" " val="1"/>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(70, 50)" end="(70, 51)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(70, 52)" end="(70, 69)" kind="«term_=_»">
                  <OtherNode start="(70, 52)" end="(70, 58)" kind="«term__[_]_?»">
                    <IdentNode start="(70, 52)" end="(70, 54)" leading="" trailing="" raw_val="bs" val="bs"/>
                    <GroupNode/>
                    <AtomNode start="(70, 54)" end="(70, 55)" leading="" trailing="" val="["/>
                    <IdentNode start="(70, 55)" end="(70, 56)" leading="" trailing="" raw_val="i" val="i"/>
                    <AtomNode start="(70, 56)" end="(70, 57)" leading="" trailing="" val="]"/>
                    <GroupNode/>
                    <AtomNode start="(70, 57)" end="(70, 58)" leading="" trailing=" " val="?"/>
                  </OtherNode>
                  <AtomNode start="(70, 59)" end="(70, 60)" leading="" trailing=" " val="="/>
                  <OtherNode start="(70, 61)" end="(70, 69)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(70, 61)" end="(70, 65)" leading="" trailing=" " raw_val="some" val="some" full_name="Option.some" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode start="(70, 66)" end="(70, 69)">
                      <OtherNode start="(70, 66)" end="(70, 69)" kind="Lean.Parser.Term.proj">
                        <IdentNode start="(70, 66)" end="(70, 67)" leading="" trailing="" raw_val="z" val="z"/>
                        <AtomNode start="(70, 67)" end="(70, 68)" leading="" trailing="" val="."/>
                        <OtherNode start="(70, 68)" end="(70, 69)" kind="fieldIdx">
                          <AtomNode start="(70, 68)" end="(70, 69)" leading="" trailing=" " val="2"/>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(70, 70)" end="(73, 36)">
          <AtomNode start="(70, 70)" end="(70, 72)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(70, 73)" end="(73, 36)">
            <AtomNode start="(70, 73)" end="(70, 75)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(71, 3)" end="(73, 36)">
              <TacticTacticseq1IndentedNode start="(71, 3)" end="(73, 36)">
                <NullNode start="(71, 3)" end="(73, 36)">
                  <OtherNode start="(71, 3)" end="(71, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;n : Nat&#10;β : Type u_2&#10;as : Vector α n&#10;bs : Vector β n&#10;z : α × β&#10;i : Nat&#10;⊢ (as.zip bs)[i]? = some z ↔ as[i]? = some z.fst ∧ bs[i]? = some z.snd" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;z : α × β&#10;i : Nat&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ ({ toArray := as, size_toArray := ⋯ }.zip bs)[i]? = some z ↔&#10;    { toArray := as, size_toArray := ⋯ }[i]? = some z.fst ∧ bs[i]? = some z.snd" tactic="rcases as with ⟨as, rfl⟩">
                    <AtomNode start="(71, 3)" end="(71, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(71, 10)" end="(71, 12)">
                      <OtherNode start="(71, 10)" end="(71, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(71, 10)" end="(71, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(71, 13)" end="(71, 27)">
                      <AtomNode start="(71, 13)" end="(71, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(71, 18)" end="(71, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(71, 18)" end="(71, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(71, 18)" end="(71, 27)">
                            <OtherNode start="(71, 18)" end="(71, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(71, 18)" end="(71, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(71, 19)" end="(71, 26)">
                                <OtherNode start="(71, 19)" end="(71, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(71, 19)" end="(71, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(71, 19)" end="(71, 21)">
                                      <OtherNode start="(71, 19)" end="(71, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(71, 19)" end="(71, 21)" leading="" trailing="" raw_val="as" val="as"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(71, 21)" end="(71, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(71, 23)" end="(71, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(71, 23)" end="(71, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(71, 23)" end="(71, 26)">
                                      <OtherNode start="(71, 23)" end="(71, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(71, 23)" end="(71, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(71, 26)" end="(71, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(72, 3)" end="(72, 25)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;z : α × β&#10;i : Nat&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ ({ toArray := as, size_toArray := ⋯ }.zip bs)[i]? = some z ↔&#10;    { toArray := as, size_toArray := ⋯ }[i]? = some z.fst ∧ bs[i]? = some z.snd" state_after="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;z : α × β&#10;i : Nat&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ ({ toArray := as, size_toArray := ⋯ }.zip { toArray := bs, size_toArray := h })[i]? = some z ↔&#10;    { toArray := as, size_toArray := ⋯ }[i]? = some z.fst ∧ { toArray := bs, size_toArray := h }[i]? = some z.snd" tactic="rcases bs with ⟨bs, h⟩">
                    <AtomNode start="(72, 3)" end="(72, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(72, 10)" end="(72, 12)">
                      <OtherNode start="(72, 10)" end="(72, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(72, 10)" end="(72, 12)" leading="" trailing=" " raw_val="bs" val="bs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(72, 13)" end="(72, 25)">
                      <AtomNode start="(72, 13)" end="(72, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(72, 18)" end="(72, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(72, 18)" end="(72, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(72, 18)" end="(72, 25)">
                            <OtherNode start="(72, 18)" end="(72, 25)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(72, 18)" end="(72, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(72, 19)" end="(72, 24)">
                                <OtherNode start="(72, 19)" end="(72, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(72, 19)" end="(72, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(72, 19)" end="(72, 21)">
                                      <OtherNode start="(72, 19)" end="(72, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(72, 19)" end="(72, 21)" leading="" trailing="" raw_val="bs" val="bs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(72, 21)" end="(72, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(72, 23)" end="(72, 24)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(72, 23)" end="(72, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(72, 23)" end="(72, 24)">
                                      <OtherNode start="(72, 23)" end="(72, 24)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(72, 23)" end="(72, 24)" leading="" trailing="" raw_val="h" val="h"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(72, 24)" end="(72, 25)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(73, 3)" end="(73, 36)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;z : α × β&#10;i : Nat&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ ({ toArray := as, size_toArray := ⋯ }.zip { toArray := bs, size_toArray := h })[i]? = some z ↔&#10;    { toArray := as, size_toArray := ⋯ }[i]? = some z.fst ∧ { toArray := bs, size_toArray := h }[i]? = some z.snd" state_after="no goals" tactic="simp [Array.getElem?_zip_eq_some]">
                    <AtomNode start="(73, 3)" end="(73, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(73, 8)" end="(73, 36)">
                      <AtomNode start="(73, 8)" end="(73, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(73, 9)" end="(73, 35)">
                        <OtherNode start="(73, 9)" end="(73, 35)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(73, 9)" end="(73, 35)" leading="" trailing="" raw_val="Array.getElem?_zip_eq_some" val="Array.getElem?_zip_eq_some" full_name="Array.getElem?_zip_eq_some" mod_name="Init.Data.Array.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Zip.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(73, 35)" end="(73, 36)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(75, 1)" end="(80, 27)" name="zipWith_map" full_name="Vector.zipWith_map">
      <CommandDeclmodifiersNode start="(75, 1)" end="(75, 8)">
        <NullNode/>
        <NullNode start="(75, 1)" end="(75, 8)">
          <OtherNode start="(75, 1)" end="(75, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(75, 1)" end="(75, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(75, 3)" end="(75, 7)">
              <OtherNode start="(75, 3)" end="(75, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(75, 3)" end="(75, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(75, 3)" end="(75, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(75, 7)" end="(75, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(76, 1)" end="(80, 27)" name="zipWith_map" full_name="Vector.zipWith_map" _is_private_decl="False">
        <AtomNode start="(76, 1)" end="(76, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(76, 9)" end="(76, 20)">
          <IdentNode start="(76, 9)" end="(76, 20)" leading="" trailing=" " raw_val="zipWith_map" val="zipWith_map"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(76, 21)" end="(77, 79)">
          <NullNode start="(76, 21)" end="(76, 100)">
            <OtherNode start="(76, 21)" end="(76, 24)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(76, 21)" end="(76, 22)" leading="" trailing="" val="{"/>
              <NullNode start="(76, 22)" end="(76, 23)">
                <IdentNode start="(76, 22)" end="(76, 23)" leading="" trailing="" raw_val="μ" val="μ"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(76, 23)" end="(76, 24)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(76, 25)" end="(76, 40)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(76, 25)" end="(76, 26)" leading="" trailing="" val="{"/>
              <NullNode start="(76, 26)" end="(76, 27)">
                <IdentNode start="(76, 26)" end="(76, 27)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(76, 28)" end="(76, 39)">
                <AtomNode start="(76, 28)" end="(76, 29)" leading="" trailing=" " val=":"/>
                <OtherNode start="(76, 30)" end="(76, 39)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(76, 30)" end="(76, 31)" leading="" trailing=" " raw_val="γ" val="γ"/>
                  <AtomNode start="(76, 32)" end="(76, 33)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(76, 34)" end="(76, 39)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(76, 34)" end="(76, 35)" leading="" trailing=" " raw_val="δ" val="δ"/>
                    <AtomNode start="(76, 36)" end="(76, 37)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(76, 38)" end="(76, 39)" leading="" trailing="" raw_val="μ" val="μ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(76, 39)" end="(76, 40)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(76, 41)" end="(76, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(76, 41)" end="(76, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(76, 42)" end="(76, 43)">
                <IdentNode start="(76, 42)" end="(76, 43)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(76, 44)" end="(76, 51)">
                <AtomNode start="(76, 44)" end="(76, 45)" leading="" trailing=" " val=":"/>
                <OtherNode start="(76, 46)" end="(76, 51)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(76, 46)" end="(76, 47)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(76, 48)" end="(76, 49)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(76, 50)" end="(76, 51)" leading="" trailing="" raw_val="γ" val="γ"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(76, 51)" end="(76, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(76, 53)" end="(76, 64)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(76, 53)" end="(76, 54)" leading="" trailing="" val="{"/>
              <NullNode start="(76, 54)" end="(76, 55)">
                <IdentNode start="(76, 54)" end="(76, 55)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(76, 56)" end="(76, 63)">
                <AtomNode start="(76, 56)" end="(76, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(76, 58)" end="(76, 63)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(76, 58)" end="(76, 59)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(76, 60)" end="(76, 61)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(76, 62)" end="(76, 63)" leading="" trailing="" raw_val="δ" val="δ"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(76, 63)" end="(76, 64)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(76, 65)" end="(76, 82)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(76, 65)" end="(76, 66)" leading="" trailing="" val="{"/>
              <NullNode start="(76, 66)" end="(76, 68)">
                <IdentNode start="(76, 66)" end="(76, 68)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(76, 69)" end="(76, 81)">
                <AtomNode start="(76, 69)" end="(76, 70)" leading="" trailing=" " val=":"/>
                <OtherNode start="(76, 71)" end="(76, 81)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(76, 71)" end="(76, 77)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(76, 78)" end="(76, 81)">
                    <IdentNode start="(76, 78)" end="(76, 79)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(76, 80)" end="(76, 81)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(76, 81)" end="(76, 82)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(76, 83)" end="(76, 100)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(76, 83)" end="(76, 84)" leading="" trailing="" val="{"/>
              <NullNode start="(76, 84)" end="(76, 86)">
                <IdentNode start="(76, 84)" end="(76, 86)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(76, 87)" end="(76, 99)">
                <AtomNode start="(76, 87)" end="(76, 88)" leading="" trailing=" " val=":"/>
                <OtherNode start="(76, 89)" end="(76, 99)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(76, 89)" end="(76, 95)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(76, 96)" end="(76, 99)">
                    <IdentNode start="(76, 96)" end="(76, 97)" leading="" trailing=" " raw_val="β" val="β"/>
                    <IdentNode start="(76, 98)" end="(76, 99)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(76, 99)" end="(76, 100)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(76, 101)" end="(77, 79)">
            <AtomNode start="(76, 101)" end="(76, 102)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(77, 5)" end="(77, 79)" kind="«term_=_»">
              <OtherNode start="(77, 5)" end="(77, 36)" kind="Lean.Parser.Term.app">
                <IdentNode start="(77, 5)" end="(77, 12)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="Vector.zipWith" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(77, 13)" end="(77, 36)">
                  <IdentNode start="(77, 13)" end="(77, 14)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(77, 15)" end="(77, 25)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(77, 15)" end="(77, 16)" leading="" trailing="" val="("/>
                    <OtherNode start="(77, 16)" end="(77, 24)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(77, 16)" end="(77, 22)" leading="" trailing=" " raw_val="as.map" val="as.map"/>
                      <NullNode start="(77, 23)" end="(77, 24)">
                        <IdentNode start="(77, 23)" end="(77, 24)" leading="" trailing="" raw_val="g" val="g"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(77, 24)" end="(77, 25)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(77, 26)" end="(77, 36)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(77, 26)" end="(77, 27)" leading="" trailing="" val="("/>
                    <OtherNode start="(77, 27)" end="(77, 35)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(77, 27)" end="(77, 33)" leading="" trailing=" " raw_val="bs.map" val="bs.map"/>
                      <NullNode start="(77, 34)" end="(77, 35)">
                        <IdentNode start="(77, 34)" end="(77, 35)" leading="" trailing="" raw_val="h" val="h"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(77, 35)" end="(77, 36)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(77, 37)" end="(77, 38)" leading="" trailing=" " val="="/>
              <OtherNode start="(77, 39)" end="(77, 79)" kind="Lean.Parser.Term.app">
                <IdentNode start="(77, 39)" end="(77, 46)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="Vector.zipWith" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(77, 47)" end="(77, 79)">
                  <OtherNode start="(77, 47)" end="(77, 73)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(77, 47)" end="(77, 48)" leading="" trailing="" val="("/>
                    <OtherNode start="(77, 48)" end="(77, 72)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(77, 48)" end="(77, 51)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(77, 52)" end="(77, 72)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(77, 52)" end="(77, 55)">
                          <IdentNode start="(77, 52)" end="(77, 53)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(77, 54)" end="(77, 55)" leading="" trailing=" " raw_val="b" val="b"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(77, 56)" end="(77, 58)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(77, 59)" end="(77, 72)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(77, 59)" end="(77, 60)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode start="(77, 61)" end="(77, 72)">
                            <OtherNode start="(77, 61)" end="(77, 66)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(77, 61)" end="(77, 62)" leading="" trailing="" val="("/>
                              <OtherNode start="(77, 62)" end="(77, 65)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(77, 62)" end="(77, 63)" leading="" trailing=" " raw_val="g" val="g"/>
                                <NullNode start="(77, 64)" end="(77, 65)">
                                  <IdentNode start="(77, 64)" end="(77, 65)" leading="" trailing="" raw_val="a" val="a"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(77, 65)" end="(77, 66)" leading="" trailing=" " val=")"/>
                            </OtherNode>
                            <OtherNode start="(77, 67)" end="(77, 72)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(77, 67)" end="(77, 68)" leading="" trailing="" val="("/>
                              <OtherNode start="(77, 68)" end="(77, 71)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(77, 68)" end="(77, 69)" leading="" trailing=" " raw_val="h" val="h"/>
                                <NullNode start="(77, 70)" end="(77, 71)">
                                  <IdentNode start="(77, 70)" end="(77, 71)" leading="" trailing="" raw_val="b" val="b"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(77, 71)" end="(77, 72)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(77, 72)" end="(77, 73)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(77, 74)" end="(77, 76)" leading="" trailing=" " raw_val="as" val="as"/>
                  <IdentNode start="(77, 77)" end="(77, 79)" leading="" trailing=" " raw_val="bs" val="bs"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(77, 80)" end="(80, 27)">
          <AtomNode start="(77, 80)" end="(77, 82)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(77, 83)" end="(80, 27)">
            <AtomNode start="(77, 83)" end="(77, 85)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(78, 3)" end="(80, 27)">
              <TacticTacticseq1IndentedNode start="(78, 3)" end="(80, 27)">
                <NullNode start="(78, 3)" end="(80, 27)">
                  <OtherNode start="(78, 3)" end="(78, 27)" kind="Lean.Parser.Tactic.rcases" state_before="γ : Type u_1&#10;δ : Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;n : Nat&#10;μ : Type u_5&#10;f : γ → δ → μ&#10;g : α → γ&#10;h : β → δ&#10;as : Vector α n&#10;bs : Vector β n&#10;⊢ zipWith f (map g as) (map h bs) = zipWith (fun a b =&amp;gt; f (g a) (h b)) as bs" state_after="case mk&#10;γ : Type u_1&#10;δ : Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;μ : Type u_5&#10;f : γ → δ → μ&#10;g : α → γ&#10;h : β → δ&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ zipWith f (map g { toArray := as, size_toArray := ⋯ }) (map h bs) =&#10;    zipWith (fun a b =&amp;gt; f (g a) (h b)) { toArray := as, size_toArray := ⋯ } bs" tactic="rcases as with ⟨as, rfl⟩">
                    <AtomNode start="(78, 3)" end="(78, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(78, 10)" end="(78, 12)">
                      <OtherNode start="(78, 10)" end="(78, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(78, 10)" end="(78, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(78, 13)" end="(78, 27)">
                      <AtomNode start="(78, 13)" end="(78, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(78, 18)" end="(78, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(78, 18)" end="(78, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(78, 18)" end="(78, 27)">
                            <OtherNode start="(78, 18)" end="(78, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(78, 18)" end="(78, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(78, 19)" end="(78, 26)">
                                <OtherNode start="(78, 19)" end="(78, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(78, 19)" end="(78, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(78, 19)" end="(78, 21)">
                                      <OtherNode start="(78, 19)" end="(78, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(78, 19)" end="(78, 21)" leading="" trailing="" raw_val="as" val="as"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(78, 21)" end="(78, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(78, 23)" end="(78, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(78, 23)" end="(78, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(78, 23)" end="(78, 26)">
                                      <OtherNode start="(78, 23)" end="(78, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(78, 23)" end="(78, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(78, 26)" end="(78, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(79, 3)" end="(79, 25)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;γ : Type u_1&#10;δ : Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;μ : Type u_5&#10;f : γ → δ → μ&#10;g : α → γ&#10;h : β → δ&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ zipWith f (map g { toArray := as, size_toArray := ⋯ }) (map h bs) =&#10;    zipWith (fun a b =&amp;gt; f (g a) (h b)) { toArray := as, size_toArray := ⋯ } bs" state_after="case mk.mk&#10;γ : Type u_1&#10;δ : Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;μ : Type u_5&#10;f : γ → δ → μ&#10;g : α → γ&#10;h✝ : β → δ&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ zipWith f (map g { toArray := as, size_toArray := ⋯ }) (map h✝ { toArray := bs, size_toArray := h }) =&#10;    zipWith (fun a b =&amp;gt; f (g a) (h✝ b)) { toArray := as, size_toArray := ⋯ } { toArray := bs, size_toArray := h }" tactic="rcases bs with ⟨bs, h⟩">
                    <AtomNode start="(79, 3)" end="(79, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(79, 10)" end="(79, 12)">
                      <OtherNode start="(79, 10)" end="(79, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(79, 10)" end="(79, 12)" leading="" trailing=" " raw_val="bs" val="bs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(79, 13)" end="(79, 25)">
                      <AtomNode start="(79, 13)" end="(79, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(79, 18)" end="(79, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(79, 18)" end="(79, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(79, 18)" end="(79, 25)">
                            <OtherNode start="(79, 18)" end="(79, 25)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(79, 18)" end="(79, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(79, 19)" end="(79, 24)">
                                <OtherNode start="(79, 19)" end="(79, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(79, 19)" end="(79, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(79, 19)" end="(79, 21)">
                                      <OtherNode start="(79, 19)" end="(79, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(79, 19)" end="(79, 21)" leading="" trailing="" raw_val="bs" val="bs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(79, 21)" end="(79, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(79, 23)" end="(79, 24)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(79, 23)" end="(79, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(79, 23)" end="(79, 24)">
                                      <OtherNode start="(79, 23)" end="(79, 24)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(79, 23)" end="(79, 24)" leading="" trailing="" raw_val="h" val="h"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(79, 24)" end="(79, 25)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(80, 3)" end="(80, 27)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;γ : Type u_1&#10;δ : Type u_2&#10;α : Type u_3&#10;β : Type u_4&#10;μ : Type u_5&#10;f : γ → δ → μ&#10;g : α → γ&#10;h✝ : β → δ&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ zipWith f (map g { toArray := as, size_toArray := ⋯ }) (map h✝ { toArray := bs, size_toArray := h }) =&#10;    zipWith (fun a b =&amp;gt; f (g a) (h✝ b)) { toArray := as, size_toArray := ⋯ } { toArray := bs, size_toArray := h }" state_after="no goals" tactic="simp [Array.zipWith_map]">
                    <AtomNode start="(80, 3)" end="(80, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(80, 8)" end="(80, 27)">
                      <AtomNode start="(80, 8)" end="(80, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(80, 9)" end="(80, 26)">
                        <OtherNode start="(80, 9)" end="(80, 26)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(80, 9)" end="(80, 26)" leading="" trailing="" raw_val="Array.zipWith_map" val="Array.zipWith_map" full_name="Array.zipWith_map" mod_name="Init.Data.Array.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Zip.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(80, 26)" end="(80, 27)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(82, 1)" end="(86, 32)" name="zipWith_map_left" full_name="Vector.zipWith_map_left">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(82, 1)" end="(86, 32)" name="zipWith_map_left" full_name="Vector.zipWith_map_left" _is_private_decl="False">
        <AtomNode start="(82, 1)" end="(82, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(82, 9)" end="(82, 25)">
          <IdentNode start="(82, 9)" end="(82, 25)" leading="" trailing=" " raw_val="zipWith_map_left" val="zipWith_map_left"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(82, 26)" end="(83, 67)">
          <NullNode start="(82, 26)" end="(82, 91)">
            <OtherNode start="(82, 26)" end="(82, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(82, 26)" end="(82, 27)" leading="" trailing="" val="{"/>
              <NullNode start="(82, 27)" end="(82, 29)">
                <IdentNode start="(82, 27)" end="(82, 29)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(82, 30)" end="(82, 42)">
                <AtomNode start="(82, 30)" end="(82, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(82, 32)" end="(82, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(82, 32)" end="(82, 38)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(82, 39)" end="(82, 42)">
                    <IdentNode start="(82, 39)" end="(82, 40)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(82, 41)" end="(82, 42)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(82, 42)" end="(82, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(82, 44)" end="(82, 61)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(82, 44)" end="(82, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(82, 45)" end="(82, 47)">
                <IdentNode start="(82, 45)" end="(82, 47)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(82, 48)" end="(82, 60)">
                <AtomNode start="(82, 48)" end="(82, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(82, 50)" end="(82, 60)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(82, 50)" end="(82, 56)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(82, 57)" end="(82, 60)">
                    <IdentNode start="(82, 57)" end="(82, 58)" leading="" trailing=" " raw_val="β" val="β"/>
                    <IdentNode start="(82, 59)" end="(82, 60)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(82, 60)" end="(82, 61)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(82, 62)" end="(82, 74)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(82, 62)" end="(82, 63)" leading="" trailing="" val="{"/>
              <NullNode start="(82, 63)" end="(82, 64)">
                <IdentNode start="(82, 63)" end="(82, 64)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(82, 65)" end="(82, 73)">
                <AtomNode start="(82, 65)" end="(82, 66)" leading="" trailing=" " val=":"/>
                <OtherNode start="(82, 67)" end="(82, 73)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(82, 67)" end="(82, 68)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(82, 69)" end="(82, 70)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(82, 71)" end="(82, 73)" leading="" trailing="" raw_val="α'" val="α'"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(82, 73)" end="(82, 74)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(82, 75)" end="(82, 91)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(82, 75)" end="(82, 76)" leading="" trailing="" val="{"/>
              <NullNode start="(82, 76)" end="(82, 77)">
                <IdentNode start="(82, 76)" end="(82, 77)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(82, 78)" end="(82, 90)">
                <AtomNode start="(82, 78)" end="(82, 79)" leading="" trailing=" " val=":"/>
                <OtherNode start="(82, 80)" end="(82, 90)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(82, 80)" end="(82, 82)" leading="" trailing=" " raw_val="α'" val="α'"/>
                  <AtomNode start="(82, 83)" end="(82, 84)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(82, 85)" end="(82, 90)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(82, 85)" end="(82, 86)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(82, 87)" end="(82, 88)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(82, 89)" end="(82, 90)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(82, 90)" end="(82, 91)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(82, 92)" end="(83, 67)">
            <AtomNode start="(82, 92)" end="(82, 93)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(83, 5)" end="(83, 67)" kind="«term_=_»">
              <OtherNode start="(83, 5)" end="(83, 28)" kind="Lean.Parser.Term.app">
                <IdentNode start="(83, 5)" end="(83, 12)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="Vector.zipWith" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(83, 13)" end="(83, 28)">
                  <IdentNode start="(83, 13)" end="(83, 14)" leading="" trailing=" " raw_val="g" val="g"/>
                  <OtherNode start="(83, 15)" end="(83, 25)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(83, 15)" end="(83, 16)" leading="" trailing="" val="("/>
                    <OtherNode start="(83, 16)" end="(83, 24)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(83, 16)" end="(83, 22)" leading="" trailing=" " raw_val="as.map" val="as.map"/>
                      <NullNode start="(83, 23)" end="(83, 24)">
                        <IdentNode start="(83, 23)" end="(83, 24)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(83, 24)" end="(83, 25)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(83, 26)" end="(83, 28)" leading="" trailing=" " raw_val="bs" val="bs"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(83, 29)" end="(83, 30)" leading="" trailing=" " val="="/>
              <OtherNode start="(83, 31)" end="(83, 67)" kind="Lean.Parser.Term.app">
                <IdentNode start="(83, 31)" end="(83, 38)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="Vector.zipWith" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(83, 39)" end="(83, 67)">
                  <OtherNode start="(83, 39)" end="(83, 61)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(83, 39)" end="(83, 40)" leading="" trailing="" val="("/>
                    <OtherNode start="(83, 40)" end="(83, 60)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(83, 40)" end="(83, 43)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(83, 44)" end="(83, 60)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(83, 44)" end="(83, 47)">
                          <IdentNode start="(83, 44)" end="(83, 45)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(83, 46)" end="(83, 47)" leading="" trailing=" " raw_val="b" val="b"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(83, 48)" end="(83, 50)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(83, 51)" end="(83, 60)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(83, 51)" end="(83, 52)" leading="" trailing=" " raw_val="g" val="g"/>
                          <NullNode start="(83, 53)" end="(83, 60)">
                            <OtherNode start="(83, 53)" end="(83, 58)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(83, 53)" end="(83, 54)" leading="" trailing="" val="("/>
                              <OtherNode start="(83, 54)" end="(83, 57)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(83, 54)" end="(83, 55)" leading="" trailing=" " raw_val="f" val="f"/>
                                <NullNode start="(83, 56)" end="(83, 57)">
                                  <IdentNode start="(83, 56)" end="(83, 57)" leading="" trailing="" raw_val="a" val="a"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(83, 57)" end="(83, 58)" leading="" trailing=" " val=")"/>
                            </OtherNode>
                            <IdentNode start="(83, 59)" end="(83, 60)" leading="" trailing="" raw_val="b" val="b"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(83, 60)" end="(83, 61)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(83, 62)" end="(83, 64)" leading="" trailing=" " raw_val="as" val="as"/>
                  <IdentNode start="(83, 65)" end="(83, 67)" leading="" trailing=" " raw_val="bs" val="bs"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(83, 68)" end="(86, 32)">
          <AtomNode start="(83, 68)" end="(83, 70)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(83, 71)" end="(86, 32)">
            <AtomNode start="(83, 71)" end="(83, 73)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(84, 3)" end="(86, 32)">
              <TacticTacticseq1IndentedNode start="(84, 3)" end="(86, 32)">
                <NullNode start="(84, 3)" end="(86, 32)">
                  <OtherNode start="(84, 3)" end="(84, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;n : Nat&#10;β : Type u_2&#10;α' : Type u_3&#10;γ : Type u_4&#10;as : Vector α n&#10;bs : Vector β n&#10;f : α → α'&#10;g : α' → β → γ&#10;⊢ zipWith g (map f as) bs = zipWith (fun a b =&amp;gt; g (f a) b) as bs" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;α' : Type u_3&#10;γ : Type u_4&#10;f : α → α'&#10;g : α' → β → γ&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ zipWith g (map f { toArray := as, size_toArray := ⋯ }) bs =&#10;    zipWith (fun a b =&amp;gt; g (f a) b) { toArray := as, size_toArray := ⋯ } bs" tactic="rcases as with ⟨as, rfl⟩">
                    <AtomNode start="(84, 3)" end="(84, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(84, 10)" end="(84, 12)">
                      <OtherNode start="(84, 10)" end="(84, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(84, 10)" end="(84, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(84, 13)" end="(84, 27)">
                      <AtomNode start="(84, 13)" end="(84, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(84, 18)" end="(84, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(84, 18)" end="(84, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(84, 18)" end="(84, 27)">
                            <OtherNode start="(84, 18)" end="(84, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(84, 18)" end="(84, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(84, 19)" end="(84, 26)">
                                <OtherNode start="(84, 19)" end="(84, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(84, 19)" end="(84, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(84, 19)" end="(84, 21)">
                                      <OtherNode start="(84, 19)" end="(84, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(84, 19)" end="(84, 21)" leading="" trailing="" raw_val="as" val="as"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(84, 21)" end="(84, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(84, 23)" end="(84, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(84, 23)" end="(84, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(84, 23)" end="(84, 26)">
                                      <OtherNode start="(84, 23)" end="(84, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(84, 23)" end="(84, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(84, 26)" end="(84, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(85, 3)" end="(85, 25)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;α' : Type u_3&#10;γ : Type u_4&#10;f : α → α'&#10;g : α' → β → γ&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ zipWith g (map f { toArray := as, size_toArray := ⋯ }) bs =&#10;    zipWith (fun a b =&amp;gt; g (f a) b) { toArray := as, size_toArray := ⋯ } bs" state_after="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;α' : Type u_3&#10;γ : Type u_4&#10;f : α → α'&#10;g : α' → β → γ&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ zipWith g (map f { toArray := as, size_toArray := ⋯ }) { toArray := bs, size_toArray := h } =&#10;    zipWith (fun a b =&amp;gt; g (f a) b) { toArray := as, size_toArray := ⋯ } { toArray := bs, size_toArray := h }" tactic="rcases bs with ⟨bs, h⟩">
                    <AtomNode start="(85, 3)" end="(85, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(85, 10)" end="(85, 12)">
                      <OtherNode start="(85, 10)" end="(85, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(85, 10)" end="(85, 12)" leading="" trailing=" " raw_val="bs" val="bs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(85, 13)" end="(85, 25)">
                      <AtomNode start="(85, 13)" end="(85, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(85, 18)" end="(85, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(85, 18)" end="(85, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(85, 18)" end="(85, 25)">
                            <OtherNode start="(85, 18)" end="(85, 25)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(85, 18)" end="(85, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(85, 19)" end="(85, 24)">
                                <OtherNode start="(85, 19)" end="(85, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(85, 19)" end="(85, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(85, 19)" end="(85, 21)">
                                      <OtherNode start="(85, 19)" end="(85, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(85, 19)" end="(85, 21)" leading="" trailing="" raw_val="bs" val="bs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(85, 21)" end="(85, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(85, 23)" end="(85, 24)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(85, 23)" end="(85, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(85, 23)" end="(85, 24)">
                                      <OtherNode start="(85, 23)" end="(85, 24)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(85, 23)" end="(85, 24)" leading="" trailing="" raw_val="h" val="h"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(85, 24)" end="(85, 25)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(86, 3)" end="(86, 32)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;α' : Type u_3&#10;γ : Type u_4&#10;f : α → α'&#10;g : α' → β → γ&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ zipWith g (map f { toArray := as, size_toArray := ⋯ }) { toArray := bs, size_toArray := h } =&#10;    zipWith (fun a b =&amp;gt; g (f a) b) { toArray := as, size_toArray := ⋯ } { toArray := bs, size_toArray := h }" state_after="no goals" tactic="simp [Array.zipWith_map_left]">
                    <AtomNode start="(86, 3)" end="(86, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(86, 8)" end="(86, 32)">
                      <AtomNode start="(86, 8)" end="(86, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(86, 9)" end="(86, 31)">
                        <OtherNode start="(86, 9)" end="(86, 31)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(86, 9)" end="(86, 31)" leading="" trailing="" raw_val="Array.zipWith_map_left" val="Array.zipWith_map_left" full_name="Array.zipWith_map_left" mod_name="Init.Data.Array.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Zip.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(86, 31)" end="(86, 32)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(88, 1)" end="(92, 33)" name="zipWith_map_right" full_name="Vector.zipWith_map_right">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(88, 1)" end="(92, 33)" name="zipWith_map_right" full_name="Vector.zipWith_map_right" _is_private_decl="False">
        <AtomNode start="(88, 1)" end="(88, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(88, 9)" end="(88, 26)">
          <IdentNode start="(88, 9)" end="(88, 26)" leading="" trailing=" " raw_val="zipWith_map_right" val="zipWith_map_right"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(88, 27)" end="(89, 67)">
          <NullNode start="(88, 27)" end="(88, 92)">
            <OtherNode start="(88, 27)" end="(88, 44)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(88, 27)" end="(88, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(88, 28)" end="(88, 30)">
                <IdentNode start="(88, 28)" end="(88, 30)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(88, 31)" end="(88, 43)">
                <AtomNode start="(88, 31)" end="(88, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(88, 33)" end="(88, 43)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(88, 33)" end="(88, 39)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(88, 40)" end="(88, 43)">
                    <IdentNode start="(88, 40)" end="(88, 41)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(88, 42)" end="(88, 43)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(88, 43)" end="(88, 44)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(88, 45)" end="(88, 62)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(88, 45)" end="(88, 46)" leading="" trailing="" val="{"/>
              <NullNode start="(88, 46)" end="(88, 48)">
                <IdentNode start="(88, 46)" end="(88, 48)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(88, 49)" end="(88, 61)">
                <AtomNode start="(88, 49)" end="(88, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(88, 51)" end="(88, 61)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(88, 51)" end="(88, 57)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(88, 58)" end="(88, 61)">
                    <IdentNode start="(88, 58)" end="(88, 59)" leading="" trailing=" " raw_val="β" val="β"/>
                    <IdentNode start="(88, 60)" end="(88, 61)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(88, 61)" end="(88, 62)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(88, 63)" end="(88, 75)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(88, 63)" end="(88, 64)" leading="" trailing="" val="{"/>
              <NullNode start="(88, 64)" end="(88, 65)">
                <IdentNode start="(88, 64)" end="(88, 65)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(88, 66)" end="(88, 74)">
                <AtomNode start="(88, 66)" end="(88, 67)" leading="" trailing=" " val=":"/>
                <OtherNode start="(88, 68)" end="(88, 74)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(88, 68)" end="(88, 69)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(88, 70)" end="(88, 71)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(88, 72)" end="(88, 74)" leading="" trailing="" raw_val="β'" val="β'"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(88, 74)" end="(88, 75)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(88, 76)" end="(88, 92)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(88, 76)" end="(88, 77)" leading="" trailing="" val="{"/>
              <NullNode start="(88, 77)" end="(88, 78)">
                <IdentNode start="(88, 77)" end="(88, 78)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(88, 79)" end="(88, 91)">
                <AtomNode start="(88, 79)" end="(88, 80)" leading="" trailing=" " val=":"/>
                <OtherNode start="(88, 81)" end="(88, 91)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(88, 81)" end="(88, 82)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(88, 83)" end="(88, 84)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(88, 85)" end="(88, 91)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(88, 85)" end="(88, 87)" leading="" trailing=" " raw_val="β'" val="β'"/>
                    <AtomNode start="(88, 88)" end="(88, 89)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(88, 90)" end="(88, 91)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(88, 91)" end="(88, 92)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(88, 93)" end="(89, 67)">
            <AtomNode start="(88, 93)" end="(88, 94)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(89, 5)" end="(89, 67)" kind="«term_=_»">
              <OtherNode start="(89, 5)" end="(89, 28)" kind="Lean.Parser.Term.app">
                <IdentNode start="(89, 5)" end="(89, 12)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="Vector.zipWith" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(89, 13)" end="(89, 28)">
                  <IdentNode start="(89, 13)" end="(89, 14)" leading="" trailing=" " raw_val="g" val="g"/>
                  <IdentNode start="(89, 15)" end="(89, 17)" leading="" trailing=" " raw_val="as" val="as"/>
                  <OtherNode start="(89, 18)" end="(89, 28)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(89, 18)" end="(89, 19)" leading="" trailing="" val="("/>
                    <OtherNode start="(89, 19)" end="(89, 27)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(89, 19)" end="(89, 25)" leading="" trailing=" " raw_val="bs.map" val="bs.map"/>
                      <NullNode start="(89, 26)" end="(89, 27)">
                        <IdentNode start="(89, 26)" end="(89, 27)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(89, 27)" end="(89, 28)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(89, 29)" end="(89, 30)" leading="" trailing=" " val="="/>
              <OtherNode start="(89, 31)" end="(89, 67)" kind="Lean.Parser.Term.app">
                <IdentNode start="(89, 31)" end="(89, 38)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="Vector.zipWith" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(89, 39)" end="(89, 67)">
                  <OtherNode start="(89, 39)" end="(89, 61)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(89, 39)" end="(89, 40)" leading="" trailing="" val="("/>
                    <OtherNode start="(89, 40)" end="(89, 60)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(89, 40)" end="(89, 43)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(89, 44)" end="(89, 60)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(89, 44)" end="(89, 47)">
                          <IdentNode start="(89, 44)" end="(89, 45)" leading="" trailing=" " raw_val="a" val="a"/>
                          <IdentNode start="(89, 46)" end="(89, 47)" leading="" trailing=" " raw_val="b" val="b"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(89, 48)" end="(89, 50)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(89, 51)" end="(89, 60)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(89, 51)" end="(89, 52)" leading="" trailing=" " raw_val="g" val="g"/>
                          <NullNode start="(89, 53)" end="(89, 60)">
                            <IdentNode start="(89, 53)" end="(89, 54)" leading="" trailing=" " raw_val="a" val="a"/>
                            <OtherNode start="(89, 55)" end="(89, 60)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(89, 55)" end="(89, 56)" leading="" trailing="" val="("/>
                              <OtherNode start="(89, 56)" end="(89, 59)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(89, 56)" end="(89, 57)" leading="" trailing=" " raw_val="f" val="f"/>
                                <NullNode start="(89, 58)" end="(89, 59)">
                                  <IdentNode start="(89, 58)" end="(89, 59)" leading="" trailing="" raw_val="b" val="b"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(89, 59)" end="(89, 60)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(89, 60)" end="(89, 61)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(89, 62)" end="(89, 64)" leading="" trailing=" " raw_val="as" val="as"/>
                  <IdentNode start="(89, 65)" end="(89, 67)" leading="" trailing=" " raw_val="bs" val="bs"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(89, 68)" end="(92, 33)">
          <AtomNode start="(89, 68)" end="(89, 70)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(89, 71)" end="(92, 33)">
            <AtomNode start="(89, 71)" end="(89, 73)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(90, 3)" end="(92, 33)">
              <TacticTacticseq1IndentedNode start="(90, 3)" end="(92, 33)">
                <NullNode start="(90, 3)" end="(92, 33)">
                  <OtherNode start="(90, 3)" end="(90, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;n : Nat&#10;β : Type u_2&#10;β' : Type u_3&#10;γ : Type u_4&#10;as : Vector α n&#10;bs : Vector β n&#10;f : β → β'&#10;g : α → β' → γ&#10;⊢ zipWith g as (map f bs) = zipWith (fun a b =&amp;gt; g a (f b)) as bs" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;β' : Type u_3&#10;γ : Type u_4&#10;f : β → β'&#10;g : α → β' → γ&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ zipWith g { toArray := as, size_toArray := ⋯ } (map f bs) =&#10;    zipWith (fun a b =&amp;gt; g a (f b)) { toArray := as, size_toArray := ⋯ } bs" tactic="rcases as with ⟨as, rfl⟩">
                    <AtomNode start="(90, 3)" end="(90, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(90, 10)" end="(90, 12)">
                      <OtherNode start="(90, 10)" end="(90, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(90, 10)" end="(90, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(90, 13)" end="(90, 27)">
                      <AtomNode start="(90, 13)" end="(90, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(90, 18)" end="(90, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(90, 18)" end="(90, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(90, 18)" end="(90, 27)">
                            <OtherNode start="(90, 18)" end="(90, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(90, 18)" end="(90, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(90, 19)" end="(90, 26)">
                                <OtherNode start="(90, 19)" end="(90, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(90, 19)" end="(90, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(90, 19)" end="(90, 21)">
                                      <OtherNode start="(90, 19)" end="(90, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(90, 19)" end="(90, 21)" leading="" trailing="" raw_val="as" val="as"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(90, 21)" end="(90, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(90, 23)" end="(90, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(90, 23)" end="(90, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(90, 23)" end="(90, 26)">
                                      <OtherNode start="(90, 23)" end="(90, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(90, 23)" end="(90, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(90, 26)" end="(90, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(91, 3)" end="(91, 25)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;β' : Type u_3&#10;γ : Type u_4&#10;f : β → β'&#10;g : α → β' → γ&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ zipWith g { toArray := as, size_toArray := ⋯ } (map f bs) =&#10;    zipWith (fun a b =&amp;gt; g a (f b)) { toArray := as, size_toArray := ⋯ } bs" state_after="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;β' : Type u_3&#10;γ : Type u_4&#10;f : β → β'&#10;g : α → β' → γ&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ zipWith g { toArray := as, size_toArray := ⋯ } (map f { toArray := bs, size_toArray := h }) =&#10;    zipWith (fun a b =&amp;gt; g a (f b)) { toArray := as, size_toArray := ⋯ } { toArray := bs, size_toArray := h }" tactic="rcases bs with ⟨bs, h⟩">
                    <AtomNode start="(91, 3)" end="(91, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(91, 10)" end="(91, 12)">
                      <OtherNode start="(91, 10)" end="(91, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(91, 10)" end="(91, 12)" leading="" trailing=" " raw_val="bs" val="bs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(91, 13)" end="(91, 25)">
                      <AtomNode start="(91, 13)" end="(91, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(91, 18)" end="(91, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(91, 18)" end="(91, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(91, 18)" end="(91, 25)">
                            <OtherNode start="(91, 18)" end="(91, 25)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(91, 18)" end="(91, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(91, 19)" end="(91, 24)">
                                <OtherNode start="(91, 19)" end="(91, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(91, 19)" end="(91, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(91, 19)" end="(91, 21)">
                                      <OtherNode start="(91, 19)" end="(91, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(91, 19)" end="(91, 21)" leading="" trailing="" raw_val="bs" val="bs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(91, 21)" end="(91, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(91, 23)" end="(91, 24)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(91, 23)" end="(91, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(91, 23)" end="(91, 24)">
                                      <OtherNode start="(91, 23)" end="(91, 24)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(91, 23)" end="(91, 24)" leading="" trailing="" raw_val="h" val="h"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(91, 24)" end="(91, 25)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(92, 3)" end="(92, 33)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;β' : Type u_3&#10;γ : Type u_4&#10;f : β → β'&#10;g : α → β' → γ&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ zipWith g { toArray := as, size_toArray := ⋯ } (map f { toArray := bs, size_toArray := h }) =&#10;    zipWith (fun a b =&amp;gt; g a (f b)) { toArray := as, size_toArray := ⋯ } { toArray := bs, size_toArray := h }" state_after="no goals" tactic="simp [Array.zipWith_map_right]">
                    <AtomNode start="(92, 3)" end="(92, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(92, 8)" end="(92, 33)">
                      <AtomNode start="(92, 8)" end="(92, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(92, 9)" end="(92, 32)">
                        <OtherNode start="(92, 9)" end="(92, 32)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(92, 9)" end="(92, 32)" leading="" trailing="" raw_val="Array.zipWith_map_right" val="Array.zipWith_map_right" full_name="Array.zipWith_map_right" mod_name="Init.Data.Array.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Zip.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(92, 32)" end="(92, 33)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(94, 1)" end="(98, 47)" name="zipWith_foldr_eq_zip_foldr" full_name="Vector.zipWith_foldr_eq_zip_foldr">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(94, 1)" end="(98, 47)" name="zipWith_foldr_eq_zip_foldr" full_name="Vector.zipWith_foldr_eq_zip_foldr" _is_private_decl="False">
        <AtomNode start="(94, 1)" end="(94, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(94, 9)" end="(94, 35)">
          <IdentNode start="(94, 9)" end="(94, 35)" leading="" trailing=" " raw_val="zipWith_foldr_eq_zip_foldr" val="zipWith_foldr_eq_zip_foldr"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(94, 36)" end="(95, 83)">
          <NullNode start="(94, 36)" end="(94, 59)">
            <OtherNode start="(94, 36)" end="(94, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(94, 36)" end="(94, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(94, 37)" end="(94, 38)">
                <IdentNode start="(94, 37)" end="(94, 38)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(94, 39)" end="(94, 50)">
                <AtomNode start="(94, 39)" end="(94, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(94, 41)" end="(94, 50)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(94, 41)" end="(94, 42)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(94, 43)" end="(94, 44)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(94, 45)" end="(94, 50)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(94, 45)" end="(94, 46)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(94, 47)" end="(94, 48)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(94, 49)" end="(94, 50)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(94, 50)" end="(94, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(94, 52)" end="(94, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(94, 52)" end="(94, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(94, 53)" end="(94, 54)">
                <IdentNode start="(94, 53)" end="(94, 54)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(94, 55)" end="(94, 58)">
                <AtomNode start="(94, 55)" end="(94, 56)" leading="" trailing=" " val=":"/>
                <IdentNode start="(94, 57)" end="(94, 58)" leading="" trailing="" raw_val="δ" val="δ"/>
              </NullNode>
              <AtomNode start="(94, 58)" end="(94, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(94, 60)" end="(95, 83)">
            <AtomNode start="(94, 60)" end="(94, 61)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(95, 5)" end="(95, 83)" kind="«term_=_»">
              <OtherNode start="(95, 5)" end="(95, 32)" kind="Lean.Parser.Term.app">
                <OtherNode start="(95, 5)" end="(95, 28)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(95, 5)" end="(95, 22)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(95, 5)" end="(95, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(95, 6)" end="(95, 21)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(95, 6)" end="(95, 13)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="Vector.zipWith" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                      <NullNode start="(95, 14)" end="(95, 21)">
                        <IdentNode start="(95, 14)" end="(95, 15)" leading="" trailing=" " raw_val="f" val="f"/>
                        <IdentNode start="(95, 16)" end="(95, 18)" leading="" trailing=" " raw_val="as" val="as"/>
                        <IdentNode start="(95, 19)" end="(95, 21)" leading="" trailing="" raw_val="bs" val="bs"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(95, 21)" end="(95, 22)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(95, 22)" end="(95, 23)" leading="" trailing="" val="."/>
                  <IdentNode start="(95, 23)" end="(95, 28)" leading="" trailing=" " raw_val="foldr" val="foldr" full_name="Vector.foldr" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                </OtherNode>
                <NullNode start="(95, 29)" end="(95, 32)">
                  <IdentNode start="(95, 29)" end="(95, 30)" leading="" trailing=" " raw_val="g" val="g"/>
                  <IdentNode start="(95, 31)" end="(95, 32)" leading="" trailing=" " raw_val="i" val="i"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(95, 33)" end="(95, 34)" leading="" trailing=" " val="="/>
              <OtherNode start="(95, 35)" end="(95, 83)" kind="Lean.Parser.Term.app">
                <OtherNode start="(95, 35)" end="(95, 52)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(95, 35)" end="(95, 46)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(95, 35)" end="(95, 36)" leading="" trailing="" val="("/>
                    <OtherNode start="(95, 36)" end="(95, 45)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(95, 36)" end="(95, 39)" leading="" trailing=" " raw_val="zip" val="zip" full_name="Vector.zip" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                      <NullNode start="(95, 40)" end="(95, 45)">
                        <IdentNode start="(95, 40)" end="(95, 42)" leading="" trailing=" " raw_val="as" val="as"/>
                        <IdentNode start="(95, 43)" end="(95, 45)" leading="" trailing="" raw_val="bs" val="bs"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(95, 45)" end="(95, 46)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(95, 46)" end="(95, 47)" leading="" trailing="" val="."/>
                  <IdentNode start="(95, 47)" end="(95, 52)" leading="" trailing=" " raw_val="foldr" val="foldr" full_name="Vector.foldr" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                </OtherNode>
                <NullNode start="(95, 53)" end="(95, 83)">
                  <OtherNode start="(95, 53)" end="(95, 81)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(95, 53)" end="(95, 54)" leading="" trailing="" val="("/>
                    <OtherNode start="(95, 54)" end="(95, 80)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(95, 54)" end="(95, 57)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(95, 58)" end="(95, 80)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(95, 58)" end="(95, 61)">
                          <IdentNode start="(95, 58)" end="(95, 59)" leading="" trailing=" " raw_val="p" val="p"/>
                          <IdentNode start="(95, 60)" end="(95, 61)" leading="" trailing=" " raw_val="r" val="r"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(95, 62)" end="(95, 64)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(95, 65)" end="(95, 80)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(95, 65)" end="(95, 66)" leading="" trailing=" " raw_val="g" val="g"/>
                          <NullNode start="(95, 67)" end="(95, 80)">
                            <OtherNode start="(95, 67)" end="(95, 78)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(95, 67)" end="(95, 68)" leading="" trailing="" val="("/>
                              <OtherNode start="(95, 68)" end="(95, 77)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(95, 68)" end="(95, 69)" leading="" trailing=" " raw_val="f" val="f"/>
                                <NullNode start="(95, 70)" end="(95, 77)">
                                  <OtherNode start="(95, 70)" end="(95, 73)" kind="Lean.Parser.Term.proj">
                                    <IdentNode start="(95, 70)" end="(95, 71)" leading="" trailing="" raw_val="p" val="p"/>
                                    <AtomNode start="(95, 71)" end="(95, 72)" leading="" trailing="" val="."/>
                                    <OtherNode start="(95, 72)" end="(95, 73)" kind="fieldIdx">
                                      <AtomNode start="(95, 72)" end="(95, 73)" leading="" trailing=" " val="1"/>
                                    </OtherNode>
                                  </OtherNode>
                                  <OtherNode start="(95, 74)" end="(95, 77)" kind="Lean.Parser.Term.proj">
                                    <IdentNode start="(95, 74)" end="(95, 75)" leading="" trailing="" raw_val="p" val="p"/>
                                    <AtomNode start="(95, 75)" end="(95, 76)" leading="" trailing="" val="."/>
                                    <OtherNode start="(95, 76)" end="(95, 77)" kind="fieldIdx">
                                      <AtomNode start="(95, 76)" end="(95, 77)" leading="" trailing="" val="2"/>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(95, 77)" end="(95, 78)" leading="" trailing=" " val=")"/>
                            </OtherNode>
                            <IdentNode start="(95, 79)" end="(95, 80)" leading="" trailing="" raw_val="r" val="r"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(95, 80)" end="(95, 81)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(95, 82)" end="(95, 83)" leading="" trailing=" " raw_val="i" val="i"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(95, 84)" end="(98, 47)">
          <AtomNode start="(95, 84)" end="(95, 86)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(95, 87)" end="(98, 47)">
            <AtomNode start="(95, 87)" end="(95, 89)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(96, 3)" end="(98, 47)">
              <TacticTacticseq1IndentedNode start="(96, 3)" end="(98, 47)">
                <NullNode start="(96, 3)" end="(98, 47)">
                  <OtherNode start="(96, 3)" end="(96, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;δ : Type u_4&#10;n✝ : Nat&#10;as : Vector α n✝&#10;bs : Vector β n✝&#10;g : γ → δ → δ&#10;f : α → β → γ&#10;i : δ&#10;⊢ foldr g i (zipWith f as bs) = foldr (fun p r =&amp;gt; g (f p.fst p.snd) r) i (as.zip bs)" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;δ : Type u_4&#10;g : γ → δ → δ&#10;f : α → β → γ&#10;i : δ&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ foldr g i (zipWith f { toArray := as, size_toArray := ⋯ } bs) =&#10;    foldr (fun p r =&amp;gt; g (f p.fst p.snd) r) i ({ toArray := as, size_toArray := ⋯ }.zip bs)" tactic="rcases as with ⟨as, rfl⟩">
                    <AtomNode start="(96, 3)" end="(96, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(96, 10)" end="(96, 12)">
                      <OtherNode start="(96, 10)" end="(96, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(96, 10)" end="(96, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(96, 13)" end="(96, 27)">
                      <AtomNode start="(96, 13)" end="(96, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(96, 18)" end="(96, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(96, 18)" end="(96, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(96, 18)" end="(96, 27)">
                            <OtherNode start="(96, 18)" end="(96, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(96, 18)" end="(96, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(96, 19)" end="(96, 26)">
                                <OtherNode start="(96, 19)" end="(96, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(96, 19)" end="(96, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(96, 19)" end="(96, 21)">
                                      <OtherNode start="(96, 19)" end="(96, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(96, 19)" end="(96, 21)" leading="" trailing="" raw_val="as" val="as"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(96, 21)" end="(96, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(96, 23)" end="(96, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(96, 23)" end="(96, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(96, 23)" end="(96, 26)">
                                      <OtherNode start="(96, 23)" end="(96, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(96, 23)" end="(96, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(96, 26)" end="(96, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(97, 3)" end="(97, 25)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;δ : Type u_4&#10;g : γ → δ → δ&#10;f : α → β → γ&#10;i : δ&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ foldr g i (zipWith f { toArray := as, size_toArray := ⋯ } bs) =&#10;    foldr (fun p r =&amp;gt; g (f p.fst p.snd) r) i ({ toArray := as, size_toArray := ⋯ }.zip bs)" state_after="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;δ : Type u_4&#10;g : γ → δ → δ&#10;f : α → β → γ&#10;i : δ&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ foldr g i (zipWith f { toArray := as, size_toArray := ⋯ } { toArray := bs, size_toArray := h }) =&#10;    foldr (fun p r =&amp;gt; g (f p.fst p.snd) r) i&#10;      ({ toArray := as, size_toArray := ⋯ }.zip { toArray := bs, size_toArray := h })" tactic="rcases bs with ⟨bs, h⟩">
                    <AtomNode start="(97, 3)" end="(97, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(97, 10)" end="(97, 12)">
                      <OtherNode start="(97, 10)" end="(97, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(97, 10)" end="(97, 12)" leading="" trailing=" " raw_val="bs" val="bs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(97, 13)" end="(97, 25)">
                      <AtomNode start="(97, 13)" end="(97, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(97, 18)" end="(97, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(97, 18)" end="(97, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(97, 18)" end="(97, 25)">
                            <OtherNode start="(97, 18)" end="(97, 25)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(97, 18)" end="(97, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(97, 19)" end="(97, 24)">
                                <OtherNode start="(97, 19)" end="(97, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(97, 19)" end="(97, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(97, 19)" end="(97, 21)">
                                      <OtherNode start="(97, 19)" end="(97, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(97, 19)" end="(97, 21)" leading="" trailing="" raw_val="bs" val="bs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(97, 21)" end="(97, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(97, 23)" end="(97, 24)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(97, 23)" end="(97, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(97, 23)" end="(97, 24)">
                                      <OtherNode start="(97, 23)" end="(97, 24)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(97, 23)" end="(97, 24)" leading="" trailing="" raw_val="h" val="h"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(97, 24)" end="(97, 25)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(98, 3)" end="(98, 47)" kind="Lean.Parser.Tactic.simpa" state_before="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;δ : Type u_4&#10;g : γ → δ → δ&#10;f : α → β → γ&#10;i : δ&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ foldr g i (zipWith f { toArray := as, size_toArray := ⋯ } { toArray := bs, size_toArray := h }) =&#10;    foldr (fun p r =&amp;gt; g (f p.fst p.snd) r) i&#10;      ({ toArray := as, size_toArray := ⋯ }.zip { toArray := bs, size_toArray := h })" state_after="no goals" tactic="simpa using Array.zipWith_foldr_eq_zip_foldr">
                    <AtomNode start="(98, 3)" end="(98, 8)" leading="" trailing=" " val="simpa"/>
                    <NullNode/>
                    <NullNode/>
                    <OtherNode start="(98, 9)" end="(98, 47)" kind="Lean.Parser.Tactic.simpaArgsRest">
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(98, 9)" end="(98, 47)">
                        <AtomNode start="(98, 9)" end="(98, 14)" leading="" trailing=" " val="using"/>
                        <IdentNode start="(98, 15)" end="(98, 47)" leading="" trailing="&#10;&#10;" raw_val="Array.zipWith_foldr_eq_zip_foldr" val="Array.zipWith_foldr_eq_zip_foldr" full_name="Array.zipWith_foldr_eq_zip_foldr" mod_name="Init.Data.Array.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Zip.lean"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(100, 1)" end="(104, 47)" name="zipWith_foldl_eq_zip_foldl" full_name="Vector.zipWith_foldl_eq_zip_foldl">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(100, 1)" end="(104, 47)" name="zipWith_foldl_eq_zip_foldl" full_name="Vector.zipWith_foldl_eq_zip_foldl" _is_private_decl="False">
        <AtomNode start="(100, 1)" end="(100, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(100, 9)" end="(100, 35)">
          <IdentNode start="(100, 9)" end="(100, 35)" leading="" trailing=" " raw_val="zipWith_foldl_eq_zip_foldl" val="zipWith_foldl_eq_zip_foldl"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(100, 36)" end="(101, 83)">
          <NullNode start="(100, 36)" end="(100, 59)">
            <OtherNode start="(100, 36)" end="(100, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(100, 36)" end="(100, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(100, 37)" end="(100, 38)">
                <IdentNode start="(100, 37)" end="(100, 38)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(100, 39)" end="(100, 50)">
                <AtomNode start="(100, 39)" end="(100, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(100, 41)" end="(100, 50)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(100, 41)" end="(100, 42)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(100, 43)" end="(100, 44)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(100, 45)" end="(100, 50)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(100, 45)" end="(100, 46)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(100, 47)" end="(100, 48)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(100, 49)" end="(100, 50)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(100, 50)" end="(100, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(100, 52)" end="(100, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(100, 52)" end="(100, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(100, 53)" end="(100, 54)">
                <IdentNode start="(100, 53)" end="(100, 54)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(100, 55)" end="(100, 58)">
                <AtomNode start="(100, 55)" end="(100, 56)" leading="" trailing=" " val=":"/>
                <IdentNode start="(100, 57)" end="(100, 58)" leading="" trailing="" raw_val="δ" val="δ"/>
              </NullNode>
              <AtomNode start="(100, 58)" end="(100, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(100, 60)" end="(101, 83)">
            <AtomNode start="(100, 60)" end="(100, 61)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(101, 5)" end="(101, 83)" kind="«term_=_»">
              <OtherNode start="(101, 5)" end="(101, 32)" kind="Lean.Parser.Term.app">
                <OtherNode start="(101, 5)" end="(101, 28)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(101, 5)" end="(101, 22)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(101, 5)" end="(101, 6)" leading="" trailing="" val="("/>
                    <OtherNode start="(101, 6)" end="(101, 21)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(101, 6)" end="(101, 13)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="Vector.zipWith" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                      <NullNode start="(101, 14)" end="(101, 21)">
                        <IdentNode start="(101, 14)" end="(101, 15)" leading="" trailing=" " raw_val="f" val="f"/>
                        <IdentNode start="(101, 16)" end="(101, 18)" leading="" trailing=" " raw_val="as" val="as"/>
                        <IdentNode start="(101, 19)" end="(101, 21)" leading="" trailing="" raw_val="bs" val="bs"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(101, 21)" end="(101, 22)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(101, 22)" end="(101, 23)" leading="" trailing="" val="."/>
                  <IdentNode start="(101, 23)" end="(101, 28)" leading="" trailing=" " raw_val="foldl" val="foldl" full_name="Vector.foldl" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                </OtherNode>
                <NullNode start="(101, 29)" end="(101, 32)">
                  <IdentNode start="(101, 29)" end="(101, 30)" leading="" trailing=" " raw_val="g" val="g"/>
                  <IdentNode start="(101, 31)" end="(101, 32)" leading="" trailing=" " raw_val="i" val="i"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(101, 33)" end="(101, 34)" leading="" trailing=" " val="="/>
              <OtherNode start="(101, 35)" end="(101, 83)" kind="Lean.Parser.Term.app">
                <OtherNode start="(101, 35)" end="(101, 52)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(101, 35)" end="(101, 46)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(101, 35)" end="(101, 36)" leading="" trailing="" val="("/>
                    <OtherNode start="(101, 36)" end="(101, 45)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(101, 36)" end="(101, 39)" leading="" trailing=" " raw_val="zip" val="zip" full_name="Vector.zip" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                      <NullNode start="(101, 40)" end="(101, 45)">
                        <IdentNode start="(101, 40)" end="(101, 42)" leading="" trailing=" " raw_val="as" val="as"/>
                        <IdentNode start="(101, 43)" end="(101, 45)" leading="" trailing="" raw_val="bs" val="bs"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(101, 45)" end="(101, 46)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(101, 46)" end="(101, 47)" leading="" trailing="" val="."/>
                  <IdentNode start="(101, 47)" end="(101, 52)" leading="" trailing=" " raw_val="foldl" val="foldl" full_name="Vector.foldl" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                </OtherNode>
                <NullNode start="(101, 53)" end="(101, 83)">
                  <OtherNode start="(101, 53)" end="(101, 81)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(101, 53)" end="(101, 54)" leading="" trailing="" val="("/>
                    <OtherNode start="(101, 54)" end="(101, 80)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(101, 54)" end="(101, 57)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(101, 58)" end="(101, 80)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(101, 58)" end="(101, 61)">
                          <IdentNode start="(101, 58)" end="(101, 59)" leading="" trailing=" " raw_val="r" val="r"/>
                          <IdentNode start="(101, 60)" end="(101, 61)" leading="" trailing=" " raw_val="p" val="p"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(101, 62)" end="(101, 64)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(101, 65)" end="(101, 80)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(101, 65)" end="(101, 66)" leading="" trailing=" " raw_val="g" val="g"/>
                          <NullNode start="(101, 67)" end="(101, 80)">
                            <IdentNode start="(101, 67)" end="(101, 68)" leading="" trailing=" " raw_val="r" val="r"/>
                            <OtherNode start="(101, 69)" end="(101, 80)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(101, 69)" end="(101, 70)" leading="" trailing="" val="("/>
                              <OtherNode start="(101, 70)" end="(101, 79)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(101, 70)" end="(101, 71)" leading="" trailing=" " raw_val="f" val="f"/>
                                <NullNode start="(101, 72)" end="(101, 79)">
                                  <OtherNode start="(101, 72)" end="(101, 75)" kind="Lean.Parser.Term.proj">
                                    <IdentNode start="(101, 72)" end="(101, 73)" leading="" trailing="" raw_val="p" val="p"/>
                                    <AtomNode start="(101, 73)" end="(101, 74)" leading="" trailing="" val="."/>
                                    <OtherNode start="(101, 74)" end="(101, 75)" kind="fieldIdx">
                                      <AtomNode start="(101, 74)" end="(101, 75)" leading="" trailing=" " val="1"/>
                                    </OtherNode>
                                  </OtherNode>
                                  <OtherNode start="(101, 76)" end="(101, 79)" kind="Lean.Parser.Term.proj">
                                    <IdentNode start="(101, 76)" end="(101, 77)" leading="" trailing="" raw_val="p" val="p"/>
                                    <AtomNode start="(101, 77)" end="(101, 78)" leading="" trailing="" val="."/>
                                    <OtherNode start="(101, 78)" end="(101, 79)" kind="fieldIdx">
                                      <AtomNode start="(101, 78)" end="(101, 79)" leading="" trailing="" val="2"/>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(101, 79)" end="(101, 80)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(101, 80)" end="(101, 81)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(101, 82)" end="(101, 83)" leading="" trailing=" " raw_val="i" val="i"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(101, 84)" end="(104, 47)">
          <AtomNode start="(101, 84)" end="(101, 86)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(101, 87)" end="(104, 47)">
            <AtomNode start="(101, 87)" end="(101, 89)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(102, 3)" end="(104, 47)">
              <TacticTacticseq1IndentedNode start="(102, 3)" end="(104, 47)">
                <NullNode start="(102, 3)" end="(104, 47)">
                  <OtherNode start="(102, 3)" end="(102, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;δ : Type u_4&#10;n✝ : Nat&#10;as : Vector α n✝&#10;bs : Vector β n✝&#10;g : δ → γ → δ&#10;f : α → β → γ&#10;i : δ&#10;⊢ foldl g i (zipWith f as bs) = foldl (fun r p =&amp;gt; g r (f p.fst p.snd)) i (as.zip bs)" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;δ : Type u_4&#10;g : δ → γ → δ&#10;f : α → β → γ&#10;i : δ&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ foldl g i (zipWith f { toArray := as, size_toArray := ⋯ } bs) =&#10;    foldl (fun r p =&amp;gt; g r (f p.fst p.snd)) i ({ toArray := as, size_toArray := ⋯ }.zip bs)" tactic="rcases as with ⟨as, rfl⟩">
                    <AtomNode start="(102, 3)" end="(102, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(102, 10)" end="(102, 12)">
                      <OtherNode start="(102, 10)" end="(102, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(102, 10)" end="(102, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(102, 13)" end="(102, 27)">
                      <AtomNode start="(102, 13)" end="(102, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(102, 18)" end="(102, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(102, 18)" end="(102, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(102, 18)" end="(102, 27)">
                            <OtherNode start="(102, 18)" end="(102, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(102, 18)" end="(102, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(102, 19)" end="(102, 26)">
                                <OtherNode start="(102, 19)" end="(102, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(102, 19)" end="(102, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(102, 19)" end="(102, 21)">
                                      <OtherNode start="(102, 19)" end="(102, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(102, 19)" end="(102, 21)" leading="" trailing="" raw_val="as" val="as"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(102, 21)" end="(102, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(102, 23)" end="(102, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(102, 23)" end="(102, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(102, 23)" end="(102, 26)">
                                      <OtherNode start="(102, 23)" end="(102, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(102, 23)" end="(102, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(102, 26)" end="(102, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(103, 3)" end="(103, 25)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;δ : Type u_4&#10;g : δ → γ → δ&#10;f : α → β → γ&#10;i : δ&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ foldl g i (zipWith f { toArray := as, size_toArray := ⋯ } bs) =&#10;    foldl (fun r p =&amp;gt; g r (f p.fst p.snd)) i ({ toArray := as, size_toArray := ⋯ }.zip bs)" state_after="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;δ : Type u_4&#10;g : δ → γ → δ&#10;f : α → β → γ&#10;i : δ&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ foldl g i (zipWith f { toArray := as, size_toArray := ⋯ } { toArray := bs, size_toArray := h }) =&#10;    foldl (fun r p =&amp;gt; g r (f p.fst p.snd)) i&#10;      ({ toArray := as, size_toArray := ⋯ }.zip { toArray := bs, size_toArray := h })" tactic="rcases bs with ⟨bs, h⟩">
                    <AtomNode start="(103, 3)" end="(103, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(103, 10)" end="(103, 12)">
                      <OtherNode start="(103, 10)" end="(103, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(103, 10)" end="(103, 12)" leading="" trailing=" " raw_val="bs" val="bs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(103, 13)" end="(103, 25)">
                      <AtomNode start="(103, 13)" end="(103, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(103, 18)" end="(103, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(103, 18)" end="(103, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(103, 18)" end="(103, 25)">
                            <OtherNode start="(103, 18)" end="(103, 25)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(103, 18)" end="(103, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(103, 19)" end="(103, 24)">
                                <OtherNode start="(103, 19)" end="(103, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(103, 19)" end="(103, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(103, 19)" end="(103, 21)">
                                      <OtherNode start="(103, 19)" end="(103, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(103, 19)" end="(103, 21)" leading="" trailing="" raw_val="bs" val="bs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(103, 21)" end="(103, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(103, 23)" end="(103, 24)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(103, 23)" end="(103, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(103, 23)" end="(103, 24)">
                                      <OtherNode start="(103, 23)" end="(103, 24)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(103, 23)" end="(103, 24)" leading="" trailing="" raw_val="h" val="h"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(103, 24)" end="(103, 25)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(104, 3)" end="(104, 47)" kind="Lean.Parser.Tactic.simpa" state_before="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;δ : Type u_4&#10;g : δ → γ → δ&#10;f : α → β → γ&#10;i : δ&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ foldl g i (zipWith f { toArray := as, size_toArray := ⋯ } { toArray := bs, size_toArray := h }) =&#10;    foldl (fun r p =&amp;gt; g r (f p.fst p.snd)) i&#10;      ({ toArray := as, size_toArray := ⋯ }.zip { toArray := bs, size_toArray := h })" state_after="no goals" tactic="simpa using Array.zipWith_foldl_eq_zip_foldl">
                    <AtomNode start="(104, 3)" end="(104, 8)" leading="" trailing=" " val="simpa"/>
                    <NullNode/>
                    <NullNode/>
                    <OtherNode start="(104, 9)" end="(104, 47)" kind="Lean.Parser.Tactic.simpaArgsRest">
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(104, 9)" end="(104, 47)">
                        <AtomNode start="(104, 9)" end="(104, 14)" leading="" trailing=" " val="using"/>
                        <IdentNode start="(104, 15)" end="(104, 47)" leading="" trailing="&#10;&#10;" raw_val="Array.zipWith_foldl_eq_zip_foldl" val="Array.zipWith_foldl_eq_zip_foldl" full_name="Array.zipWith_foldl_eq_zip_foldl" mod_name="Init.Data.Array.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Zip.lean"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(106, 1)" end="(110, 27)" name="map_zipWith" full_name="Vector.map_zipWith">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(106, 1)" end="(110, 27)" name="map_zipWith" full_name="Vector.map_zipWith" _is_private_decl="False">
        <AtomNode start="(106, 1)" end="(106, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(106, 9)" end="(106, 20)">
          <IdentNode start="(106, 9)" end="(106, 20)" leading="" trailing=" " raw_val="map_zipWith" val="map_zipWith"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(106, 21)" end="(107, 67)">
          <NullNode start="(106, 21)" end="(106, 97)">
            <OtherNode start="(106, 21)" end="(106, 33)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(106, 21)" end="(106, 22)" leading="" trailing="" val="{"/>
              <NullNode start="(106, 22)" end="(106, 23)">
                <IdentNode start="(106, 22)" end="(106, 23)" leading="" trailing=" " raw_val="δ" val="δ"/>
              </NullNode>
              <NullNode start="(106, 24)" end="(106, 32)">
                <AtomNode start="(106, 24)" end="(106, 25)" leading="" trailing=" " val=":"/>
                <OtherNode start="(106, 26)" end="(106, 32)" kind="Lean.Parser.Term.type">
                  <AtomNode start="(106, 26)" end="(106, 30)" leading="" trailing=" " val="Type"/>
                  <NullNode start="(106, 31)" end="(106, 32)">
                    <OtherNode start="(106, 31)" end="(106, 32)" kind="Lean.Parser.Level.hole">
                      <AtomNode start="(106, 31)" end="(106, 32)" leading="" trailing="" val="_"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(106, 32)" end="(106, 33)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(106, 34)" end="(106, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(106, 34)" end="(106, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(106, 35)" end="(106, 36)">
                <IdentNode start="(106, 35)" end="(106, 36)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(106, 37)" end="(106, 44)">
                <AtomNode start="(106, 37)" end="(106, 38)" leading="" trailing=" " val=":"/>
                <OtherNode start="(106, 39)" end="(106, 44)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(106, 39)" end="(106, 40)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(106, 41)" end="(106, 42)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(106, 43)" end="(106, 44)" leading="" trailing="" raw_val="β" val="β"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(106, 44)" end="(106, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(106, 46)" end="(106, 61)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(106, 46)" end="(106, 47)" leading="" trailing="" val="{"/>
              <NullNode start="(106, 47)" end="(106, 48)">
                <IdentNode start="(106, 47)" end="(106, 48)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(106, 49)" end="(106, 60)">
                <AtomNode start="(106, 49)" end="(106, 50)" leading="" trailing=" " val=":"/>
                <OtherNode start="(106, 51)" end="(106, 60)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(106, 51)" end="(106, 52)" leading="" trailing=" " raw_val="γ" val="γ"/>
                  <AtomNode start="(106, 53)" end="(106, 54)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(106, 55)" end="(106, 60)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(106, 55)" end="(106, 56)" leading="" trailing=" " raw_val="δ" val="δ"/>
                    <AtomNode start="(106, 57)" end="(106, 58)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(106, 59)" end="(106, 60)" leading="" trailing="" raw_val="α" val="α"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(106, 60)" end="(106, 61)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(106, 62)" end="(106, 79)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(106, 62)" end="(106, 63)" leading="" trailing="" val="{"/>
              <NullNode start="(106, 63)" end="(106, 65)">
                <IdentNode start="(106, 63)" end="(106, 65)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(106, 66)" end="(106, 78)">
                <AtomNode start="(106, 66)" end="(106, 67)" leading="" trailing=" " val=":"/>
                <OtherNode start="(106, 68)" end="(106, 78)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(106, 68)" end="(106, 74)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(106, 75)" end="(106, 78)">
                    <IdentNode start="(106, 75)" end="(106, 76)" leading="" trailing=" " raw_val="γ" val="γ"/>
                    <IdentNode start="(106, 77)" end="(106, 78)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(106, 78)" end="(106, 79)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(106, 80)" end="(106, 97)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(106, 80)" end="(106, 81)" leading="" trailing="" val="{"/>
              <NullNode start="(106, 81)" end="(106, 83)">
                <IdentNode start="(106, 81)" end="(106, 83)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(106, 84)" end="(106, 96)">
                <AtomNode start="(106, 84)" end="(106, 85)" leading="" trailing=" " val=":"/>
                <OtherNode start="(106, 86)" end="(106, 96)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(106, 86)" end="(106, 92)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(106, 93)" end="(106, 96)">
                    <IdentNode start="(106, 93)" end="(106, 94)" leading="" trailing=" " raw_val="δ" val="δ"/>
                    <IdentNode start="(106, 95)" end="(106, 96)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(106, 96)" end="(106, 97)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(106, 98)" end="(107, 67)">
            <AtomNode start="(106, 98)" end="(106, 99)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(107, 5)" end="(107, 67)" kind="«term_=_»">
              <OtherNode start="(107, 5)" end="(107, 28)" kind="Lean.Parser.Term.app">
                <IdentNode start="(107, 5)" end="(107, 8)" leading="" trailing=" " raw_val="map" val="map" full_name="Vector.map" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(107, 9)" end="(107, 28)">
                  <IdentNode start="(107, 9)" end="(107, 10)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(107, 11)" end="(107, 28)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(107, 11)" end="(107, 12)" leading="" trailing="" val="("/>
                    <OtherNode start="(107, 12)" end="(107, 27)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(107, 12)" end="(107, 19)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="Vector.zipWith" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                      <NullNode start="(107, 20)" end="(107, 27)">
                        <IdentNode start="(107, 20)" end="(107, 21)" leading="" trailing=" " raw_val="g" val="g"/>
                        <IdentNode start="(107, 22)" end="(107, 24)" leading="" trailing=" " raw_val="as" val="as"/>
                        <IdentNode start="(107, 25)" end="(107, 27)" leading="" trailing="" raw_val="bs" val="bs"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(107, 27)" end="(107, 28)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(107, 29)" end="(107, 30)" leading="" trailing=" " val="="/>
              <OtherNode start="(107, 31)" end="(107, 67)" kind="Lean.Parser.Term.app">
                <IdentNode start="(107, 31)" end="(107, 38)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="Vector.zipWith" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(107, 39)" end="(107, 67)">
                  <OtherNode start="(107, 39)" end="(107, 61)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(107, 39)" end="(107, 40)" leading="" trailing="" val="("/>
                    <OtherNode start="(107, 40)" end="(107, 60)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(107, 40)" end="(107, 43)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(107, 44)" end="(107, 60)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(107, 44)" end="(107, 47)">
                          <IdentNode start="(107, 44)" end="(107, 45)" leading="" trailing=" " raw_val="x" val="x"/>
                          <IdentNode start="(107, 46)" end="(107, 47)" leading="" trailing=" " raw_val="y" val="y"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(107, 48)" end="(107, 50)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(107, 51)" end="(107, 60)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(107, 51)" end="(107, 52)" leading="" trailing=" " raw_val="f" val="f"/>
                          <NullNode start="(107, 53)" end="(107, 60)">
                            <OtherNode start="(107, 53)" end="(107, 60)" kind="Lean.Parser.Term.paren">
                              <AtomNode start="(107, 53)" end="(107, 54)" leading="" trailing="" val="("/>
                              <OtherNode start="(107, 54)" end="(107, 59)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(107, 54)" end="(107, 55)" leading="" trailing=" " raw_val="g" val="g"/>
                                <NullNode start="(107, 56)" end="(107, 59)">
                                  <IdentNode start="(107, 56)" end="(107, 57)" leading="" trailing=" " raw_val="x" val="x"/>
                                  <IdentNode start="(107, 58)" end="(107, 59)" leading="" trailing="" raw_val="y" val="y"/>
                                </NullNode>
                              </OtherNode>
                              <AtomNode start="(107, 59)" end="(107, 60)" leading="" trailing="" val=")"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(107, 60)" end="(107, 61)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(107, 62)" end="(107, 64)" leading="" trailing=" " raw_val="as" val="as"/>
                  <IdentNode start="(107, 65)" end="(107, 67)" leading="" trailing=" " raw_val="bs" val="bs"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(107, 68)" end="(110, 27)">
          <AtomNode start="(107, 68)" end="(107, 70)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(107, 71)" end="(110, 27)">
            <AtomNode start="(107, 71)" end="(107, 73)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(108, 3)" end="(110, 27)">
              <TacticTacticseq1IndentedNode start="(108, 3)" end="(110, 27)">
                <NullNode start="(108, 3)" end="(110, 27)">
                  <OtherNode start="(108, 3)" end="(108, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;n : Nat&#10;δ : Type u_4&#10;f : α → β&#10;g : γ → δ → α&#10;as : Vector γ n&#10;bs : Vector δ n&#10;⊢ map f (zipWith g as bs) = zipWith (fun x y =&amp;gt; f (g x y)) as bs" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;δ : Type u_4&#10;f : α → β&#10;g : γ → δ → α&#10;as : Array γ&#10;bs : Vector δ as.size&#10;⊢ map f (zipWith g { toArray := as, size_toArray := ⋯ } bs) =&#10;    zipWith (fun x y =&amp;gt; f (g x y)) { toArray := as, size_toArray := ⋯ } bs" tactic="rcases as with ⟨as, rfl⟩">
                    <AtomNode start="(108, 3)" end="(108, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(108, 10)" end="(108, 12)">
                      <OtherNode start="(108, 10)" end="(108, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(108, 10)" end="(108, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(108, 13)" end="(108, 27)">
                      <AtomNode start="(108, 13)" end="(108, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(108, 18)" end="(108, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(108, 18)" end="(108, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(108, 18)" end="(108, 27)">
                            <OtherNode start="(108, 18)" end="(108, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(108, 18)" end="(108, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(108, 19)" end="(108, 26)">
                                <OtherNode start="(108, 19)" end="(108, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(108, 19)" end="(108, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(108, 19)" end="(108, 21)">
                                      <OtherNode start="(108, 19)" end="(108, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(108, 19)" end="(108, 21)" leading="" trailing="" raw_val="as" val="as"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(108, 21)" end="(108, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(108, 23)" end="(108, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(108, 23)" end="(108, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(108, 23)" end="(108, 26)">
                                      <OtherNode start="(108, 23)" end="(108, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(108, 23)" end="(108, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(108, 26)" end="(108, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(109, 3)" end="(109, 25)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;δ : Type u_4&#10;f : α → β&#10;g : γ → δ → α&#10;as : Array γ&#10;bs : Vector δ as.size&#10;⊢ map f (zipWith g { toArray := as, size_toArray := ⋯ } bs) =&#10;    zipWith (fun x y =&amp;gt; f (g x y)) { toArray := as, size_toArray := ⋯ } bs" state_after="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;δ : Type u_4&#10;f : α → β&#10;g : γ → δ → α&#10;as : Array γ&#10;bs : Array δ&#10;h : bs.size = as.size&#10;⊢ map f (zipWith g { toArray := as, size_toArray := ⋯ } { toArray := bs, size_toArray := h }) =&#10;    zipWith (fun x y =&amp;gt; f (g x y)) { toArray := as, size_toArray := ⋯ } { toArray := bs, size_toArray := h }" tactic="rcases bs with ⟨bs, h⟩">
                    <AtomNode start="(109, 3)" end="(109, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(109, 10)" end="(109, 12)">
                      <OtherNode start="(109, 10)" end="(109, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(109, 10)" end="(109, 12)" leading="" trailing=" " raw_val="bs" val="bs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(109, 13)" end="(109, 25)">
                      <AtomNode start="(109, 13)" end="(109, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(109, 18)" end="(109, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(109, 18)" end="(109, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(109, 18)" end="(109, 25)">
                            <OtherNode start="(109, 18)" end="(109, 25)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(109, 18)" end="(109, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(109, 19)" end="(109, 24)">
                                <OtherNode start="(109, 19)" end="(109, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(109, 19)" end="(109, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(109, 19)" end="(109, 21)">
                                      <OtherNode start="(109, 19)" end="(109, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(109, 19)" end="(109, 21)" leading="" trailing="" raw_val="bs" val="bs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(109, 21)" end="(109, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(109, 23)" end="(109, 24)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(109, 23)" end="(109, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(109, 23)" end="(109, 24)">
                                      <OtherNode start="(109, 23)" end="(109, 24)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(109, 23)" end="(109, 24)" leading="" trailing="" raw_val="h" val="h"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(109, 24)" end="(109, 25)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(110, 3)" end="(110, 27)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;δ : Type u_4&#10;f : α → β&#10;g : γ → δ → α&#10;as : Array γ&#10;bs : Array δ&#10;h : bs.size = as.size&#10;⊢ map f (zipWith g { toArray := as, size_toArray := ⋯ } { toArray := bs, size_toArray := h }) =&#10;    zipWith (fun x y =&amp;gt; f (g x y)) { toArray := as, size_toArray := ⋯ } { toArray := bs, size_toArray := h }" state_after="no goals" tactic="simp [Array.map_zipWith]">
                    <AtomNode start="(110, 3)" end="(110, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(110, 8)" end="(110, 27)">
                      <AtomNode start="(110, 8)" end="(110, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(110, 9)" end="(110, 26)">
                        <OtherNode start="(110, 9)" end="(110, 26)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(110, 9)" end="(110, 26)" leading="" trailing="" raw_val="Array.map_zipWith" val="Array.map_zipWith" full_name="Array.map_zipWith" mod_name="Init.Data.Array.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Zip.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(110, 26)" end="(110, 27)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(112, 1)" end="(115, 28)" name="take_zipWith" full_name="Vector.take_zipWith">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(112, 1)" end="(115, 28)" name="take_zipWith" full_name="Vector.take_zipWith" _is_private_decl="False">
        <AtomNode start="(112, 1)" end="(112, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(112, 9)" end="(112, 21)">
          <IdentNode start="(112, 9)" end="(112, 21)" leading="" trailing=" " raw_val="take_zipWith" val="take_zipWith"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(112, 22)" end="(112, 84)">
          <NullNode/>
          <TermTypespecNode start="(112, 22)" end="(112, 84)">
            <AtomNode start="(112, 22)" end="(112, 23)" leading="" trailing=" " val=":"/>
            <OtherNode start="(112, 24)" end="(112, 84)" kind="«term_=_»">
              <OtherNode start="(112, 24)" end="(112, 48)" kind="Lean.Parser.Term.app">
                <OtherNode start="(112, 24)" end="(112, 46)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(112, 24)" end="(112, 41)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(112, 24)" end="(112, 25)" leading="" trailing="" val="("/>
                    <OtherNode start="(112, 25)" end="(112, 40)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(112, 25)" end="(112, 32)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="Vector.zipWith" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                      <NullNode start="(112, 33)" end="(112, 40)">
                        <IdentNode start="(112, 33)" end="(112, 34)" leading="" trailing=" " raw_val="f" val="f"/>
                        <IdentNode start="(112, 35)" end="(112, 37)" leading="" trailing=" " raw_val="as" val="as"/>
                        <IdentNode start="(112, 38)" end="(112, 40)" leading="" trailing="" raw_val="bs" val="bs"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(112, 40)" end="(112, 41)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(112, 41)" end="(112, 42)" leading="" trailing="" val="."/>
                  <IdentNode start="(112, 42)" end="(112, 46)" leading="" trailing=" " raw_val="take" val="take" full_name="Vector.take" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                </OtherNode>
                <NullNode start="(112, 47)" end="(112, 48)">
                  <IdentNode start="(112, 47)" end="(112, 48)" leading="" trailing=" " raw_val="i" val="i"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(112, 49)" end="(112, 50)" leading="" trailing=" " val="="/>
              <OtherNode start="(112, 51)" end="(112, 84)" kind="Lean.Parser.Term.app">
                <IdentNode start="(112, 51)" end="(112, 58)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="Vector.zipWith" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(112, 59)" end="(112, 84)">
                  <IdentNode start="(112, 59)" end="(112, 60)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(112, 61)" end="(112, 72)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(112, 61)" end="(112, 62)" leading="" trailing="" val="("/>
                    <OtherNode start="(112, 62)" end="(112, 71)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(112, 62)" end="(112, 69)" leading="" trailing=" " raw_val="as.take" val="as.take"/>
                      <NullNode start="(112, 70)" end="(112, 71)">
                        <IdentNode start="(112, 70)" end="(112, 71)" leading="" trailing="" raw_val="i" val="i"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(112, 71)" end="(112, 72)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(112, 73)" end="(112, 84)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(112, 73)" end="(112, 74)" leading="" trailing="" val="("/>
                    <OtherNode start="(112, 74)" end="(112, 83)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(112, 74)" end="(112, 81)" leading="" trailing=" " raw_val="bs.take" val="bs.take"/>
                      <NullNode start="(112, 82)" end="(112, 83)">
                        <IdentNode start="(112, 82)" end="(112, 83)" leading="" trailing="" raw_val="i" val="i"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(112, 83)" end="(112, 84)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(112, 85)" end="(115, 28)">
          <AtomNode start="(112, 85)" end="(112, 87)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(112, 88)" end="(115, 28)">
            <AtomNode start="(112, 88)" end="(112, 90)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(113, 3)" end="(115, 28)">
              <TacticTacticseq1IndentedNode start="(113, 3)" end="(115, 28)">
                <NullNode start="(113, 3)" end="(115, 28)">
                  <OtherNode start="(113, 3)" end="(113, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;n✝ : Nat&#10;as : Vector α✝² n✝&#10;bs : Vector α✝¹ n✝&#10;i : Nat&#10;⊢ (zipWith f as bs).take i = zipWith f (as.take i) (bs.take i)" state_after="case mk&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;i : Nat&#10;as : Array α✝²&#10;bs : Vector α✝¹ as.size&#10;⊢ (zipWith f { toArray := as, size_toArray := ⋯ } bs).take i =&#10;    zipWith f ({ toArray := as, size_toArray := ⋯ }.take i) (bs.take i)" tactic="rcases as with ⟨as, rfl⟩">
                    <AtomNode start="(113, 3)" end="(113, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(113, 10)" end="(113, 12)">
                      <OtherNode start="(113, 10)" end="(113, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(113, 10)" end="(113, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(113, 13)" end="(113, 27)">
                      <AtomNode start="(113, 13)" end="(113, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(113, 18)" end="(113, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(113, 18)" end="(113, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(113, 18)" end="(113, 27)">
                            <OtherNode start="(113, 18)" end="(113, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(113, 18)" end="(113, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(113, 19)" end="(113, 26)">
                                <OtherNode start="(113, 19)" end="(113, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(113, 19)" end="(113, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(113, 19)" end="(113, 21)">
                                      <OtherNode start="(113, 19)" end="(113, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(113, 19)" end="(113, 21)" leading="" trailing="" raw_val="as" val="as"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(113, 21)" end="(113, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(113, 23)" end="(113, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(113, 23)" end="(113, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(113, 23)" end="(113, 26)">
                                      <OtherNode start="(113, 23)" end="(113, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(113, 23)" end="(113, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(113, 26)" end="(113, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(114, 3)" end="(114, 25)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;i : Nat&#10;as : Array α✝²&#10;bs : Vector α✝¹ as.size&#10;⊢ (zipWith f { toArray := as, size_toArray := ⋯ } bs).take i =&#10;    zipWith f ({ toArray := as, size_toArray := ⋯ }.take i) (bs.take i)" state_after="case mk.mk&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;i : Nat&#10;as : Array α✝²&#10;bs : Array α✝¹&#10;h : bs.size = as.size&#10;⊢ (zipWith f { toArray := as, size_toArray := ⋯ } { toArray := bs, size_toArray := h }).take i =&#10;    zipWith f ({ toArray := as, size_toArray := ⋯ }.take i) ({ toArray := bs, size_toArray := h }.take i)" tactic="rcases bs with ⟨bs, h⟩">
                    <AtomNode start="(114, 3)" end="(114, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(114, 10)" end="(114, 12)">
                      <OtherNode start="(114, 10)" end="(114, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(114, 10)" end="(114, 12)" leading="" trailing=" " raw_val="bs" val="bs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(114, 13)" end="(114, 25)">
                      <AtomNode start="(114, 13)" end="(114, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(114, 18)" end="(114, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(114, 18)" end="(114, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(114, 18)" end="(114, 25)">
                            <OtherNode start="(114, 18)" end="(114, 25)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(114, 18)" end="(114, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(114, 19)" end="(114, 24)">
                                <OtherNode start="(114, 19)" end="(114, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(114, 19)" end="(114, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(114, 19)" end="(114, 21)">
                                      <OtherNode start="(114, 19)" end="(114, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(114, 19)" end="(114, 21)" leading="" trailing="" raw_val="bs" val="bs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(114, 21)" end="(114, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(114, 23)" end="(114, 24)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(114, 23)" end="(114, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(114, 23)" end="(114, 24)">
                                      <OtherNode start="(114, 23)" end="(114, 24)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(114, 23)" end="(114, 24)" leading="" trailing="" raw_val="h" val="h"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(114, 24)" end="(114, 25)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(115, 3)" end="(115, 28)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;i : Nat&#10;as : Array α✝²&#10;bs : Array α✝¹&#10;h : bs.size = as.size&#10;⊢ (zipWith f { toArray := as, size_toArray := ⋯ } { toArray := bs, size_toArray := h }).take i =&#10;    zipWith f ({ toArray := as, size_toArray := ⋯ }.take i) ({ toArray := bs, size_toArray := h }.take i)" state_after="no goals" tactic="simp [Array.take_zipWith]">
                    <AtomNode start="(115, 3)" end="(115, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(115, 8)" end="(115, 28)">
                      <AtomNode start="(115, 8)" end="(115, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(115, 9)" end="(115, 27)">
                        <OtherNode start="(115, 9)" end="(115, 27)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(115, 9)" end="(115, 27)" leading="" trailing="" raw_val="Array.take_zipWith" val="Array.take_zipWith" full_name="Array.take_zipWith" mod_name="Init.Data.Array.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Zip.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(115, 27)" end="(115, 28)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(117, 1)" end="(120, 31)" name="extract_zipWith" full_name="Vector.extract_zipWith">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(117, 1)" end="(120, 31)" name="extract_zipWith" full_name="Vector.extract_zipWith" _is_private_decl="False">
        <AtomNode start="(117, 1)" end="(117, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(117, 9)" end="(117, 24)">
          <IdentNode start="(117, 9)" end="(117, 24)" leading="" trailing=" " raw_val="extract_zipWith" val="extract_zipWith"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(117, 25)" end="(117, 102)">
          <NullNode/>
          <TermTypespecNode start="(117, 25)" end="(117, 102)">
            <AtomNode start="(117, 25)" end="(117, 26)" leading="" trailing=" " val=":"/>
            <OtherNode start="(117, 27)" end="(117, 102)" kind="«term_=_»">
              <OtherNode start="(117, 27)" end="(117, 56)" kind="Lean.Parser.Term.app">
                <OtherNode start="(117, 27)" end="(117, 52)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(117, 27)" end="(117, 44)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(117, 27)" end="(117, 28)" leading="" trailing="" val="("/>
                    <OtherNode start="(117, 28)" end="(117, 43)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(117, 28)" end="(117, 35)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="Vector.zipWith" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                      <NullNode start="(117, 36)" end="(117, 43)">
                        <IdentNode start="(117, 36)" end="(117, 37)" leading="" trailing=" " raw_val="f" val="f"/>
                        <IdentNode start="(117, 38)" end="(117, 40)" leading="" trailing=" " raw_val="as" val="as"/>
                        <IdentNode start="(117, 41)" end="(117, 43)" leading="" trailing="" raw_val="bs" val="bs"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(117, 43)" end="(117, 44)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(117, 44)" end="(117, 45)" leading="" trailing="" val="."/>
                  <IdentNode start="(117, 45)" end="(117, 52)" leading="" trailing=" " raw_val="extract" val="extract" full_name="Vector.extract" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                </OtherNode>
                <NullNode start="(117, 53)" end="(117, 56)">
                  <IdentNode start="(117, 53)" end="(117, 54)" leading="" trailing=" " raw_val="i" val="i"/>
                  <IdentNode start="(117, 55)" end="(117, 56)" leading="" trailing=" " raw_val="j" val="j"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(117, 57)" end="(117, 58)" leading="" trailing=" " val="="/>
              <OtherNode start="(117, 59)" end="(117, 102)" kind="Lean.Parser.Term.app">
                <IdentNode start="(117, 59)" end="(117, 66)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="Vector.zipWith" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(117, 67)" end="(117, 102)">
                  <IdentNode start="(117, 67)" end="(117, 68)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(117, 69)" end="(117, 85)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(117, 69)" end="(117, 70)" leading="" trailing="" val="("/>
                    <OtherNode start="(117, 70)" end="(117, 84)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(117, 70)" end="(117, 80)" leading="" trailing=" " raw_val="as.extract" val="as.extract"/>
                      <NullNode start="(117, 81)" end="(117, 84)">
                        <IdentNode start="(117, 81)" end="(117, 82)" leading="" trailing=" " raw_val="i" val="i"/>
                        <IdentNode start="(117, 83)" end="(117, 84)" leading="" trailing="" raw_val="j" val="j"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(117, 84)" end="(117, 85)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(117, 86)" end="(117, 102)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(117, 86)" end="(117, 87)" leading="" trailing="" val="("/>
                    <OtherNode start="(117, 87)" end="(117, 101)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(117, 87)" end="(117, 97)" leading="" trailing=" " raw_val="bs.extract" val="bs.extract"/>
                      <NullNode start="(117, 98)" end="(117, 101)">
                        <IdentNode start="(117, 98)" end="(117, 99)" leading="" trailing=" " raw_val="i" val="i"/>
                        <IdentNode start="(117, 100)" end="(117, 101)" leading="" trailing="" raw_val="j" val="j"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(117, 101)" end="(117, 102)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(117, 103)" end="(120, 31)">
          <AtomNode start="(117, 103)" end="(117, 105)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(117, 106)" end="(120, 31)">
            <AtomNode start="(117, 106)" end="(117, 108)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(118, 3)" end="(120, 31)">
              <TacticTacticseq1IndentedNode start="(118, 3)" end="(120, 31)">
                <NullNode start="(118, 3)" end="(120, 31)">
                  <OtherNode start="(118, 3)" end="(118, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;n✝ : Nat&#10;as : Vector α✝² n✝&#10;bs : Vector α✝¹ n✝&#10;i j : Nat&#10;⊢ (zipWith f as bs).extract i j = zipWith f (as.extract i j) (bs.extract i j)" state_after="case mk&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;i j : Nat&#10;as : Array α✝²&#10;bs : Vector α✝¹ as.size&#10;⊢ (zipWith f { toArray := as, size_toArray := ⋯ } bs).extract i j =&#10;    zipWith f ({ toArray := as, size_toArray := ⋯ }.extract i j) (bs.extract i j)" tactic="rcases as with ⟨as, rfl⟩">
                    <AtomNode start="(118, 3)" end="(118, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(118, 10)" end="(118, 12)">
                      <OtherNode start="(118, 10)" end="(118, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(118, 10)" end="(118, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(118, 13)" end="(118, 27)">
                      <AtomNode start="(118, 13)" end="(118, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(118, 18)" end="(118, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(118, 18)" end="(118, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(118, 18)" end="(118, 27)">
                            <OtherNode start="(118, 18)" end="(118, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(118, 18)" end="(118, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(118, 19)" end="(118, 26)">
                                <OtherNode start="(118, 19)" end="(118, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(118, 19)" end="(118, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(118, 19)" end="(118, 21)">
                                      <OtherNode start="(118, 19)" end="(118, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(118, 19)" end="(118, 21)" leading="" trailing="" raw_val="as" val="as"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(118, 21)" end="(118, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(118, 23)" end="(118, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(118, 23)" end="(118, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(118, 23)" end="(118, 26)">
                                      <OtherNode start="(118, 23)" end="(118, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(118, 23)" end="(118, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(118, 26)" end="(118, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(119, 3)" end="(119, 25)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;i j : Nat&#10;as : Array α✝²&#10;bs : Vector α✝¹ as.size&#10;⊢ (zipWith f { toArray := as, size_toArray := ⋯ } bs).extract i j =&#10;    zipWith f ({ toArray := as, size_toArray := ⋯ }.extract i j) (bs.extract i j)" state_after="case mk.mk&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;i j : Nat&#10;as : Array α✝²&#10;bs : Array α✝¹&#10;h : bs.size = as.size&#10;⊢ (zipWith f { toArray := as, size_toArray := ⋯ } { toArray := bs, size_toArray := h }).extract i j =&#10;    zipWith f ({ toArray := as, size_toArray := ⋯ }.extract i j) ({ toArray := bs, size_toArray := h }.extract i j)" tactic="rcases bs with ⟨bs, h⟩">
                    <AtomNode start="(119, 3)" end="(119, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(119, 10)" end="(119, 12)">
                      <OtherNode start="(119, 10)" end="(119, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(119, 10)" end="(119, 12)" leading="" trailing=" " raw_val="bs" val="bs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(119, 13)" end="(119, 25)">
                      <AtomNode start="(119, 13)" end="(119, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(119, 18)" end="(119, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(119, 18)" end="(119, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(119, 18)" end="(119, 25)">
                            <OtherNode start="(119, 18)" end="(119, 25)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(119, 18)" end="(119, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(119, 19)" end="(119, 24)">
                                <OtherNode start="(119, 19)" end="(119, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(119, 19)" end="(119, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(119, 19)" end="(119, 21)">
                                      <OtherNode start="(119, 19)" end="(119, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(119, 19)" end="(119, 21)" leading="" trailing="" raw_val="bs" val="bs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(119, 21)" end="(119, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(119, 23)" end="(119, 24)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(119, 23)" end="(119, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(119, 23)" end="(119, 24)">
                                      <OtherNode start="(119, 23)" end="(119, 24)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(119, 23)" end="(119, 24)" leading="" trailing="" raw_val="h" val="h"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(119, 24)" end="(119, 25)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(120, 3)" end="(120, 31)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α✝² : Type u_1&#10;α✝¹ : Type u_2&#10;α✝ : Type u_3&#10;f : α✝² → α✝¹ → α✝&#10;i j : Nat&#10;as : Array α✝²&#10;bs : Array α✝¹&#10;h : bs.size = as.size&#10;⊢ (zipWith f { toArray := as, size_toArray := ⋯ } { toArray := bs, size_toArray := h }).extract i j =&#10;    zipWith f ({ toArray := as, size_toArray := ⋯ }.extract i j) ({ toArray := bs, size_toArray := h }.extract i j)" state_after="no goals" tactic="simp [Array.extract_zipWith]">
                    <AtomNode start="(120, 3)" end="(120, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(120, 8)" end="(120, 31)">
                      <AtomNode start="(120, 8)" end="(120, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(120, 9)" end="(120, 30)">
                        <OtherNode start="(120, 9)" end="(120, 30)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(120, 9)" end="(120, 30)" leading="" trailing="" raw_val="Array.extract_zipWith" val="Array.extract_zipWith" full_name="Array.extract_zipWith" mod_name="Init.Data.Array.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Zip.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(120, 30)" end="(120, 31)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(122, 1)" end="(129, 33)" name="zipWith_append" full_name="Vector.zipWith_append">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(122, 1)" end="(129, 33)" name="zipWith_append" full_name="Vector.zipWith_append" _is_private_decl="False">
        <AtomNode start="(122, 1)" end="(122, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(122, 9)" end="(122, 23)">
          <IdentNode start="(122, 9)" end="(122, 23)" leading="" trailing=" " raw_val="zipWith_append" val="zipWith_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(122, 24)" end="(124, 77)">
          <NullNode start="(122, 24)" end="(123, 78)">
            <OtherNode start="(122, 24)" end="(122, 39)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(122, 24)" end="(122, 25)" leading="" trailing="" val="{"/>
              <NullNode start="(122, 25)" end="(122, 26)">
                <IdentNode start="(122, 25)" end="(122, 26)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(122, 27)" end="(122, 38)">
                <AtomNode start="(122, 27)" end="(122, 28)" leading="" trailing=" " val=":"/>
                <OtherNode start="(122, 29)" end="(122, 38)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(122, 29)" end="(122, 30)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(122, 31)" end="(122, 32)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(122, 33)" end="(122, 38)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(122, 33)" end="(122, 34)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(122, 35)" end="(122, 36)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(122, 37)" end="(122, 38)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(122, 38)" end="(122, 39)" leading="" trailing="&#10;    " val="}"/>
            </OtherNode>
            <OtherNode start="(123, 5)" end="(123, 22)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(123, 5)" end="(123, 6)" leading="" trailing="" val="{"/>
              <NullNode start="(123, 6)" end="(123, 8)">
                <IdentNode start="(123, 6)" end="(123, 8)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(123, 9)" end="(123, 21)">
                <AtomNode start="(123, 9)" end="(123, 10)" leading="" trailing=" " val=":"/>
                <OtherNode start="(123, 11)" end="(123, 21)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(123, 11)" end="(123, 17)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(123, 18)" end="(123, 21)">
                    <IdentNode start="(123, 18)" end="(123, 19)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(123, 20)" end="(123, 21)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(123, 21)" end="(123, 22)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(123, 23)" end="(123, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(123, 23)" end="(123, 24)" leading="" trailing="" val="{"/>
              <NullNode start="(123, 24)" end="(123, 27)">
                <IdentNode start="(123, 24)" end="(123, 27)" leading="" trailing=" " raw_val="as'" val="as'"/>
              </NullNode>
              <NullNode start="(123, 28)" end="(123, 40)">
                <AtomNode start="(123, 28)" end="(123, 29)" leading="" trailing=" " val=":"/>
                <OtherNode start="(123, 30)" end="(123, 40)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(123, 30)" end="(123, 36)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(123, 37)" end="(123, 40)">
                    <IdentNode start="(123, 37)" end="(123, 38)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(123, 39)" end="(123, 40)" leading="" trailing="" raw_val="m" val="m"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(123, 40)" end="(123, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(123, 42)" end="(123, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(123, 42)" end="(123, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(123, 43)" end="(123, 45)">
                <IdentNode start="(123, 43)" end="(123, 45)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(123, 46)" end="(123, 58)">
                <AtomNode start="(123, 46)" end="(123, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(123, 48)" end="(123, 58)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(123, 48)" end="(123, 54)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(123, 55)" end="(123, 58)">
                    <IdentNode start="(123, 55)" end="(123, 56)" leading="" trailing=" " raw_val="β" val="β"/>
                    <IdentNode start="(123, 57)" end="(123, 58)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(123, 58)" end="(123, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(123, 60)" end="(123, 78)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(123, 60)" end="(123, 61)" leading="" trailing="" val="{"/>
              <NullNode start="(123, 61)" end="(123, 64)">
                <IdentNode start="(123, 61)" end="(123, 64)" leading="" trailing=" " raw_val="bs'" val="bs'"/>
              </NullNode>
              <NullNode start="(123, 65)" end="(123, 77)">
                <AtomNode start="(123, 65)" end="(123, 66)" leading="" trailing=" " val=":"/>
                <OtherNode start="(123, 67)" end="(123, 77)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(123, 67)" end="(123, 73)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(123, 74)" end="(123, 77)">
                    <IdentNode start="(123, 74)" end="(123, 75)" leading="" trailing=" " raw_val="β" val="β"/>
                    <IdentNode start="(123, 76)" end="(123, 77)" leading="" trailing="" raw_val="m" val="m"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(123, 77)" end="(123, 78)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(123, 79)" end="(124, 77)">
            <AtomNode start="(123, 79)" end="(123, 80)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(124, 5)" end="(124, 77)" kind="«term_=_»">
              <OtherNode start="(124, 5)" end="(124, 38)" kind="Lean.Parser.Term.app">
                <IdentNode start="(124, 5)" end="(124, 12)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="Vector.zipWith" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(124, 13)" end="(124, 38)">
                  <IdentNode start="(124, 13)" end="(124, 14)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(124, 15)" end="(124, 26)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(124, 15)" end="(124, 16)" leading="" trailing="" val="("/>
                    <OtherNode start="(124, 16)" end="(124, 25)" kind="«term_++_»">
                      <IdentNode start="(124, 16)" end="(124, 18)" leading="" trailing=" " raw_val="as" val="as"/>
                      <AtomNode start="(124, 19)" end="(124, 21)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(124, 22)" end="(124, 25)" leading="" trailing="" raw_val="as'" val="as'"/>
                    </OtherNode>
                    <AtomNode start="(124, 25)" end="(124, 26)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(124, 27)" end="(124, 38)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(124, 27)" end="(124, 28)" leading="" trailing="" val="("/>
                    <OtherNode start="(124, 28)" end="(124, 37)" kind="«term_++_»">
                      <IdentNode start="(124, 28)" end="(124, 30)" leading="" trailing=" " raw_val="bs" val="bs"/>
                      <AtomNode start="(124, 31)" end="(124, 33)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(124, 34)" end="(124, 37)" leading="" trailing="" raw_val="bs'" val="bs'"/>
                    </OtherNode>
                    <AtomNode start="(124, 37)" end="(124, 38)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(124, 39)" end="(124, 40)" leading="" trailing=" " val="="/>
              <OtherNode start="(124, 41)" end="(124, 77)" kind="«term_++_»">
                <OtherNode start="(124, 41)" end="(124, 56)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(124, 41)" end="(124, 48)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="Vector.zipWith" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(124, 49)" end="(124, 56)">
                    <IdentNode start="(124, 49)" end="(124, 50)" leading="" trailing=" " raw_val="f" val="f"/>
                    <IdentNode start="(124, 51)" end="(124, 53)" leading="" trailing=" " raw_val="as" val="as"/>
                    <IdentNode start="(124, 54)" end="(124, 56)" leading="" trailing=" " raw_val="bs" val="bs"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(124, 57)" end="(124, 59)" leading="" trailing=" " val="++"/>
                <OtherNode start="(124, 60)" end="(124, 77)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(124, 60)" end="(124, 67)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="Vector.zipWith" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(124, 68)" end="(124, 77)">
                    <IdentNode start="(124, 68)" end="(124, 69)" leading="" trailing=" " raw_val="f" val="f"/>
                    <IdentNode start="(124, 70)" end="(124, 73)" leading="" trailing=" " raw_val="as'" val="as'"/>
                    <IdentNode start="(124, 74)" end="(124, 77)" leading="" trailing=" " raw_val="bs'" val="bs'"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(124, 78)" end="(129, 33)">
          <AtomNode start="(124, 78)" end="(124, 80)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(124, 81)" end="(129, 33)">
            <AtomNode start="(124, 81)" end="(124, 83)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(125, 3)" end="(129, 33)">
              <TacticTacticseq1IndentedNode start="(125, 3)" end="(129, 33)">
                <NullNode start="(125, 3)" end="(129, 33)">
                  <OtherNode start="(125, 3)" end="(125, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;n m : Nat&#10;f : α → β → γ&#10;as : Vector α n&#10;as' : Vector α m&#10;bs : Vector β n&#10;bs' : Vector β m&#10;⊢ zipWith f (as ++ as') (bs ++ bs') = zipWith f as bs ++ zipWith f as' bs'" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;m : Nat&#10;f : α → β → γ&#10;as' : Vector α m&#10;bs' : Vector β m&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ zipWith f ({ toArray := as, size_toArray := ⋯ } ++ as') (bs ++ bs') =&#10;    zipWith f { toArray := as, size_toArray := ⋯ } bs ++ zipWith f as' bs'" tactic="rcases as with ⟨as, rfl⟩">
                    <AtomNode start="(125, 3)" end="(125, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(125, 10)" end="(125, 12)">
                      <OtherNode start="(125, 10)" end="(125, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(125, 10)" end="(125, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(125, 13)" end="(125, 27)">
                      <AtomNode start="(125, 13)" end="(125, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(125, 18)" end="(125, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(125, 18)" end="(125, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(125, 18)" end="(125, 27)">
                            <OtherNode start="(125, 18)" end="(125, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(125, 18)" end="(125, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(125, 19)" end="(125, 26)">
                                <OtherNode start="(125, 19)" end="(125, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(125, 19)" end="(125, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(125, 19)" end="(125, 21)">
                                      <OtherNode start="(125, 19)" end="(125, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(125, 19)" end="(125, 21)" leading="" trailing="" raw_val="as" val="as"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(125, 21)" end="(125, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(125, 23)" end="(125, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(125, 23)" end="(125, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(125, 23)" end="(125, 26)">
                                      <OtherNode start="(125, 23)" end="(125, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(125, 23)" end="(125, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(125, 26)" end="(125, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(126, 3)" end="(126, 25)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;m : Nat&#10;f : α → β → γ&#10;as' : Vector α m&#10;bs' : Vector β m&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ zipWith f ({ toArray := as, size_toArray := ⋯ } ++ as') (bs ++ bs') =&#10;    zipWith f { toArray := as, size_toArray := ⋯ } bs ++ zipWith f as' bs'" state_after="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;m : Nat&#10;f : α → β → γ&#10;as' : Vector α m&#10;bs' : Vector β m&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ zipWith f ({ toArray := as, size_toArray := ⋯ } ++ as') ({ toArray := bs, size_toArray := h } ++ bs') =&#10;    zipWith f { toArray := as, size_toArray := ⋯ } { toArray := bs, size_toArray := h } ++ zipWith f as' bs'" tactic="rcases bs with ⟨bs, h⟩">
                    <AtomNode start="(126, 3)" end="(126, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(126, 10)" end="(126, 12)">
                      <OtherNode start="(126, 10)" end="(126, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(126, 10)" end="(126, 12)" leading="" trailing=" " raw_val="bs" val="bs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(126, 13)" end="(126, 25)">
                      <AtomNode start="(126, 13)" end="(126, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(126, 18)" end="(126, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(126, 18)" end="(126, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(126, 18)" end="(126, 25)">
                            <OtherNode start="(126, 18)" end="(126, 25)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(126, 18)" end="(126, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(126, 19)" end="(126, 24)">
                                <OtherNode start="(126, 19)" end="(126, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(126, 19)" end="(126, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(126, 19)" end="(126, 21)">
                                      <OtherNode start="(126, 19)" end="(126, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(126, 19)" end="(126, 21)" leading="" trailing="" raw_val="bs" val="bs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(126, 21)" end="(126, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(126, 23)" end="(126, 24)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(126, 23)" end="(126, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(126, 23)" end="(126, 24)">
                                      <OtherNode start="(126, 23)" end="(126, 24)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(126, 23)" end="(126, 24)" leading="" trailing="" raw_val="h" val="h"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(126, 24)" end="(126, 25)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(127, 3)" end="(127, 29)" kind="Lean.Parser.Tactic.rcases" state_before="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;m : Nat&#10;f : α → β → γ&#10;as' : Vector α m&#10;bs' : Vector β m&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ zipWith f ({ toArray := as, size_toArray := ⋯ } ++ as') ({ toArray := bs, size_toArray := h } ++ bs') =&#10;    zipWith f { toArray := as, size_toArray := ⋯ } { toArray := bs, size_toArray := h } ++ zipWith f as' bs'" state_after="case mk.mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;as' : Array α&#10;bs' : Vector β as'.size&#10;⊢ zipWith f ({ toArray := as, size_toArray := ⋯ } ++ { toArray := as', size_toArray := ⋯ })&#10;      ({ toArray := bs, size_toArray := h } ++ bs') =&#10;    zipWith f { toArray := as, size_toArray := ⋯ } { toArray := bs, size_toArray := h } ++&#10;      zipWith f { toArray := as', size_toArray := ⋯ } bs'" tactic="rcases as' with ⟨as', rfl⟩">
                    <AtomNode start="(127, 3)" end="(127, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(127, 10)" end="(127, 13)">
                      <OtherNode start="(127, 10)" end="(127, 13)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(127, 10)" end="(127, 13)" leading="" trailing=" " raw_val="as'" val="as'"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(127, 14)" end="(127, 29)">
                      <AtomNode start="(127, 14)" end="(127, 18)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(127, 19)" end="(127, 29)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(127, 19)" end="(127, 29)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(127, 19)" end="(127, 29)">
                            <OtherNode start="(127, 19)" end="(127, 29)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(127, 19)" end="(127, 20)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(127, 20)" end="(127, 28)">
                                <OtherNode start="(127, 20)" end="(127, 23)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(127, 20)" end="(127, 23)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(127, 20)" end="(127, 23)">
                                      <OtherNode start="(127, 20)" end="(127, 23)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(127, 20)" end="(127, 23)" leading="" trailing="" raw_val="as'" val="as'"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(127, 23)" end="(127, 24)" leading="" trailing=" " val=","/>
                                <OtherNode start="(127, 25)" end="(127, 28)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(127, 25)" end="(127, 28)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(127, 25)" end="(127, 28)">
                                      <OtherNode start="(127, 25)" end="(127, 28)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(127, 25)" end="(127, 28)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(127, 28)" end="(127, 29)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(128, 3)" end="(128, 28)" kind="Lean.Parser.Tactic.rcases" state_before="case mk.mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;as' : Array α&#10;bs' : Vector β as'.size&#10;⊢ zipWith f ({ toArray := as, size_toArray := ⋯ } ++ { toArray := as', size_toArray := ⋯ })&#10;      ({ toArray := bs, size_toArray := h } ++ bs') =&#10;    zipWith f { toArray := as, size_toArray := ⋯ } { toArray := bs, size_toArray := h } ++&#10;      zipWith f { toArray := as', size_toArray := ⋯ } bs'" state_after="case mk.mk.mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;as' : Array α&#10;bs' : Array β&#10;h' : bs'.size = as'.size&#10;⊢ zipWith f ({ toArray := as, size_toArray := ⋯ } ++ { toArray := as', size_toArray := ⋯ })&#10;      ({ toArray := bs, size_toArray := h } ++ { toArray := bs', size_toArray := h' }) =&#10;    zipWith f { toArray := as, size_toArray := ⋯ } { toArray := bs, size_toArray := h } ++&#10;      zipWith f { toArray := as', size_toArray := ⋯ } { toArray := bs', size_toArray := h' }" tactic="rcases bs' with ⟨bs', h'⟩">
                    <AtomNode start="(128, 3)" end="(128, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(128, 10)" end="(128, 13)">
                      <OtherNode start="(128, 10)" end="(128, 13)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(128, 10)" end="(128, 13)" leading="" trailing=" " raw_val="bs'" val="bs'"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(128, 14)" end="(128, 28)">
                      <AtomNode start="(128, 14)" end="(128, 18)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(128, 19)" end="(128, 28)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(128, 19)" end="(128, 28)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(128, 19)" end="(128, 28)">
                            <OtherNode start="(128, 19)" end="(128, 28)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(128, 19)" end="(128, 20)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(128, 20)" end="(128, 27)">
                                <OtherNode start="(128, 20)" end="(128, 23)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(128, 20)" end="(128, 23)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(128, 20)" end="(128, 23)">
                                      <OtherNode start="(128, 20)" end="(128, 23)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(128, 20)" end="(128, 23)" leading="" trailing="" raw_val="bs'" val="bs'"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(128, 23)" end="(128, 24)" leading="" trailing=" " val=","/>
                                <OtherNode start="(128, 25)" end="(128, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(128, 25)" end="(128, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(128, 25)" end="(128, 27)">
                                      <OtherNode start="(128, 25)" end="(128, 27)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(128, 25)" end="(128, 27)" leading="" trailing="" raw_val="h'" val="h'"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(128, 27)" end="(128, 28)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(129, 3)" end="(129, 33)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk.mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;as' : Array α&#10;bs' : Array β&#10;h' : bs'.size = as'.size&#10;⊢ zipWith f ({ toArray := as, size_toArray := ⋯ } ++ { toArray := as', size_toArray := ⋯ })&#10;      ({ toArray := bs, size_toArray := h } ++ { toArray := bs', size_toArray := h' }) =&#10;    zipWith f { toArray := as, size_toArray := ⋯ } { toArray := bs, size_toArray := h } ++&#10;      zipWith f { toArray := as', size_toArray := ⋯ } { toArray := bs', size_toArray := h' }" state_after="no goals" tactic="simp [Array.zipWith_append, *]">
                    <AtomNode start="(129, 3)" end="(129, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(129, 8)" end="(129, 33)">
                      <AtomNode start="(129, 8)" end="(129, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(129, 9)" end="(129, 32)">
                        <OtherNode start="(129, 9)" end="(129, 29)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(129, 9)" end="(129, 29)" leading="" trailing="" raw_val="Array.zipWith_append" val="Array.zipWith_append" full_name="Array.zipWith_append" mod_name="Init.Data.Array.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Zip.lean"/>
                        </OtherNode>
                        <AtomNode start="(129, 29)" end="(129, 30)" leading="" trailing=" " val=","/>
                        <OtherNode start="(129, 31)" end="(129, 32)" kind="Lean.Parser.Tactic.simpStar">
                          <AtomNode start="(129, 31)" end="(129, 32)" leading="" trailing="" val="*"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(129, 32)" end="(129, 33)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(131, 1)" end="(146, 65)" name="zipWith_eq_append_iff" full_name="Vector.zipWith_eq_append_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(131, 1)" end="(146, 65)" name="zipWith_eq_append_iff" full_name="Vector.zipWith_eq_append_iff" _is_private_decl="False">
        <AtomNode start="(131, 1)" end="(131, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(131, 9)" end="(131, 30)">
          <IdentNode start="(131, 9)" end="(131, 30)" leading="" trailing=" " raw_val="zipWith_eq_append_iff" val="zipWith_eq_append_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(131, 31)" end="(133, 109)">
          <NullNode start="(131, 31)" end="(131, 94)">
            <OtherNode start="(131, 31)" end="(131, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(131, 31)" end="(131, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(131, 32)" end="(131, 33)">
                <IdentNode start="(131, 32)" end="(131, 33)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(131, 34)" end="(131, 45)">
                <AtomNode start="(131, 34)" end="(131, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(131, 36)" end="(131, 45)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(131, 36)" end="(131, 37)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(131, 38)" end="(131, 39)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(131, 40)" end="(131, 45)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(131, 40)" end="(131, 41)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(131, 42)" end="(131, 43)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(131, 44)" end="(131, 45)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(131, 45)" end="(131, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(131, 47)" end="(131, 70)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(131, 47)" end="(131, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(131, 48)" end="(131, 50)">
                <IdentNode start="(131, 48)" end="(131, 50)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(131, 51)" end="(131, 69)">
                <AtomNode start="(131, 51)" end="(131, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(131, 53)" end="(131, 69)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(131, 53)" end="(131, 59)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(131, 60)" end="(131, 69)">
                    <IdentNode start="(131, 60)" end="(131, 61)" leading="" trailing=" " raw_val="α" val="α"/>
                    <OtherNode start="(131, 62)" end="(131, 69)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(131, 62)" end="(131, 63)" leading="" trailing="" val="("/>
                      <OtherNode start="(131, 63)" end="(131, 68)" kind="«term_+_»">
                        <IdentNode start="(131, 63)" end="(131, 64)" leading="" trailing=" " raw_val="n" val="n"/>
                        <AtomNode start="(131, 65)" end="(131, 66)" leading="" trailing=" " val="+"/>
                        <IdentNode start="(131, 67)" end="(131, 68)" leading="" trailing="" raw_val="m" val="m"/>
                      </OtherNode>
                      <AtomNode start="(131, 68)" end="(131, 69)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(131, 69)" end="(131, 70)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(131, 71)" end="(131, 94)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(131, 71)" end="(131, 72)" leading="" trailing="" val="{"/>
              <NullNode start="(131, 72)" end="(131, 74)">
                <IdentNode start="(131, 72)" end="(131, 74)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(131, 75)" end="(131, 93)">
                <AtomNode start="(131, 75)" end="(131, 76)" leading="" trailing=" " val=":"/>
                <OtherNode start="(131, 77)" end="(131, 93)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(131, 77)" end="(131, 83)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(131, 84)" end="(131, 93)">
                    <IdentNode start="(131, 84)" end="(131, 85)" leading="" trailing=" " raw_val="β" val="β"/>
                    <OtherNode start="(131, 86)" end="(131, 93)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(131, 86)" end="(131, 87)" leading="" trailing="" val="("/>
                      <OtherNode start="(131, 87)" end="(131, 92)" kind="«term_+_»">
                        <IdentNode start="(131, 87)" end="(131, 88)" leading="" trailing=" " raw_val="n" val="n"/>
                        <AtomNode start="(131, 89)" end="(131, 90)" leading="" trailing=" " val="+"/>
                        <IdentNode start="(131, 91)" end="(131, 92)" leading="" trailing="" raw_val="m" val="m"/>
                      </OtherNode>
                      <AtomNode start="(131, 92)" end="(131, 93)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(131, 93)" end="(131, 94)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(131, 95)" end="(133, 109)">
            <AtomNode start="(131, 95)" end="(131, 96)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(132, 5)" end="(133, 109)" kind="«term_↔_»">
              <OtherNode start="(132, 5)" end="(132, 31)" kind="«term_=_»">
                <OtherNode start="(132, 5)" end="(132, 20)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(132, 5)" end="(132, 12)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="Vector.zipWith" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(132, 13)" end="(132, 20)">
                    <IdentNode start="(132, 13)" end="(132, 14)" leading="" trailing=" " raw_val="f" val="f"/>
                    <IdentNode start="(132, 15)" end="(132, 17)" leading="" trailing=" " raw_val="as" val="as"/>
                    <IdentNode start="(132, 18)" end="(132, 20)" leading="" trailing=" " raw_val="bs" val="bs"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(132, 21)" end="(132, 22)" leading="" trailing=" " val="="/>
                <OtherNode start="(132, 23)" end="(132, 31)" kind="«term_++_»">
                  <IdentNode start="(132, 23)" end="(132, 25)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <AtomNode start="(132, 26)" end="(132, 28)" leading="" trailing=" " val="++"/>
                  <IdentNode start="(132, 29)" end="(132, 31)" leading="" trailing=" " raw_val="ys" val="ys"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(132, 32)" end="(132, 33)" leading="" trailing="&#10;      " val="↔"/>
              <OtherNode start="(133, 7)" end="(133, 109)" kind="«term∃_,_»">
                <AtomNode start="(133, 7)" end="(133, 8)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(133, 9)" end="(133, 24)" kind="Lean.explicitBinders">
                  <OtherNode start="(133, 9)" end="(133, 24)" kind="Lean.unbracketedExplicitBinders">
                    <NullNode start="(133, 9)" end="(133, 24)">
                      <LeanBinderidentNode start="(133, 9)" end="(133, 12)">
                        <IdentNode start="(133, 9)" end="(133, 12)" leading="" trailing=" " raw_val="as₁" val="as₁"/>
                      </LeanBinderidentNode>
                      <LeanBinderidentNode start="(133, 13)" end="(133, 16)">
                        <IdentNode start="(133, 13)" end="(133, 16)" leading="" trailing=" " raw_val="as₂" val="as₂"/>
                      </LeanBinderidentNode>
                      <LeanBinderidentNode start="(133, 17)" end="(133, 20)">
                        <IdentNode start="(133, 17)" end="(133, 20)" leading="" trailing=" " raw_val="bs₁" val="bs₁"/>
                      </LeanBinderidentNode>
                      <LeanBinderidentNode start="(133, 21)" end="(133, 24)">
                        <IdentNode start="(133, 21)" end="(133, 24)" leading="" trailing="" raw_val="bs₂" val="bs₂"/>
                      </LeanBinderidentNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(133, 24)" end="(133, 25)" leading="" trailing=" " val=","/>
                <OtherNode start="(133, 26)" end="(133, 109)" kind="«term_∧_»">
                  <OtherNode start="(133, 26)" end="(133, 41)" kind="«term_=_»">
                    <IdentNode start="(133, 26)" end="(133, 28)" leading="" trailing=" " raw_val="as" val="as"/>
                    <AtomNode start="(133, 29)" end="(133, 30)" leading="" trailing=" " val="="/>
                    <OtherNode start="(133, 31)" end="(133, 41)" kind="«term_++_»">
                      <IdentNode start="(133, 31)" end="(133, 34)" leading="" trailing=" " raw_val="as₁" val="as₁"/>
                      <AtomNode start="(133, 35)" end="(133, 37)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(133, 38)" end="(133, 41)" leading="" trailing=" " raw_val="as₂" val="as₂"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(133, 42)" end="(133, 43)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(133, 44)" end="(133, 109)" kind="«term_∧_»">
                    <OtherNode start="(133, 44)" end="(133, 59)" kind="«term_=_»">
                      <IdentNode start="(133, 44)" end="(133, 46)" leading="" trailing=" " raw_val="bs" val="bs"/>
                      <AtomNode start="(133, 47)" end="(133, 48)" leading="" trailing=" " val="="/>
                      <OtherNode start="(133, 49)" end="(133, 59)" kind="«term_++_»">
                        <IdentNode start="(133, 49)" end="(133, 52)" leading="" trailing=" " raw_val="bs₁" val="bs₁"/>
                        <AtomNode start="(133, 53)" end="(133, 55)" leading="" trailing=" " val="++"/>
                        <IdentNode start="(133, 56)" end="(133, 59)" leading="" trailing=" " raw_val="bs₂" val="bs₂"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(133, 60)" end="(133, 61)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(133, 62)" end="(133, 109)" kind="«term_∧_»">
                      <OtherNode start="(133, 62)" end="(133, 84)" kind="«term_=_»">
                        <IdentNode start="(133, 62)" end="(133, 64)" leading="" trailing=" " raw_val="xs" val="xs"/>
                        <AtomNode start="(133, 65)" end="(133, 66)" leading="" trailing=" " val="="/>
                        <OtherNode start="(133, 67)" end="(133, 84)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(133, 67)" end="(133, 74)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="Vector.zipWith" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                          <NullNode start="(133, 75)" end="(133, 84)">
                            <IdentNode start="(133, 75)" end="(133, 76)" leading="" trailing=" " raw_val="f" val="f"/>
                            <IdentNode start="(133, 77)" end="(133, 80)" leading="" trailing=" " raw_val="as₁" val="as₁"/>
                            <IdentNode start="(133, 81)" end="(133, 84)" leading="" trailing=" " raw_val="bs₁" val="bs₁"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(133, 85)" end="(133, 86)" leading="" trailing=" " val="∧"/>
                      <OtherNode start="(133, 87)" end="(133, 109)" kind="«term_=_»">
                        <IdentNode start="(133, 87)" end="(133, 89)" leading="" trailing=" " raw_val="ys" val="ys"/>
                        <AtomNode start="(133, 90)" end="(133, 91)" leading="" trailing=" " val="="/>
                        <OtherNode start="(133, 92)" end="(133, 109)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(133, 92)" end="(133, 99)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="Vector.zipWith" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                          <NullNode start="(133, 100)" end="(133, 109)">
                            <IdentNode start="(133, 100)" end="(133, 101)" leading="" trailing=" " raw_val="f" val="f"/>
                            <IdentNode start="(133, 102)" end="(133, 105)" leading="" trailing=" " raw_val="as₂" val="as₂"/>
                            <IdentNode start="(133, 106)" end="(133, 109)" leading="" trailing=" " raw_val="bs₂" val="bs₂"/>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(133, 110)" end="(146, 65)">
          <AtomNode start="(133, 110)" end="(133, 112)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(133, 113)" end="(146, 65)">
            <AtomNode start="(133, 113)" end="(133, 115)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(134, 3)" end="(146, 65)">
              <TacticTacticseq1IndentedNode start="(134, 3)" end="(146, 65)">
                <NullNode start="(134, 3)" end="(146, 65)">
                  <OtherNode start="(134, 3)" end="(134, 26)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;n m : Nat&#10;xs : Vector γ n&#10;ys : Vector γ m&#10;f : α → β → γ&#10;as : Vector α (n + m)&#10;bs : Vector β (n + m)&#10;⊢ zipWith f as bs = xs ++ ys ↔&#10;    ∃ as₁ as₂ bs₁ bs₂, as = as₁ ++ as₂ ∧ bs = bs₁ ++ bs₂ ∧ xs = zipWith f as₁ bs₁ ∧ ys = zipWith f as₂ bs₂" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;n m : Nat&#10;xs : Vector γ n&#10;ys : Vector γ m&#10;f : α → β → γ&#10;bs : Vector β (n + m)&#10;as : Array α&#10;h₁ : as.size = n + m&#10;⊢ zipWith f { toArray := as, size_toArray := h₁ } bs = xs ++ ys ↔&#10;    ∃ as₁ as₂ bs₁ bs₂,&#10;      { toArray := as, size_toArray := h₁ } = as₁ ++ as₂ ∧&#10;        bs = bs₁ ++ bs₂ ∧ xs = zipWith f as₁ bs₁ ∧ ys = zipWith f as₂ bs₂" tactic="rcases as with ⟨as, h₁⟩">
                    <AtomNode start="(134, 3)" end="(134, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(134, 10)" end="(134, 12)">
                      <OtherNode start="(134, 10)" end="(134, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(134, 10)" end="(134, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(134, 13)" end="(134, 26)">
                      <AtomNode start="(134, 13)" end="(134, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(134, 18)" end="(134, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(134, 18)" end="(134, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(134, 18)" end="(134, 26)">
                            <OtherNode start="(134, 18)" end="(134, 26)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(134, 18)" end="(134, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(134, 19)" end="(134, 25)">
                                <OtherNode start="(134, 19)" end="(134, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(134, 19)" end="(134, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(134, 19)" end="(134, 21)">
                                      <OtherNode start="(134, 19)" end="(134, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(134, 19)" end="(134, 21)" leading="" trailing="" raw_val="as" val="as"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(134, 21)" end="(134, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(134, 23)" end="(134, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(134, 23)" end="(134, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(134, 23)" end="(134, 25)">
                                      <OtherNode start="(134, 23)" end="(134, 25)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(134, 23)" end="(134, 25)" leading="" trailing="" raw_val="h₁" val="h₁"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(134, 25)" end="(134, 26)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(135, 3)" end="(135, 26)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;n m : Nat&#10;xs : Vector γ n&#10;ys : Vector γ m&#10;f : α → β → γ&#10;bs : Vector β (n + m)&#10;as : Array α&#10;h₁ : as.size = n + m&#10;⊢ zipWith f { toArray := as, size_toArray := h₁ } bs = xs ++ ys ↔&#10;    ∃ as₁ as₂ bs₁ bs₂,&#10;      { toArray := as, size_toArray := h₁ } = as₁ ++ as₂ ∧&#10;        bs = bs₁ ++ bs₂ ∧ xs = zipWith f as₁ bs₁ ∧ ys = zipWith f as₂ bs₂" state_after="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;n m : Nat&#10;xs : Vector γ n&#10;ys : Vector γ m&#10;f : α → β → γ&#10;as : Array α&#10;h₁ : as.size = n + m&#10;bs : Array β&#10;h₂ : bs.size = n + m&#10;⊢ zipWith f { toArray := as, size_toArray := h₁ } { toArray := bs, size_toArray := h₂ } = xs ++ ys ↔&#10;    ∃ as₁ as₂ bs₁ bs₂,&#10;      { toArray := as, size_toArray := h₁ } = as₁ ++ as₂ ∧&#10;        { toArray := bs, size_toArray := h₂ } = bs₁ ++ bs₂ ∧ xs = zipWith f as₁ bs₁ ∧ ys = zipWith f as₂ bs₂" tactic="rcases bs with ⟨bs, h₂⟩">
                    <AtomNode start="(135, 3)" end="(135, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(135, 10)" end="(135, 12)">
                      <OtherNode start="(135, 10)" end="(135, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(135, 10)" end="(135, 12)" leading="" trailing=" " raw_val="bs" val="bs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(135, 13)" end="(135, 26)">
                      <AtomNode start="(135, 13)" end="(135, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(135, 18)" end="(135, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(135, 18)" end="(135, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(135, 18)" end="(135, 26)">
                            <OtherNode start="(135, 18)" end="(135, 26)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(135, 18)" end="(135, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(135, 19)" end="(135, 25)">
                                <OtherNode start="(135, 19)" end="(135, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(135, 19)" end="(135, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(135, 19)" end="(135, 21)">
                                      <OtherNode start="(135, 19)" end="(135, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(135, 19)" end="(135, 21)" leading="" trailing="" raw_val="bs" val="bs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(135, 21)" end="(135, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(135, 23)" end="(135, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(135, 23)" end="(135, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(135, 23)" end="(135, 25)">
                                      <OtherNode start="(135, 23)" end="(135, 25)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(135, 23)" end="(135, 25)" leading="" trailing="" raw_val="h₂" val="h₂"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(135, 25)" end="(135, 26)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(136, 3)" end="(136, 27)" kind="Lean.Parser.Tactic.rcases" state_before="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;n m : Nat&#10;xs : Vector γ n&#10;ys : Vector γ m&#10;f : α → β → γ&#10;as : Array α&#10;h₁ : as.size = n + m&#10;bs : Array β&#10;h₂ : bs.size = n + m&#10;⊢ zipWith f { toArray := as, size_toArray := h₁ } { toArray := bs, size_toArray := h₂ } = xs ++ ys ↔&#10;    ∃ as₁ as₂ bs₁ bs₂,&#10;      { toArray := as, size_toArray := h₁ } = as₁ ++ as₂ ∧&#10;        { toArray := bs, size_toArray := h₂ } = bs₁ ++ bs₂ ∧ xs = zipWith f as₁ bs₁ ∧ ys = zipWith f as₂ bs₂" state_after="case mk.mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;m : Nat&#10;ys : Vector γ m&#10;f : α → β → γ&#10;as : Array α&#10;bs : Array β&#10;xs : Array γ&#10;h₁ : as.size = xs.size + m&#10;h₂ : bs.size = xs.size + m&#10;⊢ zipWith f { toArray := as, size_toArray := h₁ } { toArray := bs, size_toArray := h₂ } =&#10;      { toArray := xs, size_toArray := ⋯ } ++ ys ↔&#10;    ∃ as₁ as₂ bs₁ bs₂,&#10;      { toArray := as, size_toArray := h₁ } = as₁ ++ as₂ ∧&#10;        { toArray := bs, size_toArray := h₂ } = bs₁ ++ bs₂ ∧&#10;          { toArray := xs, size_toArray := ⋯ } = zipWith f as₁ bs₁ ∧ ys = zipWith f as₂ bs₂" tactic="rcases xs with ⟨xs, rfl⟩">
                    <AtomNode start="(136, 3)" end="(136, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(136, 10)" end="(136, 12)">
                      <OtherNode start="(136, 10)" end="(136, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(136, 10)" end="(136, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(136, 13)" end="(136, 27)">
                      <AtomNode start="(136, 13)" end="(136, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(136, 18)" end="(136, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(136, 18)" end="(136, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(136, 18)" end="(136, 27)">
                            <OtherNode start="(136, 18)" end="(136, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(136, 18)" end="(136, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(136, 19)" end="(136, 26)">
                                <OtherNode start="(136, 19)" end="(136, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(136, 19)" end="(136, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(136, 19)" end="(136, 21)">
                                      <OtherNode start="(136, 19)" end="(136, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(136, 19)" end="(136, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(136, 21)" end="(136, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(136, 23)" end="(136, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(136, 23)" end="(136, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(136, 23)" end="(136, 26)">
                                      <OtherNode start="(136, 23)" end="(136, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(136, 23)" end="(136, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(136, 26)" end="(136, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(137, 3)" end="(137, 27)" kind="Lean.Parser.Tactic.rcases" state_before="case mk.mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;m : Nat&#10;ys : Vector γ m&#10;f : α → β → γ&#10;as : Array α&#10;bs : Array β&#10;xs : Array γ&#10;h₁ : as.size = xs.size + m&#10;h₂ : bs.size = xs.size + m&#10;⊢ zipWith f { toArray := as, size_toArray := h₁ } { toArray := bs, size_toArray := h₂ } =&#10;      { toArray := xs, size_toArray := ⋯ } ++ ys ↔&#10;    ∃ as₁ as₂ bs₁ bs₂,&#10;      { toArray := as, size_toArray := h₁ } = as₁ ++ as₂ ∧&#10;        { toArray := bs, size_toArray := h₂ } = bs₁ ++ bs₂ ∧&#10;          { toArray := xs, size_toArray := ⋯ } = zipWith f as₁ bs₁ ∧ ys = zipWith f as₂ bs₂" state_after="case mk.mk.mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as : Array α&#10;bs : Array β&#10;xs ys : Array γ&#10;h₁ : as.size = xs.size + ys.size&#10;h₂ : bs.size = xs.size + ys.size&#10;⊢ zipWith f { toArray := as, size_toArray := h₁ } { toArray := bs, size_toArray := h₂ } =&#10;      { toArray := xs, size_toArray := ⋯ } ++ { toArray := ys, size_toArray := ⋯ } ↔&#10;    ∃ as₁ as₂ bs₁ bs₂,&#10;      { toArray := as, size_toArray := h₁ } = as₁ ++ as₂ ∧&#10;        { toArray := bs, size_toArray := h₂ } = bs₁ ++ bs₂ ∧&#10;          { toArray := xs, size_toArray := ⋯ } = zipWith f as₁ bs₁ ∧&#10;            { toArray := ys, size_toArray := ⋯ } = zipWith f as₂ bs₂" tactic="rcases ys with ⟨ys, rfl⟩">
                    <AtomNode start="(137, 3)" end="(137, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(137, 10)" end="(137, 12)">
                      <OtherNode start="(137, 10)" end="(137, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(137, 10)" end="(137, 12)" leading="" trailing=" " raw_val="ys" val="ys"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(137, 13)" end="(137, 27)">
                      <AtomNode start="(137, 13)" end="(137, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(137, 18)" end="(137, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(137, 18)" end="(137, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(137, 18)" end="(137, 27)">
                            <OtherNode start="(137, 18)" end="(137, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(137, 18)" end="(137, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(137, 19)" end="(137, 26)">
                                <OtherNode start="(137, 19)" end="(137, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(137, 19)" end="(137, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(137, 19)" end="(137, 21)">
                                      <OtherNode start="(137, 19)" end="(137, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(137, 19)" end="(137, 21)" leading="" trailing="" raw_val="ys" val="ys"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(137, 21)" end="(137, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(137, 23)" end="(137, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(137, 23)" end="(137, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(137, 23)" end="(137, 26)">
                                      <OtherNode start="(137, 23)" end="(137, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(137, 23)" end="(137, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(137, 26)" end="(137, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(138, 3)" end="(139, 44)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk.mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as : Array α&#10;bs : Array β&#10;xs ys : Array γ&#10;h₁ : as.size = xs.size + ys.size&#10;h₂ : bs.size = xs.size + ys.size&#10;⊢ zipWith f { toArray := as, size_toArray := h₁ } { toArray := bs, size_toArray := h₂ } =&#10;      { toArray := xs, size_toArray := ⋯ } ++ { toArray := ys, size_toArray := ⋯ } ↔&#10;    ∃ as₁ as₂ bs₁ bs₂,&#10;      { toArray := as, size_toArray := h₁ } = as₁ ++ as₂ ∧&#10;        { toArray := bs, size_toArray := h₂ } = bs₁ ++ bs₂ ∧&#10;          { toArray := xs, size_toArray := ⋯ } = zipWith f as₁ bs₁ ∧&#10;            { toArray := ys, size_toArray := ⋯ } = zipWith f as₂ bs₂" state_after="case mk.mk.mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as : Array α&#10;bs : Array β&#10;xs ys : Array γ&#10;h₁ : as.size = xs.size + ys.size&#10;h₂ : bs.size = xs.size + ys.size&#10;⊢ (∃ as₁ as₂ bs₁ bs₂,&#10;      as₁.size = bs₁.size ∧&#10;        as = as₁ ++ as₂ ∧ bs = bs₁ ++ bs₂ ∧ xs = Array.zipWith f as₁ bs₁ ∧ ys = Array.zipWith f as₂ bs₂) ↔&#10;    ∃ as₁ as₂ bs₁ bs₂,&#10;      as = as₁.toArray ++ as₂.toArray ∧&#10;        bs = bs₁.toArray ++ bs₂.toArray ∧&#10;          xs = Array.zipWith f as₁.toArray bs₁.toArray ∧ ys = Array.zipWith f as₂.toArray bs₂.toArray" tactic="simp only [mk_zipWith_mk, mk_append_mk, eq_mk, Array.zipWith_eq_append_iff,&#10;  mk_eq, toArray_append, toArray_zipWith]">
                    <AtomNode start="(138, 3)" end="(138, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(138, 8)" end="(138, 12)">
                      <AtomNode start="(138, 8)" end="(138, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(138, 13)" end="(139, 44)">
                      <AtomNode start="(138, 13)" end="(138, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(138, 14)" end="(139, 43)">
                        <OtherNode start="(138, 14)" end="(138, 27)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(138, 14)" end="(138, 27)" leading="" trailing="" raw_val="mk_zipWith_mk" val="mk_zipWith_mk" full_name="Vector.mk_zipWith_mk" mod_name="Init.Data.Vector.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(138, 27)" end="(138, 28)" leading="" trailing=" " val=","/>
                        <OtherNode start="(138, 29)" end="(138, 41)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(138, 29)" end="(138, 41)" leading="" trailing="" raw_val="mk_append_mk" val="mk_append_mk" full_name="Vector.mk_append_mk" mod_name="Init.Data.Vector.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(138, 41)" end="(138, 42)" leading="" trailing=" " val=","/>
                        <OtherNode start="(138, 43)" end="(138, 48)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(138, 43)" end="(138, 48)" leading="" trailing="" raw_val="eq_mk" val="eq_mk" full_name="Vector.eq_mk" mod_name="Init.Data.Vector.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(138, 48)" end="(138, 49)" leading="" trailing=" " val=","/>
                        <OtherNode start="(138, 50)" end="(138, 77)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(138, 50)" end="(138, 77)" leading="" trailing="" raw_val="Array.zipWith_eq_append_iff" val="Array.zipWith_eq_append_iff" full_name="Array.zipWith_eq_append_iff" mod_name="Init.Data.Array.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Zip.lean"/>
                        </OtherNode>
                        <AtomNode start="(138, 77)" end="(138, 78)" leading="" trailing="&#10;    " val=","/>
                        <OtherNode start="(139, 5)" end="(139, 10)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(139, 5)" end="(139, 10)" leading="" trailing="" raw_val="mk_eq" val="mk_eq" full_name="Vector.mk_eq" mod_name="Init.Data.Vector.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(139, 10)" end="(139, 11)" leading="" trailing=" " val=","/>
                        <OtherNode start="(139, 12)" end="(139, 26)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(139, 12)" end="(139, 26)" leading="" trailing="" raw_val="toArray_append" val="toArray_append" full_name="Vector.toArray_append" mod_name="Init.Data.Vector.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(139, 26)" end="(139, 27)" leading="" trailing=" " val=","/>
                        <OtherNode start="(139, 28)" end="(139, 43)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(139, 28)" end="(139, 43)" leading="" trailing="" raw_val="toArray_zipWith" val="toArray_zipWith" full_name="Vector.toArray_zipWith" mod_name="Init.Data.Vector.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(139, 43)" end="(139, 44)" leading="" trailing="&#10;  " val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(140, 3)" end="(140, 14)" kind="Lean.Parser.Tactic.constructor" state_before="case mk.mk.mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as : Array α&#10;bs : Array β&#10;xs ys : Array γ&#10;h₁ : as.size = xs.size + ys.size&#10;h₂ : bs.size = xs.size + ys.size&#10;⊢ (∃ as₁ as₂ bs₁ bs₂,&#10;      as₁.size = bs₁.size ∧&#10;        as = as₁ ++ as₂ ∧ bs = bs₁ ++ bs₂ ∧ xs = Array.zipWith f as₁ bs₁ ∧ ys = Array.zipWith f as₂ bs₂) ↔&#10;    ∃ as₁ as₂ bs₁ bs₂,&#10;      as = as₁.toArray ++ as₂.toArray ∧&#10;        bs = bs₁.toArray ++ bs₂.toArray ∧&#10;          xs = Array.zipWith f as₁.toArray bs₁.toArray ∧ ys = Array.zipWith f as₂.toArray bs₂.toArray" state_after="case mk.mk.mk.mk.mp&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as : Array α&#10;bs : Array β&#10;xs ys : Array γ&#10;h₁ : as.size = xs.size + ys.size&#10;h₂ : bs.size = xs.size + ys.size&#10;⊢ (∃ as₁ as₂ bs₁ bs₂,&#10;      as₁.size = bs₁.size ∧&#10;        as = as₁ ++ as₂ ∧ bs = bs₁ ++ bs₂ ∧ xs = Array.zipWith f as₁ bs₁ ∧ ys = Array.zipWith f as₂ bs₂) →&#10;    ∃ as₁ as₂ bs₁ bs₂,&#10;      as = as₁.toArray ++ as₂.toArray ∧&#10;        bs = bs₁.toArray ++ bs₂.toArray ∧&#10;          xs = Array.zipWith f as₁.toArray bs₁.toArray ∧ ys = Array.zipWith f as₂.toArray bs₂.toArray&#10;&#10;case mk.mk.mk.mk.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as : Array α&#10;bs : Array β&#10;xs ys : Array γ&#10;h₁ : as.size = xs.size + ys.size&#10;h₂ : bs.size = xs.size + ys.size&#10;⊢ (∃ as₁ as₂ bs₁ bs₂,&#10;      as = as₁.toArray ++ as₂.toArray ∧&#10;        bs = bs₁.toArray ++ bs₂.toArray ∧&#10;          xs = Array.zipWith f as₁.toArray bs₁.toArray ∧ ys = Array.zipWith f as₂.toArray bs₂.toArray) →&#10;    ∃ as₁ as₂ bs₁ bs₂,&#10;      as₁.size = bs₁.size ∧&#10;        as = as₁ ++ as₂ ∧ bs = bs₁ ++ bs₂ ∧ xs = Array.zipWith f as₁ bs₁ ∧ ys = Array.zipWith f as₂ bs₂" tactic="constructor">
                    <AtomNode start="(140, 3)" end="(140, 14)" leading="" trailing="&#10;  " val="constructor"/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(141, 3)" end="(143, 120)" kind="Lean.cdot" state_before="case mk.mk.mk.mk.mp&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as : Array α&#10;bs : Array β&#10;xs ys : Array γ&#10;h₁ : as.size = xs.size + ys.size&#10;h₂ : bs.size = xs.size + ys.size&#10;⊢ (∃ as₁ as₂ bs₁ bs₂,&#10;      as₁.size = bs₁.size ∧&#10;        as = as₁ ++ as₂ ∧ bs = bs₁ ++ bs₂ ∧ xs = Array.zipWith f as₁ bs₁ ∧ ys = Array.zipWith f as₂ bs₂) →&#10;    ∃ as₁ as₂ bs₁ bs₂,&#10;      as = as₁.toArray ++ as₂.toArray ∧&#10;        bs = bs₁.toArray ++ bs₂.toArray ∧&#10;          xs = Array.zipWith f as₁.toArray bs₁.toArray ∧ ys = Array.zipWith f as₂.toArray bs₂.toArray&#10;&#10;case mk.mk.mk.mk.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as : Array α&#10;bs : Array β&#10;xs ys : Array γ&#10;h₁ : as.size = xs.size + ys.size&#10;h₂ : bs.size = xs.size + ys.size&#10;⊢ (∃ as₁ as₂ bs₁ bs₂,&#10;      as = as₁.toArray ++ as₂.toArray ∧&#10;        bs = bs₁.toArray ++ bs₂.toArray ∧&#10;          xs = Array.zipWith f as₁.toArray bs₁.toArray ∧ ys = Array.zipWith f as₂.toArray bs₂.toArray) →&#10;    ∃ as₁ as₂ bs₁ bs₂,&#10;      as₁.size = bs₁.size ∧&#10;        as = as₁ ++ as₂ ∧ bs = bs₁ ++ bs₂ ∧ xs = Array.zipWith f as₁ bs₁ ∧ ys = Array.zipWith f as₂ bs₂" state_after="case mk.mk.mk.mk.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as : Array α&#10;bs : Array β&#10;xs ys : Array γ&#10;h₁ : as.size = xs.size + ys.size&#10;h₂ : bs.size = xs.size + ys.size&#10;⊢ (∃ as₁ as₂ bs₁ bs₂,&#10;      as = as₁.toArray ++ as₂.toArray ∧&#10;        bs = bs₁.toArray ++ bs₂.toArray ∧&#10;          xs = Array.zipWith f as₁.toArray bs₁.toArray ∧ ys = Array.zipWith f as₂.toArray bs₂.toArray) →&#10;    ∃ as₁ as₂ bs₁ bs₂,&#10;      as₁.size = bs₁.size ∧&#10;        as = as₁ ++ as₂ ∧ bs = bs₁ ++ bs₂ ∧ xs = Array.zipWith f as₁ bs₁ ∧ ys = Array.zipWith f as₂ bs₂" tactic="· rintro ⟨as₁, as₂, bs₁, bs₂, h, rfl, rfl, rfl, rfl⟩&#10;  simp only [Array.size_append, Array.size_zipWith] at h₁ h₂&#10;  exact ⟨mk as₁ (by simp; omega), mk as₂ (by simp; omega), mk bs₁ (by simp; omega), mk bs₂ (by simp; omega), by simp⟩">
                    <OtherNode start="(141, 3)" end="(141, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(141, 3)" end="(141, 4)" kind="patternIgnore">
                        <OtherNode start="(141, 3)" end="(141, 4)" kind="token.«· »">
                          <AtomNode start="(141, 3)" end="(141, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(141, 5)" end="(143, 120)">
                      <TacticTacticseq1IndentedNode start="(141, 5)" end="(143, 120)">
                        <NullNode start="(141, 5)" end="(143, 120)">
                          <OtherNode start="(141, 5)" end="(141, 55)" kind="Lean.Parser.Tactic.rintro" state_before="case mk.mk.mk.mk.mp&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as : Array α&#10;bs : Array β&#10;xs ys : Array γ&#10;h₁ : as.size = xs.size + ys.size&#10;h₂ : bs.size = xs.size + ys.size&#10;⊢ (∃ as₁ as₂ bs₁ bs₂,&#10;      as₁.size = bs₁.size ∧&#10;        as = as₁ ++ as₂ ∧ bs = bs₁ ++ bs₂ ∧ xs = Array.zipWith f as₁ bs₁ ∧ ys = Array.zipWith f as₂ bs₂) →&#10;    ∃ as₁ as₂ bs₁ bs₂,&#10;      as = as₁.toArray ++ as₂.toArray ∧&#10;        bs = bs₁.toArray ++ bs₂.toArray ∧&#10;          xs = Array.zipWith f as₁.toArray bs₁.toArray ∧ ys = Array.zipWith f as₂.toArray bs₂.toArray" state_after="case mk.mk.mk.mk.mp.intro.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as₁ as₂ : Array α&#10;bs₁ bs₂ : Array β&#10;h : as₁.size = bs₁.size&#10;h₁ : (as₁ ++ as₂).size = (Array.zipWith f as₁ bs₁).size + (Array.zipWith f as₂ bs₂).size&#10;h₂ : (bs₁ ++ bs₂).size = (Array.zipWith f as₁ bs₁).size + (Array.zipWith f as₂ bs₂).size&#10;⊢ ∃ as₁_1 as₂_1 bs₁_1 bs₂_1,&#10;    as₁ ++ as₂ = as₁_1.toArray ++ as₂_1.toArray ∧&#10;      bs₁ ++ bs₂ = bs₁_1.toArray ++ bs₂_1.toArray ∧&#10;        Array.zipWith f as₁ bs₁ = Array.zipWith f as₁_1.toArray bs₁_1.toArray ∧&#10;          Array.zipWith f as₂ bs₂ = Array.zipWith f as₂_1.toArray bs₂_1.toArray" tactic="rintro ⟨as₁, as₂, bs₁, bs₂, h, rfl, rfl, rfl, rfl⟩">
                            <AtomNode start="(141, 5)" end="(141, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(141, 12)" end="(141, 55)">
                              <OtherNode start="(141, 12)" end="(141, 55)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(141, 12)" end="(141, 55)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                  <AtomNode start="(141, 12)" end="(141, 13)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(141, 13)" end="(141, 54)">
                                    <OtherNode start="(141, 13)" end="(141, 16)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(141, 13)" end="(141, 16)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(141, 13)" end="(141, 16)">
                                          <OtherNode start="(141, 13)" end="(141, 16)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(141, 13)" end="(141, 16)" leading="" trailing="" raw_val="as₁" val="as₁"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(141, 16)" end="(141, 17)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(141, 18)" end="(141, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(141, 18)" end="(141, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(141, 18)" end="(141, 21)">
                                          <OtherNode start="(141, 18)" end="(141, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(141, 18)" end="(141, 21)" leading="" trailing="" raw_val="as₂" val="as₂"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(141, 21)" end="(141, 22)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(141, 23)" end="(141, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(141, 23)" end="(141, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(141, 23)" end="(141, 26)">
                                          <OtherNode start="(141, 23)" end="(141, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(141, 23)" end="(141, 26)" leading="" trailing="" raw_val="bs₁" val="bs₁"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(141, 26)" end="(141, 27)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(141, 28)" end="(141, 31)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(141, 28)" end="(141, 31)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(141, 28)" end="(141, 31)">
                                          <OtherNode start="(141, 28)" end="(141, 31)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(141, 28)" end="(141, 31)" leading="" trailing="" raw_val="bs₂" val="bs₂"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(141, 31)" end="(141, 32)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(141, 33)" end="(141, 34)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(141, 33)" end="(141, 34)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(141, 33)" end="(141, 34)">
                                          <OtherNode start="(141, 33)" end="(141, 34)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(141, 33)" end="(141, 34)" leading="" trailing="" raw_val="h" val="h"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(141, 34)" end="(141, 35)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(141, 36)" end="(141, 39)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(141, 36)" end="(141, 39)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(141, 36)" end="(141, 39)">
                                          <OtherNode start="(141, 36)" end="(141, 39)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(141, 36)" end="(141, 39)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(141, 39)" end="(141, 40)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(141, 41)" end="(141, 44)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(141, 41)" end="(141, 44)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(141, 41)" end="(141, 44)">
                                          <OtherNode start="(141, 41)" end="(141, 44)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(141, 41)" end="(141, 44)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(141, 44)" end="(141, 45)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(141, 46)" end="(141, 49)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(141, 46)" end="(141, 49)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(141, 46)" end="(141, 49)">
                                          <OtherNode start="(141, 46)" end="(141, 49)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(141, 46)" end="(141, 49)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(141, 49)" end="(141, 50)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(141, 51)" end="(141, 54)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(141, 51)" end="(141, 54)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(141, 51)" end="(141, 54)">
                                          <OtherNode start="(141, 51)" end="(141, 54)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(141, 51)" end="(141, 54)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(141, 54)" end="(141, 55)" leading="" trailing="&#10;    " val="⟩"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(142, 5)" end="(142, 63)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk.mk.mk.mp.intro.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as₁ as₂ : Array α&#10;bs₁ bs₂ : Array β&#10;h : as₁.size = bs₁.size&#10;h₁ : (as₁ ++ as₂).size = (Array.zipWith f as₁ bs₁).size + (Array.zipWith f as₂ bs₂).size&#10;h₂ : (bs₁ ++ bs₂).size = (Array.zipWith f as₁ bs₁).size + (Array.zipWith f as₂ bs₂).size&#10;⊢ ∃ as₁_1 as₂_1 bs₁_1 bs₂_1,&#10;    as₁ ++ as₂ = as₁_1.toArray ++ as₂_1.toArray ∧&#10;      bs₁ ++ bs₂ = bs₁_1.toArray ++ bs₂_1.toArray ∧&#10;        Array.zipWith f as₁ bs₁ = Array.zipWith f as₁_1.toArray bs₁_1.toArray ∧&#10;          Array.zipWith f as₂ bs₂ = Array.zipWith f as₂_1.toArray bs₂_1.toArray" state_after="case mk.mk.mk.mk.mp.intro.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as₁ as₂ : Array α&#10;bs₁ bs₂ : Array β&#10;h : as₁.size = bs₁.size&#10;h₁ : as₁.size + as₂.size = min as₁.size bs₁.size + min as₂.size bs₂.size&#10;h₂ : bs₁.size + bs₂.size = min as₁.size bs₁.size + min as₂.size bs₂.size&#10;⊢ ∃ as₁_1 as₂_1 bs₁_1 bs₂_1,&#10;    as₁ ++ as₂ = as₁_1.toArray ++ as₂_1.toArray ∧&#10;      bs₁ ++ bs₂ = bs₁_1.toArray ++ bs₂_1.toArray ∧&#10;        Array.zipWith f as₁ bs₁ = Array.zipWith f as₁_1.toArray bs₁_1.toArray ∧&#10;          Array.zipWith f as₂ bs₂ = Array.zipWith f as₂_1.toArray bs₂_1.toArray" tactic="simp only [Array.size_append, Array.size_zipWith] at h₁ h₂">
                            <AtomNode start="(142, 5)" end="(142, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(142, 10)" end="(142, 14)">
                              <AtomNode start="(142, 10)" end="(142, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode start="(142, 15)" end="(142, 54)">
                              <AtomNode start="(142, 15)" end="(142, 16)" leading="" trailing="" val="["/>
                              <NullNode start="(142, 16)" end="(142, 53)">
                                <OtherNode start="(142, 16)" end="(142, 33)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(142, 16)" end="(142, 33)" leading="" trailing="" raw_val="Array.size_append" val="Array.size_append" full_name="Array.size_append" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                                <AtomNode start="(142, 33)" end="(142, 34)" leading="" trailing=" " val=","/>
                                <OtherNode start="(142, 35)" end="(142, 53)" kind="Lean.Parser.Tactic.simpLemma">
                                  <NullNode/>
                                  <NullNode/>
                                  <IdentNode start="(142, 35)" end="(142, 53)" leading="" trailing="" raw_val="Array.size_zipWith" val="Array.size_zipWith" full_name="Array.size_zipWith" mod_name="Init.Data.Array.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Lemmas.lean"/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(142, 53)" end="(142, 54)" leading="" trailing=" " val="]"/>
                            </NullNode>
                            <NullNode start="(142, 55)" end="(142, 63)">
                              <OtherNode start="(142, 55)" end="(142, 63)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(142, 55)" end="(142, 57)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(142, 58)" end="(142, 63)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(142, 58)" end="(142, 63)">
                                    <IdentNode start="(142, 58)" end="(142, 60)" leading="" trailing=" " raw_val="h₁" val="h₁"/>
                                    <IdentNode start="(142, 61)" end="(142, 63)" leading="" trailing="&#10;    " raw_val="h₂" val="h₂"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(143, 5)" end="(143, 120)" kind="Lean.Parser.Tactic.exact" state_before="case mk.mk.mk.mk.mp.intro.intro.intro.intro.intro.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as₁ as₂ : Array α&#10;bs₁ bs₂ : Array β&#10;h : as₁.size = bs₁.size&#10;h₁ : as₁.size + as₂.size = min as₁.size bs₁.size + min as₂.size bs₂.size&#10;h₂ : bs₁.size + bs₂.size = min as₁.size bs₁.size + min as₂.size bs₂.size&#10;⊢ ∃ as₁_1 as₂_1 bs₁_1 bs₂_1,&#10;    as₁ ++ as₂ = as₁_1.toArray ++ as₂_1.toArray ∧&#10;      bs₁ ++ bs₂ = bs₁_1.toArray ++ bs₂_1.toArray ∧&#10;        Array.zipWith f as₁ bs₁ = Array.zipWith f as₁_1.toArray bs₁_1.toArray ∧&#10;          Array.zipWith f as₂ bs₂ = Array.zipWith f as₂_1.toArray bs₂_1.toArray" state_after="no goals" tactic="exact ⟨mk as₁ (by simp; omega), mk as₂ (by simp; omega), mk bs₁ (by simp; omega), mk bs₂ (by simp; omega), by simp⟩">
                            <AtomNode start="(143, 5)" end="(143, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(143, 11)" end="(143, 120)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(143, 11)" end="(143, 12)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(143, 12)" end="(143, 119)">
                                <OtherNode start="(143, 12)" end="(143, 35)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(143, 12)" end="(143, 14)" leading="" trailing=" " raw_val="mk" val="mk" full_name="Vector.mk" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                                  <NullNode start="(143, 15)" end="(143, 35)">
                                    <IdentNode start="(143, 15)" end="(143, 18)" leading="" trailing=" " raw_val="as₁" val="as₁"/>
                                    <OtherNode start="(143, 19)" end="(143, 35)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(143, 19)" end="(143, 20)" leading="" trailing="" val="("/>
                                      <TermBytacticNode start="(143, 20)" end="(143, 34)">
                                        <AtomNode start="(143, 20)" end="(143, 22)" leading="" trailing=" " val="by"/>
                                        <TacticTacticseqNode start="(143, 23)" end="(143, 34)">
                                          <TacticTacticseq1IndentedNode start="(143, 23)" end="(143, 34)">
                                            <NullNode start="(143, 23)" end="(143, 34)">
                                              <OtherNode start="(143, 23)" end="(143, 27)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as₁ as₂ : Array α&#10;bs₁ bs₂ : Array β&#10;h : as₁.size = bs₁.size&#10;h₁ : as₁.size + as₂.size = min as₁.size bs₁.size + min as₂.size bs₂.size&#10;h₂ : bs₁.size + bs₂.size = min as₁.size bs₁.size + min as₂.size bs₂.size&#10;⊢ as₁.size = (Array.zipWith f as₁ bs₁).size" state_after="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as₁ as₂ : Array α&#10;bs₁ bs₂ : Array β&#10;h : as₁.size = bs₁.size&#10;h₁ : as₁.size + as₂.size = min as₁.size bs₁.size + min as₂.size bs₂.size&#10;h₂ : bs₁.size + bs₂.size = min as₁.size bs₁.size + min as₂.size bs₂.size&#10;⊢ as₁.size = min as₁.size bs₁.size" tactic="simp">
                                                <AtomNode start="(143, 23)" end="(143, 27)" leading="" trailing="" val="simp"/>
                                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                  <NullNode/>
                                                </OtherNode>
                                                <NullNode/>
                                                <NullNode/>
                                                <NullNode/>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(143, 27)" end="(143, 28)" leading="" trailing=" " val=";"/>
                                              <OtherNode start="(143, 29)" end="(143, 34)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as₁ as₂ : Array α&#10;bs₁ bs₂ : Array β&#10;h : as₁.size = bs₁.size&#10;h₁ : as₁.size + as₂.size = min as₁.size bs₁.size + min as₂.size bs₂.size&#10;h₂ : bs₁.size + bs₂.size = min as₁.size bs₁.size + min as₂.size bs₂.size&#10;⊢ as₁.size = min as₁.size bs₁.size" state_after="no goals" tactic="omega">
                                                <AtomNode start="(143, 29)" end="(143, 34)" leading="" trailing="" val="omega"/>
                                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                  <NullNode/>
                                                </OtherNode>
                                              </OtherNode>
                                            </NullNode>
                                          </TacticTacticseq1IndentedNode>
                                        </TacticTacticseqNode>
                                      </TermBytacticNode>
                                      <AtomNode start="(143, 34)" end="(143, 35)" leading="" trailing="" val=")"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(143, 35)" end="(143, 36)" leading="" trailing=" " val=","/>
                                <OtherNode start="(143, 37)" end="(143, 60)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(143, 37)" end="(143, 39)" leading="" trailing=" " raw_val="mk" val="mk" full_name="Vector.mk" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                                  <NullNode start="(143, 40)" end="(143, 60)">
                                    <IdentNode start="(143, 40)" end="(143, 43)" leading="" trailing=" " raw_val="as₂" val="as₂"/>
                                    <OtherNode start="(143, 44)" end="(143, 60)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(143, 44)" end="(143, 45)" leading="" trailing="" val="("/>
                                      <TermBytacticNode start="(143, 45)" end="(143, 59)">
                                        <AtomNode start="(143, 45)" end="(143, 47)" leading="" trailing=" " val="by"/>
                                        <TacticTacticseqNode start="(143, 48)" end="(143, 59)">
                                          <TacticTacticseq1IndentedNode start="(143, 48)" end="(143, 59)">
                                            <NullNode start="(143, 48)" end="(143, 59)">
                                              <OtherNode start="(143, 48)" end="(143, 52)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as₁ as₂ : Array α&#10;bs₁ bs₂ : Array β&#10;h : as₁.size = bs₁.size&#10;h₁ : as₁.size + as₂.size = min as₁.size bs₁.size + min as₂.size bs₂.size&#10;h₂ : bs₁.size + bs₂.size = min as₁.size bs₁.size + min as₂.size bs₂.size&#10;⊢ as₂.size = (Array.zipWith f as₂ bs₂).size" state_after="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as₁ as₂ : Array α&#10;bs₁ bs₂ : Array β&#10;h : as₁.size = bs₁.size&#10;h₁ : as₁.size + as₂.size = min as₁.size bs₁.size + min as₂.size bs₂.size&#10;h₂ : bs₁.size + bs₂.size = min as₁.size bs₁.size + min as₂.size bs₂.size&#10;⊢ as₂.size = min as₂.size bs₂.size" tactic="simp">
                                                <AtomNode start="(143, 48)" end="(143, 52)" leading="" trailing="" val="simp"/>
                                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                  <NullNode/>
                                                </OtherNode>
                                                <NullNode/>
                                                <NullNode/>
                                                <NullNode/>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(143, 52)" end="(143, 53)" leading="" trailing=" " val=";"/>
                                              <OtherNode start="(143, 54)" end="(143, 59)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as₁ as₂ : Array α&#10;bs₁ bs₂ : Array β&#10;h : as₁.size = bs₁.size&#10;h₁ : as₁.size + as₂.size = min as₁.size bs₁.size + min as₂.size bs₂.size&#10;h₂ : bs₁.size + bs₂.size = min as₁.size bs₁.size + min as₂.size bs₂.size&#10;⊢ as₂.size = min as₂.size bs₂.size" state_after="no goals" tactic="omega">
                                                <AtomNode start="(143, 54)" end="(143, 59)" leading="" trailing="" val="omega"/>
                                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                  <NullNode/>
                                                </OtherNode>
                                              </OtherNode>
                                            </NullNode>
                                          </TacticTacticseq1IndentedNode>
                                        </TacticTacticseqNode>
                                      </TermBytacticNode>
                                      <AtomNode start="(143, 59)" end="(143, 60)" leading="" trailing="" val=")"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(143, 60)" end="(143, 61)" leading="" trailing=" " val=","/>
                                <OtherNode start="(143, 62)" end="(143, 85)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(143, 62)" end="(143, 64)" leading="" trailing=" " raw_val="mk" val="mk" full_name="Vector.mk" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                                  <NullNode start="(143, 65)" end="(143, 85)">
                                    <IdentNode start="(143, 65)" end="(143, 68)" leading="" trailing=" " raw_val="bs₁" val="bs₁"/>
                                    <OtherNode start="(143, 69)" end="(143, 85)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(143, 69)" end="(143, 70)" leading="" trailing="" val="("/>
                                      <TermBytacticNode start="(143, 70)" end="(143, 84)">
                                        <AtomNode start="(143, 70)" end="(143, 72)" leading="" trailing=" " val="by"/>
                                        <TacticTacticseqNode start="(143, 73)" end="(143, 84)">
                                          <TacticTacticseq1IndentedNode start="(143, 73)" end="(143, 84)">
                                            <NullNode start="(143, 73)" end="(143, 84)">
                                              <OtherNode start="(143, 73)" end="(143, 77)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as₁ as₂ : Array α&#10;bs₁ bs₂ : Array β&#10;h : as₁.size = bs₁.size&#10;h₁ : as₁.size + as₂.size = min as₁.size bs₁.size + min as₂.size bs₂.size&#10;h₂ : bs₁.size + bs₂.size = min as₁.size bs₁.size + min as₂.size bs₂.size&#10;⊢ bs₁.size = (Array.zipWith f as₁ bs₁).size" state_after="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as₁ as₂ : Array α&#10;bs₁ bs₂ : Array β&#10;h : as₁.size = bs₁.size&#10;h₁ : as₁.size + as₂.size = min as₁.size bs₁.size + min as₂.size bs₂.size&#10;h₂ : bs₁.size + bs₂.size = min as₁.size bs₁.size + min as₂.size bs₂.size&#10;⊢ bs₁.size = min as₁.size bs₁.size" tactic="simp">
                                                <AtomNode start="(143, 73)" end="(143, 77)" leading="" trailing="" val="simp"/>
                                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                  <NullNode/>
                                                </OtherNode>
                                                <NullNode/>
                                                <NullNode/>
                                                <NullNode/>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(143, 77)" end="(143, 78)" leading="" trailing=" " val=";"/>
                                              <OtherNode start="(143, 79)" end="(143, 84)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as₁ as₂ : Array α&#10;bs₁ bs₂ : Array β&#10;h : as₁.size = bs₁.size&#10;h₁ : as₁.size + as₂.size = min as₁.size bs₁.size + min as₂.size bs₂.size&#10;h₂ : bs₁.size + bs₂.size = min as₁.size bs₁.size + min as₂.size bs₂.size&#10;⊢ bs₁.size = min as₁.size bs₁.size" state_after="no goals" tactic="omega">
                                                <AtomNode start="(143, 79)" end="(143, 84)" leading="" trailing="" val="omega"/>
                                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                  <NullNode/>
                                                </OtherNode>
                                              </OtherNode>
                                            </NullNode>
                                          </TacticTacticseq1IndentedNode>
                                        </TacticTacticseqNode>
                                      </TermBytacticNode>
                                      <AtomNode start="(143, 84)" end="(143, 85)" leading="" trailing="" val=")"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(143, 85)" end="(143, 86)" leading="" trailing=" " val=","/>
                                <OtherNode start="(143, 87)" end="(143, 110)" kind="Lean.Parser.Term.app">
                                  <IdentNode start="(143, 87)" end="(143, 89)" leading="" trailing=" " raw_val="mk" val="mk" full_name="Vector.mk" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                                  <NullNode start="(143, 90)" end="(143, 110)">
                                    <IdentNode start="(143, 90)" end="(143, 93)" leading="" trailing=" " raw_val="bs₂" val="bs₂"/>
                                    <OtherNode start="(143, 94)" end="(143, 110)" kind="Lean.Parser.Term.paren">
                                      <AtomNode start="(143, 94)" end="(143, 95)" leading="" trailing="" val="("/>
                                      <TermBytacticNode start="(143, 95)" end="(143, 109)">
                                        <AtomNode start="(143, 95)" end="(143, 97)" leading="" trailing=" " val="by"/>
                                        <TacticTacticseqNode start="(143, 98)" end="(143, 109)">
                                          <TacticTacticseq1IndentedNode start="(143, 98)" end="(143, 109)">
                                            <NullNode start="(143, 98)" end="(143, 109)">
                                              <OtherNode start="(143, 98)" end="(143, 102)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as₁ as₂ : Array α&#10;bs₁ bs₂ : Array β&#10;h : as₁.size = bs₁.size&#10;h₁ : as₁.size + as₂.size = min as₁.size bs₁.size + min as₂.size bs₂.size&#10;h₂ : bs₁.size + bs₂.size = min as₁.size bs₁.size + min as₂.size bs₂.size&#10;⊢ bs₂.size = (Array.zipWith f as₂ bs₂).size" state_after="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as₁ as₂ : Array α&#10;bs₁ bs₂ : Array β&#10;h : as₁.size = bs₁.size&#10;h₁ : as₁.size + as₂.size = min as₁.size bs₁.size + min as₂.size bs₂.size&#10;h₂ : bs₁.size + bs₂.size = min as₁.size bs₁.size + min as₂.size bs₂.size&#10;⊢ bs₂.size = min as₂.size bs₂.size" tactic="simp">
                                                <AtomNode start="(143, 98)" end="(143, 102)" leading="" trailing="" val="simp"/>
                                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                  <NullNode/>
                                                </OtherNode>
                                                <NullNode/>
                                                <NullNode/>
                                                <NullNode/>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(143, 102)" end="(143, 103)" leading="" trailing=" " val=";"/>
                                              <OtherNode start="(143, 104)" end="(143, 109)" kind="Lean.Parser.Tactic.omega" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as₁ as₂ : Array α&#10;bs₁ bs₂ : Array β&#10;h : as₁.size = bs₁.size&#10;h₁ : as₁.size + as₂.size = min as₁.size bs₁.size + min as₂.size bs₂.size&#10;h₂ : bs₁.size + bs₂.size = min as₁.size bs₁.size + min as₂.size bs₂.size&#10;⊢ bs₂.size = min as₂.size bs₂.size" state_after="no goals" tactic="omega">
                                                <AtomNode start="(143, 104)" end="(143, 109)" leading="" trailing="" val="omega"/>
                                                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                                  <NullNode/>
                                                </OtherNode>
                                              </OtherNode>
                                            </NullNode>
                                          </TacticTacticseq1IndentedNode>
                                        </TacticTacticseqNode>
                                      </TermBytacticNode>
                                      <AtomNode start="(143, 109)" end="(143, 110)" leading="" trailing="" val=")"/>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <AtomNode start="(143, 110)" end="(143, 111)" leading="" trailing=" " val=","/>
                                <TermBytacticNode start="(143, 112)" end="(143, 119)">
                                  <AtomNode start="(143, 112)" end="(143, 114)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(143, 115)" end="(143, 119)">
                                    <TacticTacticseq1IndentedNode start="(143, 115)" end="(143, 119)">
                                      <NullNode start="(143, 115)" end="(143, 119)">
                                        <OtherNode start="(143, 115)" end="(143, 119)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as₁ as₂ : Array α&#10;bs₁ bs₂ : Array β&#10;h : as₁.size = bs₁.size&#10;h₁ : as₁.size + as₂.size = min as₁.size bs₁.size + min as₂.size bs₂.size&#10;h₂ : bs₁.size + bs₂.size = min as₁.size bs₁.size + min as₂.size bs₂.size&#10;⊢ as₁ ++ as₂ = { toArray := as₁, size_toArray := ⋯ }.toArray ++ { toArray := as₂, size_toArray := ⋯ }.toArray ∧&#10;    bs₁ ++ bs₂ = { toArray := bs₁, size_toArray := ⋯ }.toArray ++ { toArray := bs₂, size_toArray := ⋯ }.toArray ∧&#10;      Array.zipWith f as₁ bs₁ =&#10;          Array.zipWith f { toArray := as₁, size_toArray := ⋯ }.toArray { toArray := bs₁, size_toArray := ⋯ }.toArray ∧&#10;        Array.zipWith f as₂ bs₂ =&#10;          Array.zipWith f { toArray := as₂, size_toArray := ⋯ }.toArray { toArray := bs₂, size_toArray := ⋯ }.toArray" state_after="no goals" tactic="simp">
                                          <AtomNode start="(143, 115)" end="(143, 119)" leading="" trailing="" val="simp"/>
                                          <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                            <NullNode/>
                                          </OtherNode>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                          <NullNode/>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </NullNode>
                              <AtomNode start="(143, 119)" end="(143, 120)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(144, 3)" end="(146, 65)" kind="Lean.cdot" state_before="case mk.mk.mk.mk.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as : Array α&#10;bs : Array β&#10;xs ys : Array γ&#10;h₁ : as.size = xs.size + ys.size&#10;h₂ : bs.size = xs.size + ys.size&#10;⊢ (∃ as₁ as₂ bs₁ bs₂,&#10;      as = as₁.toArray ++ as₂.toArray ∧&#10;        bs = bs₁.toArray ++ bs₂.toArray ∧&#10;          xs = Array.zipWith f as₁.toArray bs₁.toArray ∧ ys = Array.zipWith f as₂.toArray bs₂.toArray) →&#10;    ∃ as₁ as₂ bs₁ bs₂,&#10;      as₁.size = bs₁.size ∧&#10;        as = as₁ ++ as₂ ∧ bs = bs₁ ++ bs₂ ∧ xs = Array.zipWith f as₁ bs₁ ∧ ys = Array.zipWith f as₂ bs₂" state_after="no goals" tactic="· rintro ⟨⟨as₁, hw⟩, ⟨as₂, hx⟩, ⟨bs₁, hy⟩, ⟨bs₂, hz⟩, rfl, rfl, w₁, w₂⟩&#10;  simp only at w₁ w₂&#10;  exact ⟨as₁, as₂, bs₁, bs₂, by simpa [hw, hy] using ⟨w₁, w₂⟩⟩">
                    <OtherNode start="(144, 3)" end="(144, 4)" kind="Lean.cdotTk">
                      <OtherNode start="(144, 3)" end="(144, 4)" kind="patternIgnore">
                        <OtherNode start="(144, 3)" end="(144, 4)" kind="token.«· »">
                          <AtomNode start="(144, 3)" end="(144, 4)" leading="" trailing=" " val="·"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <TacticTacticseqNode start="(144, 5)" end="(146, 65)">
                      <TacticTacticseq1IndentedNode start="(144, 5)" end="(146, 65)">
                        <NullNode start="(144, 5)" end="(146, 65)">
                          <OtherNode start="(144, 5)" end="(144, 74)" kind="Lean.Parser.Tactic.rintro" state_before="case mk.mk.mk.mk.mpr&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as : Array α&#10;bs : Array β&#10;xs ys : Array γ&#10;h₁ : as.size = xs.size + ys.size&#10;h₂ : bs.size = xs.size + ys.size&#10;⊢ (∃ as₁ as₂ bs₁ bs₂,&#10;      as = as₁.toArray ++ as₂.toArray ∧&#10;        bs = bs₁.toArray ++ bs₂.toArray ∧&#10;          xs = Array.zipWith f as₁.toArray bs₁.toArray ∧ ys = Array.zipWith f as₂.toArray bs₂.toArray) →&#10;    ∃ as₁ as₂ bs₁ bs₂,&#10;      as₁.size = bs₁.size ∧&#10;        as = as₁ ++ as₂ ∧ bs = bs₁ ++ bs₂ ∧ xs = Array.zipWith f as₁ bs₁ ∧ ys = Array.zipWith f as₂ bs₂" state_after="case mk.mk.mk.mk.mpr.intro.mk.intro.mk.intro.mk.intro.mk.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;xs ys : Array γ&#10;as₁ : Array α&#10;hw : as₁.size = xs.size&#10;as₂ : Array α&#10;hx : as₂.size = ys.size&#10;bs₁ : Array β&#10;hy : bs₁.size = xs.size&#10;bs₂ : Array β&#10;hz : bs₂.size = ys.size&#10;h₁ :&#10;  ({ toArray := as₁, size_toArray := hw }.toArray ++ { toArray := as₂, size_toArray := hx }.toArray).size =&#10;    xs.size + ys.size&#10;h₂ :&#10;  ({ toArray := bs₁, size_toArray := hy }.toArray ++ { toArray := bs₂, size_toArray := hz }.toArray).size =&#10;    xs.size + ys.size&#10;w₁ : xs = Array.zipWith f { toArray := as₁, size_toArray := hw }.toArray { toArray := bs₁, size_toArray := hy }.toArray&#10;w₂ : ys = Array.zipWith f { toArray := as₂, size_toArray := hx }.toArray { toArray := bs₂, size_toArray := hz }.toArray&#10;⊢ ∃ as₁_1 as₂_1 bs₁_1 bs₂_1,&#10;    as₁_1.size = bs₁_1.size ∧&#10;      { toArray := as₁, size_toArray := hw }.toArray ++ { toArray := as₂, size_toArray := hx }.toArray =&#10;          as₁_1 ++ as₂_1 ∧&#10;        { toArray := bs₁, size_toArray := hy }.toArray ++ { toArray := bs₂, size_toArray := hz }.toArray =&#10;            bs₁_1 ++ bs₂_1 ∧&#10;          xs = Array.zipWith f as₁_1 bs₁_1 ∧ ys = Array.zipWith f as₂_1 bs₂_1" tactic="rintro ⟨⟨as₁, hw⟩, ⟨as₂, hx⟩, ⟨bs₁, hy⟩, ⟨bs₂, hz⟩, rfl, rfl, w₁, w₂⟩">
                            <AtomNode start="(144, 5)" end="(144, 11)" leading="" trailing=" " val="rintro"/>
                            <NullNode start="(144, 12)" end="(144, 74)">
                              <OtherNode start="(144, 12)" end="(144, 74)" kind="Lean.Parser.Tactic.rintroPat.one">
                                <OtherNode start="(144, 12)" end="(144, 74)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                  <AtomNode start="(144, 12)" end="(144, 13)" leading="" trailing="" val="⟨"/>
                                  <NullNode start="(144, 13)" end="(144, 73)">
                                    <OtherNode start="(144, 13)" end="(144, 22)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(144, 13)" end="(144, 22)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(144, 13)" end="(144, 22)">
                                          <OtherNode start="(144, 13)" end="(144, 22)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                            <AtomNode start="(144, 13)" end="(144, 14)" leading="" trailing="" val="⟨"/>
                                            <NullNode start="(144, 14)" end="(144, 21)">
                                              <OtherNode start="(144, 14)" end="(144, 17)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(144, 14)" end="(144, 17)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(144, 14)" end="(144, 17)">
                                                    <OtherNode start="(144, 14)" end="(144, 17)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(144, 14)" end="(144, 17)" leading="" trailing="" raw_val="as₁" val="as₁"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(144, 17)" end="(144, 18)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(144, 19)" end="(144, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(144, 19)" end="(144, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(144, 19)" end="(144, 21)">
                                                    <OtherNode start="(144, 19)" end="(144, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(144, 19)" end="(144, 21)" leading="" trailing="" raw_val="hw" val="hw"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(144, 21)" end="(144, 22)" leading="" trailing="" val="⟩"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(144, 22)" end="(144, 23)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(144, 24)" end="(144, 33)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(144, 24)" end="(144, 33)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(144, 24)" end="(144, 33)">
                                          <OtherNode start="(144, 24)" end="(144, 33)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                            <AtomNode start="(144, 24)" end="(144, 25)" leading="" trailing="" val="⟨"/>
                                            <NullNode start="(144, 25)" end="(144, 32)">
                                              <OtherNode start="(144, 25)" end="(144, 28)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(144, 25)" end="(144, 28)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(144, 25)" end="(144, 28)">
                                                    <OtherNode start="(144, 25)" end="(144, 28)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(144, 25)" end="(144, 28)" leading="" trailing="" raw_val="as₂" val="as₂"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(144, 28)" end="(144, 29)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(144, 30)" end="(144, 32)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(144, 30)" end="(144, 32)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(144, 30)" end="(144, 32)">
                                                    <OtherNode start="(144, 30)" end="(144, 32)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(144, 30)" end="(144, 32)" leading="" trailing="" raw_val="hx" val="hx"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(144, 32)" end="(144, 33)" leading="" trailing="" val="⟩"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(144, 33)" end="(144, 34)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(144, 35)" end="(144, 44)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(144, 35)" end="(144, 44)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(144, 35)" end="(144, 44)">
                                          <OtherNode start="(144, 35)" end="(144, 44)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                            <AtomNode start="(144, 35)" end="(144, 36)" leading="" trailing="" val="⟨"/>
                                            <NullNode start="(144, 36)" end="(144, 43)">
                                              <OtherNode start="(144, 36)" end="(144, 39)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(144, 36)" end="(144, 39)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(144, 36)" end="(144, 39)">
                                                    <OtherNode start="(144, 36)" end="(144, 39)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(144, 36)" end="(144, 39)" leading="" trailing="" raw_val="bs₁" val="bs₁"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(144, 39)" end="(144, 40)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(144, 41)" end="(144, 43)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(144, 41)" end="(144, 43)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(144, 41)" end="(144, 43)">
                                                    <OtherNode start="(144, 41)" end="(144, 43)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(144, 41)" end="(144, 43)" leading="" trailing="" raw_val="hy" val="hy"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(144, 43)" end="(144, 44)" leading="" trailing="" val="⟩"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(144, 44)" end="(144, 45)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(144, 46)" end="(144, 55)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(144, 46)" end="(144, 55)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(144, 46)" end="(144, 55)">
                                          <OtherNode start="(144, 46)" end="(144, 55)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                                            <AtomNode start="(144, 46)" end="(144, 47)" leading="" trailing="" val="⟨"/>
                                            <NullNode start="(144, 47)" end="(144, 54)">
                                              <OtherNode start="(144, 47)" end="(144, 50)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(144, 47)" end="(144, 50)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(144, 47)" end="(144, 50)">
                                                    <OtherNode start="(144, 47)" end="(144, 50)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(144, 47)" end="(144, 50)" leading="" trailing="" raw_val="bs₂" val="bs₂"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                              <AtomNode start="(144, 50)" end="(144, 51)" leading="" trailing=" " val=","/>
                                              <OtherNode start="(144, 52)" end="(144, 54)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                                <OtherNode start="(144, 52)" end="(144, 54)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                                  <NullNode start="(144, 52)" end="(144, 54)">
                                                    <OtherNode start="(144, 52)" end="(144, 54)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                                      <IdentNode start="(144, 52)" end="(144, 54)" leading="" trailing="" raw_val="hz" val="hz"/>
                                                    </OtherNode>
                                                  </NullNode>
                                                </OtherNode>
                                                <NullNode/>
                                              </OtherNode>
                                            </NullNode>
                                            <AtomNode start="(144, 54)" end="(144, 55)" leading="" trailing="" val="⟩"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(144, 55)" end="(144, 56)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(144, 57)" end="(144, 60)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(144, 57)" end="(144, 60)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(144, 57)" end="(144, 60)">
                                          <OtherNode start="(144, 57)" end="(144, 60)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(144, 57)" end="(144, 60)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(144, 60)" end="(144, 61)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(144, 62)" end="(144, 65)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(144, 62)" end="(144, 65)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(144, 62)" end="(144, 65)">
                                          <OtherNode start="(144, 62)" end="(144, 65)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(144, 62)" end="(144, 65)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(144, 65)" end="(144, 66)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(144, 67)" end="(144, 69)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(144, 67)" end="(144, 69)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(144, 67)" end="(144, 69)">
                                          <OtherNode start="(144, 67)" end="(144, 69)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(144, 67)" end="(144, 69)" leading="" trailing="" raw_val="w₁" val="w₁"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(144, 69)" end="(144, 70)" leading="" trailing=" " val=","/>
                                    <OtherNode start="(144, 71)" end="(144, 73)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                      <OtherNode start="(144, 71)" end="(144, 73)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                        <NullNode start="(144, 71)" end="(144, 73)">
                                          <OtherNode start="(144, 71)" end="(144, 73)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                            <IdentNode start="(144, 71)" end="(144, 73)" leading="" trailing="" raw_val="w₂" val="w₂"/>
                                          </OtherNode>
                                        </NullNode>
                                      </OtherNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(144, 73)" end="(144, 74)" leading="" trailing="&#10;    " val="⟩"/>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                            <NullNode/>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(145, 5)" end="(145, 23)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk.mk.mk.mpr.intro.mk.intro.mk.intro.mk.intro.mk.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;xs ys : Array γ&#10;as₁ : Array α&#10;hw : as₁.size = xs.size&#10;as₂ : Array α&#10;hx : as₂.size = ys.size&#10;bs₁ : Array β&#10;hy : bs₁.size = xs.size&#10;bs₂ : Array β&#10;hz : bs₂.size = ys.size&#10;h₁ :&#10;  ({ toArray := as₁, size_toArray := hw }.toArray ++ { toArray := as₂, size_toArray := hx }.toArray).size =&#10;    xs.size + ys.size&#10;h₂ :&#10;  ({ toArray := bs₁, size_toArray := hy }.toArray ++ { toArray := bs₂, size_toArray := hz }.toArray).size =&#10;    xs.size + ys.size&#10;w₁ : xs = Array.zipWith f { toArray := as₁, size_toArray := hw }.toArray { toArray := bs₁, size_toArray := hy }.toArray&#10;w₂ : ys = Array.zipWith f { toArray := as₂, size_toArray := hx }.toArray { toArray := bs₂, size_toArray := hz }.toArray&#10;⊢ ∃ as₁_1 as₂_1 bs₁_1 bs₂_1,&#10;    as₁_1.size = bs₁_1.size ∧&#10;      { toArray := as₁, size_toArray := hw }.toArray ++ { toArray := as₂, size_toArray := hx }.toArray =&#10;          as₁_1 ++ as₂_1 ∧&#10;        { toArray := bs₁, size_toArray := hy }.toArray ++ { toArray := bs₂, size_toArray := hz }.toArray =&#10;            bs₁_1 ++ bs₂_1 ∧&#10;          xs = Array.zipWith f as₁_1 bs₁_1 ∧ ys = Array.zipWith f as₂_1 bs₂_1" state_after="case mk.mk.mk.mk.mpr.intro.mk.intro.mk.intro.mk.intro.mk.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;xs ys : Array γ&#10;as₁ : Array α&#10;hw : as₁.size = xs.size&#10;as₂ : Array α&#10;hx : as₂.size = ys.size&#10;bs₁ : Array β&#10;hy : bs₁.size = xs.size&#10;bs₂ : Array β&#10;hz : bs₂.size = ys.size&#10;h₁ :&#10;  ({ toArray := as₁, size_toArray := hw }.toArray ++ { toArray := as₂, size_toArray := hx }.toArray).size =&#10;    xs.size + ys.size&#10;h₂ :&#10;  ({ toArray := bs₁, size_toArray := hy }.toArray ++ { toArray := bs₂, size_toArray := hz }.toArray).size =&#10;    xs.size + ys.size&#10;w₁ : xs = Array.zipWith f as₁ bs₁&#10;w₂ : ys = Array.zipWith f as₂ bs₂&#10;⊢ ∃ as₁_1 as₂_1 bs₁_1 bs₂_1,&#10;    as₁_1.size = bs₁_1.size ∧&#10;      { toArray := as₁, size_toArray := hw }.toArray ++ { toArray := as₂, size_toArray := hx }.toArray =&#10;          as₁_1 ++ as₂_1 ∧&#10;        { toArray := bs₁, size_toArray := hy }.toArray ++ { toArray := bs₂, size_toArray := hz }.toArray =&#10;            bs₁_1 ++ bs₂_1 ∧&#10;          xs = Array.zipWith f as₁_1 bs₁_1 ∧ ys = Array.zipWith f as₂_1 bs₂_1" tactic="simp only at w₁ w₂">
                            <AtomNode start="(145, 5)" end="(145, 9)" leading="" trailing=" " val="simp"/>
                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                              <NullNode/>
                            </OtherNode>
                            <NullNode/>
                            <NullNode start="(145, 10)" end="(145, 14)">
                              <AtomNode start="(145, 10)" end="(145, 14)" leading="" trailing=" " val="only"/>
                            </NullNode>
                            <NullNode/>
                            <NullNode start="(145, 15)" end="(145, 23)">
                              <OtherNode start="(145, 15)" end="(145, 23)" kind="Lean.Parser.Tactic.location">
                                <AtomNode start="(145, 15)" end="(145, 17)" leading="" trailing=" " val="at"/>
                                <OtherNode start="(145, 18)" end="(145, 23)" kind="Lean.Parser.Tactic.locationHyp">
                                  <NullNode start="(145, 18)" end="(145, 23)">
                                    <IdentNode start="(145, 18)" end="(145, 20)" leading="" trailing=" " raw_val="w₁" val="w₁"/>
                                    <IdentNode start="(145, 21)" end="(145, 23)" leading="" trailing="&#10;    " raw_val="w₂" val="w₂"/>
                                  </NullNode>
                                </OtherNode>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                          <NullNode/>
                          <OtherNode start="(146, 5)" end="(146, 65)" kind="Lean.Parser.Tactic.exact" state_before="case mk.mk.mk.mk.mpr.intro.mk.intro.mk.intro.mk.intro.mk.intro.intro.intro&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;xs ys : Array γ&#10;as₁ : Array α&#10;hw : as₁.size = xs.size&#10;as₂ : Array α&#10;hx : as₂.size = ys.size&#10;bs₁ : Array β&#10;hy : bs₁.size = xs.size&#10;bs₂ : Array β&#10;hz : bs₂.size = ys.size&#10;h₁ :&#10;  ({ toArray := as₁, size_toArray := hw }.toArray ++ { toArray := as₂, size_toArray := hx }.toArray).size =&#10;    xs.size + ys.size&#10;h₂ :&#10;  ({ toArray := bs₁, size_toArray := hy }.toArray ++ { toArray := bs₂, size_toArray := hz }.toArray).size =&#10;    xs.size + ys.size&#10;w₁ : xs = Array.zipWith f as₁ bs₁&#10;w₂ : ys = Array.zipWith f as₂ bs₂&#10;⊢ ∃ as₁_1 as₂_1 bs₁_1 bs₂_1,&#10;    as₁_1.size = bs₁_1.size ∧&#10;      { toArray := as₁, size_toArray := hw }.toArray ++ { toArray := as₂, size_toArray := hx }.toArray =&#10;          as₁_1 ++ as₂_1 ∧&#10;        { toArray := bs₁, size_toArray := hy }.toArray ++ { toArray := bs₂, size_toArray := hz }.toArray =&#10;            bs₁_1 ++ bs₂_1 ∧&#10;          xs = Array.zipWith f as₁_1 bs₁_1 ∧ ys = Array.zipWith f as₂_1 bs₂_1" state_after="no goals" tactic="exact ⟨as₁, as₂, bs₁, bs₂, by simpa [hw, hy] using ⟨w₁, w₂⟩⟩">
                            <AtomNode start="(146, 5)" end="(146, 10)" leading="" trailing=" " val="exact"/>
                            <OtherNode start="(146, 11)" end="(146, 65)" kind="Lean.Parser.Term.anonymousCtor">
                              <AtomNode start="(146, 11)" end="(146, 12)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(146, 12)" end="(146, 64)">
                                <IdentNode start="(146, 12)" end="(146, 15)" leading="" trailing="" raw_val="as₁" val="as₁"/>
                                <AtomNode start="(146, 15)" end="(146, 16)" leading="" trailing=" " val=","/>
                                <IdentNode start="(146, 17)" end="(146, 20)" leading="" trailing="" raw_val="as₂" val="as₂"/>
                                <AtomNode start="(146, 20)" end="(146, 21)" leading="" trailing=" " val=","/>
                                <IdentNode start="(146, 22)" end="(146, 25)" leading="" trailing="" raw_val="bs₁" val="bs₁"/>
                                <AtomNode start="(146, 25)" end="(146, 26)" leading="" trailing=" " val=","/>
                                <IdentNode start="(146, 27)" end="(146, 30)" leading="" trailing="" raw_val="bs₂" val="bs₂"/>
                                <AtomNode start="(146, 30)" end="(146, 31)" leading="" trailing=" " val=","/>
                                <TermBytacticNode start="(146, 32)" end="(146, 64)">
                                  <AtomNode start="(146, 32)" end="(146, 34)" leading="" trailing=" " val="by"/>
                                  <TacticTacticseqNode start="(146, 35)" end="(146, 64)">
                                    <TacticTacticseq1IndentedNode start="(146, 35)" end="(146, 64)">
                                      <NullNode start="(146, 35)" end="(146, 64)">
                                        <OtherNode start="(146, 35)" end="(146, 64)" kind="Lean.Parser.Tactic.simpa" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;xs ys : Array γ&#10;as₁ : Array α&#10;hw : as₁.size = xs.size&#10;as₂ : Array α&#10;hx : as₂.size = ys.size&#10;bs₁ : Array β&#10;hy : bs₁.size = xs.size&#10;bs₂ : Array β&#10;hz : bs₂.size = ys.size&#10;h₁ :&#10;  ({ toArray := as₁, size_toArray := hw }.toArray ++ { toArray := as₂, size_toArray := hx }.toArray).size =&#10;    xs.size + ys.size&#10;h₂ :&#10;  ({ toArray := bs₁, size_toArray := hy }.toArray ++ { toArray := bs₂, size_toArray := hz }.toArray).size =&#10;    xs.size + ys.size&#10;w₁ : xs = Array.zipWith f as₁ bs₁&#10;w₂ : ys = Array.zipWith f as₂ bs₂&#10;⊢ as₁.size = bs₁.size ∧&#10;    { toArray := as₁, size_toArray := hw }.toArray ++ { toArray := as₂, size_toArray := hx }.toArray = as₁ ++ as₂ ∧&#10;      { toArray := bs₁, size_toArray := hy }.toArray ++ { toArray := bs₂, size_toArray := hz }.toArray = bs₁ ++ bs₂ ∧&#10;        xs = Array.zipWith f as₁ bs₁ ∧ ys = Array.zipWith f as₂ bs₂" state_after="no goals" tactic="simpa [hw, hy] using ⟨w₁, w₂⟩">
                                          <AtomNode start="(146, 35)" end="(146, 40)" leading="" trailing=" " val="simpa"/>
                                          <NullNode/>
                                          <NullNode/>
                                          <OtherNode start="(146, 41)" end="(146, 64)" kind="Lean.Parser.Tactic.simpaArgsRest">
                                            <OtherNode kind="Lean.Parser.Tactic.optConfig">
                                              <NullNode/>
                                            </OtherNode>
                                            <NullNode/>
                                            <NullNode/>
                                            <NullNode start="(146, 41)" end="(146, 49)">
                                              <OtherNode start="(146, 41)" end="(146, 49)" kind="Lean.Parser.Tactic.simpArgs">
                                                <AtomNode start="(146, 41)" end="(146, 42)" leading="" trailing="" val="["/>
                                                <NullNode start="(146, 42)" end="(146, 48)">
                                                  <OtherNode start="(146, 42)" end="(146, 44)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(146, 42)" end="(146, 44)" leading="" trailing="" raw_val="hw" val="hw"/>
                                                  </OtherNode>
                                                  <AtomNode start="(146, 44)" end="(146, 45)" leading="" trailing=" " val=","/>
                                                  <OtherNode start="(146, 46)" end="(146, 48)" kind="Lean.Parser.Tactic.simpLemma">
                                                    <NullNode/>
                                                    <NullNode/>
                                                    <IdentNode start="(146, 46)" end="(146, 48)" leading="" trailing="" raw_val="hy" val="hy"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <AtomNode start="(146, 48)" end="(146, 49)" leading="" trailing=" " val="]"/>
                                              </OtherNode>
                                            </NullNode>
                                            <NullNode start="(146, 50)" end="(146, 64)">
                                              <AtomNode start="(146, 50)" end="(146, 55)" leading="" trailing=" " val="using"/>
                                              <OtherNode start="(146, 56)" end="(146, 64)" kind="Lean.Parser.Term.anonymousCtor">
                                                <AtomNode start="(146, 56)" end="(146, 57)" leading="" trailing="" val="⟨"/>
                                                <NullNode start="(146, 57)" end="(146, 63)">
                                                  <IdentNode start="(146, 57)" end="(146, 59)" leading="" trailing="" raw_val="w₁" val="w₁"/>
                                                  <AtomNode start="(146, 59)" end="(146, 60)" leading="" trailing=" " val=","/>
                                                  <IdentNode start="(146, 61)" end="(146, 63)" leading="" trailing="" raw_val="w₂" val="w₂"/>
                                                </NullNode>
                                                <AtomNode start="(146, 63)" end="(146, 64)" leading="" trailing="" val="⟩"/>
                                              </OtherNode>
                                            </NullNode>
                                          </OtherNode>
                                        </OtherNode>
                                      </NullNode>
                                    </TacticTacticseq1IndentedNode>
                                  </TacticTacticseqNode>
                                </TermBytacticNode>
                              </NullNode>
                              <AtomNode start="(146, 64)" end="(146, 65)" leading="" trailing="&#10;&#10;" val="⟩"/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(148, 1)" end="(151, 7)" name="zipWith_replicate" full_name="Vector.zipWith_replicate">
      <CommandDeclmodifiersNode start="(148, 1)" end="(148, 8)">
        <NullNode/>
        <NullNode start="(148, 1)" end="(148, 8)">
          <OtherNode start="(148, 1)" end="(148, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(148, 1)" end="(148, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(148, 3)" end="(148, 7)">
              <OtherNode start="(148, 3)" end="(148, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(148, 3)" end="(148, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(148, 3)" end="(148, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(148, 7)" end="(148, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(148, 9)" end="(151, 7)" name="zipWith_replicate" full_name="Vector.zipWith_replicate" _is_private_decl="False">
        <AtomNode start="(148, 9)" end="(148, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(148, 17)" end="(148, 34)">
          <IdentNode start="(148, 17)" end="(148, 34)" leading="" trailing=" " raw_val="zipWith_replicate" val="zipWith_replicate"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(148, 35)" end="(149, 68)">
          <NullNode start="(148, 35)" end="(148, 60)">
            <OtherNode start="(148, 35)" end="(148, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(148, 35)" end="(148, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(148, 36)" end="(148, 37)">
                <IdentNode start="(148, 36)" end="(148, 37)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(148, 38)" end="(148, 41)">
                <AtomNode start="(148, 38)" end="(148, 39)" leading="" trailing=" " val=":"/>
                <IdentNode start="(148, 40)" end="(148, 41)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(148, 41)" end="(148, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(148, 43)" end="(148, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(148, 43)" end="(148, 44)" leading="" trailing="" val="{"/>
              <NullNode start="(148, 44)" end="(148, 45)">
                <IdentNode start="(148, 44)" end="(148, 45)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(148, 46)" end="(148, 49)">
                <AtomNode start="(148, 46)" end="(148, 47)" leading="" trailing=" " val=":"/>
                <IdentNode start="(148, 48)" end="(148, 49)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(148, 49)" end="(148, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(148, 51)" end="(148, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(148, 51)" end="(148, 52)" leading="" trailing="" val="{"/>
              <NullNode start="(148, 52)" end="(148, 53)">
                <IdentNode start="(148, 52)" end="(148, 53)" leading="" trailing=" " raw_val="n" val="n"/>
              </NullNode>
              <NullNode start="(148, 54)" end="(148, 59)">
                <AtomNode start="(148, 54)" end="(148, 55)" leading="" trailing=" " val=":"/>
                <IdentNode start="(148, 56)" end="(148, 59)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(148, 59)" end="(148, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(148, 61)" end="(149, 68)">
            <AtomNode start="(148, 61)" end="(148, 62)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(149, 5)" end="(149, 68)" kind="«term_=_»">
              <OtherNode start="(149, 5)" end="(149, 46)" kind="Lean.Parser.Term.app">
                <IdentNode start="(149, 5)" end="(149, 12)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="Vector.zipWith" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(149, 13)" end="(149, 46)">
                  <IdentNode start="(149, 13)" end="(149, 14)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(149, 15)" end="(149, 30)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(149, 15)" end="(149, 16)" leading="" trailing="" val="("/>
                    <OtherNode start="(149, 16)" end="(149, 29)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(149, 16)" end="(149, 25)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Vector.replicate" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                      <NullNode start="(149, 26)" end="(149, 29)">
                        <IdentNode start="(149, 26)" end="(149, 27)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(149, 28)" end="(149, 29)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(149, 29)" end="(149, 30)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(149, 31)" end="(149, 46)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(149, 31)" end="(149, 32)" leading="" trailing="" val="("/>
                    <OtherNode start="(149, 32)" end="(149, 45)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(149, 32)" end="(149, 41)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Vector.replicate" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                      <NullNode start="(149, 42)" end="(149, 45)">
                        <IdentNode start="(149, 42)" end="(149, 43)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(149, 44)" end="(149, 45)" leading="" trailing="" raw_val="b" val="b"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(149, 45)" end="(149, 46)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(149, 47)" end="(149, 48)" leading="" trailing=" " val="="/>
              <OtherNode start="(149, 49)" end="(149, 68)" kind="Lean.Parser.Term.app">
                <IdentNode start="(149, 49)" end="(149, 58)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Vector.replicate" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(149, 59)" end="(149, 68)">
                  <IdentNode start="(149, 59)" end="(149, 60)" leading="" trailing=" " raw_val="n" val="n"/>
                  <OtherNode start="(149, 61)" end="(149, 68)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(149, 61)" end="(149, 62)" leading="" trailing="" val="("/>
                    <OtherNode start="(149, 62)" end="(149, 67)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(149, 62)" end="(149, 63)" leading="" trailing=" " raw_val="f" val="f"/>
                      <NullNode start="(149, 64)" end="(149, 67)">
                        <IdentNode start="(149, 64)" end="(149, 65)" leading="" trailing=" " raw_val="a" val="a"/>
                        <IdentNode start="(149, 66)" end="(149, 67)" leading="" trailing="" raw_val="b" val="b"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(149, 67)" end="(149, 68)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(149, 69)" end="(151, 7)">
          <AtomNode start="(149, 69)" end="(149, 71)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(149, 72)" end="(151, 7)">
            <AtomNode start="(149, 72)" end="(149, 74)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(150, 3)" end="(151, 7)">
              <TacticTacticseq1IndentedNode start="(150, 3)" end="(151, 7)">
                <NullNode start="(150, 3)" end="(151, 7)">
                  <OtherNode start="(150, 3)" end="(150, 6)" kind="Lean.Elab.Tactic.Ext.ext" state_before="α : Type u_1&#10;β : Type u_2&#10;α✝ : Type u_3&#10;f : α → β → α✝&#10;a : α&#10;b : β&#10;n : Nat&#10;⊢ zipWith f (replicate n a) (replicate n b) = replicate n (f a b)" state_after="case h&#10;α : Type u_1&#10;β : Type u_2&#10;α✝ : Type u_3&#10;f : α → β → α✝&#10;a : α&#10;b : β&#10;n i✝ : Nat&#10;x✝ : i✝ &amp;lt; n&#10;⊢ (zipWith f (replicate n a) (replicate n b))[i✝] = (replicate n (f a b))[i✝]" tactic="ext">
                    <AtomNode start="(150, 3)" end="(150, 6)" leading="" trailing="&#10;  " val="ext"/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(151, 3)" end="(151, 7)" kind="Lean.Parser.Tactic.simp" state_before="case h&#10;α : Type u_1&#10;β : Type u_2&#10;α✝ : Type u_3&#10;f : α → β → α✝&#10;a : α&#10;b : β&#10;n i✝ : Nat&#10;x✝ : i✝ &amp;lt; n&#10;⊢ (zipWith f (replicate n a) (replicate n b))[i✝] = (replicate n (f a b))[i✝]" state_after="no goals" tactic="simp">
                    <AtomNode start="(151, 3)" end="(151, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(153, 1)" end="(154, 46)" name="zipWith_mkVector" full_name="Vector.zipWith_mkVector">
      <CommandDeclmodifiersNode start="(153, 1)" end="(153, 56)">
        <NullNode/>
        <NullNode start="(153, 1)" end="(153, 56)">
          <OtherNode start="(153, 1)" end="(153, 56)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(153, 1)" end="(153, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(153, 3)" end="(153, 55)">
              <OtherNode start="(153, 3)" end="(153, 55)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(153, 3)" end="(153, 55)" kind="Lean.deprecated">
                  <AtomNode start="(153, 3)" end="(153, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(153, 14)" end="(153, 31)">
                    <IdentNode start="(153, 14)" end="(153, 31)" leading="" trailing=" " raw_val="zipWith_replicate" val="zipWith_replicate" full_name="Vector.zipWith_replicate" mod_name="Init.Data.Vector.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Zip.lean" def_start="(148, 17)" def_end="(148, 34)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(153, 32)" end="(153, 55)">
                    <AtomNode start="(153, 32)" end="(153, 33)" leading="" trailing="" val="("/>
                    <AtomNode start="(153, 33)" end="(153, 38)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(153, 39)" end="(153, 41)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(153, 42)" end="(153, 54)" kind="str">
                      <AtomNode start="(153, 42)" end="(153, 54)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(153, 54)" end="(153, 55)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(153, 55)" end="(153, 56)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(154, 1)" end="(154, 46)" name="zipWith_mkVector">
        <AtomNode start="(154, 1)" end="(154, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(154, 8)" end="(154, 24)">
          <IdentNode start="(154, 8)" end="(154, 24)" leading="" trailing=" " raw_val="zipWith_mkVector" val="zipWith_mkVector"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(154, 25)" end="(154, 46)">
          <AtomNode start="(154, 25)" end="(154, 27)" leading="" trailing=" " val=":="/>
          <OtherNode start="(154, 28)" end="(154, 46)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(154, 28)" end="(154, 29)" leading="" trailing="" val="@"/>
            <IdentNode start="(154, 29)" end="(154, 46)" leading="" trailing="&#10;&#10;" raw_val="zipWith_replicate" val="zipWith_replicate" full_name="Vector.zipWith_replicate" mod_name="Init.Data.Vector.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Zip.lean" def_start="(148, 17)" def_end="(148, 34)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(156, 1)" end="(160, 42)" name="map_uncurry_zip_eq_zipWith" full_name="Vector.map_uncurry_zip_eq_zipWith">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(156, 1)" end="(160, 42)" name="map_uncurry_zip_eq_zipWith" full_name="Vector.map_uncurry_zip_eq_zipWith" _is_private_decl="False">
        <AtomNode start="(156, 1)" end="(156, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(156, 9)" end="(156, 35)">
          <IdentNode start="(156, 9)" end="(156, 35)" leading="" trailing=" " raw_val="map_uncurry_zip_eq_zipWith" val="map_uncurry_zip_eq_zipWith"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(156, 36)" end="(157, 59)">
          <NullNode start="(156, 36)" end="(156, 87)">
            <OtherNode start="(156, 36)" end="(156, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(156, 36)" end="(156, 37)" leading="" trailing="" val="{"/>
              <NullNode start="(156, 37)" end="(156, 38)">
                <IdentNode start="(156, 37)" end="(156, 38)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(156, 39)" end="(156, 50)">
                <AtomNode start="(156, 39)" end="(156, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(156, 41)" end="(156, 50)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(156, 41)" end="(156, 42)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(156, 43)" end="(156, 44)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(156, 45)" end="(156, 50)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(156, 45)" end="(156, 46)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(156, 47)" end="(156, 48)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(156, 49)" end="(156, 50)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(156, 50)" end="(156, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(156, 52)" end="(156, 69)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(156, 52)" end="(156, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(156, 53)" end="(156, 55)">
                <IdentNode start="(156, 53)" end="(156, 55)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(156, 56)" end="(156, 68)">
                <AtomNode start="(156, 56)" end="(156, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(156, 58)" end="(156, 68)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(156, 58)" end="(156, 64)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(156, 65)" end="(156, 68)">
                    <IdentNode start="(156, 65)" end="(156, 66)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(156, 67)" end="(156, 68)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(156, 68)" end="(156, 69)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(156, 70)" end="(156, 87)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(156, 70)" end="(156, 71)" leading="" trailing="" val="{"/>
              <NullNode start="(156, 71)" end="(156, 73)">
                <IdentNode start="(156, 71)" end="(156, 73)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(156, 74)" end="(156, 86)">
                <AtomNode start="(156, 74)" end="(156, 75)" leading="" trailing=" " val=":"/>
                <OtherNode start="(156, 76)" end="(156, 86)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(156, 76)" end="(156, 82)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(156, 83)" end="(156, 86)">
                    <IdentNode start="(156, 83)" end="(156, 84)" leading="" trailing=" " raw_val="β" val="β"/>
                    <IdentNode start="(156, 85)" end="(156, 86)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(156, 86)" end="(156, 87)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(156, 88)" end="(157, 59)">
            <AtomNode start="(156, 88)" end="(156, 89)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(157, 5)" end="(157, 59)" kind="«term_=_»">
              <OtherNode start="(157, 5)" end="(157, 41)" kind="Lean.Parser.Term.app">
                <IdentNode start="(157, 5)" end="(157, 8)" leading="" trailing=" " raw_val="map" val="map" full_name="Vector.map" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(157, 9)" end="(157, 41)">
                  <OtherNode start="(157, 9)" end="(157, 29)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(157, 9)" end="(157, 10)" leading="" trailing="" val="("/>
                    <OtherNode start="(157, 10)" end="(157, 28)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(157, 10)" end="(157, 26)" leading="" trailing=" " raw_val="Function.uncurry" val="Function.uncurry" full_name="Function.uncurry" mod_name="Init.Data.Function" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Function.lean"/>
                      <NullNode start="(157, 27)" end="(157, 28)">
                        <IdentNode start="(157, 27)" end="(157, 28)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(157, 28)" end="(157, 29)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(157, 30)" end="(157, 41)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(157, 30)" end="(157, 31)" leading="" trailing="" val="("/>
                    <OtherNode start="(157, 31)" end="(157, 40)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(157, 31)" end="(157, 37)" leading="" trailing=" " raw_val="as.zip" val="as.zip"/>
                      <NullNode start="(157, 38)" end="(157, 40)">
                        <IdentNode start="(157, 38)" end="(157, 40)" leading="" trailing="" raw_val="bs" val="bs"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(157, 40)" end="(157, 41)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(157, 42)" end="(157, 43)" leading="" trailing=" " val="="/>
              <OtherNode start="(157, 44)" end="(157, 59)" kind="Lean.Parser.Term.app">
                <IdentNode start="(157, 44)" end="(157, 51)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="Vector.zipWith" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(157, 52)" end="(157, 59)">
                  <IdentNode start="(157, 52)" end="(157, 53)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(157, 54)" end="(157, 56)" leading="" trailing=" " raw_val="as" val="as"/>
                  <IdentNode start="(157, 57)" end="(157, 59)" leading="" trailing=" " raw_val="bs" val="bs"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(157, 60)" end="(160, 42)">
          <AtomNode start="(157, 60)" end="(157, 62)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(157, 63)" end="(160, 42)">
            <AtomNode start="(157, 63)" end="(157, 65)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(158, 3)" end="(160, 42)">
              <TacticTacticseq1IndentedNode start="(158, 3)" end="(160, 42)">
                <NullNode start="(158, 3)" end="(160, 42)">
                  <OtherNode start="(158, 3)" end="(158, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;n : Nat&#10;f : α → β → γ&#10;as : Vector α n&#10;bs : Vector β n&#10;⊢ map (Function.uncurry f) (as.zip bs) = zipWith f as bs" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ map (Function.uncurry f) ({ toArray := as, size_toArray := ⋯ }.zip bs) =&#10;    zipWith f { toArray := as, size_toArray := ⋯ } bs" tactic="rcases as with ⟨as, rfl⟩">
                    <AtomNode start="(158, 3)" end="(158, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(158, 10)" end="(158, 12)">
                      <OtherNode start="(158, 10)" end="(158, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(158, 10)" end="(158, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(158, 13)" end="(158, 27)">
                      <AtomNode start="(158, 13)" end="(158, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(158, 18)" end="(158, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(158, 18)" end="(158, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(158, 18)" end="(158, 27)">
                            <OtherNode start="(158, 18)" end="(158, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(158, 18)" end="(158, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(158, 19)" end="(158, 26)">
                                <OtherNode start="(158, 19)" end="(158, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(158, 19)" end="(158, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(158, 19)" end="(158, 21)">
                                      <OtherNode start="(158, 19)" end="(158, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(158, 19)" end="(158, 21)" leading="" trailing="" raw_val="as" val="as"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(158, 21)" end="(158, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(158, 23)" end="(158, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(158, 23)" end="(158, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(158, 23)" end="(158, 26)">
                                      <OtherNode start="(158, 23)" end="(158, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(158, 23)" end="(158, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(158, 26)" end="(158, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(159, 3)" end="(159, 25)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ map (Function.uncurry f) ({ toArray := as, size_toArray := ⋯ }.zip bs) =&#10;    zipWith f { toArray := as, size_toArray := ⋯ } bs" state_after="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ map (Function.uncurry f) ({ toArray := as, size_toArray := ⋯ }.zip { toArray := bs, size_toArray := h }) =&#10;    zipWith f { toArray := as, size_toArray := ⋯ } { toArray := bs, size_toArray := h }" tactic="rcases bs with ⟨bs, h⟩">
                    <AtomNode start="(159, 3)" end="(159, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(159, 10)" end="(159, 12)">
                      <OtherNode start="(159, 10)" end="(159, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(159, 10)" end="(159, 12)" leading="" trailing=" " raw_val="bs" val="bs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(159, 13)" end="(159, 25)">
                      <AtomNode start="(159, 13)" end="(159, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(159, 18)" end="(159, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(159, 18)" end="(159, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(159, 18)" end="(159, 25)">
                            <OtherNode start="(159, 18)" end="(159, 25)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(159, 18)" end="(159, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(159, 19)" end="(159, 24)">
                                <OtherNode start="(159, 19)" end="(159, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(159, 19)" end="(159, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(159, 19)" end="(159, 21)">
                                      <OtherNode start="(159, 19)" end="(159, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(159, 19)" end="(159, 21)" leading="" trailing="" raw_val="bs" val="bs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(159, 21)" end="(159, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(159, 23)" end="(159, 24)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(159, 23)" end="(159, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(159, 23)" end="(159, 24)">
                                      <OtherNode start="(159, 23)" end="(159, 24)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(159, 23)" end="(159, 24)" leading="" trailing="" raw_val="h" val="h"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(159, 24)" end="(159, 25)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(160, 3)" end="(160, 42)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ map (Function.uncurry f) ({ toArray := as, size_toArray := ⋯ }.zip { toArray := bs, size_toArray := h }) =&#10;    zipWith f { toArray := as, size_toArray := ⋯ } { toArray := bs, size_toArray := h }" state_after="no goals" tactic="simp [Array.map_uncurry_zip_eq_zipWith]">
                    <AtomNode start="(160, 3)" end="(160, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(160, 8)" end="(160, 42)">
                      <AtomNode start="(160, 8)" end="(160, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(160, 9)" end="(160, 41)">
                        <OtherNode start="(160, 9)" end="(160, 41)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(160, 9)" end="(160, 41)" leading="" trailing="" raw_val="Array.map_uncurry_zip_eq_zipWith" val="Array.map_uncurry_zip_eq_zipWith" full_name="Array.map_uncurry_zip_eq_zipWith" mod_name="Init.Data.Array.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Zip.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(160, 41)" end="(160, 42)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(162, 1)" end="(166, 34)" name="map_zip_eq_zipWith" full_name="Vector.map_zip_eq_zipWith">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(162, 1)" end="(166, 34)" name="map_zip_eq_zipWith" full_name="Vector.map_zip_eq_zipWith" _is_private_decl="False">
        <AtomNode start="(162, 1)" end="(162, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(162, 9)" end="(162, 27)">
          <IdentNode start="(162, 9)" end="(162, 27)" leading="" trailing=" " raw_val="map_zip_eq_zipWith" val="map_zip_eq_zipWith"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(162, 28)" end="(163, 57)">
          <NullNode start="(162, 28)" end="(162, 79)">
            <OtherNode start="(162, 28)" end="(162, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(162, 28)" end="(162, 29)" leading="" trailing="" val="{"/>
              <NullNode start="(162, 29)" end="(162, 30)">
                <IdentNode start="(162, 29)" end="(162, 30)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(162, 31)" end="(162, 42)">
                <AtomNode start="(162, 31)" end="(162, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(162, 33)" end="(162, 42)" kind="Lean.Parser.Term.arrow">
                  <OtherNode start="(162, 33)" end="(162, 38)" kind="«term_×_»">
                    <IdentNode start="(162, 33)" end="(162, 34)" leading="" trailing=" " raw_val="α" val="α"/>
                    <AtomNode start="(162, 35)" end="(162, 36)" leading="" trailing=" " val="×"/>
                    <IdentNode start="(162, 37)" end="(162, 38)" leading="" trailing=" " raw_val="β" val="β"/>
                  </OtherNode>
                  <AtomNode start="(162, 39)" end="(162, 40)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(162, 41)" end="(162, 42)" leading="" trailing="" raw_val="γ" val="γ"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(162, 42)" end="(162, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(162, 44)" end="(162, 61)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(162, 44)" end="(162, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(162, 45)" end="(162, 47)">
                <IdentNode start="(162, 45)" end="(162, 47)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(162, 48)" end="(162, 60)">
                <AtomNode start="(162, 48)" end="(162, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(162, 50)" end="(162, 60)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(162, 50)" end="(162, 56)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(162, 57)" end="(162, 60)">
                    <IdentNode start="(162, 57)" end="(162, 58)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(162, 59)" end="(162, 60)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(162, 60)" end="(162, 61)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(162, 62)" end="(162, 79)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(162, 62)" end="(162, 63)" leading="" trailing="" val="{"/>
              <NullNode start="(162, 63)" end="(162, 65)">
                <IdentNode start="(162, 63)" end="(162, 65)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(162, 66)" end="(162, 78)">
                <AtomNode start="(162, 66)" end="(162, 67)" leading="" trailing=" " val=":"/>
                <OtherNode start="(162, 68)" end="(162, 78)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(162, 68)" end="(162, 74)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(162, 75)" end="(162, 78)">
                    <IdentNode start="(162, 75)" end="(162, 76)" leading="" trailing=" " raw_val="β" val="β"/>
                    <IdentNode start="(162, 77)" end="(162, 78)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(162, 78)" end="(162, 79)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(162, 80)" end="(163, 57)">
            <AtomNode start="(162, 80)" end="(162, 81)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(163, 5)" end="(163, 57)" kind="«term_=_»">
              <OtherNode start="(163, 5)" end="(163, 22)" kind="Lean.Parser.Term.app">
                <IdentNode start="(163, 5)" end="(163, 8)" leading="" trailing=" " raw_val="map" val="map" full_name="Vector.map" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(163, 9)" end="(163, 22)">
                  <IdentNode start="(163, 9)" end="(163, 10)" leading="" trailing=" " raw_val="f" val="f"/>
                  <OtherNode start="(163, 11)" end="(163, 22)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(163, 11)" end="(163, 12)" leading="" trailing="" val="("/>
                    <OtherNode start="(163, 12)" end="(163, 21)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(163, 12)" end="(163, 18)" leading="" trailing=" " raw_val="as.zip" val="as.zip"/>
                      <NullNode start="(163, 19)" end="(163, 21)">
                        <IdentNode start="(163, 19)" end="(163, 21)" leading="" trailing="" raw_val="bs" val="bs"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(163, 21)" end="(163, 22)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(163, 23)" end="(163, 24)" leading="" trailing=" " val="="/>
              <OtherNode start="(163, 25)" end="(163, 57)" kind="Lean.Parser.Term.app">
                <IdentNode start="(163, 25)" end="(163, 32)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="Vector.zipWith" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(163, 33)" end="(163, 57)">
                  <OtherNode start="(163, 33)" end="(163, 51)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(163, 33)" end="(163, 34)" leading="" trailing="" val="("/>
                    <OtherNode start="(163, 34)" end="(163, 50)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(163, 34)" end="(163, 48)" leading="" trailing=" " raw_val="Function.curry" val="Function.curry" full_name="Function.curry" mod_name="Init.Data.Function" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Function.lean"/>
                      <NullNode start="(163, 49)" end="(163, 50)">
                        <IdentNode start="(163, 49)" end="(163, 50)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(163, 50)" end="(163, 51)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(163, 52)" end="(163, 54)" leading="" trailing=" " raw_val="as" val="as"/>
                  <IdentNode start="(163, 55)" end="(163, 57)" leading="" trailing=" " raw_val="bs" val="bs"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(163, 58)" end="(166, 34)">
          <AtomNode start="(163, 58)" end="(163, 60)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(163, 61)" end="(166, 34)">
            <AtomNode start="(163, 61)" end="(163, 63)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(164, 3)" end="(166, 34)">
              <TacticTacticseq1IndentedNode start="(164, 3)" end="(166, 34)">
                <NullNode start="(164, 3)" end="(166, 34)">
                  <OtherNode start="(164, 3)" end="(164, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;n : Nat&#10;f : α × β → γ&#10;as : Vector α n&#10;bs : Vector β n&#10;⊢ map f (as.zip bs) = zipWith (Function.curry f) as bs" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α × β → γ&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ map f ({ toArray := as, size_toArray := ⋯ }.zip bs) =&#10;    zipWith (Function.curry f) { toArray := as, size_toArray := ⋯ } bs" tactic="rcases as with ⟨as, rfl⟩">
                    <AtomNode start="(164, 3)" end="(164, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(164, 10)" end="(164, 12)">
                      <OtherNode start="(164, 10)" end="(164, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(164, 10)" end="(164, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(164, 13)" end="(164, 27)">
                      <AtomNode start="(164, 13)" end="(164, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(164, 18)" end="(164, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(164, 18)" end="(164, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(164, 18)" end="(164, 27)">
                            <OtherNode start="(164, 18)" end="(164, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(164, 18)" end="(164, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(164, 19)" end="(164, 26)">
                                <OtherNode start="(164, 19)" end="(164, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(164, 19)" end="(164, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(164, 19)" end="(164, 21)">
                                      <OtherNode start="(164, 19)" end="(164, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(164, 19)" end="(164, 21)" leading="" trailing="" raw_val="as" val="as"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(164, 21)" end="(164, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(164, 23)" end="(164, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(164, 23)" end="(164, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(164, 23)" end="(164, 26)">
                                      <OtherNode start="(164, 23)" end="(164, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(164, 23)" end="(164, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(164, 26)" end="(164, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(165, 3)" end="(165, 25)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α × β → γ&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ map f ({ toArray := as, size_toArray := ⋯ }.zip bs) =&#10;    zipWith (Function.curry f) { toArray := as, size_toArray := ⋯ } bs" state_after="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α × β → γ&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ map f ({ toArray := as, size_toArray := ⋯ }.zip { toArray := bs, size_toArray := h }) =&#10;    zipWith (Function.curry f) { toArray := as, size_toArray := ⋯ } { toArray := bs, size_toArray := h }" tactic="rcases bs with ⟨bs, h⟩">
                    <AtomNode start="(165, 3)" end="(165, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(165, 10)" end="(165, 12)">
                      <OtherNode start="(165, 10)" end="(165, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(165, 10)" end="(165, 12)" leading="" trailing=" " raw_val="bs" val="bs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(165, 13)" end="(165, 25)">
                      <AtomNode start="(165, 13)" end="(165, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(165, 18)" end="(165, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(165, 18)" end="(165, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(165, 18)" end="(165, 25)">
                            <OtherNode start="(165, 18)" end="(165, 25)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(165, 18)" end="(165, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(165, 19)" end="(165, 24)">
                                <OtherNode start="(165, 19)" end="(165, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(165, 19)" end="(165, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(165, 19)" end="(165, 21)">
                                      <OtherNode start="(165, 19)" end="(165, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(165, 19)" end="(165, 21)" leading="" trailing="" raw_val="bs" val="bs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(165, 21)" end="(165, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(165, 23)" end="(165, 24)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(165, 23)" end="(165, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(165, 23)" end="(165, 24)">
                                      <OtherNode start="(165, 23)" end="(165, 24)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(165, 23)" end="(165, 24)" leading="" trailing="" raw_val="h" val="h"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(165, 24)" end="(165, 25)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(166, 3)" end="(166, 34)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α × β → γ&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ map f ({ toArray := as, size_toArray := ⋯ }.zip { toArray := bs, size_toArray := h }) =&#10;    zipWith (Function.curry f) { toArray := as, size_toArray := ⋯ } { toArray := bs, size_toArray := h }" state_after="no goals" tactic="simp [Array.map_zip_eq_zipWith]">
                    <AtomNode start="(166, 3)" end="(166, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(166, 8)" end="(166, 34)">
                      <AtomNode start="(166, 8)" end="(166, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(166, 9)" end="(166, 33)">
                        <OtherNode start="(166, 9)" end="(166, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(166, 9)" end="(166, 33)" leading="" trailing="" raw_val="Array.map_zip_eq_zipWith" val="Array.map_zip_eq_zipWith" full_name="Array.map_zip_eq_zipWith" mod_name="Init.Data.Array.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Zip.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(166, 33)" end="(166, 34)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(168, 1)" end="(172, 34)" name="reverse_zipWith" full_name="Vector.reverse_zipWith">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(168, 1)" end="(172, 34)" name="reverse_zipWith" full_name="Vector.reverse_zipWith" _is_private_decl="False">
        <AtomNode start="(168, 1)" end="(168, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(168, 9)" end="(168, 24)">
          <IdentNode start="(168, 9)" end="(168, 24)" leading="" trailing=" " raw_val="reverse_zipWith" val="reverse_zipWith"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(168, 25)" end="(169, 64)">
          <NullNode start="(168, 25)" end="(168, 76)">
            <OtherNode start="(168, 25)" end="(168, 40)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(168, 25)" end="(168, 26)" leading="" trailing="" val="{"/>
              <NullNode start="(168, 26)" end="(168, 27)">
                <IdentNode start="(168, 26)" end="(168, 27)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(168, 28)" end="(168, 39)">
                <AtomNode start="(168, 28)" end="(168, 29)" leading="" trailing=" " val=":"/>
                <OtherNode start="(168, 30)" end="(168, 39)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(168, 30)" end="(168, 31)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(168, 32)" end="(168, 33)" leading="" trailing=" " val="→"/>
                  <OtherNode start="(168, 34)" end="(168, 39)" kind="Lean.Parser.Term.arrow">
                    <IdentNode start="(168, 34)" end="(168, 35)" leading="" trailing=" " raw_val="β" val="β"/>
                    <AtomNode start="(168, 36)" end="(168, 37)" leading="" trailing=" " val="→"/>
                    <IdentNode start="(168, 38)" end="(168, 39)" leading="" trailing="" raw_val="γ" val="γ"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(168, 39)" end="(168, 40)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(168, 41)" end="(168, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(168, 41)" end="(168, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(168, 42)" end="(168, 44)">
                <IdentNode start="(168, 42)" end="(168, 44)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(168, 45)" end="(168, 57)">
                <AtomNode start="(168, 45)" end="(168, 46)" leading="" trailing=" " val=":"/>
                <OtherNode start="(168, 47)" end="(168, 57)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(168, 47)" end="(168, 53)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(168, 54)" end="(168, 57)">
                    <IdentNode start="(168, 54)" end="(168, 55)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(168, 56)" end="(168, 57)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(168, 57)" end="(168, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(168, 59)" end="(168, 76)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(168, 59)" end="(168, 60)" leading="" trailing="" val="{"/>
              <NullNode start="(168, 60)" end="(168, 62)">
                <IdentNode start="(168, 60)" end="(168, 62)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(168, 63)" end="(168, 75)">
                <AtomNode start="(168, 63)" end="(168, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(168, 65)" end="(168, 75)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(168, 65)" end="(168, 71)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(168, 72)" end="(168, 75)">
                    <IdentNode start="(168, 72)" end="(168, 73)" leading="" trailing=" " raw_val="β" val="β"/>
                    <IdentNode start="(168, 74)" end="(168, 75)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(168, 75)" end="(168, 76)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(168, 77)" end="(169, 64)">
            <AtomNode start="(168, 77)" end="(168, 78)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(169, 5)" end="(169, 64)" kind="«term_=_»">
              <OtherNode start="(169, 5)" end="(169, 30)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(169, 5)" end="(169, 22)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(169, 5)" end="(169, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(169, 6)" end="(169, 21)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(169, 6)" end="(169, 13)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="Vector.zipWith" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                    <NullNode start="(169, 14)" end="(169, 21)">
                      <IdentNode start="(169, 14)" end="(169, 15)" leading="" trailing=" " raw_val="f" val="f"/>
                      <IdentNode start="(169, 16)" end="(169, 18)" leading="" trailing=" " raw_val="as" val="as"/>
                      <IdentNode start="(169, 19)" end="(169, 21)" leading="" trailing="" raw_val="bs" val="bs"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(169, 21)" end="(169, 22)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(169, 22)" end="(169, 23)" leading="" trailing="" val="."/>
                <IdentNode start="(169, 23)" end="(169, 30)" leading="" trailing=" " raw_val="reverse" val="reverse" full_name="Vector.reverse" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
              </OtherNode>
              <AtomNode start="(169, 31)" end="(169, 32)" leading="" trailing=" " val="="/>
              <OtherNode start="(169, 33)" end="(169, 64)" kind="Lean.Parser.Term.app">
                <IdentNode start="(169, 33)" end="(169, 40)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="Vector.zipWith" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(169, 41)" end="(169, 64)">
                  <IdentNode start="(169, 41)" end="(169, 42)" leading="" trailing=" " raw_val="f" val="f"/>
                  <IdentNode start="(169, 43)" end="(169, 53)" leading="" trailing=" " raw_val="as.reverse" val="as.reverse"/>
                  <IdentNode start="(169, 54)" end="(169, 64)" leading="" trailing=" " raw_val="bs.reverse" val="bs.reverse"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(169, 65)" end="(172, 34)">
          <AtomNode start="(169, 65)" end="(169, 67)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(169, 68)" end="(172, 34)">
            <AtomNode start="(169, 68)" end="(169, 70)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(170, 3)" end="(172, 34)">
              <TacticTacticseq1IndentedNode start="(170, 3)" end="(172, 34)">
                <NullNode start="(170, 3)" end="(172, 34)">
                  <OtherNode start="(170, 3)" end="(170, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;n : Nat&#10;f : α → β → γ&#10;as : Vector α n&#10;bs : Vector β n&#10;⊢ (zipWith f as bs).reverse = zipWith f as.reverse bs.reverse" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ (zipWith f { toArray := as, size_toArray := ⋯ } bs).reverse =&#10;    zipWith f { toArray := as, size_toArray := ⋯ }.reverse bs.reverse" tactic="rcases as with ⟨as, rfl⟩">
                    <AtomNode start="(170, 3)" end="(170, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(170, 10)" end="(170, 12)">
                      <OtherNode start="(170, 10)" end="(170, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(170, 10)" end="(170, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(170, 13)" end="(170, 27)">
                      <AtomNode start="(170, 13)" end="(170, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(170, 18)" end="(170, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(170, 18)" end="(170, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(170, 18)" end="(170, 27)">
                            <OtherNode start="(170, 18)" end="(170, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(170, 18)" end="(170, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(170, 19)" end="(170, 26)">
                                <OtherNode start="(170, 19)" end="(170, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(170, 19)" end="(170, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(170, 19)" end="(170, 21)">
                                      <OtherNode start="(170, 19)" end="(170, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(170, 19)" end="(170, 21)" leading="" trailing="" raw_val="as" val="as"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(170, 21)" end="(170, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(170, 23)" end="(170, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(170, 23)" end="(170, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(170, 23)" end="(170, 26)">
                                      <OtherNode start="(170, 23)" end="(170, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(170, 23)" end="(170, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(170, 26)" end="(170, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(171, 3)" end="(171, 25)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ (zipWith f { toArray := as, size_toArray := ⋯ } bs).reverse =&#10;    zipWith f { toArray := as, size_toArray := ⋯ }.reverse bs.reverse" state_after="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ (zipWith f { toArray := as, size_toArray := ⋯ } { toArray := bs, size_toArray := h }).reverse =&#10;    zipWith f { toArray := as, size_toArray := ⋯ }.reverse { toArray := bs, size_toArray := h }.reverse" tactic="rcases bs with ⟨bs, h⟩">
                    <AtomNode start="(171, 3)" end="(171, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(171, 10)" end="(171, 12)">
                      <OtherNode start="(171, 10)" end="(171, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(171, 10)" end="(171, 12)" leading="" trailing=" " raw_val="bs" val="bs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(171, 13)" end="(171, 25)">
                      <AtomNode start="(171, 13)" end="(171, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(171, 18)" end="(171, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(171, 18)" end="(171, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(171, 18)" end="(171, 25)">
                            <OtherNode start="(171, 18)" end="(171, 25)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(171, 18)" end="(171, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(171, 19)" end="(171, 24)">
                                <OtherNode start="(171, 19)" end="(171, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(171, 19)" end="(171, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(171, 19)" end="(171, 21)">
                                      <OtherNode start="(171, 19)" end="(171, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(171, 19)" end="(171, 21)" leading="" trailing="" raw_val="bs" val="bs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(171, 21)" end="(171, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(171, 23)" end="(171, 24)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(171, 23)" end="(171, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(171, 23)" end="(171, 24)">
                                      <OtherNode start="(171, 23)" end="(171, 24)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(171, 23)" end="(171, 24)" leading="" trailing="" raw_val="h" val="h"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(171, 24)" end="(171, 25)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(172, 3)" end="(172, 34)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β → γ&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ (zipWith f { toArray := as, size_toArray := ⋯ } { toArray := bs, size_toArray := h }).reverse =&#10;    zipWith f { toArray := as, size_toArray := ⋯ }.reverse { toArray := bs, size_toArray := h }.reverse" state_after="no goals" tactic="simp [Array.reverse_zipWith, h]">
                    <AtomNode start="(172, 3)" end="(172, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(172, 8)" end="(172, 34)">
                      <AtomNode start="(172, 8)" end="(172, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(172, 9)" end="(172, 33)">
                        <OtherNode start="(172, 9)" end="(172, 30)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(172, 9)" end="(172, 30)" leading="" trailing="" raw_val="Array.reverse_zipWith" val="Array.reverse_zipWith" full_name="Array.reverse_zipWith" mod_name="Init.Data.Array.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Zip.lean"/>
                        </OtherNode>
                        <AtomNode start="(172, 30)" end="(172, 31)" leading="" trailing=" " val=","/>
                        <OtherNode start="(172, 32)" end="(172, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(172, 32)" end="(172, 33)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(172, 33)" end="(172, 34)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(174, 1)" end="(174, 15)" comment="### zip -/">
      <AtomNode start="(174, 1)" end="(174, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(174, 5)" end="(174, 15)" leading="" trailing="&#10;&#10;" val="### zip -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(176, 1)" end="(179, 21)" name="getElem_zip" full_name="Vector.getElem_zip">
      <CommandDeclmodifiersNode start="(176, 1)" end="(176, 8)">
        <NullNode/>
        <NullNode start="(176, 1)" end="(176, 8)">
          <OtherNode start="(176, 1)" end="(176, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(176, 1)" end="(176, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(176, 3)" end="(176, 7)">
              <OtherNode start="(176, 3)" end="(176, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(176, 3)" end="(176, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(176, 3)" end="(176, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(176, 7)" end="(176, 8)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(177, 1)" end="(179, 21)" name="getElem_zip" full_name="Vector.getElem_zip" _is_private_decl="False">
        <AtomNode start="(177, 1)" end="(177, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(177, 9)" end="(177, 20)">
          <IdentNode start="(177, 9)" end="(177, 20)" leading="" trailing=" " raw_val="getElem_zip" val="getElem_zip"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(177, 21)" end="(178, 36)">
          <NullNode start="(177, 21)" end="(177, 78)">
            <OtherNode start="(177, 21)" end="(177, 38)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(177, 21)" end="(177, 22)" leading="" trailing="" val="{"/>
              <NullNode start="(177, 22)" end="(177, 24)">
                <IdentNode start="(177, 22)" end="(177, 24)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(177, 25)" end="(177, 37)">
                <AtomNode start="(177, 25)" end="(177, 26)" leading="" trailing=" " val=":"/>
                <OtherNode start="(177, 27)" end="(177, 37)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(177, 27)" end="(177, 33)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(177, 34)" end="(177, 37)">
                    <IdentNode start="(177, 34)" end="(177, 35)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(177, 36)" end="(177, 37)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(177, 37)" end="(177, 38)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(177, 39)" end="(177, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(177, 39)" end="(177, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(177, 40)" end="(177, 42)">
                <IdentNode start="(177, 40)" end="(177, 42)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(177, 43)" end="(177, 55)">
                <AtomNode start="(177, 43)" end="(177, 44)" leading="" trailing=" " val=":"/>
                <OtherNode start="(177, 45)" end="(177, 55)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(177, 45)" end="(177, 51)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(177, 52)" end="(177, 55)">
                    <IdentNode start="(177, 52)" end="(177, 53)" leading="" trailing=" " raw_val="β" val="β"/>
                    <IdentNode start="(177, 54)" end="(177, 55)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(177, 55)" end="(177, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(177, 57)" end="(177, 66)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(177, 57)" end="(177, 58)" leading="" trailing="" val="{"/>
              <NullNode start="(177, 58)" end="(177, 59)">
                <IdentNode start="(177, 58)" end="(177, 59)" leading="" trailing=" " raw_val="i" val="i"/>
              </NullNode>
              <NullNode start="(177, 60)" end="(177, 65)">
                <AtomNode start="(177, 60)" end="(177, 61)" leading="" trailing=" " val=":"/>
                <IdentNode start="(177, 62)" end="(177, 65)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(177, 65)" end="(177, 66)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(177, 67)" end="(177, 78)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(177, 67)" end="(177, 68)" leading="" trailing="" val="{"/>
              <NullNode start="(177, 68)" end="(177, 69)">
                <IdentNode start="(177, 68)" end="(177, 69)" leading="" trailing=" " raw_val="h" val="h"/>
              </NullNode>
              <NullNode start="(177, 70)" end="(177, 77)">
                <AtomNode start="(177, 70)" end="(177, 71)" leading="" trailing=" " val=":"/>
                <OtherNode start="(177, 72)" end="(177, 77)" kind="«term_&amp;lt;_»">
                  <IdentNode start="(177, 72)" end="(177, 73)" leading="" trailing=" " raw_val="i" val="i"/>
                  <AtomNode start="(177, 74)" end="(177, 75)" leading="" trailing=" " val="&amp;lt;"/>
                  <IdentNode start="(177, 76)" end="(177, 77)" leading="" trailing="" raw_val="n" val="n"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(177, 77)" end="(177, 78)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(177, 79)" end="(178, 36)">
            <AtomNode start="(177, 79)" end="(177, 80)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(178, 5)" end="(178, 36)" kind="«term_=_»">
              <OtherNode start="(178, 5)" end="(178, 19)" kind="«term__[_]»">
                <OtherNode start="(178, 5)" end="(178, 16)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(178, 5)" end="(178, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(178, 6)" end="(178, 15)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(178, 6)" end="(178, 9)" leading="" trailing=" " raw_val="zip" val="zip" full_name="Vector.zip" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                    <NullNode start="(178, 10)" end="(178, 15)">
                      <IdentNode start="(178, 10)" end="(178, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                      <IdentNode start="(178, 13)" end="(178, 15)" leading="" trailing="" raw_val="bs" val="bs"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(178, 15)" end="(178, 16)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(178, 16)" end="(178, 17)" leading="" trailing="" val="["/>
                <IdentNode start="(178, 17)" end="(178, 18)" leading="" trailing="" raw_val="i" val="i"/>
                <AtomNode start="(178, 18)" end="(178, 19)" leading="" trailing=" " val="]"/>
              </OtherNode>
              <AtomNode start="(178, 20)" end="(178, 21)" leading="" trailing=" " val="="/>
              <OtherNode start="(178, 22)" end="(178, 36)" kind="Lean.Parser.Term.tuple">
                <AtomNode start="(178, 22)" end="(178, 23)" leading="" trailing="" val="("/>
                <NullNode start="(178, 23)" end="(178, 35)">
                  <OtherNode start="(178, 23)" end="(178, 28)" kind="«term__[_]»">
                    <IdentNode start="(178, 23)" end="(178, 25)" leading="" trailing="" raw_val="as" val="as"/>
                    <AtomNode start="(178, 25)" end="(178, 26)" leading="" trailing="" val="["/>
                    <IdentNode start="(178, 26)" end="(178, 27)" leading="" trailing="" raw_val="i" val="i"/>
                    <AtomNode start="(178, 27)" end="(178, 28)" leading="" trailing="" val="]"/>
                  </OtherNode>
                  <AtomNode start="(178, 28)" end="(178, 29)" leading="" trailing=" " val=","/>
                  <NullNode start="(178, 30)" end="(178, 35)">
                    <OtherNode start="(178, 30)" end="(178, 35)" kind="«term__[_]»">
                      <IdentNode start="(178, 30)" end="(178, 32)" leading="" trailing="" raw_val="bs" val="bs"/>
                      <AtomNode start="(178, 32)" end="(178, 33)" leading="" trailing="" val="["/>
                      <IdentNode start="(178, 33)" end="(178, 34)" leading="" trailing="" raw_val="i" val="i"/>
                      <AtomNode start="(178, 34)" end="(178, 35)" leading="" trailing="" val="]"/>
                    </OtherNode>
                  </NullNode>
                </NullNode>
                <AtomNode start="(178, 35)" end="(178, 36)" leading="" trailing=" " val=")"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(178, 37)" end="(179, 21)">
          <AtomNode start="(178, 37)" end="(178, 39)" leading="" trailing="&#10;  " val=":="/>
          <OtherNode start="(179, 3)" end="(179, 21)" kind="Lean.Parser.Term.app">
            <IdentNode start="(179, 3)" end="(179, 18)" leading="" trailing=" " raw_val="getElem_zipWith" val="getElem_zipWith" full_name="Vector.getElem_zipWith" mod_name="Init.Data.Vector.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Lemmas.lean"/>
            <NullNode start="(179, 19)" end="(179, 21)">
              <OtherNode start="(179, 19)" end="(179, 21)" kind="Lean.Parser.Term.ellipsis">
                <AtomNode start="(179, 19)" end="(179, 21)" leading="" trailing="&#10;&#10;" val=".."/>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(181, 1)" end="(184, 33)" name="zip_eq_zipWith" full_name="Vector.zip_eq_zipWith">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(181, 1)" end="(184, 33)" name="zip_eq_zipWith" full_name="Vector.zip_eq_zipWith" _is_private_decl="False">
        <AtomNode start="(181, 1)" end="(181, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(181, 9)" end="(181, 23)">
          <IdentNode start="(181, 9)" end="(181, 23)" leading="" trailing=" " raw_val="zip_eq_zipWith" val="zip_eq_zipWith"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(181, 24)" end="(181, 95)">
          <NullNode start="(181, 24)" end="(181, 59)">
            <OtherNode start="(181, 24)" end="(181, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(181, 24)" end="(181, 25)" leading="" trailing="" val="{"/>
              <NullNode start="(181, 25)" end="(181, 27)">
                <IdentNode start="(181, 25)" end="(181, 27)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(181, 28)" end="(181, 40)">
                <AtomNode start="(181, 28)" end="(181, 29)" leading="" trailing=" " val=":"/>
                <OtherNode start="(181, 30)" end="(181, 40)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(181, 30)" end="(181, 36)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(181, 37)" end="(181, 40)">
                    <IdentNode start="(181, 37)" end="(181, 38)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(181, 39)" end="(181, 40)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(181, 40)" end="(181, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(181, 42)" end="(181, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(181, 42)" end="(181, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(181, 43)" end="(181, 45)">
                <IdentNode start="(181, 43)" end="(181, 45)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(181, 46)" end="(181, 58)">
                <AtomNode start="(181, 46)" end="(181, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(181, 48)" end="(181, 58)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(181, 48)" end="(181, 54)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(181, 55)" end="(181, 58)">
                    <IdentNode start="(181, 55)" end="(181, 56)" leading="" trailing=" " raw_val="β" val="β"/>
                    <IdentNode start="(181, 57)" end="(181, 58)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(181, 58)" end="(181, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(181, 60)" end="(181, 95)">
            <AtomNode start="(181, 60)" end="(181, 61)" leading="" trailing=" " val=":"/>
            <OtherNode start="(181, 62)" end="(181, 95)" kind="«term_=_»">
              <OtherNode start="(181, 62)" end="(181, 71)" kind="Lean.Parser.Term.app">
                <IdentNode start="(181, 62)" end="(181, 65)" leading="" trailing=" " raw_val="zip" val="zip" full_name="Vector.zip" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(181, 66)" end="(181, 71)">
                  <IdentNode start="(181, 66)" end="(181, 68)" leading="" trailing=" " raw_val="as" val="as"/>
                  <IdentNode start="(181, 69)" end="(181, 71)" leading="" trailing=" " raw_val="bs" val="bs"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(181, 72)" end="(181, 73)" leading="" trailing=" " val="="/>
              <OtherNode start="(181, 74)" end="(181, 95)" kind="Lean.Parser.Term.app">
                <IdentNode start="(181, 74)" end="(181, 81)" leading="" trailing=" " raw_val="zipWith" val="zipWith" full_name="Vector.zipWith" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(181, 82)" end="(181, 95)">
                  <IdentNode start="(181, 82)" end="(181, 89)" leading="" trailing=" " raw_val="Prod.mk" val="Prod.mk" full_name="Prod.mk" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <IdentNode start="(181, 90)" end="(181, 92)" leading="" trailing=" " raw_val="as" val="as"/>
                  <IdentNode start="(181, 93)" end="(181, 95)" leading="" trailing=" " raw_val="bs" val="bs"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(181, 96)" end="(184, 33)">
          <AtomNode start="(181, 96)" end="(181, 98)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(181, 99)" end="(184, 33)">
            <AtomNode start="(181, 99)" end="(181, 101)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(182, 3)" end="(184, 33)">
              <TacticTacticseq1IndentedNode start="(182, 3)" end="(184, 33)">
                <NullNode start="(182, 3)" end="(184, 33)">
                  <OtherNode start="(182, 3)" end="(182, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;n : Nat&#10;β : Type u_2&#10;as : Vector α n&#10;bs : Vector β n&#10;⊢ as.zip bs = zipWith Prod.mk as bs" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ { toArray := as, size_toArray := ⋯ }.zip bs = zipWith Prod.mk { toArray := as, size_toArray := ⋯ } bs" tactic="rcases as with ⟨as, rfl⟩">
                    <AtomNode start="(182, 3)" end="(182, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(182, 10)" end="(182, 12)">
                      <OtherNode start="(182, 10)" end="(182, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(182, 10)" end="(182, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(182, 13)" end="(182, 27)">
                      <AtomNode start="(182, 13)" end="(182, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(182, 18)" end="(182, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(182, 18)" end="(182, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(182, 18)" end="(182, 27)">
                            <OtherNode start="(182, 18)" end="(182, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(182, 18)" end="(182, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(182, 19)" end="(182, 26)">
                                <OtherNode start="(182, 19)" end="(182, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(182, 19)" end="(182, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(182, 19)" end="(182, 21)">
                                      <OtherNode start="(182, 19)" end="(182, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(182, 19)" end="(182, 21)" leading="" trailing="" raw_val="as" val="as"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(182, 21)" end="(182, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(182, 23)" end="(182, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(182, 23)" end="(182, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(182, 23)" end="(182, 26)">
                                      <OtherNode start="(182, 23)" end="(182, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(182, 23)" end="(182, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(182, 26)" end="(182, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(183, 3)" end="(183, 25)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ { toArray := as, size_toArray := ⋯ }.zip bs = zipWith Prod.mk { toArray := as, size_toArray := ⋯ } bs" state_after="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ { toArray := as, size_toArray := ⋯ }.zip { toArray := bs, size_toArray := h } =&#10;    zipWith Prod.mk { toArray := as, size_toArray := ⋯ } { toArray := bs, size_toArray := h }" tactic="rcases bs with ⟨bs, h⟩">
                    <AtomNode start="(183, 3)" end="(183, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(183, 10)" end="(183, 12)">
                      <OtherNode start="(183, 10)" end="(183, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(183, 10)" end="(183, 12)" leading="" trailing=" " raw_val="bs" val="bs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(183, 13)" end="(183, 25)">
                      <AtomNode start="(183, 13)" end="(183, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(183, 18)" end="(183, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(183, 18)" end="(183, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(183, 18)" end="(183, 25)">
                            <OtherNode start="(183, 18)" end="(183, 25)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(183, 18)" end="(183, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(183, 19)" end="(183, 24)">
                                <OtherNode start="(183, 19)" end="(183, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(183, 19)" end="(183, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(183, 19)" end="(183, 21)">
                                      <OtherNode start="(183, 19)" end="(183, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(183, 19)" end="(183, 21)" leading="" trailing="" raw_val="bs" val="bs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(183, 21)" end="(183, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(183, 23)" end="(183, 24)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(183, 23)" end="(183, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(183, 23)" end="(183, 24)">
                                      <OtherNode start="(183, 23)" end="(183, 24)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(183, 23)" end="(183, 24)" leading="" trailing="" raw_val="h" val="h"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(183, 24)" end="(183, 25)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(184, 3)" end="(184, 33)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ { toArray := as, size_toArray := ⋯ }.zip { toArray := bs, size_toArray := h } =&#10;    zipWith Prod.mk { toArray := as, size_toArray := ⋯ } { toArray := bs, size_toArray := h }" state_after="no goals" tactic="simp [Array.zip_eq_zipWith, h]">
                    <AtomNode start="(184, 3)" end="(184, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(184, 8)" end="(184, 33)">
                      <AtomNode start="(184, 8)" end="(184, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(184, 9)" end="(184, 32)">
                        <OtherNode start="(184, 9)" end="(184, 29)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(184, 9)" end="(184, 29)" leading="" trailing="" raw_val="Array.zip_eq_zipWith" val="Array.zip_eq_zipWith" full_name="Array.zip_eq_zipWith" mod_name="Init.Data.Array.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Zip.lean"/>
                        </OtherNode>
                        <AtomNode start="(184, 29)" end="(184, 30)" leading="" trailing=" " val=","/>
                        <OtherNode start="(184, 31)" end="(184, 32)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(184, 31)" end="(184, 32)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(184, 32)" end="(184, 33)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(186, 1)" end="(190, 26)" name="zip_map" full_name="Vector.zip_map">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(186, 1)" end="(190, 26)" name="zip_map" full_name="Vector.zip_map" _is_private_decl="False">
        <AtomNode start="(186, 1)" end="(186, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(186, 9)" end="(186, 16)">
          <IdentNode start="(186, 9)" end="(186, 16)" leading="" trailing=" " raw_val="zip_map" val="zip_map"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(186, 17)" end="(187, 63)">
          <NullNode start="(186, 17)" end="(186, 76)">
            <OtherNode start="(186, 17)" end="(186, 28)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(186, 17)" end="(186, 18)" leading="" trailing="" val="{"/>
              <NullNode start="(186, 18)" end="(186, 19)">
                <IdentNode start="(186, 18)" end="(186, 19)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(186, 20)" end="(186, 27)">
                <AtomNode start="(186, 20)" end="(186, 21)" leading="" trailing=" " val=":"/>
                <OtherNode start="(186, 22)" end="(186, 27)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(186, 22)" end="(186, 23)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(186, 24)" end="(186, 25)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(186, 26)" end="(186, 27)" leading="" trailing="" raw_val="γ" val="γ"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(186, 27)" end="(186, 28)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(186, 29)" end="(186, 40)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(186, 29)" end="(186, 30)" leading="" trailing="" val="{"/>
              <NullNode start="(186, 30)" end="(186, 31)">
                <IdentNode start="(186, 30)" end="(186, 31)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(186, 32)" end="(186, 39)">
                <AtomNode start="(186, 32)" end="(186, 33)" leading="" trailing=" " val=":"/>
                <OtherNode start="(186, 34)" end="(186, 39)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(186, 34)" end="(186, 35)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(186, 36)" end="(186, 37)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(186, 38)" end="(186, 39)" leading="" trailing="" raw_val="δ" val="δ"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(186, 39)" end="(186, 40)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(186, 41)" end="(186, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(186, 41)" end="(186, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(186, 42)" end="(186, 44)">
                <IdentNode start="(186, 42)" end="(186, 44)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(186, 45)" end="(186, 57)">
                <AtomNode start="(186, 45)" end="(186, 46)" leading="" trailing=" " val=":"/>
                <OtherNode start="(186, 47)" end="(186, 57)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(186, 47)" end="(186, 53)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(186, 54)" end="(186, 57)">
                    <IdentNode start="(186, 54)" end="(186, 55)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(186, 56)" end="(186, 57)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(186, 57)" end="(186, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(186, 59)" end="(186, 76)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(186, 59)" end="(186, 60)" leading="" trailing="" val="{"/>
              <NullNode start="(186, 60)" end="(186, 62)">
                <IdentNode start="(186, 60)" end="(186, 62)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(186, 63)" end="(186, 75)">
                <AtomNode start="(186, 63)" end="(186, 64)" leading="" trailing=" " val=":"/>
                <OtherNode start="(186, 65)" end="(186, 75)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(186, 65)" end="(186, 71)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(186, 72)" end="(186, 75)">
                    <IdentNode start="(186, 72)" end="(186, 73)" leading="" trailing=" " raw_val="β" val="β"/>
                    <IdentNode start="(186, 74)" end="(186, 75)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(186, 75)" end="(186, 76)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(186, 77)" end="(187, 63)">
            <AtomNode start="(186, 77)" end="(186, 78)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(187, 5)" end="(187, 63)" kind="«term_=_»">
              <OtherNode start="(187, 5)" end="(187, 30)" kind="Lean.Parser.Term.app">
                <IdentNode start="(187, 5)" end="(187, 8)" leading="" trailing=" " raw_val="zip" val="zip" full_name="Vector.zip" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(187, 9)" end="(187, 30)">
                  <OtherNode start="(187, 9)" end="(187, 19)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(187, 9)" end="(187, 10)" leading="" trailing="" val="("/>
                    <OtherNode start="(187, 10)" end="(187, 18)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(187, 10)" end="(187, 16)" leading="" trailing=" " raw_val="as.map" val="as.map"/>
                      <NullNode start="(187, 17)" end="(187, 18)">
                        <IdentNode start="(187, 17)" end="(187, 18)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(187, 18)" end="(187, 19)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(187, 20)" end="(187, 30)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(187, 20)" end="(187, 21)" leading="" trailing="" val="("/>
                    <OtherNode start="(187, 21)" end="(187, 29)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(187, 21)" end="(187, 27)" leading="" trailing=" " raw_val="bs.map" val="bs.map"/>
                      <NullNode start="(187, 28)" end="(187, 29)">
                        <IdentNode start="(187, 28)" end="(187, 29)" leading="" trailing="" raw_val="g" val="g"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(187, 29)" end="(187, 30)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(187, 31)" end="(187, 32)" leading="" trailing=" " val="="/>
              <OtherNode start="(187, 33)" end="(187, 63)" kind="Lean.Parser.Term.app">
                <OtherNode start="(187, 33)" end="(187, 48)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(187, 33)" end="(187, 44)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(187, 33)" end="(187, 34)" leading="" trailing="" val="("/>
                    <OtherNode start="(187, 34)" end="(187, 43)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(187, 34)" end="(187, 37)" leading="" trailing=" " raw_val="zip" val="zip" full_name="Vector.zip" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                      <NullNode start="(187, 38)" end="(187, 43)">
                        <IdentNode start="(187, 38)" end="(187, 40)" leading="" trailing=" " raw_val="as" val="as"/>
                        <IdentNode start="(187, 41)" end="(187, 43)" leading="" trailing="" raw_val="bs" val="bs"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(187, 43)" end="(187, 44)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(187, 44)" end="(187, 45)" leading="" trailing="" val="."/>
                  <IdentNode start="(187, 45)" end="(187, 48)" leading="" trailing=" " raw_val="map" val="map" full_name="Vector.map" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                </OtherNode>
                <NullNode start="(187, 49)" end="(187, 63)">
                  <OtherNode start="(187, 49)" end="(187, 63)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(187, 49)" end="(187, 50)" leading="" trailing="" val="("/>
                    <OtherNode start="(187, 50)" end="(187, 62)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(187, 50)" end="(187, 58)" leading="" trailing=" " raw_val="Prod.map" val="Prod.map" full_name="Prod.map" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                      <NullNode start="(187, 59)" end="(187, 62)">
                        <IdentNode start="(187, 59)" end="(187, 60)" leading="" trailing=" " raw_val="f" val="f"/>
                        <IdentNode start="(187, 61)" end="(187, 62)" leading="" trailing="" raw_val="g" val="g"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(187, 62)" end="(187, 63)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(187, 64)" end="(190, 26)">
          <AtomNode start="(187, 64)" end="(187, 66)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(187, 67)" end="(190, 26)">
            <AtomNode start="(187, 67)" end="(187, 69)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(188, 3)" end="(190, 26)">
              <TacticTacticseq1IndentedNode start="(188, 3)" end="(190, 26)">
                <NullNode start="(188, 3)" end="(190, 26)">
                  <OtherNode start="(188, 3)" end="(188, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;γ : Type u_2&#10;β : Type u_3&#10;δ : Type u_4&#10;n : Nat&#10;f : α → γ&#10;g : β → δ&#10;as : Vector α n&#10;bs : Vector β n&#10;⊢ (map f as).zip (map g bs) = map (Prod.map f g) (as.zip bs)" state_after="case mk&#10;α : Type u_1&#10;γ : Type u_2&#10;β : Type u_3&#10;δ : Type u_4&#10;f : α → γ&#10;g : β → δ&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ (map f { toArray := as, size_toArray := ⋯ }).zip (map g bs) =&#10;    map (Prod.map f g) ({ toArray := as, size_toArray := ⋯ }.zip bs)" tactic="rcases as with ⟨as, rfl⟩">
                    <AtomNode start="(188, 3)" end="(188, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(188, 10)" end="(188, 12)">
                      <OtherNode start="(188, 10)" end="(188, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(188, 10)" end="(188, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(188, 13)" end="(188, 27)">
                      <AtomNode start="(188, 13)" end="(188, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(188, 18)" end="(188, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(188, 18)" end="(188, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(188, 18)" end="(188, 27)">
                            <OtherNode start="(188, 18)" end="(188, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(188, 18)" end="(188, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(188, 19)" end="(188, 26)">
                                <OtherNode start="(188, 19)" end="(188, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(188, 19)" end="(188, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(188, 19)" end="(188, 21)">
                                      <OtherNode start="(188, 19)" end="(188, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(188, 19)" end="(188, 21)" leading="" trailing="" raw_val="as" val="as"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(188, 21)" end="(188, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(188, 23)" end="(188, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(188, 23)" end="(188, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(188, 23)" end="(188, 26)">
                                      <OtherNode start="(188, 23)" end="(188, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(188, 23)" end="(188, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(188, 26)" end="(188, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(189, 3)" end="(189, 25)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α : Type u_1&#10;γ : Type u_2&#10;β : Type u_3&#10;δ : Type u_4&#10;f : α → γ&#10;g : β → δ&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ (map f { toArray := as, size_toArray := ⋯ }).zip (map g bs) =&#10;    map (Prod.map f g) ({ toArray := as, size_toArray := ⋯ }.zip bs)" state_after="case mk.mk&#10;α : Type u_1&#10;γ : Type u_2&#10;β : Type u_3&#10;δ : Type u_4&#10;f : α → γ&#10;g : β → δ&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ (map f { toArray := as, size_toArray := ⋯ }).zip (map g { toArray := bs, size_toArray := h }) =&#10;    map (Prod.map f g) ({ toArray := as, size_toArray := ⋯ }.zip { toArray := bs, size_toArray := h })" tactic="rcases bs with ⟨bs, h⟩">
                    <AtomNode start="(189, 3)" end="(189, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(189, 10)" end="(189, 12)">
                      <OtherNode start="(189, 10)" end="(189, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(189, 10)" end="(189, 12)" leading="" trailing=" " raw_val="bs" val="bs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(189, 13)" end="(189, 25)">
                      <AtomNode start="(189, 13)" end="(189, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(189, 18)" end="(189, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(189, 18)" end="(189, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(189, 18)" end="(189, 25)">
                            <OtherNode start="(189, 18)" end="(189, 25)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(189, 18)" end="(189, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(189, 19)" end="(189, 24)">
                                <OtherNode start="(189, 19)" end="(189, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(189, 19)" end="(189, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(189, 19)" end="(189, 21)">
                                      <OtherNode start="(189, 19)" end="(189, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(189, 19)" end="(189, 21)" leading="" trailing="" raw_val="bs" val="bs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(189, 21)" end="(189, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(189, 23)" end="(189, 24)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(189, 23)" end="(189, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(189, 23)" end="(189, 24)">
                                      <OtherNode start="(189, 23)" end="(189, 24)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(189, 23)" end="(189, 24)" leading="" trailing="" raw_val="h" val="h"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(189, 24)" end="(189, 25)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(190, 3)" end="(190, 26)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α : Type u_1&#10;γ : Type u_2&#10;β : Type u_3&#10;δ : Type u_4&#10;f : α → γ&#10;g : β → δ&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ (map f { toArray := as, size_toArray := ⋯ }).zip (map g { toArray := bs, size_toArray := h }) =&#10;    map (Prod.map f g) ({ toArray := as, size_toArray := ⋯ }.zip { toArray := bs, size_toArray := h })" state_after="no goals" tactic="simp [Array.zip_map, h]">
                    <AtomNode start="(190, 3)" end="(190, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(190, 8)" end="(190, 26)">
                      <AtomNode start="(190, 8)" end="(190, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(190, 9)" end="(190, 25)">
                        <OtherNode start="(190, 9)" end="(190, 22)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(190, 9)" end="(190, 22)" leading="" trailing="" raw_val="Array.zip_map" val="Array.zip_map" full_name="Array.zip_map" mod_name="Init.Data.Array.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Zip.lean"/>
                        </OtherNode>
                        <AtomNode start="(190, 22)" end="(190, 23)" leading="" trailing=" " val=","/>
                        <OtherNode start="(190, 24)" end="(190, 25)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(190, 24)" end="(190, 25)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(190, 25)" end="(190, 26)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(192, 1)" end="(193, 85)" name="zip_map_left" full_name="Vector.zip_map_left">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(192, 1)" end="(193, 85)" name="zip_map_left" full_name="Vector.zip_map_left" _is_private_decl="False">
        <AtomNode start="(192, 1)" end="(192, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(192, 9)" end="(192, 21)">
          <IdentNode start="(192, 9)" end="(192, 21)" leading="" trailing=" " raw_val="zip_map_left" val="zip_map_left"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(192, 22)" end="(193, 56)">
          <NullNode start="(192, 22)" end="(192, 69)">
            <OtherNode start="(192, 22)" end="(192, 33)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(192, 22)" end="(192, 23)" leading="" trailing="" val="{"/>
              <NullNode start="(192, 23)" end="(192, 24)">
                <IdentNode start="(192, 23)" end="(192, 24)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(192, 25)" end="(192, 32)">
                <AtomNode start="(192, 25)" end="(192, 26)" leading="" trailing=" " val=":"/>
                <OtherNode start="(192, 27)" end="(192, 32)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(192, 27)" end="(192, 28)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(192, 29)" end="(192, 30)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(192, 31)" end="(192, 32)" leading="" trailing="" raw_val="γ" val="γ"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(192, 32)" end="(192, 33)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(192, 34)" end="(192, 51)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(192, 34)" end="(192, 35)" leading="" trailing="" val="{"/>
              <NullNode start="(192, 35)" end="(192, 37)">
                <IdentNode start="(192, 35)" end="(192, 37)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(192, 38)" end="(192, 50)">
                <AtomNode start="(192, 38)" end="(192, 39)" leading="" trailing=" " val=":"/>
                <OtherNode start="(192, 40)" end="(192, 50)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(192, 40)" end="(192, 46)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(192, 47)" end="(192, 50)">
                    <IdentNode start="(192, 47)" end="(192, 48)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(192, 49)" end="(192, 50)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(192, 50)" end="(192, 51)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(192, 52)" end="(192, 69)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(192, 52)" end="(192, 53)" leading="" trailing="" val="{"/>
              <NullNode start="(192, 53)" end="(192, 55)">
                <IdentNode start="(192, 53)" end="(192, 55)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(192, 56)" end="(192, 68)">
                <AtomNode start="(192, 56)" end="(192, 57)" leading="" trailing=" " val=":"/>
                <OtherNode start="(192, 58)" end="(192, 68)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(192, 58)" end="(192, 64)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(192, 65)" end="(192, 68)">
                    <IdentNode start="(192, 65)" end="(192, 66)" leading="" trailing=" " raw_val="β" val="β"/>
                    <IdentNode start="(192, 67)" end="(192, 68)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(192, 68)" end="(192, 69)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(192, 70)" end="(193, 56)">
            <AtomNode start="(192, 70)" end="(192, 71)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(193, 5)" end="(193, 56)" kind="«term_=_»">
              <OtherNode start="(193, 5)" end="(193, 22)" kind="Lean.Parser.Term.app">
                <IdentNode start="(193, 5)" end="(193, 8)" leading="" trailing=" " raw_val="zip" val="zip" full_name="Vector.zip" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(193, 9)" end="(193, 22)">
                  <OtherNode start="(193, 9)" end="(193, 19)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(193, 9)" end="(193, 10)" leading="" trailing="" val="("/>
                    <OtherNode start="(193, 10)" end="(193, 18)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(193, 10)" end="(193, 16)" leading="" trailing=" " raw_val="as.map" val="as.map"/>
                      <NullNode start="(193, 17)" end="(193, 18)">
                        <IdentNode start="(193, 17)" end="(193, 18)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(193, 18)" end="(193, 19)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <IdentNode start="(193, 20)" end="(193, 22)" leading="" trailing=" " raw_val="bs" val="bs"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(193, 23)" end="(193, 24)" leading="" trailing=" " val="="/>
              <OtherNode start="(193, 25)" end="(193, 56)" kind="Lean.Parser.Term.app">
                <OtherNode start="(193, 25)" end="(193, 40)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(193, 25)" end="(193, 36)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(193, 25)" end="(193, 26)" leading="" trailing="" val="("/>
                    <OtherNode start="(193, 26)" end="(193, 35)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(193, 26)" end="(193, 29)" leading="" trailing=" " raw_val="zip" val="zip" full_name="Vector.zip" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                      <NullNode start="(193, 30)" end="(193, 35)">
                        <IdentNode start="(193, 30)" end="(193, 32)" leading="" trailing=" " raw_val="as" val="as"/>
                        <IdentNode start="(193, 33)" end="(193, 35)" leading="" trailing="" raw_val="bs" val="bs"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(193, 35)" end="(193, 36)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(193, 36)" end="(193, 37)" leading="" trailing="" val="."/>
                  <IdentNode start="(193, 37)" end="(193, 40)" leading="" trailing=" " raw_val="map" val="map" full_name="Vector.map" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                </OtherNode>
                <NullNode start="(193, 41)" end="(193, 56)">
                  <OtherNode start="(193, 41)" end="(193, 56)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(193, 41)" end="(193, 42)" leading="" trailing="" val="("/>
                    <OtherNode start="(193, 42)" end="(193, 55)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(193, 42)" end="(193, 50)" leading="" trailing=" " raw_val="Prod.map" val="Prod.map" full_name="Prod.map" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                      <NullNode start="(193, 51)" end="(193, 55)">
                        <IdentNode start="(193, 51)" end="(193, 52)" leading="" trailing=" " raw_val="f" val="f"/>
                        <IdentNode start="(193, 53)" end="(193, 55)" leading="" trailing="" raw_val="id" val="id" full_name="id" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(193, 55)" end="(193, 56)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(193, 57)" end="(193, 85)">
          <AtomNode start="(193, 57)" end="(193, 59)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(193, 60)" end="(193, 85)">
            <AtomNode start="(193, 60)" end="(193, 62)" leading="" trailing=" " val="by"/>
            <TacticTacticseqNode start="(193, 63)" end="(193, 85)">
              <TacticTacticseq1IndentedNode start="(193, 63)" end="(193, 85)">
                <NullNode start="(193, 63)" end="(193, 85)">
                  <OtherNode start="(193, 63)" end="(193, 85)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;γ : Type u_2&#10;n : Nat&#10;β : Type u_3&#10;f : α → γ&#10;as : Vector α n&#10;bs : Vector β n&#10;⊢ (map f as).zip bs = map (Prod.map f id) (as.zip bs)" state_after="no goals" tactic="rw [← zip_map, map_id]">
                    <AtomNode start="(193, 63)" end="(193, 65)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(193, 66)" end="(193, 85)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(193, 66)" end="(193, 67)" leading="" trailing="" val="["/>
                      <NullNode start="(193, 67)" end="(193, 84)">
                        <OtherNode start="(193, 67)" end="(193, 76)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(193, 67)" end="(193, 68)">
                            <OtherNode start="(193, 67)" end="(193, 68)" kind="patternIgnore">
                              <OtherNode start="(193, 67)" end="(193, 68)" kind="token.«← »">
                                <AtomNode start="(193, 67)" end="(193, 68)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(193, 69)" end="(193, 76)" leading="" trailing="" raw_val="zip_map" val="zip_map" full_name="Vector.zip_map" mod_name="Init.Data.Vector.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Zip.lean" def_start="(186, 9)" def_end="(186, 16)"/>
                        </OtherNode>
                        <AtomNode start="(193, 76)" end="(193, 77)" leading="" trailing=" " val=","/>
                        <OtherNode start="(193, 78)" end="(193, 84)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(193, 78)" end="(193, 84)" leading="" trailing="" raw_val="map_id" val="map_id" full_name="Vector.map_id" mod_name="Init.Data.Vector.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(193, 84)" end="(193, 85)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(195, 1)" end="(196, 85)" name="zip_map_right" full_name="Vector.zip_map_right">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(195, 1)" end="(196, 85)" name="zip_map_right" full_name="Vector.zip_map_right" _is_private_decl="False">
        <AtomNode start="(195, 1)" end="(195, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(195, 9)" end="(195, 22)">
          <IdentNode start="(195, 9)" end="(195, 22)" leading="" trailing=" " raw_val="zip_map_right" val="zip_map_right"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(195, 23)" end="(196, 56)">
          <NullNode start="(195, 23)" end="(195, 70)">
            <OtherNode start="(195, 23)" end="(195, 34)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(195, 23)" end="(195, 24)" leading="" trailing="" val="{"/>
              <NullNode start="(195, 24)" end="(195, 25)">
                <IdentNode start="(195, 24)" end="(195, 25)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(195, 26)" end="(195, 33)">
                <AtomNode start="(195, 26)" end="(195, 27)" leading="" trailing=" " val=":"/>
                <OtherNode start="(195, 28)" end="(195, 33)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(195, 28)" end="(195, 29)" leading="" trailing=" " raw_val="β" val="β"/>
                  <AtomNode start="(195, 30)" end="(195, 31)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(195, 32)" end="(195, 33)" leading="" trailing="" raw_val="γ" val="γ"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(195, 33)" end="(195, 34)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(195, 35)" end="(195, 52)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(195, 35)" end="(195, 36)" leading="" trailing="" val="{"/>
              <NullNode start="(195, 36)" end="(195, 38)">
                <IdentNode start="(195, 36)" end="(195, 38)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(195, 39)" end="(195, 51)">
                <AtomNode start="(195, 39)" end="(195, 40)" leading="" trailing=" " val=":"/>
                <OtherNode start="(195, 41)" end="(195, 51)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(195, 41)" end="(195, 47)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(195, 48)" end="(195, 51)">
                    <IdentNode start="(195, 48)" end="(195, 49)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(195, 50)" end="(195, 51)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(195, 51)" end="(195, 52)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(195, 53)" end="(195, 70)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(195, 53)" end="(195, 54)" leading="" trailing="" val="{"/>
              <NullNode start="(195, 54)" end="(195, 56)">
                <IdentNode start="(195, 54)" end="(195, 56)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(195, 57)" end="(195, 69)">
                <AtomNode start="(195, 57)" end="(195, 58)" leading="" trailing=" " val=":"/>
                <OtherNode start="(195, 59)" end="(195, 69)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(195, 59)" end="(195, 65)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(195, 66)" end="(195, 69)">
                    <IdentNode start="(195, 66)" end="(195, 67)" leading="" trailing=" " raw_val="β" val="β"/>
                    <IdentNode start="(195, 68)" end="(195, 69)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(195, 69)" end="(195, 70)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(195, 71)" end="(196, 56)">
            <AtomNode start="(195, 71)" end="(195, 72)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(196, 5)" end="(196, 56)" kind="«term_=_»">
              <OtherNode start="(196, 5)" end="(196, 22)" kind="Lean.Parser.Term.app">
                <IdentNode start="(196, 5)" end="(196, 8)" leading="" trailing=" " raw_val="zip" val="zip" full_name="Vector.zip" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(196, 9)" end="(196, 22)">
                  <IdentNode start="(196, 9)" end="(196, 11)" leading="" trailing=" " raw_val="as" val="as"/>
                  <OtherNode start="(196, 12)" end="(196, 22)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(196, 12)" end="(196, 13)" leading="" trailing="" val="("/>
                    <OtherNode start="(196, 13)" end="(196, 21)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(196, 13)" end="(196, 19)" leading="" trailing=" " raw_val="bs.map" val="bs.map"/>
                      <NullNode start="(196, 20)" end="(196, 21)">
                        <IdentNode start="(196, 20)" end="(196, 21)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(196, 21)" end="(196, 22)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(196, 23)" end="(196, 24)" leading="" trailing=" " val="="/>
              <OtherNode start="(196, 25)" end="(196, 56)" kind="Lean.Parser.Term.app">
                <OtherNode start="(196, 25)" end="(196, 40)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(196, 25)" end="(196, 36)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(196, 25)" end="(196, 26)" leading="" trailing="" val="("/>
                    <OtherNode start="(196, 26)" end="(196, 35)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(196, 26)" end="(196, 29)" leading="" trailing=" " raw_val="zip" val="zip" full_name="Vector.zip" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                      <NullNode start="(196, 30)" end="(196, 35)">
                        <IdentNode start="(196, 30)" end="(196, 32)" leading="" trailing=" " raw_val="as" val="as"/>
                        <IdentNode start="(196, 33)" end="(196, 35)" leading="" trailing="" raw_val="bs" val="bs"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(196, 35)" end="(196, 36)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(196, 36)" end="(196, 37)" leading="" trailing="" val="."/>
                  <IdentNode start="(196, 37)" end="(196, 40)" leading="" trailing=" " raw_val="map" val="map" full_name="Vector.map" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                </OtherNode>
                <NullNode start="(196, 41)" end="(196, 56)">
                  <OtherNode start="(196, 41)" end="(196, 56)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(196, 41)" end="(196, 42)" leading="" trailing="" val="("/>
                    <OtherNode start="(196, 42)" end="(196, 55)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(196, 42)" end="(196, 50)" leading="" trailing=" " raw_val="Prod.map" val="Prod.map" full_name="Prod.map" mod_name="Init.Core" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Core.lean"/>
                      <NullNode start="(196, 51)" end="(196, 55)">
                        <IdentNode start="(196, 51)" end="(196, 53)" leading="" trailing=" " raw_val="id" val="id" full_name="id" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <IdentNode start="(196, 54)" end="(196, 55)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(196, 55)" end="(196, 56)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(196, 57)" end="(196, 85)">
          <AtomNode start="(196, 57)" end="(196, 59)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(196, 60)" end="(196, 85)">
            <AtomNode start="(196, 60)" end="(196, 62)" leading="" trailing=" " val="by"/>
            <TacticTacticseqNode start="(196, 63)" end="(196, 85)">
              <TacticTacticseq1IndentedNode start="(196, 63)" end="(196, 85)">
                <NullNode start="(196, 63)" end="(196, 85)">
                  <OtherNode start="(196, 63)" end="(196, 85)" kind="Lean.Parser.Tactic.rwSeq" state_before="β : Type u_1&#10;γ : Type u_2&#10;α : Type u_3&#10;n : Nat&#10;f : β → γ&#10;as : Vector α n&#10;bs : Vector β n&#10;⊢ as.zip (map f bs) = map (Prod.map id f) (as.zip bs)" state_after="no goals" tactic="rw [← zip_map, map_id]">
                    <AtomNode start="(196, 63)" end="(196, 65)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(196, 66)" end="(196, 85)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(196, 66)" end="(196, 67)" leading="" trailing="" val="["/>
                      <NullNode start="(196, 67)" end="(196, 84)">
                        <OtherNode start="(196, 67)" end="(196, 76)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(196, 67)" end="(196, 68)">
                            <OtherNode start="(196, 67)" end="(196, 68)" kind="patternIgnore">
                              <OtherNode start="(196, 67)" end="(196, 68)" kind="token.«← »">
                                <AtomNode start="(196, 67)" end="(196, 68)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(196, 69)" end="(196, 76)" leading="" trailing="" raw_val="zip_map" val="zip_map" full_name="Vector.zip_map" mod_name="Init.Data.Vector.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Zip.lean" def_start="(186, 9)" def_end="(186, 16)"/>
                        </OtherNode>
                        <AtomNode start="(196, 76)" end="(196, 77)" leading="" trailing=" " val=","/>
                        <OtherNode start="(196, 78)" end="(196, 84)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(196, 78)" end="(196, 84)" leading="" trailing="" raw_val="map_id" val="map_id" full_name="Vector.map_id" mod_name="Init.Data.Vector.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Lemmas.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(196, 84)" end="(196, 85)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(198, 1)" end="(204, 33)" name="zip_append" full_name="Vector.zip_append">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(198, 1)" end="(204, 33)" name="zip_append" full_name="Vector.zip_append" _is_private_decl="False">
        <AtomNode start="(198, 1)" end="(198, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(198, 9)" end="(198, 19)">
          <IdentNode start="(198, 9)" end="(198, 19)" leading="" trailing=" " raw_val="zip_append" val="zip_append"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(198, 20)" end="(199, 59)">
          <NullNode start="(198, 20)" end="(198, 93)">
            <OtherNode start="(198, 20)" end="(198, 37)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(198, 20)" end="(198, 21)" leading="" trailing="" val="{"/>
              <NullNode start="(198, 21)" end="(198, 23)">
                <IdentNode start="(198, 21)" end="(198, 23)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(198, 24)" end="(198, 36)">
                <AtomNode start="(198, 24)" end="(198, 25)" leading="" trailing=" " val=":"/>
                <OtherNode start="(198, 26)" end="(198, 36)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(198, 26)" end="(198, 32)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(198, 33)" end="(198, 36)">
                    <IdentNode start="(198, 33)" end="(198, 34)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(198, 35)" end="(198, 36)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(198, 36)" end="(198, 37)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(198, 38)" end="(198, 55)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(198, 38)" end="(198, 39)" leading="" trailing="" val="{"/>
              <NullNode start="(198, 39)" end="(198, 41)">
                <IdentNode start="(198, 39)" end="(198, 41)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(198, 42)" end="(198, 54)">
                <AtomNode start="(198, 42)" end="(198, 43)" leading="" trailing=" " val=":"/>
                <OtherNode start="(198, 44)" end="(198, 54)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(198, 44)" end="(198, 50)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(198, 51)" end="(198, 54)">
                    <IdentNode start="(198, 51)" end="(198, 52)" leading="" trailing=" " raw_val="β" val="β"/>
                    <IdentNode start="(198, 53)" end="(198, 54)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(198, 54)" end="(198, 55)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(198, 56)" end="(198, 74)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(198, 56)" end="(198, 57)" leading="" trailing="" val="{"/>
              <NullNode start="(198, 57)" end="(198, 60)">
                <IdentNode start="(198, 57)" end="(198, 60)" leading="" trailing=" " raw_val="as'" val="as'"/>
              </NullNode>
              <NullNode start="(198, 61)" end="(198, 73)">
                <AtomNode start="(198, 61)" end="(198, 62)" leading="" trailing=" " val=":"/>
                <OtherNode start="(198, 63)" end="(198, 73)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(198, 63)" end="(198, 69)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(198, 70)" end="(198, 73)">
                    <IdentNode start="(198, 70)" end="(198, 71)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(198, 72)" end="(198, 73)" leading="" trailing="" raw_val="m" val="m"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(198, 73)" end="(198, 74)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(198, 75)" end="(198, 93)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(198, 75)" end="(198, 76)" leading="" trailing="" val="{"/>
              <NullNode start="(198, 76)" end="(198, 79)">
                <IdentNode start="(198, 76)" end="(198, 79)" leading="" trailing=" " raw_val="bs'" val="bs'"/>
              </NullNode>
              <NullNode start="(198, 80)" end="(198, 92)">
                <AtomNode start="(198, 80)" end="(198, 81)" leading="" trailing=" " val=":"/>
                <OtherNode start="(198, 82)" end="(198, 92)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(198, 82)" end="(198, 88)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(198, 89)" end="(198, 92)">
                    <IdentNode start="(198, 89)" end="(198, 90)" leading="" trailing=" " raw_val="β" val="β"/>
                    <IdentNode start="(198, 91)" end="(198, 92)" leading="" trailing="" raw_val="m" val="m"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(198, 92)" end="(198, 93)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(198, 94)" end="(199, 59)">
            <AtomNode start="(198, 94)" end="(198, 95)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(199, 5)" end="(199, 59)" kind="«term_=_»">
              <OtherNode start="(199, 5)" end="(199, 32)" kind="Lean.Parser.Term.app">
                <IdentNode start="(199, 5)" end="(199, 8)" leading="" trailing=" " raw_val="zip" val="zip" full_name="Vector.zip" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(199, 9)" end="(199, 32)">
                  <OtherNode start="(199, 9)" end="(199, 20)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(199, 9)" end="(199, 10)" leading="" trailing="" val="("/>
                    <OtherNode start="(199, 10)" end="(199, 19)" kind="«term_++_»">
                      <IdentNode start="(199, 10)" end="(199, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                      <AtomNode start="(199, 13)" end="(199, 15)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(199, 16)" end="(199, 19)" leading="" trailing="" raw_val="as'" val="as'"/>
                    </OtherNode>
                    <AtomNode start="(199, 19)" end="(199, 20)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(199, 21)" end="(199, 32)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(199, 21)" end="(199, 22)" leading="" trailing="" val="("/>
                    <OtherNode start="(199, 22)" end="(199, 31)" kind="«term_++_»">
                      <IdentNode start="(199, 22)" end="(199, 24)" leading="" trailing=" " raw_val="bs" val="bs"/>
                      <AtomNode start="(199, 25)" end="(199, 27)" leading="" trailing=" " val="++"/>
                      <IdentNode start="(199, 28)" end="(199, 31)" leading="" trailing="" raw_val="bs'" val="bs'"/>
                    </OtherNode>
                    <AtomNode start="(199, 31)" end="(199, 32)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(199, 33)" end="(199, 34)" leading="" trailing=" " val="="/>
              <OtherNode start="(199, 35)" end="(199, 59)" kind="«term_++_»">
                <OtherNode start="(199, 35)" end="(199, 44)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(199, 35)" end="(199, 38)" leading="" trailing=" " raw_val="zip" val="zip" full_name="Vector.zip" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(199, 39)" end="(199, 44)">
                    <IdentNode start="(199, 39)" end="(199, 41)" leading="" trailing=" " raw_val="as" val="as"/>
                    <IdentNode start="(199, 42)" end="(199, 44)" leading="" trailing=" " raw_val="bs" val="bs"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(199, 45)" end="(199, 47)" leading="" trailing=" " val="++"/>
                <OtherNode start="(199, 48)" end="(199, 59)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(199, 48)" end="(199, 51)" leading="" trailing=" " raw_val="zip" val="zip" full_name="Vector.zip" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(199, 52)" end="(199, 59)">
                    <IdentNode start="(199, 52)" end="(199, 55)" leading="" trailing=" " raw_val="as'" val="as'"/>
                    <IdentNode start="(199, 56)" end="(199, 59)" leading="" trailing=" " raw_val="bs'" val="bs'"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(199, 60)" end="(204, 33)">
          <AtomNode start="(199, 60)" end="(199, 62)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(199, 63)" end="(204, 33)">
            <AtomNode start="(199, 63)" end="(199, 65)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(200, 3)" end="(204, 33)">
              <TacticTacticseq1IndentedNode start="(200, 3)" end="(204, 33)">
                <NullNode start="(200, 3)" end="(204, 33)">
                  <OtherNode start="(200, 3)" end="(200, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;n : Nat&#10;β : Type u_2&#10;m : Nat&#10;as : Vector α n&#10;bs : Vector β n&#10;as' : Vector α m&#10;bs' : Vector β m&#10;⊢ (as ++ as').zip (bs ++ bs') = as.zip bs ++ as'.zip bs'" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;m : Nat&#10;as' : Vector α m&#10;bs' : Vector β m&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ ({ toArray := as, size_toArray := ⋯ } ++ as').zip (bs ++ bs') =&#10;    { toArray := as, size_toArray := ⋯ }.zip bs ++ as'.zip bs'" tactic="rcases as with ⟨as, rfl⟩">
                    <AtomNode start="(200, 3)" end="(200, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(200, 10)" end="(200, 12)">
                      <OtherNode start="(200, 10)" end="(200, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(200, 10)" end="(200, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(200, 13)" end="(200, 27)">
                      <AtomNode start="(200, 13)" end="(200, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(200, 18)" end="(200, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(200, 18)" end="(200, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(200, 18)" end="(200, 27)">
                            <OtherNode start="(200, 18)" end="(200, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(200, 18)" end="(200, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(200, 19)" end="(200, 26)">
                                <OtherNode start="(200, 19)" end="(200, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(200, 19)" end="(200, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(200, 19)" end="(200, 21)">
                                      <OtherNode start="(200, 19)" end="(200, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(200, 19)" end="(200, 21)" leading="" trailing="" raw_val="as" val="as"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(200, 21)" end="(200, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(200, 23)" end="(200, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(200, 23)" end="(200, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(200, 23)" end="(200, 26)">
                                      <OtherNode start="(200, 23)" end="(200, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(200, 23)" end="(200, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(200, 26)" end="(200, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(201, 3)" end="(201, 25)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;m : Nat&#10;as' : Vector α m&#10;bs' : Vector β m&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ ({ toArray := as, size_toArray := ⋯ } ++ as').zip (bs ++ bs') =&#10;    { toArray := as, size_toArray := ⋯ }.zip bs ++ as'.zip bs'" state_after="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;m : Nat&#10;as' : Vector α m&#10;bs' : Vector β m&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ ({ toArray := as, size_toArray := ⋯ } ++ as').zip ({ toArray := bs, size_toArray := h } ++ bs') =&#10;    { toArray := as, size_toArray := ⋯ }.zip { toArray := bs, size_toArray := h } ++ as'.zip bs'" tactic="rcases bs with ⟨bs, h⟩">
                    <AtomNode start="(201, 3)" end="(201, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(201, 10)" end="(201, 12)">
                      <OtherNode start="(201, 10)" end="(201, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(201, 10)" end="(201, 12)" leading="" trailing=" " raw_val="bs" val="bs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(201, 13)" end="(201, 25)">
                      <AtomNode start="(201, 13)" end="(201, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(201, 18)" end="(201, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(201, 18)" end="(201, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(201, 18)" end="(201, 25)">
                            <OtherNode start="(201, 18)" end="(201, 25)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(201, 18)" end="(201, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(201, 19)" end="(201, 24)">
                                <OtherNode start="(201, 19)" end="(201, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(201, 19)" end="(201, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(201, 19)" end="(201, 21)">
                                      <OtherNode start="(201, 19)" end="(201, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(201, 19)" end="(201, 21)" leading="" trailing="" raw_val="bs" val="bs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(201, 21)" end="(201, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(201, 23)" end="(201, 24)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(201, 23)" end="(201, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(201, 23)" end="(201, 24)">
                                      <OtherNode start="(201, 23)" end="(201, 24)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(201, 23)" end="(201, 24)" leading="" trailing="" raw_val="h" val="h"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(201, 24)" end="(201, 25)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(202, 3)" end="(202, 29)" kind="Lean.Parser.Tactic.rcases" state_before="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;m : Nat&#10;as' : Vector α m&#10;bs' : Vector β m&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ ({ toArray := as, size_toArray := ⋯ } ++ as').zip ({ toArray := bs, size_toArray := h } ++ bs') =&#10;    { toArray := as, size_toArray := ⋯ }.zip { toArray := bs, size_toArray := h } ++ as'.zip bs'" state_after="case mk.mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;as' : Array α&#10;bs' : Vector β as'.size&#10;⊢ ({ toArray := as, size_toArray := ⋯ } ++ { toArray := as', size_toArray := ⋯ }).zip&#10;      ({ toArray := bs, size_toArray := h } ++ bs') =&#10;    { toArray := as, size_toArray := ⋯ }.zip { toArray := bs, size_toArray := h } ++&#10;      { toArray := as', size_toArray := ⋯ }.zip bs'" tactic="rcases as' with ⟨as', rfl⟩">
                    <AtomNode start="(202, 3)" end="(202, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(202, 10)" end="(202, 13)">
                      <OtherNode start="(202, 10)" end="(202, 13)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(202, 10)" end="(202, 13)" leading="" trailing=" " raw_val="as'" val="as'"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(202, 14)" end="(202, 29)">
                      <AtomNode start="(202, 14)" end="(202, 18)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(202, 19)" end="(202, 29)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(202, 19)" end="(202, 29)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(202, 19)" end="(202, 29)">
                            <OtherNode start="(202, 19)" end="(202, 29)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(202, 19)" end="(202, 20)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(202, 20)" end="(202, 28)">
                                <OtherNode start="(202, 20)" end="(202, 23)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(202, 20)" end="(202, 23)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(202, 20)" end="(202, 23)">
                                      <OtherNode start="(202, 20)" end="(202, 23)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(202, 20)" end="(202, 23)" leading="" trailing="" raw_val="as'" val="as'"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(202, 23)" end="(202, 24)" leading="" trailing=" " val=","/>
                                <OtherNode start="(202, 25)" end="(202, 28)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(202, 25)" end="(202, 28)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(202, 25)" end="(202, 28)">
                                      <OtherNode start="(202, 25)" end="(202, 28)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(202, 25)" end="(202, 28)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(202, 28)" end="(202, 29)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(203, 3)" end="(203, 28)" kind="Lean.Parser.Tactic.rcases" state_before="case mk.mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;as' : Array α&#10;bs' : Vector β as'.size&#10;⊢ ({ toArray := as, size_toArray := ⋯ } ++ { toArray := as', size_toArray := ⋯ }).zip&#10;      ({ toArray := bs, size_toArray := h } ++ bs') =&#10;    { toArray := as, size_toArray := ⋯ }.zip { toArray := bs, size_toArray := h } ++&#10;      { toArray := as', size_toArray := ⋯ }.zip bs'" state_after="case mk.mk.mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;as' : Array α&#10;bs' : Array β&#10;h' : bs'.size = as'.size&#10;⊢ ({ toArray := as, size_toArray := ⋯ } ++ { toArray := as', size_toArray := ⋯ }).zip&#10;      ({ toArray := bs, size_toArray := h } ++ { toArray := bs', size_toArray := h' }) =&#10;    { toArray := as, size_toArray := ⋯ }.zip { toArray := bs, size_toArray := h } ++&#10;      { toArray := as', size_toArray := ⋯ }.zip { toArray := bs', size_toArray := h' }" tactic="rcases bs' with ⟨bs', h'⟩">
                    <AtomNode start="(203, 3)" end="(203, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(203, 10)" end="(203, 13)">
                      <OtherNode start="(203, 10)" end="(203, 13)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(203, 10)" end="(203, 13)" leading="" trailing=" " raw_val="bs'" val="bs'"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(203, 14)" end="(203, 28)">
                      <AtomNode start="(203, 14)" end="(203, 18)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(203, 19)" end="(203, 28)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(203, 19)" end="(203, 28)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(203, 19)" end="(203, 28)">
                            <OtherNode start="(203, 19)" end="(203, 28)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(203, 19)" end="(203, 20)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(203, 20)" end="(203, 27)">
                                <OtherNode start="(203, 20)" end="(203, 23)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(203, 20)" end="(203, 23)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(203, 20)" end="(203, 23)">
                                      <OtherNode start="(203, 20)" end="(203, 23)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(203, 20)" end="(203, 23)" leading="" trailing="" raw_val="bs'" val="bs'"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(203, 23)" end="(203, 24)" leading="" trailing=" " val=","/>
                                <OtherNode start="(203, 25)" end="(203, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(203, 25)" end="(203, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(203, 25)" end="(203, 27)">
                                      <OtherNode start="(203, 25)" end="(203, 27)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(203, 25)" end="(203, 27)" leading="" trailing="" raw_val="h'" val="h'"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(203, 27)" end="(203, 28)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(204, 3)" end="(204, 33)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk.mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;as' : Array α&#10;bs' : Array β&#10;h' : bs'.size = as'.size&#10;⊢ ({ toArray := as, size_toArray := ⋯ } ++ { toArray := as', size_toArray := ⋯ }).zip&#10;      ({ toArray := bs, size_toArray := h } ++ { toArray := bs', size_toArray := h' }) =&#10;    { toArray := as, size_toArray := ⋯ }.zip { toArray := bs, size_toArray := h } ++&#10;      { toArray := as', size_toArray := ⋯ }.zip { toArray := bs', size_toArray := h' }" state_after="no goals" tactic="simp [Array.zip_append, h, h']">
                    <AtomNode start="(204, 3)" end="(204, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(204, 8)" end="(204, 33)">
                      <AtomNode start="(204, 8)" end="(204, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(204, 9)" end="(204, 32)">
                        <OtherNode start="(204, 9)" end="(204, 25)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(204, 9)" end="(204, 25)" leading="" trailing="" raw_val="Array.zip_append" val="Array.zip_append" full_name="Array.zip_append" mod_name="Init.Data.Array.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Zip.lean"/>
                        </OtherNode>
                        <AtomNode start="(204, 25)" end="(204, 26)" leading="" trailing=" " val=","/>
                        <OtherNode start="(204, 27)" end="(204, 28)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(204, 27)" end="(204, 28)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                        <AtomNode start="(204, 28)" end="(204, 29)" leading="" trailing=" " val=","/>
                        <OtherNode start="(204, 30)" end="(204, 32)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(204, 30)" end="(204, 32)" leading="" trailing="" raw_val="h'" val="h'"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(204, 32)" end="(204, 33)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(206, 1)" end="(209, 24)" name="zip_map'" full_name="Vector.zip_map'">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(206, 1)" end="(209, 24)" name="zip_map'" full_name="Vector.zip_map'" _is_private_decl="False">
        <AtomNode start="(206, 1)" end="(206, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(206, 9)" end="(206, 17)">
          <IdentNode start="(206, 9)" end="(206, 17)" leading="" trailing=" " raw_val="zip_map'" val="zip_map'"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(206, 18)" end="(207, 59)">
          <NullNode start="(206, 18)" end="(206, 59)">
            <OtherNode start="(206, 18)" end="(206, 29)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(206, 18)" end="(206, 19)" leading="" trailing="" val="{"/>
              <NullNode start="(206, 19)" end="(206, 20)">
                <IdentNode start="(206, 19)" end="(206, 20)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(206, 21)" end="(206, 28)">
                <AtomNode start="(206, 21)" end="(206, 22)" leading="" trailing=" " val=":"/>
                <OtherNode start="(206, 23)" end="(206, 28)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(206, 23)" end="(206, 24)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(206, 25)" end="(206, 26)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(206, 27)" end="(206, 28)" leading="" trailing="" raw_val="β" val="β"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(206, 28)" end="(206, 29)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(206, 30)" end="(206, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(206, 30)" end="(206, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(206, 31)" end="(206, 32)">
                <IdentNode start="(206, 31)" end="(206, 32)" leading="" trailing=" " raw_val="g" val="g"/>
              </NullNode>
              <NullNode start="(206, 33)" end="(206, 40)">
                <AtomNode start="(206, 33)" end="(206, 34)" leading="" trailing=" " val=":"/>
                <OtherNode start="(206, 35)" end="(206, 40)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(206, 35)" end="(206, 36)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(206, 37)" end="(206, 38)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(206, 39)" end="(206, 40)" leading="" trailing="" raw_val="γ" val="γ"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(206, 40)" end="(206, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(206, 42)" end="(206, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(206, 42)" end="(206, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(206, 43)" end="(206, 45)">
                <IdentNode start="(206, 43)" end="(206, 45)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(206, 46)" end="(206, 58)">
                <AtomNode start="(206, 46)" end="(206, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(206, 48)" end="(206, 58)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(206, 48)" end="(206, 54)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(206, 55)" end="(206, 58)">
                    <IdentNode start="(206, 55)" end="(206, 56)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(206, 57)" end="(206, 58)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(206, 58)" end="(206, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(206, 60)" end="(207, 59)">
            <AtomNode start="(206, 60)" end="(206, 61)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(207, 5)" end="(207, 59)" kind="«term_=_»">
              <OtherNode start="(207, 5)" end="(207, 30)" kind="Lean.Parser.Term.app">
                <IdentNode start="(207, 5)" end="(207, 8)" leading="" trailing=" " raw_val="zip" val="zip" full_name="Vector.zip" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(207, 9)" end="(207, 30)">
                  <OtherNode start="(207, 9)" end="(207, 19)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(207, 9)" end="(207, 10)" leading="" trailing="" val="("/>
                    <OtherNode start="(207, 10)" end="(207, 18)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(207, 10)" end="(207, 16)" leading="" trailing=" " raw_val="xs.map" val="xs.map"/>
                      <NullNode start="(207, 17)" end="(207, 18)">
                        <IdentNode start="(207, 17)" end="(207, 18)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(207, 18)" end="(207, 19)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(207, 20)" end="(207, 30)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(207, 20)" end="(207, 21)" leading="" trailing="" val="("/>
                    <OtherNode start="(207, 21)" end="(207, 29)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(207, 21)" end="(207, 27)" leading="" trailing=" " raw_val="xs.map" val="xs.map"/>
                      <NullNode start="(207, 28)" end="(207, 29)">
                        <IdentNode start="(207, 28)" end="(207, 29)" leading="" trailing="" raw_val="g" val="g"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(207, 29)" end="(207, 30)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(207, 31)" end="(207, 32)" leading="" trailing=" " val="="/>
              <OtherNode start="(207, 33)" end="(207, 59)" kind="Lean.Parser.Term.app">
                <IdentNode start="(207, 33)" end="(207, 39)" leading="" trailing=" " raw_val="xs.map" val="xs.map"/>
                <NullNode start="(207, 40)" end="(207, 59)">
                  <OtherNode start="(207, 40)" end="(207, 59)" kind="Lean.Parser.Term.fun">
                    <AtomNode start="(207, 40)" end="(207, 43)" leading="" trailing=" " val="fun"/>
                    <OtherNode start="(207, 44)" end="(207, 59)" kind="Lean.Parser.Term.basicFun">
                      <NullNode start="(207, 44)" end="(207, 45)">
                        <IdentNode start="(207, 44)" end="(207, 45)" leading="" trailing=" " raw_val="a" val="a"/>
                      </NullNode>
                      <NullNode/>
                      <AtomNode start="(207, 46)" end="(207, 48)" leading="" trailing=" " val="=&amp;gt;"/>
                      <OtherNode start="(207, 49)" end="(207, 59)" kind="Lean.Parser.Term.tuple">
                        <AtomNode start="(207, 49)" end="(207, 50)" leading="" trailing="" val="("/>
                        <NullNode start="(207, 50)" end="(207, 58)">
                          <OtherNode start="(207, 50)" end="(207, 53)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(207, 50)" end="(207, 51)" leading="" trailing=" " raw_val="f" val="f"/>
                            <NullNode start="(207, 52)" end="(207, 53)">
                              <IdentNode start="(207, 52)" end="(207, 53)" leading="" trailing="" raw_val="a" val="a"/>
                            </NullNode>
                          </OtherNode>
                          <AtomNode start="(207, 53)" end="(207, 54)" leading="" trailing=" " val=","/>
                          <NullNode start="(207, 55)" end="(207, 58)">
                            <OtherNode start="(207, 55)" end="(207, 58)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(207, 55)" end="(207, 56)" leading="" trailing=" " raw_val="g" val="g"/>
                              <NullNode start="(207, 57)" end="(207, 58)">
                                <IdentNode start="(207, 57)" end="(207, 58)" leading="" trailing="" raw_val="a" val="a"/>
                              </NullNode>
                            </OtherNode>
                          </NullNode>
                        </NullNode>
                        <AtomNode start="(207, 58)" end="(207, 59)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(207, 60)" end="(209, 24)">
          <AtomNode start="(207, 60)" end="(207, 62)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(207, 63)" end="(209, 24)">
            <AtomNode start="(207, 63)" end="(207, 65)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(208, 3)" end="(209, 24)">
              <TacticTacticseq1IndentedNode start="(208, 3)" end="(209, 24)">
                <NullNode start="(208, 3)" end="(209, 24)">
                  <OtherNode start="(208, 3)" end="(208, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;n : Nat&#10;f : α → β&#10;g : α → γ&#10;xs : Vector α n&#10;⊢ (map f xs).zip (map g xs) = map (fun a =&amp;gt; (f a, g a)) xs" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β&#10;g : α → γ&#10;xs : Array α&#10;⊢ (map f { toArray := xs, size_toArray := ⋯ }).zip (map g { toArray := xs, size_toArray := ⋯ }) =&#10;    map (fun a =&amp;gt; (f a, g a)) { toArray := xs, size_toArray := ⋯ }" tactic="rcases xs with ⟨xs, rfl⟩">
                    <AtomNode start="(208, 3)" end="(208, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(208, 10)" end="(208, 12)">
                      <OtherNode start="(208, 10)" end="(208, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(208, 10)" end="(208, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(208, 13)" end="(208, 27)">
                      <AtomNode start="(208, 13)" end="(208, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(208, 18)" end="(208, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(208, 18)" end="(208, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(208, 18)" end="(208, 27)">
                            <OtherNode start="(208, 18)" end="(208, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(208, 18)" end="(208, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(208, 19)" end="(208, 26)">
                                <OtherNode start="(208, 19)" end="(208, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(208, 19)" end="(208, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(208, 19)" end="(208, 21)">
                                      <OtherNode start="(208, 19)" end="(208, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(208, 19)" end="(208, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(208, 21)" end="(208, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(208, 23)" end="(208, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(208, 23)" end="(208, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(208, 23)" end="(208, 26)">
                                      <OtherNode start="(208, 23)" end="(208, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(208, 23)" end="(208, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(208, 26)" end="(208, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(209, 3)" end="(209, 24)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;γ : Type u_3&#10;f : α → β&#10;g : α → γ&#10;xs : Array α&#10;⊢ (map f { toArray := xs, size_toArray := ⋯ }).zip (map g { toArray := xs, size_toArray := ⋯ }) =&#10;    map (fun a =&amp;gt; (f a, g a)) { toArray := xs, size_toArray := ⋯ }" state_after="no goals" tactic="simp [Array.zip_map']">
                    <AtomNode start="(209, 3)" end="(209, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(209, 8)" end="(209, 24)">
                      <AtomNode start="(209, 8)" end="(209, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(209, 9)" end="(209, 23)">
                        <OtherNode start="(209, 9)" end="(209, 23)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(209, 9)" end="(209, 23)" leading="" trailing="" raw_val="Array.zip_map'" val="Array.zip_map'" full_name="Array.zip_map'" mod_name="Init.Data.Array.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Zip.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(209, 23)" end="(209, 24)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(211, 1)" end="(214, 31)" name="of_mem_zip" full_name="Vector.of_mem_zip">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(211, 1)" end="(214, 31)" name="of_mem_zip" full_name="Vector.of_mem_zip" _is_private_decl="False">
        <AtomNode start="(211, 1)" end="(211, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(211, 9)" end="(211, 19)">
          <IdentNode start="(211, 9)" end="(211, 19)" leading="" trailing=" " raw_val="of_mem_zip" val="of_mem_zip"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(211, 20)" end="(211, 100)">
          <NullNode start="(211, 20)" end="(211, 61)">
            <OtherNode start="(211, 20)" end="(211, 25)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(211, 20)" end="(211, 21)" leading="" trailing="" val="{"/>
              <NullNode start="(211, 21)" end="(211, 24)">
                <IdentNode start="(211, 21)" end="(211, 22)" leading="" trailing=" " raw_val="a" val="a"/>
                <IdentNode start="(211, 23)" end="(211, 24)" leading="" trailing="" raw_val="b" val="b"/>
              </NullNode>
              <NullNode/>
              <AtomNode start="(211, 24)" end="(211, 25)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(211, 26)" end="(211, 43)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(211, 26)" end="(211, 27)" leading="" trailing="" val="{"/>
              <NullNode start="(211, 27)" end="(211, 29)">
                <IdentNode start="(211, 27)" end="(211, 29)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(211, 30)" end="(211, 42)">
                <AtomNode start="(211, 30)" end="(211, 31)" leading="" trailing=" " val=":"/>
                <OtherNode start="(211, 32)" end="(211, 42)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(211, 32)" end="(211, 38)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(211, 39)" end="(211, 42)">
                    <IdentNode start="(211, 39)" end="(211, 40)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(211, 41)" end="(211, 42)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(211, 42)" end="(211, 43)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(211, 44)" end="(211, 61)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(211, 44)" end="(211, 45)" leading="" trailing="" val="{"/>
              <NullNode start="(211, 45)" end="(211, 47)">
                <IdentNode start="(211, 45)" end="(211, 47)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(211, 48)" end="(211, 60)">
                <AtomNode start="(211, 48)" end="(211, 49)" leading="" trailing=" " val=":"/>
                <OtherNode start="(211, 50)" end="(211, 60)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(211, 50)" end="(211, 56)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(211, 57)" end="(211, 60)">
                    <IdentNode start="(211, 57)" end="(211, 58)" leading="" trailing=" " raw_val="β" val="β"/>
                    <IdentNode start="(211, 59)" end="(211, 60)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(211, 60)" end="(211, 61)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(211, 62)" end="(211, 100)">
            <AtomNode start="(211, 62)" end="(211, 63)" leading="" trailing=" " val=":"/>
            <OtherNode start="(211, 64)" end="(211, 100)" kind="Lean.Parser.Term.arrow">
              <OtherNode start="(211, 64)" end="(211, 82)" kind="«term_∈_»">
                <OtherNode start="(211, 64)" end="(211, 70)" kind="Lean.Parser.Term.tuple">
                  <AtomNode start="(211, 64)" end="(211, 65)" leading="" trailing="" val="("/>
                  <NullNode start="(211, 65)" end="(211, 69)">
                    <IdentNode start="(211, 65)" end="(211, 66)" leading="" trailing="" raw_val="a" val="a"/>
                    <AtomNode start="(211, 66)" end="(211, 67)" leading="" trailing=" " val=","/>
                    <NullNode start="(211, 68)" end="(211, 69)">
                      <IdentNode start="(211, 68)" end="(211, 69)" leading="" trailing="" raw_val="b" val="b"/>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(211, 69)" end="(211, 70)" leading="" trailing=" " val=")"/>
                </OtherNode>
                <AtomNode start="(211, 71)" end="(211, 72)" leading="" trailing=" " val="∈"/>
                <OtherNode start="(211, 73)" end="(211, 82)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(211, 73)" end="(211, 76)" leading="" trailing=" " raw_val="zip" val="zip" full_name="Vector.zip" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(211, 77)" end="(211, 82)">
                    <IdentNode start="(211, 77)" end="(211, 79)" leading="" trailing=" " raw_val="as" val="as"/>
                    <IdentNode start="(211, 80)" end="(211, 82)" leading="" trailing=" " raw_val="bs" val="bs"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(211, 83)" end="(211, 84)" leading="" trailing=" " val="→"/>
              <OtherNode start="(211, 85)" end="(211, 100)" kind="«term_∧_»">
                <OtherNode start="(211, 85)" end="(211, 91)" kind="«term_∈_»">
                  <IdentNode start="(211, 85)" end="(211, 86)" leading="" trailing=" " raw_val="a" val="a"/>
                  <AtomNode start="(211, 87)" end="(211, 88)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(211, 89)" end="(211, 91)" leading="" trailing=" " raw_val="as" val="as"/>
                </OtherNode>
                <AtomNode start="(211, 92)" end="(211, 93)" leading="" trailing=" " val="∧"/>
                <OtherNode start="(211, 94)" end="(211, 100)" kind="«term_∈_»">
                  <IdentNode start="(211, 94)" end="(211, 95)" leading="" trailing=" " raw_val="b" val="b"/>
                  <AtomNode start="(211, 96)" end="(211, 97)" leading="" trailing=" " val="∈"/>
                  <IdentNode start="(211, 98)" end="(211, 100)" leading="" trailing=" " raw_val="bs" val="bs"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(211, 101)" end="(214, 31)">
          <AtomNode start="(211, 101)" end="(211, 103)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(211, 104)" end="(214, 31)">
            <AtomNode start="(211, 104)" end="(211, 106)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(212, 3)" end="(214, 31)">
              <TacticTacticseq1IndentedNode start="(212, 3)" end="(214, 31)">
                <NullNode start="(212, 3)" end="(214, 31)">
                  <OtherNode start="(212, 3)" end="(212, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;n : Nat&#10;β : Type u_2&#10;a : α&#10;b : β&#10;as : Vector α n&#10;bs : Vector β n&#10;⊢ (a, b) ∈ as.zip bs → a ∈ as ∧ b ∈ bs" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ (a, b) ∈ { toArray := as, size_toArray := ⋯ }.zip bs → a ∈ { toArray := as, size_toArray := ⋯ } ∧ b ∈ bs" tactic="rcases as with ⟨as, rfl⟩">
                    <AtomNode start="(212, 3)" end="(212, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(212, 10)" end="(212, 12)">
                      <OtherNode start="(212, 10)" end="(212, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(212, 10)" end="(212, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(212, 13)" end="(212, 27)">
                      <AtomNode start="(212, 13)" end="(212, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(212, 18)" end="(212, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(212, 18)" end="(212, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(212, 18)" end="(212, 27)">
                            <OtherNode start="(212, 18)" end="(212, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(212, 18)" end="(212, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(212, 19)" end="(212, 26)">
                                <OtherNode start="(212, 19)" end="(212, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(212, 19)" end="(212, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(212, 19)" end="(212, 21)">
                                      <OtherNode start="(212, 19)" end="(212, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(212, 19)" end="(212, 21)" leading="" trailing="" raw_val="as" val="as"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(212, 21)" end="(212, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(212, 23)" end="(212, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(212, 23)" end="(212, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(212, 23)" end="(212, 26)">
                                      <OtherNode start="(212, 23)" end="(212, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(212, 23)" end="(212, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(212, 26)" end="(212, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(213, 3)" end="(213, 25)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ (a, b) ∈ { toArray := as, size_toArray := ⋯ }.zip bs → a ∈ { toArray := as, size_toArray := ⋯ } ∧ b ∈ bs" state_after="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ (a, b) ∈ { toArray := as, size_toArray := ⋯ }.zip { toArray := bs, size_toArray := h } →&#10;    a ∈ { toArray := as, size_toArray := ⋯ } ∧ b ∈ { toArray := bs, size_toArray := h }" tactic="rcases bs with ⟨bs, h⟩">
                    <AtomNode start="(213, 3)" end="(213, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(213, 10)" end="(213, 12)">
                      <OtherNode start="(213, 10)" end="(213, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(213, 10)" end="(213, 12)" leading="" trailing=" " raw_val="bs" val="bs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(213, 13)" end="(213, 25)">
                      <AtomNode start="(213, 13)" end="(213, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(213, 18)" end="(213, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(213, 18)" end="(213, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(213, 18)" end="(213, 25)">
                            <OtherNode start="(213, 18)" end="(213, 25)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(213, 18)" end="(213, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(213, 19)" end="(213, 24)">
                                <OtherNode start="(213, 19)" end="(213, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(213, 19)" end="(213, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(213, 19)" end="(213, 21)">
                                      <OtherNode start="(213, 19)" end="(213, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(213, 19)" end="(213, 21)" leading="" trailing="" raw_val="bs" val="bs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(213, 21)" end="(213, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(213, 23)" end="(213, 24)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(213, 23)" end="(213, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(213, 23)" end="(213, 24)">
                                      <OtherNode start="(213, 23)" end="(213, 24)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(213, 23)" end="(213, 24)" leading="" trailing="" raw_val="h" val="h"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(213, 24)" end="(213, 25)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(214, 3)" end="(214, 31)" kind="Lean.Parser.Tactic.simpa" state_before="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ (a, b) ∈ { toArray := as, size_toArray := ⋯ }.zip { toArray := bs, size_toArray := h } →&#10;    a ∈ { toArray := as, size_toArray := ⋯ } ∧ b ∈ { toArray := bs, size_toArray := h }" state_after="no goals" tactic="simpa using Array.of_mem_zip">
                    <AtomNode start="(214, 3)" end="(214, 8)" leading="" trailing=" " val="simpa"/>
                    <NullNode/>
                    <NullNode/>
                    <OtherNode start="(214, 9)" end="(214, 31)" kind="Lean.Parser.Tactic.simpaArgsRest">
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode start="(214, 9)" end="(214, 31)">
                        <AtomNode start="(214, 9)" end="(214, 14)" leading="" trailing=" " val="using"/>
                        <IdentNode start="(214, 15)" end="(214, 31)" leading="" trailing="&#10;&#10;-- The argument `as` is explicit so we can rewrite from right to left.&#10;" raw_val="Array.of_mem_zip" val="Array.of_mem_zip" full_name="Array.of_mem_zip" mod_name="Init.Data.Array.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Zip.lean"/>
                      </NullNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(217, 1)" end="(221, 30)" name="map_fst_zip" full_name="Vector.map_fst_zip">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(217, 1)" end="(221, 30)" name="map_fst_zip" full_name="Vector.map_fst_zip" _is_private_decl="False">
        <AtomNode start="(217, 1)" end="(217, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(217, 9)" end="(217, 20)">
          <IdentNode start="(217, 9)" end="(217, 20)" leading="" trailing=" " raw_val="map_fst_zip" val="map_fst_zip"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(217, 21)" end="(218, 34)">
          <NullNode start="(217, 21)" end="(217, 56)">
            <TermExplicitbinderNode start="(217, 21)" end="(217, 38)">
              <AtomNode start="(217, 21)" end="(217, 22)" leading="" trailing="" val="("/>
              <NullNode start="(217, 22)" end="(217, 24)">
                <IdentNode start="(217, 22)" end="(217, 24)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(217, 25)" end="(217, 37)">
                <AtomNode start="(217, 25)" end="(217, 26)" leading="" trailing=" " val=":"/>
                <OtherNode start="(217, 27)" end="(217, 37)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(217, 27)" end="(217, 33)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(217, 34)" end="(217, 37)">
                    <IdentNode start="(217, 34)" end="(217, 35)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(217, 36)" end="(217, 37)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(217, 37)" end="(217, 38)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
            <OtherNode start="(217, 39)" end="(217, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(217, 39)" end="(217, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(217, 40)" end="(217, 42)">
                <IdentNode start="(217, 40)" end="(217, 42)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(217, 43)" end="(217, 55)">
                <AtomNode start="(217, 43)" end="(217, 44)" leading="" trailing=" " val=":"/>
                <OtherNode start="(217, 45)" end="(217, 55)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(217, 45)" end="(217, 51)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(217, 52)" end="(217, 55)">
                    <IdentNode start="(217, 52)" end="(217, 53)" leading="" trailing=" " raw_val="β" val="β"/>
                    <IdentNode start="(217, 54)" end="(217, 55)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(217, 55)" end="(217, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(217, 57)" end="(218, 34)">
            <AtomNode start="(217, 57)" end="(217, 58)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(218, 5)" end="(218, 34)" kind="«term_=_»">
              <OtherNode start="(218, 5)" end="(218, 29)" kind="Lean.Parser.Term.app">
                <IdentNode start="(218, 5)" end="(218, 8)" leading="" trailing=" " raw_val="map" val="map" full_name="Vector.map" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(218, 9)" end="(218, 29)">
                  <IdentNode start="(218, 9)" end="(218, 17)" leading="" trailing=" " raw_val="Prod.fst" val="Prod.fst" full_name="Prod.fst" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <OtherNode start="(218, 18)" end="(218, 29)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(218, 18)" end="(218, 19)" leading="" trailing="" val="("/>
                    <OtherNode start="(218, 19)" end="(218, 28)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(218, 19)" end="(218, 22)" leading="" trailing=" " raw_val="zip" val="zip" full_name="Vector.zip" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                      <NullNode start="(218, 23)" end="(218, 28)">
                        <IdentNode start="(218, 23)" end="(218, 25)" leading="" trailing=" " raw_val="as" val="as"/>
                        <IdentNode start="(218, 26)" end="(218, 28)" leading="" trailing="" raw_val="bs" val="bs"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(218, 28)" end="(218, 29)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(218, 30)" end="(218, 31)" leading="" trailing=" " val="="/>
              <IdentNode start="(218, 32)" end="(218, 34)" leading="" trailing=" " raw_val="as" val="as"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(218, 35)" end="(221, 30)">
          <AtomNode start="(218, 35)" end="(218, 37)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(218, 38)" end="(221, 30)">
            <AtomNode start="(218, 38)" end="(218, 40)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(219, 3)" end="(221, 30)">
              <TacticTacticseq1IndentedNode start="(219, 3)" end="(221, 30)">
                <NullNode start="(219, 3)" end="(221, 30)">
                  <OtherNode start="(219, 3)" end="(219, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;n : Nat&#10;β : Type u_2&#10;as : Vector α n&#10;bs : Vector β n&#10;⊢ map Prod.fst (as.zip bs) = as" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ map Prod.fst ({ toArray := as, size_toArray := ⋯ }.zip bs) = { toArray := as, size_toArray := ⋯ }" tactic="rcases as with ⟨as, rfl⟩">
                    <AtomNode start="(219, 3)" end="(219, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(219, 10)" end="(219, 12)">
                      <OtherNode start="(219, 10)" end="(219, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(219, 10)" end="(219, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(219, 13)" end="(219, 27)">
                      <AtomNode start="(219, 13)" end="(219, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(219, 18)" end="(219, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(219, 18)" end="(219, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(219, 18)" end="(219, 27)">
                            <OtherNode start="(219, 18)" end="(219, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(219, 18)" end="(219, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(219, 19)" end="(219, 26)">
                                <OtherNode start="(219, 19)" end="(219, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(219, 19)" end="(219, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(219, 19)" end="(219, 21)">
                                      <OtherNode start="(219, 19)" end="(219, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(219, 19)" end="(219, 21)" leading="" trailing="" raw_val="as" val="as"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(219, 21)" end="(219, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(219, 23)" end="(219, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(219, 23)" end="(219, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(219, 23)" end="(219, 26)">
                                      <OtherNode start="(219, 23)" end="(219, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(219, 23)" end="(219, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(219, 26)" end="(219, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(220, 3)" end="(220, 25)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ map Prod.fst ({ toArray := as, size_toArray := ⋯ }.zip bs) = { toArray := as, size_toArray := ⋯ }" state_after="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ map Prod.fst ({ toArray := as, size_toArray := ⋯ }.zip { toArray := bs, size_toArray := h }) =&#10;    { toArray := as, size_toArray := ⋯ }" tactic="rcases bs with ⟨bs, h⟩">
                    <AtomNode start="(220, 3)" end="(220, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(220, 10)" end="(220, 12)">
                      <OtherNode start="(220, 10)" end="(220, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(220, 10)" end="(220, 12)" leading="" trailing=" " raw_val="bs" val="bs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(220, 13)" end="(220, 25)">
                      <AtomNode start="(220, 13)" end="(220, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(220, 18)" end="(220, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(220, 18)" end="(220, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(220, 18)" end="(220, 25)">
                            <OtherNode start="(220, 18)" end="(220, 25)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(220, 18)" end="(220, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(220, 19)" end="(220, 24)">
                                <OtherNode start="(220, 19)" end="(220, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(220, 19)" end="(220, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(220, 19)" end="(220, 21)">
                                      <OtherNode start="(220, 19)" end="(220, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(220, 19)" end="(220, 21)" leading="" trailing="" raw_val="bs" val="bs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(220, 21)" end="(220, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(220, 23)" end="(220, 24)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(220, 23)" end="(220, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(220, 23)" end="(220, 24)">
                                      <OtherNode start="(220, 23)" end="(220, 24)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(220, 23)" end="(220, 24)" leading="" trailing="" raw_val="h" val="h"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(220, 24)" end="(220, 25)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(221, 3)" end="(221, 30)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ map Prod.fst ({ toArray := as, size_toArray := ⋯ }.zip { toArray := bs, size_toArray := h }) =&#10;    { toArray := as, size_toArray := ⋯ }" state_after="no goals" tactic="simp [Array.map_fst_zip, h]">
                    <AtomNode start="(221, 3)" end="(221, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(221, 8)" end="(221, 30)">
                      <AtomNode start="(221, 8)" end="(221, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(221, 9)" end="(221, 29)">
                        <OtherNode start="(221, 9)" end="(221, 26)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(221, 9)" end="(221, 26)" leading="" trailing="" raw_val="Array.map_fst_zip" val="Array.map_fst_zip" full_name="Array.map_fst_zip" mod_name="Init.Data.Array.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Zip.lean"/>
                        </OtherNode>
                        <AtomNode start="(221, 26)" end="(221, 27)" leading="" trailing=" " val=","/>
                        <OtherNode start="(221, 28)" end="(221, 29)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(221, 28)" end="(221, 29)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(221, 29)" end="(221, 30)" leading="" trailing="&#10;&#10;-- The argument `bs` is explicit so we can rewrite from right to left.&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(224, 1)" end="(228, 30)" name="map_snd_zip" full_name="Vector.map_snd_zip">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(224, 1)" end="(228, 30)" name="map_snd_zip" full_name="Vector.map_snd_zip" _is_private_decl="False">
        <AtomNode start="(224, 1)" end="(224, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(224, 9)" end="(224, 20)">
          <IdentNode start="(224, 9)" end="(224, 20)" leading="" trailing=" " raw_val="map_snd_zip" val="map_snd_zip"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(224, 21)" end="(225, 34)">
          <NullNode start="(224, 21)" end="(224, 56)">
            <OtherNode start="(224, 21)" end="(224, 38)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(224, 21)" end="(224, 22)" leading="" trailing="" val="{"/>
              <NullNode start="(224, 22)" end="(224, 24)">
                <IdentNode start="(224, 22)" end="(224, 24)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(224, 25)" end="(224, 37)">
                <AtomNode start="(224, 25)" end="(224, 26)" leading="" trailing=" " val=":"/>
                <OtherNode start="(224, 27)" end="(224, 37)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(224, 27)" end="(224, 33)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(224, 34)" end="(224, 37)">
                    <IdentNode start="(224, 34)" end="(224, 35)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(224, 36)" end="(224, 37)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(224, 37)" end="(224, 38)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(224, 39)" end="(224, 56)">
              <AtomNode start="(224, 39)" end="(224, 40)" leading="" trailing="" val="("/>
              <NullNode start="(224, 40)" end="(224, 42)">
                <IdentNode start="(224, 40)" end="(224, 42)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(224, 43)" end="(224, 55)">
                <AtomNode start="(224, 43)" end="(224, 44)" leading="" trailing=" " val=":"/>
                <OtherNode start="(224, 45)" end="(224, 55)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(224, 45)" end="(224, 51)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(224, 52)" end="(224, 55)">
                    <IdentNode start="(224, 52)" end="(224, 53)" leading="" trailing=" " raw_val="β" val="β"/>
                    <IdentNode start="(224, 54)" end="(224, 55)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(224, 55)" end="(224, 56)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(224, 57)" end="(225, 34)">
            <AtomNode start="(224, 57)" end="(224, 58)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(225, 5)" end="(225, 34)" kind="«term_=_»">
              <OtherNode start="(225, 5)" end="(225, 29)" kind="Lean.Parser.Term.app">
                <IdentNode start="(225, 5)" end="(225, 8)" leading="" trailing=" " raw_val="map" val="map" full_name="Vector.map" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(225, 9)" end="(225, 29)">
                  <IdentNode start="(225, 9)" end="(225, 17)" leading="" trailing=" " raw_val="Prod.snd" val="Prod.snd" full_name="Prod.snd" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <OtherNode start="(225, 18)" end="(225, 29)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(225, 18)" end="(225, 19)" leading="" trailing="" val="("/>
                    <OtherNode start="(225, 19)" end="(225, 28)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(225, 19)" end="(225, 22)" leading="" trailing=" " raw_val="zip" val="zip" full_name="Vector.zip" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                      <NullNode start="(225, 23)" end="(225, 28)">
                        <IdentNode start="(225, 23)" end="(225, 25)" leading="" trailing=" " raw_val="as" val="as"/>
                        <IdentNode start="(225, 26)" end="(225, 28)" leading="" trailing="" raw_val="bs" val="bs"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(225, 28)" end="(225, 29)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(225, 30)" end="(225, 31)" leading="" trailing=" " val="="/>
              <IdentNode start="(225, 32)" end="(225, 34)" leading="" trailing=" " raw_val="bs" val="bs"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(225, 35)" end="(228, 30)">
          <AtomNode start="(225, 35)" end="(225, 37)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(225, 38)" end="(228, 30)">
            <AtomNode start="(225, 38)" end="(225, 40)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(226, 3)" end="(228, 30)">
              <TacticTacticseq1IndentedNode start="(226, 3)" end="(228, 30)">
                <NullNode start="(226, 3)" end="(228, 30)">
                  <OtherNode start="(226, 3)" end="(226, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;n : Nat&#10;β : Type u_2&#10;as : Vector α n&#10;bs : Vector β n&#10;⊢ map Prod.snd (as.zip bs) = bs" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ map Prod.snd ({ toArray := as, size_toArray := ⋯ }.zip bs) = bs" tactic="rcases as with ⟨as, rfl⟩">
                    <AtomNode start="(226, 3)" end="(226, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(226, 10)" end="(226, 12)">
                      <OtherNode start="(226, 10)" end="(226, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(226, 10)" end="(226, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(226, 13)" end="(226, 27)">
                      <AtomNode start="(226, 13)" end="(226, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(226, 18)" end="(226, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(226, 18)" end="(226, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(226, 18)" end="(226, 27)">
                            <OtherNode start="(226, 18)" end="(226, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(226, 18)" end="(226, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(226, 19)" end="(226, 26)">
                                <OtherNode start="(226, 19)" end="(226, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(226, 19)" end="(226, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(226, 19)" end="(226, 21)">
                                      <OtherNode start="(226, 19)" end="(226, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(226, 19)" end="(226, 21)" leading="" trailing="" raw_val="as" val="as"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(226, 21)" end="(226, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(226, 23)" end="(226, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(226, 23)" end="(226, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(226, 23)" end="(226, 26)">
                                      <OtherNode start="(226, 23)" end="(226, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(226, 23)" end="(226, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(226, 26)" end="(226, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(227, 3)" end="(227, 25)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ map Prod.snd ({ toArray := as, size_toArray := ⋯ }.zip bs) = bs" state_after="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ map Prod.snd ({ toArray := as, size_toArray := ⋯ }.zip { toArray := bs, size_toArray := h }) =&#10;    { toArray := bs, size_toArray := h }" tactic="rcases bs with ⟨bs, h⟩">
                    <AtomNode start="(227, 3)" end="(227, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(227, 10)" end="(227, 12)">
                      <OtherNode start="(227, 10)" end="(227, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(227, 10)" end="(227, 12)" leading="" trailing=" " raw_val="bs" val="bs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(227, 13)" end="(227, 25)">
                      <AtomNode start="(227, 13)" end="(227, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(227, 18)" end="(227, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(227, 18)" end="(227, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(227, 18)" end="(227, 25)">
                            <OtherNode start="(227, 18)" end="(227, 25)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(227, 18)" end="(227, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(227, 19)" end="(227, 24)">
                                <OtherNode start="(227, 19)" end="(227, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(227, 19)" end="(227, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(227, 19)" end="(227, 21)">
                                      <OtherNode start="(227, 19)" end="(227, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(227, 19)" end="(227, 21)" leading="" trailing="" raw_val="bs" val="bs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(227, 21)" end="(227, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(227, 23)" end="(227, 24)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(227, 23)" end="(227, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(227, 23)" end="(227, 24)">
                                      <OtherNode start="(227, 23)" end="(227, 24)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(227, 23)" end="(227, 24)" leading="" trailing="" raw_val="h" val="h"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(227, 24)" end="(227, 25)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(228, 3)" end="(228, 30)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ map Prod.snd ({ toArray := as, size_toArray := ⋯ }.zip { toArray := bs, size_toArray := h }) =&#10;    { toArray := bs, size_toArray := h }" state_after="no goals" tactic="simp [Array.map_snd_zip, h]">
                    <AtomNode start="(228, 3)" end="(228, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(228, 8)" end="(228, 30)">
                      <AtomNode start="(228, 8)" end="(228, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(228, 9)" end="(228, 29)">
                        <OtherNode start="(228, 9)" end="(228, 26)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(228, 9)" end="(228, 26)" leading="" trailing="" raw_val="Array.map_snd_zip" val="Array.map_snd_zip" full_name="Array.map_snd_zip" mod_name="Init.Data.Array.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Zip.lean"/>
                        </OtherNode>
                        <AtomNode start="(228, 26)" end="(228, 27)" leading="" trailing=" " val=","/>
                        <OtherNode start="(228, 28)" end="(228, 29)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(228, 28)" end="(228, 29)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(228, 29)" end="(228, 30)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(230, 1)" end="(235, 7)" name="map_prod_left_eq_zip" full_name="Vector.map_prod_left_eq_zip">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(230, 1)" end="(235, 7)" name="map_prod_left_eq_zip" full_name="Vector.map_prod_left_eq_zip" _is_private_decl="False">
        <AtomNode start="(230, 1)" end="(230, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(230, 9)" end="(230, 29)">
          <IdentNode start="(230, 9)" end="(230, 29)" leading="" trailing=" " raw_val="map_prod_left_eq_zip" val="map_prod_left_eq_zip"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(230, 30)" end="(231, 51)">
          <NullNode start="(230, 30)" end="(230, 59)">
            <OtherNode start="(230, 30)" end="(230, 47)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(230, 30)" end="(230, 31)" leading="" trailing="" val="{"/>
              <NullNode start="(230, 31)" end="(230, 33)">
                <IdentNode start="(230, 31)" end="(230, 33)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(230, 34)" end="(230, 46)">
                <AtomNode start="(230, 34)" end="(230, 35)" leading="" trailing=" " val=":"/>
                <OtherNode start="(230, 36)" end="(230, 46)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(230, 36)" end="(230, 42)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(230, 43)" end="(230, 46)">
                    <IdentNode start="(230, 43)" end="(230, 44)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(230, 45)" end="(230, 46)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(230, 46)" end="(230, 47)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(230, 48)" end="(230, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(230, 48)" end="(230, 49)" leading="" trailing="" val="{"/>
              <NullNode start="(230, 49)" end="(230, 50)">
                <IdentNode start="(230, 49)" end="(230, 50)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(230, 51)" end="(230, 58)">
                <AtomNode start="(230, 51)" end="(230, 52)" leading="" trailing=" " val=":"/>
                <OtherNode start="(230, 53)" end="(230, 58)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(230, 53)" end="(230, 54)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(230, 55)" end="(230, 56)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(230, 57)" end="(230, 58)" leading="" trailing="" raw_val="β" val="β"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(230, 58)" end="(230, 59)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(230, 60)" end="(231, 51)">
            <AtomNode start="(230, 60)" end="(230, 61)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(231, 5)" end="(231, 51)" kind="«term_=_»">
              <OtherNode start="(231, 5)" end="(231, 31)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(231, 5)" end="(231, 6)" leading="" trailing="" val="("/>
                <OtherNode start="(231, 6)" end="(231, 30)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(231, 6)" end="(231, 12)" leading="" trailing=" " raw_val="xs.map" val="xs.map"/>
                  <NullNode start="(231, 13)" end="(231, 30)">
                    <OtherNode start="(231, 13)" end="(231, 30)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(231, 13)" end="(231, 16)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(231, 17)" end="(231, 30)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(231, 17)" end="(231, 18)">
                          <IdentNode start="(231, 17)" end="(231, 18)" leading="" trailing=" " raw_val="x" val="x"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(231, 19)" end="(231, 21)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(231, 22)" end="(231, 30)" kind="Lean.Parser.Term.tuple">
                          <AtomNode start="(231, 22)" end="(231, 23)" leading="" trailing="" val="("/>
                          <NullNode start="(231, 23)" end="(231, 29)">
                            <IdentNode start="(231, 23)" end="(231, 24)" leading="" trailing="" raw_val="x" val="x"/>
                            <AtomNode start="(231, 24)" end="(231, 25)" leading="" trailing=" " val=","/>
                            <NullNode start="(231, 26)" end="(231, 29)">
                              <OtherNode start="(231, 26)" end="(231, 29)" kind="Lean.Parser.Term.app">
                                <IdentNode start="(231, 26)" end="(231, 27)" leading="" trailing=" " raw_val="f" val="f"/>
                                <NullNode start="(231, 28)" end="(231, 29)">
                                  <IdentNode start="(231, 28)" end="(231, 29)" leading="" trailing="" raw_val="x" val="x"/>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(231, 29)" end="(231, 30)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(231, 30)" end="(231, 31)" leading="" trailing=" " val=")"/>
              </OtherNode>
              <AtomNode start="(231, 32)" end="(231, 33)" leading="" trailing=" " val="="/>
              <OtherNode start="(231, 34)" end="(231, 51)" kind="Lean.Parser.Term.app">
                <IdentNode start="(231, 34)" end="(231, 40)" leading="" trailing=" " raw_val="xs.zip" val="xs.zip"/>
                <NullNode start="(231, 41)" end="(231, 51)">
                  <OtherNode start="(231, 41)" end="(231, 51)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(231, 41)" end="(231, 42)" leading="" trailing="" val="("/>
                    <OtherNode start="(231, 42)" end="(231, 50)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(231, 42)" end="(231, 48)" leading="" trailing=" " raw_val="xs.map" val="xs.map"/>
                      <NullNode start="(231, 49)" end="(231, 50)">
                        <IdentNode start="(231, 49)" end="(231, 50)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(231, 50)" end="(231, 51)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(231, 52)" end="(235, 7)">
          <AtomNode start="(231, 52)" end="(231, 54)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(231, 55)" end="(235, 7)">
            <AtomNode start="(231, 55)" end="(231, 57)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(232, 3)" end="(235, 7)">
              <TacticTacticseq1IndentedNode start="(232, 3)" end="(235, 7)">
                <NullNode start="(232, 3)" end="(235, 7)">
                  <OtherNode start="(232, 3)" end="(232, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;n : Nat&#10;β : Type u_2&#10;xs : Vector α n&#10;f : α → β&#10;⊢ map (fun x =&amp;gt; (x, f x)) xs = xs.zip (map f xs)" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → β&#10;xs : Array α&#10;⊢ map (fun x =&amp;gt; (x, f x)) { toArray := xs, size_toArray := ⋯ } =&#10;    { toArray := xs, size_toArray := ⋯ }.zip (map f { toArray := xs, size_toArray := ⋯ })" tactic="rcases xs with ⟨xs, rfl⟩">
                    <AtomNode start="(232, 3)" end="(232, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(232, 10)" end="(232, 12)">
                      <OtherNode start="(232, 10)" end="(232, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(232, 10)" end="(232, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(232, 13)" end="(232, 27)">
                      <AtomNode start="(232, 13)" end="(232, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(232, 18)" end="(232, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(232, 18)" end="(232, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(232, 18)" end="(232, 27)">
                            <OtherNode start="(232, 18)" end="(232, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(232, 18)" end="(232, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(232, 19)" end="(232, 26)">
                                <OtherNode start="(232, 19)" end="(232, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(232, 19)" end="(232, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(232, 19)" end="(232, 21)">
                                      <OtherNode start="(232, 19)" end="(232, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(232, 19)" end="(232, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(232, 21)" end="(232, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(232, 23)" end="(232, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(232, 23)" end="(232, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(232, 23)" end="(232, 26)">
                                      <OtherNode start="(232, 23)" end="(232, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(232, 23)" end="(232, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(232, 26)" end="(232, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(233, 3)" end="(233, 18)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → β&#10;xs : Array α&#10;⊢ map (fun x =&amp;gt; (x, f x)) { toArray := xs, size_toArray := ⋯ } =&#10;    { toArray := xs, size_toArray := ⋯ }.zip (map f { toArray := xs, size_toArray := ⋯ })" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → β&#10;xs : Array α&#10;⊢ (map (fun x =&amp;gt; x) { toArray := xs, size_toArray := ⋯ }).zip (map f { toArray := xs, size_toArray := ⋯ }) =&#10;    { toArray := xs, size_toArray := ⋯ }.zip (map f { toArray := xs, size_toArray := ⋯ })" tactic="rw [← zip_map']">
                    <AtomNode start="(233, 3)" end="(233, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(233, 6)" end="(233, 18)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(233, 6)" end="(233, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(233, 7)" end="(233, 17)">
                        <OtherNode start="(233, 7)" end="(233, 17)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(233, 7)" end="(233, 8)">
                            <OtherNode start="(233, 7)" end="(233, 8)" kind="patternIgnore">
                              <OtherNode start="(233, 7)" end="(233, 8)" kind="token.«← »">
                                <AtomNode start="(233, 7)" end="(233, 8)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(233, 9)" end="(233, 17)" leading="" trailing="" raw_val="zip_map'" val="zip_map'" full_name="Vector.zip_map'" mod_name="Init.Data.Vector.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Zip.lean" def_start="(206, 9)" def_end="(206, 17)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(233, 17)" end="(233, 18)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(234, 3)" end="(234, 8)" kind="Lean.Parser.Tactic.congr" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → β&#10;xs : Array α&#10;⊢ (map (fun x =&amp;gt; x) { toArray := xs, size_toArray := ⋯ }).zip (map f { toArray := xs, size_toArray := ⋯ }) =&#10;    { toArray := xs, size_toArray := ⋯ }.zip (map f { toArray := xs, size_toArray := ⋯ })" state_after="case mk.e_as&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → β&#10;xs : Array α&#10;⊢ map (fun x =&amp;gt; x) { toArray := xs, size_toArray := ⋯ } = { toArray := xs, size_toArray := ⋯ }" tactic="congr">
                    <AtomNode start="(234, 3)" end="(234, 8)" leading="" trailing="&#10;  " val="congr"/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(235, 3)" end="(235, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk.e_as&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → β&#10;xs : Array α&#10;⊢ map (fun x =&amp;gt; x) { toArray := xs, size_toArray := ⋯ } = { toArray := xs, size_toArray := ⋯ }" state_after="no goals" tactic="simp">
                    <AtomNode start="(235, 3)" end="(235, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(237, 1)" end="(242, 7)" name="map_prod_right_eq_zip" full_name="Vector.map_prod_right_eq_zip">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(237, 1)" end="(242, 7)" name="map_prod_right_eq_zip" full_name="Vector.map_prod_right_eq_zip" _is_private_decl="False">
        <AtomNode start="(237, 1)" end="(237, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(237, 9)" end="(237, 30)">
          <IdentNode start="(237, 9)" end="(237, 30)" leading="" trailing=" " raw_val="map_prod_right_eq_zip" val="map_prod_right_eq_zip"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(237, 31)" end="(238, 51)">
          <NullNode start="(237, 31)" end="(237, 60)">
            <OtherNode start="(237, 31)" end="(237, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(237, 31)" end="(237, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(237, 32)" end="(237, 34)">
                <IdentNode start="(237, 32)" end="(237, 34)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(237, 35)" end="(237, 47)">
                <AtomNode start="(237, 35)" end="(237, 36)" leading="" trailing=" " val=":"/>
                <OtherNode start="(237, 37)" end="(237, 47)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(237, 37)" end="(237, 43)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(237, 44)" end="(237, 47)">
                    <IdentNode start="(237, 44)" end="(237, 45)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(237, 46)" end="(237, 47)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(237, 47)" end="(237, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(237, 49)" end="(237, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(237, 49)" end="(237, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(237, 50)" end="(237, 51)">
                <IdentNode start="(237, 50)" end="(237, 51)" leading="" trailing=" " raw_val="f" val="f"/>
              </NullNode>
              <NullNode start="(237, 52)" end="(237, 59)">
                <AtomNode start="(237, 52)" end="(237, 53)" leading="" trailing=" " val=":"/>
                <OtherNode start="(237, 54)" end="(237, 59)" kind="Lean.Parser.Term.arrow">
                  <IdentNode start="(237, 54)" end="(237, 55)" leading="" trailing=" " raw_val="α" val="α"/>
                  <AtomNode start="(237, 56)" end="(237, 57)" leading="" trailing=" " val="→"/>
                  <IdentNode start="(237, 58)" end="(237, 59)" leading="" trailing="" raw_val="β" val="β"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(237, 59)" end="(237, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(237, 61)" end="(238, 51)">
            <AtomNode start="(237, 61)" end="(237, 62)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(238, 5)" end="(238, 51)" kind="«term_=_»">
              <OtherNode start="(238, 5)" end="(238, 31)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(238, 5)" end="(238, 6)" leading="" trailing="" val="("/>
                <OtherNode start="(238, 6)" end="(238, 30)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(238, 6)" end="(238, 12)" leading="" trailing=" " raw_val="xs.map" val="xs.map"/>
                  <NullNode start="(238, 13)" end="(238, 30)">
                    <OtherNode start="(238, 13)" end="(238, 30)" kind="Lean.Parser.Term.fun">
                      <AtomNode start="(238, 13)" end="(238, 16)" leading="" trailing=" " val="fun"/>
                      <OtherNode start="(238, 17)" end="(238, 30)" kind="Lean.Parser.Term.basicFun">
                        <NullNode start="(238, 17)" end="(238, 18)">
                          <IdentNode start="(238, 17)" end="(238, 18)" leading="" trailing=" " raw_val="x" val="x"/>
                        </NullNode>
                        <NullNode/>
                        <AtomNode start="(238, 19)" end="(238, 21)" leading="" trailing=" " val="=&amp;gt;"/>
                        <OtherNode start="(238, 22)" end="(238, 30)" kind="Lean.Parser.Term.tuple">
                          <AtomNode start="(238, 22)" end="(238, 23)" leading="" trailing="" val="("/>
                          <NullNode start="(238, 23)" end="(238, 29)">
                            <OtherNode start="(238, 23)" end="(238, 26)" kind="Lean.Parser.Term.app">
                              <IdentNode start="(238, 23)" end="(238, 24)" leading="" trailing=" " raw_val="f" val="f"/>
                              <NullNode start="(238, 25)" end="(238, 26)">
                                <IdentNode start="(238, 25)" end="(238, 26)" leading="" trailing="" raw_val="x" val="x"/>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(238, 26)" end="(238, 27)" leading="" trailing=" " val=","/>
                            <NullNode start="(238, 28)" end="(238, 29)">
                              <IdentNode start="(238, 28)" end="(238, 29)" leading="" trailing="" raw_val="x" val="x"/>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(238, 29)" end="(238, 30)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(238, 30)" end="(238, 31)" leading="" trailing=" " val=")"/>
              </OtherNode>
              <AtomNode start="(238, 32)" end="(238, 33)" leading="" trailing=" " val="="/>
              <OtherNode start="(238, 34)" end="(238, 51)" kind="Lean.Parser.Term.app">
                <OtherNode start="(238, 34)" end="(238, 48)" kind="Lean.Parser.Term.proj">
                  <OtherNode start="(238, 34)" end="(238, 44)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(238, 34)" end="(238, 35)" leading="" trailing="" val="("/>
                    <OtherNode start="(238, 35)" end="(238, 43)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(238, 35)" end="(238, 41)" leading="" trailing=" " raw_val="xs.map" val="xs.map"/>
                      <NullNode start="(238, 42)" end="(238, 43)">
                        <IdentNode start="(238, 42)" end="(238, 43)" leading="" trailing="" raw_val="f" val="f"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(238, 43)" end="(238, 44)" leading="" trailing="" val=")"/>
                  </OtherNode>
                  <AtomNode start="(238, 44)" end="(238, 45)" leading="" trailing="" val="."/>
                  <IdentNode start="(238, 45)" end="(238, 48)" leading="" trailing=" " raw_val="zip" val="zip" full_name="Vector.zip" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                </OtherNode>
                <NullNode start="(238, 49)" end="(238, 51)">
                  <IdentNode start="(238, 49)" end="(238, 51)" leading="" trailing=" " raw_val="xs" val="xs"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(238, 52)" end="(242, 7)">
          <AtomNode start="(238, 52)" end="(238, 54)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(238, 55)" end="(242, 7)">
            <AtomNode start="(238, 55)" end="(238, 57)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(239, 3)" end="(242, 7)">
              <TacticTacticseq1IndentedNode start="(239, 3)" end="(242, 7)">
                <NullNode start="(239, 3)" end="(242, 7)">
                  <OtherNode start="(239, 3)" end="(239, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;n : Nat&#10;β : Type u_2&#10;xs : Vector α n&#10;f : α → β&#10;⊢ map (fun x =&amp;gt; (f x, x)) xs = (map f xs).zip xs" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → β&#10;xs : Array α&#10;⊢ map (fun x =&amp;gt; (f x, x)) { toArray := xs, size_toArray := ⋯ } =&#10;    (map f { toArray := xs, size_toArray := ⋯ }).zip { toArray := xs, size_toArray := ⋯ }" tactic="rcases xs with ⟨xs, rfl⟩">
                    <AtomNode start="(239, 3)" end="(239, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(239, 10)" end="(239, 12)">
                      <OtherNode start="(239, 10)" end="(239, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(239, 10)" end="(239, 12)" leading="" trailing=" " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(239, 13)" end="(239, 27)">
                      <AtomNode start="(239, 13)" end="(239, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(239, 18)" end="(239, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(239, 18)" end="(239, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(239, 18)" end="(239, 27)">
                            <OtherNode start="(239, 18)" end="(239, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(239, 18)" end="(239, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(239, 19)" end="(239, 26)">
                                <OtherNode start="(239, 19)" end="(239, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(239, 19)" end="(239, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(239, 19)" end="(239, 21)">
                                      <OtherNode start="(239, 19)" end="(239, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(239, 19)" end="(239, 21)" leading="" trailing="" raw_val="xs" val="xs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(239, 21)" end="(239, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(239, 23)" end="(239, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(239, 23)" end="(239, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(239, 23)" end="(239, 26)">
                                      <OtherNode start="(239, 23)" end="(239, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(239, 23)" end="(239, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(239, 26)" end="(239, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(240, 3)" end="(240, 18)" kind="Lean.Parser.Tactic.rwSeq" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → β&#10;xs : Array α&#10;⊢ map (fun x =&amp;gt; (f x, x)) { toArray := xs, size_toArray := ⋯ } =&#10;    (map f { toArray := xs, size_toArray := ⋯ }).zip { toArray := xs, size_toArray := ⋯ }" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → β&#10;xs : Array α&#10;⊢ (map f { toArray := xs, size_toArray := ⋯ }).zip (map (fun x =&amp;gt; x) { toArray := xs, size_toArray := ⋯ }) =&#10;    (map f { toArray := xs, size_toArray := ⋯ }).zip { toArray := xs, size_toArray := ⋯ }" tactic="rw [← zip_map']">
                    <AtomNode start="(240, 3)" end="(240, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(240, 6)" end="(240, 18)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(240, 6)" end="(240, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(240, 7)" end="(240, 17)">
                        <OtherNode start="(240, 7)" end="(240, 17)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(240, 7)" end="(240, 8)">
                            <OtherNode start="(240, 7)" end="(240, 8)" kind="patternIgnore">
                              <OtherNode start="(240, 7)" end="(240, 8)" kind="token.«← »">
                                <AtomNode start="(240, 7)" end="(240, 8)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(240, 9)" end="(240, 17)" leading="" trailing="" raw_val="zip_map'" val="zip_map'" full_name="Vector.zip_map'" mod_name="Init.Data.Vector.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Zip.lean" def_start="(206, 9)" def_end="(206, 17)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(240, 17)" end="(240, 18)" leading="" trailing="&#10;  " val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(241, 3)" end="(241, 8)" kind="Lean.Parser.Tactic.congr" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → β&#10;xs : Array α&#10;⊢ (map f { toArray := xs, size_toArray := ⋯ }).zip (map (fun x =&amp;gt; x) { toArray := xs, size_toArray := ⋯ }) =&#10;    (map f { toArray := xs, size_toArray := ⋯ }).zip { toArray := xs, size_toArray := ⋯ }" state_after="case mk.e_bs&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → β&#10;xs : Array α&#10;⊢ map (fun x =&amp;gt; x) { toArray := xs, size_toArray := ⋯ } = { toArray := xs, size_toArray := ⋯ }" tactic="congr">
                    <AtomNode start="(241, 3)" end="(241, 8)" leading="" trailing="&#10;  " val="congr"/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(242, 3)" end="(242, 7)" kind="Lean.Parser.Tactic.simp" state_before="case mk.e_bs&#10;α : Type u_1&#10;β : Type u_2&#10;f : α → β&#10;xs : Array α&#10;⊢ map (fun x =&amp;gt; x) { toArray := xs, size_toArray := ⋯ } = { toArray := xs, size_toArray := ⋯ }" state_after="no goals" tactic="simp">
                    <AtomNode start="(242, 3)" end="(242, 7)" leading="" trailing="&#10;&#10;" val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(244, 1)" end="(247, 47)" name="zip_eq_append_iff" full_name="Vector.zip_eq_append_iff">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(244, 1)" end="(247, 47)" name="zip_eq_append_iff" full_name="Vector.zip_eq_append_iff" _is_private_decl="False">
        <AtomNode start="(244, 1)" end="(244, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(244, 9)" end="(244, 26)">
          <IdentNode start="(244, 9)" end="(244, 26)" leading="" trailing=" " raw_val="zip_eq_append_iff" val="zip_eq_append_iff"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(244, 27)" end="(246, 119)">
          <NullNode start="(244, 27)" end="(244, 122)">
            <OtherNode start="(244, 27)" end="(244, 50)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(244, 27)" end="(244, 28)" leading="" trailing="" val="{"/>
              <NullNode start="(244, 28)" end="(244, 30)">
                <IdentNode start="(244, 28)" end="(244, 30)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(244, 31)" end="(244, 49)">
                <AtomNode start="(244, 31)" end="(244, 32)" leading="" trailing=" " val=":"/>
                <OtherNode start="(244, 33)" end="(244, 49)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(244, 33)" end="(244, 39)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(244, 40)" end="(244, 49)">
                    <IdentNode start="(244, 40)" end="(244, 41)" leading="" trailing=" " raw_val="α" val="α"/>
                    <OtherNode start="(244, 42)" end="(244, 49)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(244, 42)" end="(244, 43)" leading="" trailing="" val="("/>
                      <OtherNode start="(244, 43)" end="(244, 48)" kind="«term_+_»">
                        <IdentNode start="(244, 43)" end="(244, 44)" leading="" trailing=" " raw_val="n" val="n"/>
                        <AtomNode start="(244, 45)" end="(244, 46)" leading="" trailing=" " val="+"/>
                        <IdentNode start="(244, 47)" end="(244, 48)" leading="" trailing="" raw_val="m" val="m"/>
                      </OtherNode>
                      <AtomNode start="(244, 48)" end="(244, 49)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(244, 49)" end="(244, 50)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(244, 51)" end="(244, 74)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(244, 51)" end="(244, 52)" leading="" trailing="" val="{"/>
              <NullNode start="(244, 52)" end="(244, 54)">
                <IdentNode start="(244, 52)" end="(244, 54)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(244, 55)" end="(244, 73)">
                <AtomNode start="(244, 55)" end="(244, 56)" leading="" trailing=" " val=":"/>
                <OtherNode start="(244, 57)" end="(244, 73)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(244, 57)" end="(244, 63)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(244, 64)" end="(244, 73)">
                    <IdentNode start="(244, 64)" end="(244, 65)" leading="" trailing=" " raw_val="β" val="β"/>
                    <OtherNode start="(244, 66)" end="(244, 73)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(244, 66)" end="(244, 67)" leading="" trailing="" val="("/>
                      <OtherNode start="(244, 67)" end="(244, 72)" kind="«term_+_»">
                        <IdentNode start="(244, 67)" end="(244, 68)" leading="" trailing=" " raw_val="n" val="n"/>
                        <AtomNode start="(244, 69)" end="(244, 70)" leading="" trailing=" " val="+"/>
                        <IdentNode start="(244, 71)" end="(244, 72)" leading="" trailing="" raw_val="m" val="m"/>
                      </OtherNode>
                      <AtomNode start="(244, 72)" end="(244, 73)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(244, 73)" end="(244, 74)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(244, 75)" end="(244, 98)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(244, 75)" end="(244, 76)" leading="" trailing="" val="{"/>
              <NullNode start="(244, 76)" end="(244, 78)">
                <IdentNode start="(244, 76)" end="(244, 78)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(244, 79)" end="(244, 97)">
                <AtomNode start="(244, 79)" end="(244, 80)" leading="" trailing=" " val=":"/>
                <OtherNode start="(244, 81)" end="(244, 97)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(244, 81)" end="(244, 87)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(244, 88)" end="(244, 97)">
                    <OtherNode start="(244, 88)" end="(244, 95)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(244, 88)" end="(244, 89)" leading="" trailing="" val="("/>
                      <OtherNode start="(244, 89)" end="(244, 94)" kind="«term_×_»">
                        <IdentNode start="(244, 89)" end="(244, 90)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(244, 91)" end="(244, 92)" leading="" trailing=" " val="×"/>
                        <IdentNode start="(244, 93)" end="(244, 94)" leading="" trailing="" raw_val="β" val="β"/>
                      </OtherNode>
                      <AtomNode start="(244, 94)" end="(244, 95)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <IdentNode start="(244, 96)" end="(244, 97)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(244, 97)" end="(244, 98)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(244, 99)" end="(244, 122)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(244, 99)" end="(244, 100)" leading="" trailing="" val="{"/>
              <NullNode start="(244, 100)" end="(244, 102)">
                <IdentNode start="(244, 100)" end="(244, 102)" leading="" trailing=" " raw_val="ys" val="ys"/>
              </NullNode>
              <NullNode start="(244, 103)" end="(244, 121)">
                <AtomNode start="(244, 103)" end="(244, 104)" leading="" trailing=" " val=":"/>
                <OtherNode start="(244, 105)" end="(244, 121)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(244, 105)" end="(244, 111)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(244, 112)" end="(244, 121)">
                    <OtherNode start="(244, 112)" end="(244, 119)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(244, 112)" end="(244, 113)" leading="" trailing="" val="("/>
                      <OtherNode start="(244, 113)" end="(244, 118)" kind="«term_×_»">
                        <IdentNode start="(244, 113)" end="(244, 114)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(244, 115)" end="(244, 116)" leading="" trailing=" " val="×"/>
                        <IdentNode start="(244, 117)" end="(244, 118)" leading="" trailing="" raw_val="β" val="β"/>
                      </OtherNode>
                      <AtomNode start="(244, 118)" end="(244, 119)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <IdentNode start="(244, 120)" end="(244, 121)" leading="" trailing="" raw_val="m" val="m"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(244, 121)" end="(244, 122)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(244, 123)" end="(246, 119)">
            <AtomNode start="(244, 123)" end="(244, 124)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(245, 5)" end="(246, 119)" kind="«term_↔_»">
              <OtherNode start="(245, 5)" end="(245, 25)" kind="«term_=_»">
                <OtherNode start="(245, 5)" end="(245, 14)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(245, 5)" end="(245, 8)" leading="" trailing=" " raw_val="zip" val="zip" full_name="Vector.zip" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(245, 9)" end="(245, 14)">
                    <IdentNode start="(245, 9)" end="(245, 11)" leading="" trailing=" " raw_val="as" val="as"/>
                    <IdentNode start="(245, 12)" end="(245, 14)" leading="" trailing=" " raw_val="bs" val="bs"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(245, 15)" end="(245, 16)" leading="" trailing=" " val="="/>
                <OtherNode start="(245, 17)" end="(245, 25)" kind="«term_++_»">
                  <IdentNode start="(245, 17)" end="(245, 19)" leading="" trailing=" " raw_val="xs" val="xs"/>
                  <AtomNode start="(245, 20)" end="(245, 22)" leading="" trailing=" " val="++"/>
                  <IdentNode start="(245, 23)" end="(245, 25)" leading="" trailing=" " raw_val="ys" val="ys"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(245, 26)" end="(245, 27)" leading="" trailing="&#10;      " val="↔"/>
              <OtherNode start="(246, 7)" end="(246, 119)" kind="«term∃_,_»">
                <AtomNode start="(246, 7)" end="(246, 8)" leading="" trailing=" " val="∃"/>
                <OtherNode start="(246, 9)" end="(246, 24)" kind="Lean.explicitBinders">
                  <OtherNode start="(246, 9)" end="(246, 24)" kind="Lean.unbracketedExplicitBinders">
                    <NullNode start="(246, 9)" end="(246, 24)">
                      <LeanBinderidentNode start="(246, 9)" end="(246, 12)">
                        <IdentNode start="(246, 9)" end="(246, 12)" leading="" trailing=" " raw_val="as₁" val="as₁"/>
                      </LeanBinderidentNode>
                      <LeanBinderidentNode start="(246, 13)" end="(246, 16)">
                        <IdentNode start="(246, 13)" end="(246, 16)" leading="" trailing=" " raw_val="as₂" val="as₂"/>
                      </LeanBinderidentNode>
                      <LeanBinderidentNode start="(246, 17)" end="(246, 20)">
                        <IdentNode start="(246, 17)" end="(246, 20)" leading="" trailing=" " raw_val="bs₁" val="bs₁"/>
                      </LeanBinderidentNode>
                      <LeanBinderidentNode start="(246, 21)" end="(246, 24)">
                        <IdentNode start="(246, 21)" end="(246, 24)" leading="" trailing="" raw_val="bs₂" val="bs₂"/>
                      </LeanBinderidentNode>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(246, 24)" end="(246, 25)" leading="" trailing=" " val=","/>
                <OtherNode start="(246, 26)" end="(246, 119)" kind="«term_∧_»">
                  <OtherNode start="(246, 26)" end="(246, 45)" kind="«term_=_»">
                    <IdentNode start="(246, 26)" end="(246, 34)" leading="" trailing=" " raw_val="as₁.size" val="as₁.size"/>
                    <AtomNode start="(246, 35)" end="(246, 36)" leading="" trailing=" " val="="/>
                    <IdentNode start="(246, 37)" end="(246, 45)" leading="" trailing=" " raw_val="bs₁.size" val="bs₁.size"/>
                  </OtherNode>
                  <AtomNode start="(246, 46)" end="(246, 47)" leading="" trailing=" " val="∧"/>
                  <OtherNode start="(246, 48)" end="(246, 119)" kind="«term_∧_»">
                    <OtherNode start="(246, 48)" end="(246, 63)" kind="«term_=_»">
                      <IdentNode start="(246, 48)" end="(246, 50)" leading="" trailing=" " raw_val="as" val="as"/>
                      <AtomNode start="(246, 51)" end="(246, 52)" leading="" trailing=" " val="="/>
                      <OtherNode start="(246, 53)" end="(246, 63)" kind="«term_++_»">
                        <IdentNode start="(246, 53)" end="(246, 56)" leading="" trailing=" " raw_val="as₁" val="as₁"/>
                        <AtomNode start="(246, 57)" end="(246, 59)" leading="" trailing=" " val="++"/>
                        <IdentNode start="(246, 60)" end="(246, 63)" leading="" trailing=" " raw_val="as₂" val="as₂"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(246, 64)" end="(246, 65)" leading="" trailing=" " val="∧"/>
                    <OtherNode start="(246, 66)" end="(246, 119)" kind="«term_∧_»">
                      <OtherNode start="(246, 66)" end="(246, 81)" kind="«term_=_»">
                        <IdentNode start="(246, 66)" end="(246, 68)" leading="" trailing=" " raw_val="bs" val="bs"/>
                        <AtomNode start="(246, 69)" end="(246, 70)" leading="" trailing=" " val="="/>
                        <OtherNode start="(246, 71)" end="(246, 81)" kind="«term_++_»">
                          <IdentNode start="(246, 71)" end="(246, 74)" leading="" trailing=" " raw_val="bs₁" val="bs₁"/>
                          <AtomNode start="(246, 75)" end="(246, 77)" leading="" trailing=" " val="++"/>
                          <IdentNode start="(246, 78)" end="(246, 81)" leading="" trailing=" " raw_val="bs₂" val="bs₂"/>
                        </OtherNode>
                      </OtherNode>
                      <AtomNode start="(246, 82)" end="(246, 83)" leading="" trailing=" " val="∧"/>
                      <OtherNode start="(246, 84)" end="(246, 119)" kind="«term_∧_»">
                        <OtherNode start="(246, 84)" end="(246, 100)" kind="«term_=_»">
                          <IdentNode start="(246, 84)" end="(246, 86)" leading="" trailing=" " raw_val="xs" val="xs"/>
                          <AtomNode start="(246, 87)" end="(246, 88)" leading="" trailing=" " val="="/>
                          <OtherNode start="(246, 89)" end="(246, 100)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(246, 89)" end="(246, 92)" leading="" trailing=" " raw_val="zip" val="zip" full_name="Vector.zip" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                            <NullNode start="(246, 93)" end="(246, 100)">
                              <IdentNode start="(246, 93)" end="(246, 96)" leading="" trailing=" " raw_val="as₁" val="as₁"/>
                              <IdentNode start="(246, 97)" end="(246, 100)" leading="" trailing=" " raw_val="bs₁" val="bs₁"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(246, 101)" end="(246, 102)" leading="" trailing=" " val="∧"/>
                        <OtherNode start="(246, 103)" end="(246, 119)" kind="«term_=_»">
                          <IdentNode start="(246, 103)" end="(246, 105)" leading="" trailing=" " raw_val="ys" val="ys"/>
                          <AtomNode start="(246, 106)" end="(246, 107)" leading="" trailing=" " val="="/>
                          <OtherNode start="(246, 108)" end="(246, 119)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(246, 108)" end="(246, 111)" leading="" trailing=" " raw_val="zip" val="zip" full_name="Vector.zip" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                            <NullNode start="(246, 112)" end="(246, 119)">
                              <IdentNode start="(246, 112)" end="(246, 115)" leading="" trailing=" " raw_val="as₂" val="as₂"/>
                              <IdentNode start="(246, 116)" end="(246, 119)" leading="" trailing=" " raw_val="bs₂" val="bs₂"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(246, 120)" end="(247, 47)">
          <AtomNode start="(246, 120)" end="(246, 122)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(246, 123)" end="(247, 47)">
            <AtomNode start="(246, 123)" end="(246, 125)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(247, 3)" end="(247, 47)">
              <TacticTacticseq1IndentedNode start="(247, 3)" end="(247, 47)">
                <NullNode start="(247, 3)" end="(247, 47)">
                  <OtherNode start="(247, 3)" end="(247, 47)" kind="Lean.Parser.Tactic.simp" state_before="α : Type u_1&#10;n m : Nat&#10;β : Type u_2&#10;as : Vector α (n + m)&#10;bs : Vector β (n + m)&#10;xs : Vector (α × β) n&#10;ys : Vector (α × β) m&#10;⊢ as.zip bs = xs ++ ys ↔&#10;    ∃ as₁ as₂ bs₁ bs₂, as₁.size = bs₁.size ∧ as = as₁ ++ as₂ ∧ bs = bs₁ ++ bs₂ ∧ xs = as₁.zip bs₁ ∧ ys = as₂.zip bs₂" state_after="no goals" tactic="simp [zip_eq_zipWith, zipWith_eq_append_iff]">
                    <AtomNode start="(247, 3)" end="(247, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(247, 8)" end="(247, 47)">
                      <AtomNode start="(247, 8)" end="(247, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(247, 9)" end="(247, 46)">
                        <OtherNode start="(247, 9)" end="(247, 23)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(247, 9)" end="(247, 23)" leading="" trailing="" raw_val="zip_eq_zipWith" val="zip_eq_zipWith" full_name="Vector.zip_eq_zipWith" mod_name="Init.Data.Vector.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Zip.lean" def_start="(181, 9)" def_end="(181, 23)"/>
                        </OtherNode>
                        <AtomNode start="(247, 23)" end="(247, 24)" leading="" trailing=" " val=","/>
                        <OtherNode start="(247, 25)" end="(247, 46)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(247, 25)" end="(247, 46)" leading="" trailing="" raw_val="zipWith_eq_append_iff" val="zipWith_eq_append_iff" full_name="Vector.zipWith_eq_append_iff" mod_name="Init.Data.Vector.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Zip.lean" def_start="(131, 9)" def_end="(131, 30)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(247, 46)" end="(247, 47)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(249, 1)" end="(251, 15)" name="zip_replicate" full_name="Vector.zip_replicate">
      <CommandDeclmodifiersNode start="(249, 1)" end="(249, 8)">
        <NullNode/>
        <NullNode start="(249, 1)" end="(249, 8)">
          <OtherNode start="(249, 1)" end="(249, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(249, 1)" end="(249, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(249, 3)" end="(249, 7)">
              <OtherNode start="(249, 3)" end="(249, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(249, 3)" end="(249, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(249, 3)" end="(249, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(249, 7)" end="(249, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(249, 9)" end="(251, 15)" name="zip_replicate" full_name="Vector.zip_replicate" _is_private_decl="False">
        <AtomNode start="(249, 9)" end="(249, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(249, 17)" end="(249, 30)">
          <IdentNode start="(249, 17)" end="(249, 30)" leading="" trailing=" " raw_val="zip_replicate" val="zip_replicate"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(249, 31)" end="(250, 61)">
          <NullNode start="(249, 31)" end="(249, 56)">
            <OtherNode start="(249, 31)" end="(249, 38)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(249, 31)" end="(249, 32)" leading="" trailing="" val="{"/>
              <NullNode start="(249, 32)" end="(249, 33)">
                <IdentNode start="(249, 32)" end="(249, 33)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(249, 34)" end="(249, 37)">
                <AtomNode start="(249, 34)" end="(249, 35)" leading="" trailing=" " val=":"/>
                <IdentNode start="(249, 36)" end="(249, 37)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(249, 37)" end="(249, 38)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(249, 39)" end="(249, 46)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(249, 39)" end="(249, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(249, 40)" end="(249, 41)">
                <IdentNode start="(249, 40)" end="(249, 41)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(249, 42)" end="(249, 45)">
                <AtomNode start="(249, 42)" end="(249, 43)" leading="" trailing=" " val=":"/>
                <IdentNode start="(249, 44)" end="(249, 45)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(249, 45)" end="(249, 46)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(249, 47)" end="(249, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(249, 47)" end="(249, 48)" leading="" trailing="" val="{"/>
              <NullNode start="(249, 48)" end="(249, 49)">
                <IdentNode start="(249, 48)" end="(249, 49)" leading="" trailing=" " raw_val="n" val="n"/>
              </NullNode>
              <NullNode start="(249, 50)" end="(249, 55)">
                <AtomNode start="(249, 50)" end="(249, 51)" leading="" trailing=" " val=":"/>
                <IdentNode start="(249, 52)" end="(249, 55)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(249, 55)" end="(249, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(249, 57)" end="(250, 61)">
            <AtomNode start="(249, 57)" end="(249, 58)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(250, 5)" end="(250, 61)" kind="«term_=_»">
              <OtherNode start="(250, 5)" end="(250, 40)" kind="Lean.Parser.Term.app">
                <IdentNode start="(250, 5)" end="(250, 8)" leading="" trailing=" " raw_val="zip" val="zip" full_name="Vector.zip" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(250, 9)" end="(250, 40)">
                  <OtherNode start="(250, 9)" end="(250, 24)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(250, 9)" end="(250, 10)" leading="" trailing="" val="("/>
                    <OtherNode start="(250, 10)" end="(250, 23)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(250, 10)" end="(250, 19)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Vector.replicate" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                      <NullNode start="(250, 20)" end="(250, 23)">
                        <IdentNode start="(250, 20)" end="(250, 21)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(250, 22)" end="(250, 23)" leading="" trailing="" raw_val="a" val="a"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(250, 23)" end="(250, 24)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(250, 25)" end="(250, 40)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(250, 25)" end="(250, 26)" leading="" trailing="" val="("/>
                    <OtherNode start="(250, 26)" end="(250, 39)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(250, 26)" end="(250, 35)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Vector.replicate" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                      <NullNode start="(250, 36)" end="(250, 39)">
                        <IdentNode start="(250, 36)" end="(250, 37)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(250, 38)" end="(250, 39)" leading="" trailing="" raw_val="b" val="b"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(250, 39)" end="(250, 40)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(250, 41)" end="(250, 42)" leading="" trailing=" " val="="/>
              <OtherNode start="(250, 43)" end="(250, 61)" kind="Lean.Parser.Term.app">
                <IdentNode start="(250, 43)" end="(250, 52)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Vector.replicate" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(250, 53)" end="(250, 61)">
                  <IdentNode start="(250, 53)" end="(250, 54)" leading="" trailing=" " raw_val="n" val="n"/>
                  <OtherNode start="(250, 55)" end="(250, 61)" kind="Lean.Parser.Term.tuple">
                    <AtomNode start="(250, 55)" end="(250, 56)" leading="" trailing="" val="("/>
                    <NullNode start="(250, 56)" end="(250, 60)">
                      <IdentNode start="(250, 56)" end="(250, 57)" leading="" trailing="" raw_val="a" val="a"/>
                      <AtomNode start="(250, 57)" end="(250, 58)" leading="" trailing=" " val=","/>
                      <NullNode start="(250, 59)" end="(250, 60)">
                        <IdentNode start="(250, 59)" end="(250, 60)" leading="" trailing="" raw_val="b" val="b"/>
                      </NullNode>
                    </NullNode>
                    <AtomNode start="(250, 60)" end="(250, 61)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(250, 62)" end="(251, 15)">
          <AtomNode start="(250, 62)" end="(250, 64)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(250, 65)" end="(251, 15)">
            <AtomNode start="(250, 65)" end="(250, 67)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(251, 3)" end="(251, 15)">
              <TacticTacticseq1IndentedNode start="(251, 3)" end="(251, 15)">
                <NullNode start="(251, 3)" end="(251, 15)">
                  <OtherNode start="(251, 3)" end="(251, 15)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;n : Nat&#10;⊢ (replicate n a).zip (replicate n b) = replicate n (a, b)" state_after="no goals" tactic="ext &amp;lt;;&amp;gt; simp">
                    <OtherNode start="(251, 3)" end="(251, 6)" kind="Lean.Elab.Tactic.Ext.ext">
                      <AtomNode start="(251, 3)" end="(251, 6)" leading="" trailing=" " val="ext"/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(251, 7)" end="(251, 10)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(251, 11)" end="(251, 15)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(251, 11)" end="(251, 15)" leading="" trailing="&#10;&#10;" val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(253, 1)" end="(254, 38)" name="zip_mkVector" full_name="Vector.zip_mkVector">
      <CommandDeclmodifiersNode start="(253, 1)" end="(253, 52)">
        <NullNode/>
        <NullNode start="(253, 1)" end="(253, 52)">
          <OtherNode start="(253, 1)" end="(253, 52)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(253, 1)" end="(253, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(253, 3)" end="(253, 51)">
              <OtherNode start="(253, 3)" end="(253, 51)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(253, 3)" end="(253, 51)" kind="Lean.deprecated">
                  <AtomNode start="(253, 3)" end="(253, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(253, 14)" end="(253, 27)">
                    <IdentNode start="(253, 14)" end="(253, 27)" leading="" trailing=" " raw_val="zip_replicate" val="zip_replicate" full_name="Vector.zip_replicate" mod_name="Init.Data.Vector.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Zip.lean" def_start="(249, 17)" def_end="(249, 30)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(253, 28)" end="(253, 51)">
                    <AtomNode start="(253, 28)" end="(253, 29)" leading="" trailing="" val="("/>
                    <AtomNode start="(253, 29)" end="(253, 34)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(253, 35)" end="(253, 37)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(253, 38)" end="(253, 50)" kind="str">
                      <AtomNode start="(253, 38)" end="(253, 50)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(253, 50)" end="(253, 51)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(253, 51)" end="(253, 52)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(254, 1)" end="(254, 38)" name="zip_mkVector">
        <AtomNode start="(254, 1)" end="(254, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(254, 8)" end="(254, 20)">
          <IdentNode start="(254, 8)" end="(254, 20)" leading="" trailing=" " raw_val="zip_mkVector" val="zip_mkVector"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(254, 21)" end="(254, 38)">
          <AtomNode start="(254, 21)" end="(254, 23)" leading="" trailing=" " val=":="/>
          <OtherNode start="(254, 24)" end="(254, 38)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(254, 24)" end="(254, 25)" leading="" trailing="" val="@"/>
            <IdentNode start="(254, 25)" end="(254, 38)" leading="" trailing="&#10;&#10;" raw_val="zip_replicate" val="zip_replicate" full_name="Vector.zip_replicate" mod_name="Init.Data.Vector.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Zip.lean" def_start="(249, 17)" def_end="(249, 30)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandModuledocNode start="(256, 1)" end="(256, 17)" comment="### unzip -/">
      <AtomNode start="(256, 1)" end="(256, 4)" leading="" trailing=" " val="/-!"/>
      <AtomNode start="(256, 5)" end="(256, 17)" leading="" trailing="&#10;&#10;" val="### unzip -/"/>
    </CommandModuledocNode>
    <CommandDeclarationNode start="(258, 1)" end="(260, 11)" name="unzip_fst" full_name="Vector.unzip_fst">
      <CommandDeclmodifiersNode start="(258, 1)" end="(258, 8)">
        <NullNode/>
        <NullNode start="(258, 1)" end="(258, 8)">
          <OtherNode start="(258, 1)" end="(258, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(258, 1)" end="(258, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(258, 3)" end="(258, 7)">
              <OtherNode start="(258, 3)" end="(258, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(258, 3)" end="(258, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(258, 3)" end="(258, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(258, 7)" end="(258, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(258, 9)" end="(260, 11)" name="unzip_fst" full_name="Vector.unzip_fst" _is_private_decl="False">
        <AtomNode start="(258, 9)" end="(258, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(258, 17)" end="(258, 26)">
          <IdentNode start="(258, 17)" end="(258, 26)" leading="" trailing=" " raw_val="unzip_fst" val="unzip_fst"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(258, 27)" end="(258, 61)">
          <NullNode/>
          <TermTypespecNode start="(258, 27)" end="(258, 61)">
            <AtomNode start="(258, 27)" end="(258, 28)" leading="" trailing=" " val=":"/>
            <OtherNode start="(258, 29)" end="(258, 61)" kind="«term_=_»">
              <OtherNode start="(258, 29)" end="(258, 43)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(258, 29)" end="(258, 39)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(258, 29)" end="(258, 30)" leading="" trailing="" val="("/>
                  <OtherNode start="(258, 30)" end="(258, 38)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(258, 30)" end="(258, 35)" leading="" trailing=" " raw_val="unzip" val="unzip" full_name="Vector.unzip" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                    <NullNode start="(258, 36)" end="(258, 38)">
                      <IdentNode start="(258, 36)" end="(258, 38)" leading="" trailing="" raw_val="xs" val="xs"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(258, 38)" end="(258, 39)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(258, 39)" end="(258, 40)" leading="" trailing="" val="."/>
                <IdentNode start="(258, 40)" end="(258, 43)" leading="" trailing=" " raw_val="fst" val="fst" full_name="Prod.fst" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(258, 44)" end="(258, 45)" leading="" trailing=" " val="="/>
              <OtherNode start="(258, 46)" end="(258, 61)" kind="Lean.Parser.Term.app">
                <IdentNode start="(258, 46)" end="(258, 52)" leading="" trailing=" " raw_val="xs.map" val="xs.map"/>
                <NullNode start="(258, 53)" end="(258, 61)">
                  <IdentNode start="(258, 53)" end="(258, 61)" leading="" trailing=" " raw_val="Prod.fst" val="Prod.fst" full_name="Prod.fst" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(258, 62)" end="(260, 11)">
          <AtomNode start="(258, 62)" end="(258, 64)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(258, 65)" end="(260, 11)">
            <AtomNode start="(258, 65)" end="(258, 67)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(259, 3)" end="(260, 11)">
              <TacticTacticseq1IndentedNode start="(259, 3)" end="(260, 11)">
                <NullNode start="(259, 3)" end="(260, 11)">
                  <OtherNode start="(259, 3)" end="(259, 11)" kind="Lean.Parser.Tactic.cases" state_before="α✝ : Type u_1&#10;β✝ : Type u_2&#10;n✝ : Nat&#10;xs : Vector (α✝ × β✝) n✝&#10;⊢ xs.unzip.fst = map Prod.fst xs" state_after="case mk&#10;α✝ : Type u_1&#10;β✝ : Type u_2&#10;n✝ : Nat&#10;toArray✝ : Array (α✝ × β✝)&#10;size_toArray✝ : toArray✝.size = n✝&#10;⊢ { toArray := toArray✝, size_toArray := size_toArray✝ }.unzip.fst =&#10;    map Prod.fst { toArray := toArray✝, size_toArray := size_toArray✝ }" tactic="cases xs">
                    <AtomNode start="(259, 3)" end="(259, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(259, 9)" end="(259, 11)">
                      <OtherNode start="(259, 9)" end="(259, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(259, 9)" end="(259, 11)" leading="" trailing="&#10;  " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(260, 3)" end="(260, 11)" kind="Lean.Parser.Tactic.simpAll" state_before="case mk&#10;α✝ : Type u_1&#10;β✝ : Type u_2&#10;n✝ : Nat&#10;toArray✝ : Array (α✝ × β✝)&#10;size_toArray✝ : toArray✝.size = n✝&#10;⊢ { toArray := toArray✝, size_toArray := size_toArray✝ }.unzip.fst =&#10;    map Prod.fst { toArray := toArray✝, size_toArray := size_toArray✝ }" state_after="no goals" tactic="simp_all">
                    <AtomNode start="(260, 3)" end="(260, 11)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(262, 1)" end="(264, 11)" name="unzip_snd" full_name="Vector.unzip_snd">
      <CommandDeclmodifiersNode start="(262, 1)" end="(262, 8)">
        <NullNode/>
        <NullNode start="(262, 1)" end="(262, 8)">
          <OtherNode start="(262, 1)" end="(262, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(262, 1)" end="(262, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(262, 3)" end="(262, 7)">
              <OtherNode start="(262, 3)" end="(262, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(262, 3)" end="(262, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(262, 3)" end="(262, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(262, 7)" end="(262, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(262, 9)" end="(264, 11)" name="unzip_snd" full_name="Vector.unzip_snd" _is_private_decl="False">
        <AtomNode start="(262, 9)" end="(262, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(262, 17)" end="(262, 26)">
          <IdentNode start="(262, 17)" end="(262, 26)" leading="" trailing=" " raw_val="unzip_snd" val="unzip_snd"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(262, 27)" end="(262, 61)">
          <NullNode/>
          <TermTypespecNode start="(262, 27)" end="(262, 61)">
            <AtomNode start="(262, 27)" end="(262, 28)" leading="" trailing=" " val=":"/>
            <OtherNode start="(262, 29)" end="(262, 61)" kind="«term_=_»">
              <OtherNode start="(262, 29)" end="(262, 43)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(262, 29)" end="(262, 39)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(262, 29)" end="(262, 30)" leading="" trailing="" val="("/>
                  <OtherNode start="(262, 30)" end="(262, 38)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(262, 30)" end="(262, 35)" leading="" trailing=" " raw_val="unzip" val="unzip" full_name="Vector.unzip" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                    <NullNode start="(262, 36)" end="(262, 38)">
                      <IdentNode start="(262, 36)" end="(262, 38)" leading="" trailing="" raw_val="xs" val="xs"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(262, 38)" end="(262, 39)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(262, 39)" end="(262, 40)" leading="" trailing="" val="."/>
                <IdentNode start="(262, 40)" end="(262, 43)" leading="" trailing=" " raw_val="snd" val="snd" full_name="Prod.snd" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </OtherNode>
              <AtomNode start="(262, 44)" end="(262, 45)" leading="" trailing=" " val="="/>
              <OtherNode start="(262, 46)" end="(262, 61)" kind="Lean.Parser.Term.app">
                <IdentNode start="(262, 46)" end="(262, 52)" leading="" trailing=" " raw_val="xs.map" val="xs.map"/>
                <NullNode start="(262, 53)" end="(262, 61)">
                  <IdentNode start="(262, 53)" end="(262, 61)" leading="" trailing=" " raw_val="Prod.snd" val="Prod.snd" full_name="Prod.snd" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(262, 62)" end="(264, 11)">
          <AtomNode start="(262, 62)" end="(262, 64)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(262, 65)" end="(264, 11)">
            <AtomNode start="(262, 65)" end="(262, 67)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(263, 3)" end="(264, 11)">
              <TacticTacticseq1IndentedNode start="(263, 3)" end="(264, 11)">
                <NullNode start="(263, 3)" end="(264, 11)">
                  <OtherNode start="(263, 3)" end="(263, 11)" kind="Lean.Parser.Tactic.cases" state_before="α✝ : Type u_1&#10;β✝ : Type u_2&#10;n✝ : Nat&#10;xs : Vector (α✝ × β✝) n✝&#10;⊢ xs.unzip.snd = map Prod.snd xs" state_after="case mk&#10;α✝ : Type u_1&#10;β✝ : Type u_2&#10;n✝ : Nat&#10;toArray✝ : Array (α✝ × β✝)&#10;size_toArray✝ : toArray✝.size = n✝&#10;⊢ { toArray := toArray✝, size_toArray := size_toArray✝ }.unzip.snd =&#10;    map Prod.snd { toArray := toArray✝, size_toArray := size_toArray✝ }" tactic="cases xs">
                    <AtomNode start="(263, 3)" end="(263, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(263, 9)" end="(263, 11)">
                      <OtherNode start="(263, 9)" end="(263, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(263, 9)" end="(263, 11)" leading="" trailing="&#10;  " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(264, 3)" end="(264, 11)" kind="Lean.Parser.Tactic.simpAll" state_before="case mk&#10;α✝ : Type u_1&#10;β✝ : Type u_2&#10;n✝ : Nat&#10;toArray✝ : Array (α✝ × β✝)&#10;size_toArray✝ : toArray✝.size = n✝&#10;⊢ { toArray := toArray✝, size_toArray := size_toArray✝ }.unzip.snd =&#10;    map Prod.snd { toArray := toArray✝, size_toArray := size_toArray✝ }" state_after="no goals" tactic="simp_all">
                    <AtomNode start="(264, 3)" end="(264, 11)" leading="" trailing="&#10;&#10;" val="simp_all"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(266, 1)" end="(268, 27)" name="unzip_eq_map" full_name="Vector.unzip_eq_map">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(266, 1)" end="(268, 27)" name="unzip_eq_map" full_name="Vector.unzip_eq_map" _is_private_decl="False">
        <AtomNode start="(266, 1)" end="(266, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(266, 9)" end="(266, 21)">
          <IdentNode start="(266, 9)" end="(266, 21)" leading="" trailing=" " raw_val="unzip_eq_map" val="unzip_eq_map"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(266, 22)" end="(266, 93)">
          <NullNode start="(266, 22)" end="(266, 45)">
            <OtherNode start="(266, 22)" end="(266, 45)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(266, 22)" end="(266, 23)" leading="" trailing="" val="{"/>
              <NullNode start="(266, 23)" end="(266, 25)">
                <IdentNode start="(266, 23)" end="(266, 25)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(266, 26)" end="(266, 44)">
                <AtomNode start="(266, 26)" end="(266, 27)" leading="" trailing=" " val=":"/>
                <OtherNode start="(266, 28)" end="(266, 44)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(266, 28)" end="(266, 34)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(266, 35)" end="(266, 44)">
                    <OtherNode start="(266, 35)" end="(266, 42)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(266, 35)" end="(266, 36)" leading="" trailing="" val="("/>
                      <OtherNode start="(266, 36)" end="(266, 41)" kind="«term_×_»">
                        <IdentNode start="(266, 36)" end="(266, 37)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(266, 38)" end="(266, 39)" leading="" trailing=" " val="×"/>
                        <IdentNode start="(266, 40)" end="(266, 41)" leading="" trailing="" raw_val="β" val="β"/>
                      </OtherNode>
                      <AtomNode start="(266, 41)" end="(266, 42)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <IdentNode start="(266, 43)" end="(266, 44)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(266, 44)" end="(266, 45)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(266, 46)" end="(266, 93)">
            <AtomNode start="(266, 46)" end="(266, 47)" leading="" trailing=" " val=":"/>
            <OtherNode start="(266, 48)" end="(266, 93)" kind="«term_=_»">
              <OtherNode start="(266, 48)" end="(266, 56)" kind="Lean.Parser.Term.app">
                <IdentNode start="(266, 48)" end="(266, 53)" leading="" trailing=" " raw_val="unzip" val="unzip" full_name="Vector.unzip" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(266, 54)" end="(266, 56)">
                  <IdentNode start="(266, 54)" end="(266, 56)" leading="" trailing=" " raw_val="xs" val="xs"/>
                </NullNode>
              </OtherNode>
              <AtomNode start="(266, 57)" end="(266, 58)" leading="" trailing=" " val="="/>
              <OtherNode start="(266, 59)" end="(266, 93)" kind="Lean.Parser.Term.tuple">
                <AtomNode start="(266, 59)" end="(266, 60)" leading="" trailing="" val="("/>
                <NullNode start="(266, 60)" end="(266, 92)">
                  <OtherNode start="(266, 60)" end="(266, 75)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(266, 60)" end="(266, 66)" leading="" trailing=" " raw_val="xs.map" val="xs.map"/>
                    <NullNode start="(266, 67)" end="(266, 75)">
                      <IdentNode start="(266, 67)" end="(266, 75)" leading="" trailing="" raw_val="Prod.fst" val="Prod.fst" full_name="Prod.fst" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(266, 75)" end="(266, 76)" leading="" trailing=" " val=","/>
                  <NullNode start="(266, 77)" end="(266, 92)">
                    <OtherNode start="(266, 77)" end="(266, 92)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(266, 77)" end="(266, 83)" leading="" trailing=" " raw_val="xs.map" val="xs.map"/>
                      <NullNode start="(266, 84)" end="(266, 92)">
                        <IdentNode start="(266, 84)" end="(266, 92)" leading="" trailing="" raw_val="Prod.snd" val="Prod.snd" full_name="Prod.snd" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                </NullNode>
                <AtomNode start="(266, 92)" end="(266, 93)" leading="" trailing=" " val=")"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(266, 94)" end="(268, 27)">
          <AtomNode start="(266, 94)" end="(266, 96)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(266, 97)" end="(268, 27)">
            <AtomNode start="(266, 97)" end="(266, 99)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(267, 3)" end="(268, 27)">
              <TacticTacticseq1IndentedNode start="(267, 3)" end="(268, 27)">
                <NullNode start="(267, 3)" end="(268, 27)">
                  <OtherNode start="(267, 3)" end="(267, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;β : Type u_2&#10;n : Nat&#10;xs : Vector (α × β) n&#10;⊢ xs.unzip = (map Prod.fst xs, map Prod.snd xs)" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;n : Nat&#10;toArray✝ : Array (α × β)&#10;size_toArray✝ : toArray✝.size = n&#10;⊢ { toArray := toArray✝, size_toArray := size_toArray✝ }.unzip =&#10;    (map Prod.fst { toArray := toArray✝, size_toArray := size_toArray✝ },&#10;      map Prod.snd { toArray := toArray✝, size_toArray := size_toArray✝ })" tactic="cases xs">
                    <AtomNode start="(267, 3)" end="(267, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(267, 9)" end="(267, 11)">
                      <OtherNode start="(267, 9)" end="(267, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(267, 9)" end="(267, 11)" leading="" trailing="&#10;  " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(268, 3)" end="(268, 27)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;n : Nat&#10;toArray✝ : Array (α × β)&#10;size_toArray✝ : toArray✝.size = n&#10;⊢ { toArray := toArray✝, size_toArray := size_toArray✝ }.unzip =&#10;    (map Prod.fst { toArray := toArray✝, size_toArray := size_toArray✝ },&#10;      map Prod.snd { toArray := toArray✝, size_toArray := size_toArray✝ })" state_after="no goals" tactic="simp [List.unzip_eq_map]">
                    <AtomNode start="(268, 3)" end="(268, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(268, 8)" end="(268, 27)">
                      <AtomNode start="(268, 8)" end="(268, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(268, 9)" end="(268, 26)">
                        <OtherNode start="(268, 9)" end="(268, 26)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(268, 9)" end="(268, 26)" leading="" trailing="" raw_val="List.unzip_eq_map" val="List.unzip_eq_map" full_name="List.unzip_eq_map" mod_name="Init.Data.List.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/List/Zip.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(268, 26)" end="(268, 27)" leading="" trailing="&#10;&#10;-- The argument `xs` is explicit so we can rewrite from right to left.&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(271, 1)" end="(273, 51)" name="zip_unzip" full_name="Vector.zip_unzip">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(271, 1)" end="(273, 51)" name="zip_unzip" full_name="Vector.zip_unzip" _is_private_decl="False">
        <AtomNode start="(271, 1)" end="(271, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(271, 9)" end="(271, 18)">
          <IdentNode start="(271, 9)" end="(271, 18)" leading="" trailing=" " raw_val="zip_unzip" val="zip_unzip"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(271, 19)" end="(271, 79)">
          <NullNode start="(271, 19)" end="(271, 42)">
            <TermExplicitbinderNode start="(271, 19)" end="(271, 42)">
              <AtomNode start="(271, 19)" end="(271, 20)" leading="" trailing="" val="("/>
              <NullNode start="(271, 20)" end="(271, 22)">
                <IdentNode start="(271, 20)" end="(271, 22)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(271, 23)" end="(271, 41)">
                <AtomNode start="(271, 23)" end="(271, 24)" leading="" trailing=" " val=":"/>
                <OtherNode start="(271, 25)" end="(271, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(271, 25)" end="(271, 31)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(271, 32)" end="(271, 41)">
                    <OtherNode start="(271, 32)" end="(271, 39)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(271, 32)" end="(271, 33)" leading="" trailing="" val="("/>
                      <OtherNode start="(271, 33)" end="(271, 38)" kind="«term_×_»">
                        <IdentNode start="(271, 33)" end="(271, 34)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(271, 35)" end="(271, 36)" leading="" trailing=" " val="×"/>
                        <IdentNode start="(271, 37)" end="(271, 38)" leading="" trailing="" raw_val="β" val="β"/>
                      </OtherNode>
                      <AtomNode start="(271, 38)" end="(271, 39)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <IdentNode start="(271, 40)" end="(271, 41)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(271, 41)" end="(271, 42)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(271, 43)" end="(271, 79)">
            <AtomNode start="(271, 43)" end="(271, 44)" leading="" trailing=" " val=":"/>
            <OtherNode start="(271, 45)" end="(271, 79)" kind="«term_=_»">
              <OtherNode start="(271, 45)" end="(271, 74)" kind="Lean.Parser.Term.app">
                <IdentNode start="(271, 45)" end="(271, 48)" leading="" trailing=" " raw_val="zip" val="zip" full_name="Vector.zip" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(271, 49)" end="(271, 74)">
                  <OtherNode start="(271, 49)" end="(271, 61)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(271, 49)" end="(271, 59)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(271, 49)" end="(271, 50)" leading="" trailing="" val="("/>
                      <OtherNode start="(271, 50)" end="(271, 58)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(271, 50)" end="(271, 55)" leading="" trailing=" " raw_val="unzip" val="unzip" full_name="Vector.unzip" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                        <NullNode start="(271, 56)" end="(271, 58)">
                          <IdentNode start="(271, 56)" end="(271, 58)" leading="" trailing="" raw_val="xs" val="xs"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(271, 58)" end="(271, 59)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(271, 59)" end="(271, 60)" leading="" trailing="" val="."/>
                    <OtherNode start="(271, 60)" end="(271, 61)" kind="fieldIdx">
                      <AtomNode start="(271, 60)" end="(271, 61)" leading="" trailing=" " val="1"/>
                    </OtherNode>
                  </OtherNode>
                  <OtherNode start="(271, 62)" end="(271, 74)" kind="Lean.Parser.Term.proj">
                    <OtherNode start="(271, 62)" end="(271, 72)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(271, 62)" end="(271, 63)" leading="" trailing="" val="("/>
                      <OtherNode start="(271, 63)" end="(271, 71)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(271, 63)" end="(271, 68)" leading="" trailing=" " raw_val="unzip" val="unzip" full_name="Vector.unzip" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                        <NullNode start="(271, 69)" end="(271, 71)">
                          <IdentNode start="(271, 69)" end="(271, 71)" leading="" trailing="" raw_val="xs" val="xs"/>
                        </NullNode>
                      </OtherNode>
                      <AtomNode start="(271, 71)" end="(271, 72)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(271, 72)" end="(271, 73)" leading="" trailing="" val="."/>
                    <OtherNode start="(271, 73)" end="(271, 74)" kind="fieldIdx">
                      <AtomNode start="(271, 73)" end="(271, 74)" leading="" trailing=" " val="2"/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(271, 75)" end="(271, 76)" leading="" trailing=" " val="="/>
              <IdentNode start="(271, 77)" end="(271, 79)" leading="" trailing=" " raw_val="xs" val="xs"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(271, 80)" end="(273, 51)">
          <AtomNode start="(271, 80)" end="(271, 82)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(271, 83)" end="(273, 51)">
            <AtomNode start="(271, 83)" end="(271, 85)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(272, 3)" end="(273, 51)">
              <TacticTacticseq1IndentedNode start="(272, 3)" end="(273, 51)">
                <NullNode start="(272, 3)" end="(273, 51)">
                  <OtherNode start="(272, 3)" end="(272, 11)" kind="Lean.Parser.Tactic.cases" state_before="α : Type u_1&#10;β : Type u_2&#10;n : Nat&#10;xs : Vector (α × β) n&#10;⊢ xs.unzip.fst.zip xs.unzip.snd = xs" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;n : Nat&#10;toArray✝ : Array (α × β)&#10;size_toArray✝ : toArray✝.size = n&#10;⊢ { toArray := toArray✝, size_toArray := size_toArray✝ }.unzip.fst.zip&#10;      { toArray := toArray✝, size_toArray := size_toArray✝ }.unzip.snd =&#10;    { toArray := toArray✝, size_toArray := size_toArray✝ }" tactic="cases xs">
                    <AtomNode start="(272, 3)" end="(272, 8)" leading="" trailing=" " val="cases"/>
                    <NullNode start="(272, 9)" end="(272, 11)">
                      <OtherNode start="(272, 9)" end="(272, 11)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(272, 9)" end="(272, 11)" leading="" trailing="&#10;  " raw_val="xs" val="xs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(273, 3)" end="(273, 51)" kind="Lean.Parser.Tactic.simp" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;n : Nat&#10;toArray✝ : Array (α × β)&#10;size_toArray✝ : toArray✝.size = n&#10;⊢ { toArray := toArray✝, size_toArray := size_toArray✝ }.unzip.fst.zip&#10;      { toArray := toArray✝, size_toArray := size_toArray✝ }.unzip.snd =&#10;    { toArray := toArray✝, size_toArray := size_toArray✝ }" state_after="no goals" tactic="simp only [unzip_mk, mk_zip_mk, Array.zip_unzip]">
                    <AtomNode start="(273, 3)" end="(273, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(273, 8)" end="(273, 12)">
                      <AtomNode start="(273, 8)" end="(273, 12)" leading="" trailing=" " val="only"/>
                    </NullNode>
                    <NullNode start="(273, 13)" end="(273, 51)">
                      <AtomNode start="(273, 13)" end="(273, 14)" leading="" trailing="" val="["/>
                      <NullNode start="(273, 14)" end="(273, 50)">
                        <OtherNode start="(273, 14)" end="(273, 22)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(273, 14)" end="(273, 22)" leading="" trailing="" raw_val="unzip_mk" val="unzip_mk" full_name="Vector.unzip_mk" mod_name="Init.Data.Vector.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(273, 22)" end="(273, 23)" leading="" trailing=" " val=","/>
                        <OtherNode start="(273, 24)" end="(273, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(273, 24)" end="(273, 33)" leading="" trailing="" raw_val="mk_zip_mk" val="mk_zip_mk" full_name="Vector.mk_zip_mk" mod_name="Init.Data.Vector.Lemmas" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Lemmas.lean"/>
                        </OtherNode>
                        <AtomNode start="(273, 33)" end="(273, 34)" leading="" trailing=" " val=","/>
                        <OtherNode start="(273, 35)" end="(273, 50)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(273, 35)" end="(273, 50)" leading="" trailing="" raw_val="Array.zip_unzip" val="Array.zip_unzip" full_name="Array.zip_unzip" mod_name="Init.Data.Array.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Zip.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(273, 50)" end="(273, 51)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(275, 1)" end="(279, 52)" name="unzip_zip_left" full_name="Vector.unzip_zip_left">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(275, 1)" end="(279, 52)" name="unzip_zip_left" full_name="Vector.unzip_zip_left" _is_private_decl="False">
        <AtomNode start="(275, 1)" end="(275, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(275, 9)" end="(275, 23)">
          <IdentNode start="(275, 9)" end="(275, 23)" leading="" trailing=" " raw_val="unzip_zip_left" val="unzip_zip_left"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(275, 24)" end="(276, 31)">
          <NullNode start="(275, 24)" end="(275, 59)">
            <OtherNode start="(275, 24)" end="(275, 41)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(275, 24)" end="(275, 25)" leading="" trailing="" val="{"/>
              <NullNode start="(275, 25)" end="(275, 27)">
                <IdentNode start="(275, 25)" end="(275, 27)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(275, 28)" end="(275, 40)">
                <AtomNode start="(275, 28)" end="(275, 29)" leading="" trailing=" " val=":"/>
                <OtherNode start="(275, 30)" end="(275, 40)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(275, 30)" end="(275, 36)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(275, 37)" end="(275, 40)">
                    <IdentNode start="(275, 37)" end="(275, 38)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(275, 39)" end="(275, 40)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(275, 40)" end="(275, 41)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(275, 42)" end="(275, 59)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(275, 42)" end="(275, 43)" leading="" trailing="" val="{"/>
              <NullNode start="(275, 43)" end="(275, 45)">
                <IdentNode start="(275, 43)" end="(275, 45)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(275, 46)" end="(275, 58)">
                <AtomNode start="(275, 46)" end="(275, 47)" leading="" trailing=" " val=":"/>
                <OtherNode start="(275, 48)" end="(275, 58)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(275, 48)" end="(275, 54)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(275, 55)" end="(275, 58)">
                    <IdentNode start="(275, 55)" end="(275, 56)" leading="" trailing=" " raw_val="β" val="β"/>
                    <IdentNode start="(275, 57)" end="(275, 58)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(275, 58)" end="(275, 59)" leading="" trailing="  " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(275, 61)" end="(276, 31)">
            <AtomNode start="(275, 61)" end="(275, 62)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(276, 5)" end="(276, 31)" kind="«term_=_»">
              <OtherNode start="(276, 5)" end="(276, 26)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(276, 5)" end="(276, 24)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(276, 5)" end="(276, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(276, 6)" end="(276, 23)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(276, 6)" end="(276, 11)" leading="" trailing=" " raw_val="unzip" val="unzip" full_name="Vector.unzip" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                    <NullNode start="(276, 12)" end="(276, 23)">
                      <OtherNode start="(276, 12)" end="(276, 23)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(276, 12)" end="(276, 13)" leading="" trailing="" val="("/>
                        <OtherNode start="(276, 13)" end="(276, 22)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(276, 13)" end="(276, 16)" leading="" trailing=" " raw_val="zip" val="zip" full_name="Vector.zip" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                          <NullNode start="(276, 17)" end="(276, 22)">
                            <IdentNode start="(276, 17)" end="(276, 19)" leading="" trailing=" " raw_val="as" val="as"/>
                            <IdentNode start="(276, 20)" end="(276, 22)" leading="" trailing="" raw_val="bs" val="bs"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(276, 22)" end="(276, 23)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(276, 23)" end="(276, 24)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(276, 24)" end="(276, 25)" leading="" trailing="" val="."/>
                <OtherNode start="(276, 25)" end="(276, 26)" kind="fieldIdx">
                  <AtomNode start="(276, 25)" end="(276, 26)" leading="" trailing=" " val="1"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(276, 27)" end="(276, 28)" leading="" trailing=" " val="="/>
              <IdentNode start="(276, 29)" end="(276, 31)" leading="" trailing=" " raw_val="as" val="as"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(276, 32)" end="(279, 52)">
          <AtomNode start="(276, 32)" end="(276, 34)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(276, 35)" end="(279, 52)">
            <AtomNode start="(276, 35)" end="(276, 37)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(277, 3)" end="(279, 52)">
              <TacticTacticseq1IndentedNode start="(277, 3)" end="(279, 52)">
                <NullNode start="(277, 3)" end="(279, 52)">
                  <OtherNode start="(277, 3)" end="(277, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;n : Nat&#10;β : Type u_2&#10;as : Vector α n&#10;bs : Vector β n&#10;⊢ (as.zip bs).unzip.fst = as" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ ({ toArray := as, size_toArray := ⋯ }.zip bs).unzip.fst = { toArray := as, size_toArray := ⋯ }" tactic="rcases as with ⟨as, rfl⟩">
                    <AtomNode start="(277, 3)" end="(277, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(277, 10)" end="(277, 12)">
                      <OtherNode start="(277, 10)" end="(277, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(277, 10)" end="(277, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(277, 13)" end="(277, 27)">
                      <AtomNode start="(277, 13)" end="(277, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(277, 18)" end="(277, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(277, 18)" end="(277, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(277, 18)" end="(277, 27)">
                            <OtherNode start="(277, 18)" end="(277, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(277, 18)" end="(277, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(277, 19)" end="(277, 26)">
                                <OtherNode start="(277, 19)" end="(277, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(277, 19)" end="(277, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(277, 19)" end="(277, 21)">
                                      <OtherNode start="(277, 19)" end="(277, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(277, 19)" end="(277, 21)" leading="" trailing="" raw_val="as" val="as"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(277, 21)" end="(277, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(277, 23)" end="(277, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(277, 23)" end="(277, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(277, 23)" end="(277, 26)">
                                      <OtherNode start="(277, 23)" end="(277, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(277, 23)" end="(277, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(277, 26)" end="(277, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(278, 3)" end="(278, 25)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ ({ toArray := as, size_toArray := ⋯ }.zip bs).unzip.fst = { toArray := as, size_toArray := ⋯ }" state_after="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ ({ toArray := as, size_toArray := ⋯ }.zip { toArray := bs, size_toArray := h }).unzip.fst =&#10;    { toArray := as, size_toArray := ⋯ }" tactic="rcases bs with ⟨bs, h⟩">
                    <AtomNode start="(278, 3)" end="(278, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(278, 10)" end="(278, 12)">
                      <OtherNode start="(278, 10)" end="(278, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(278, 10)" end="(278, 12)" leading="" trailing=" " raw_val="bs" val="bs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(278, 13)" end="(278, 25)">
                      <AtomNode start="(278, 13)" end="(278, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(278, 18)" end="(278, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(278, 18)" end="(278, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(278, 18)" end="(278, 25)">
                            <OtherNode start="(278, 18)" end="(278, 25)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(278, 18)" end="(278, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(278, 19)" end="(278, 24)">
                                <OtherNode start="(278, 19)" end="(278, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(278, 19)" end="(278, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(278, 19)" end="(278, 21)">
                                      <OtherNode start="(278, 19)" end="(278, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(278, 19)" end="(278, 21)" leading="" trailing="" raw_val="bs" val="bs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(278, 21)" end="(278, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(278, 23)" end="(278, 24)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(278, 23)" end="(278, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(278, 23)" end="(278, 24)">
                                      <OtherNode start="(278, 23)" end="(278, 24)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(278, 23)" end="(278, 24)" leading="" trailing="" raw_val="h" val="h"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(278, 24)" end="(278, 25)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(279, 3)" end="(279, 52)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ ({ toArray := as, size_toArray := ⋯ }.zip { toArray := bs, size_toArray := h }).unzip.fst =&#10;    { toArray := as, size_toArray := ⋯ }" state_after="no goals" tactic="simp [Array.unzip_zip_left, h, Array.map_fst_zip]">
                    <AtomNode start="(279, 3)" end="(279, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(279, 8)" end="(279, 52)">
                      <AtomNode start="(279, 8)" end="(279, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(279, 9)" end="(279, 51)">
                        <OtherNode start="(279, 9)" end="(279, 29)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(279, 9)" end="(279, 29)" leading="" trailing="" raw_val="Array.unzip_zip_left" val="Array.unzip_zip_left" full_name="Array.unzip_zip_left" mod_name="Init.Data.Array.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Zip.lean"/>
                        </OtherNode>
                        <AtomNode start="(279, 29)" end="(279, 30)" leading="" trailing=" " val=","/>
                        <OtherNode start="(279, 31)" end="(279, 32)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(279, 31)" end="(279, 32)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                        <AtomNode start="(279, 32)" end="(279, 33)" leading="" trailing=" " val=","/>
                        <OtherNode start="(279, 34)" end="(279, 51)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(279, 34)" end="(279, 51)" leading="" trailing="" raw_val="Array.map_fst_zip" val="Array.map_fst_zip" full_name="Array.map_fst_zip" mod_name="Init.Data.Array.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Zip.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(279, 51)" end="(279, 52)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(281, 1)" end="(285, 53)" name="unzip_zip_right" full_name="Vector.unzip_zip_right">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(281, 1)" end="(285, 53)" name="unzip_zip_right" full_name="Vector.unzip_zip_right" _is_private_decl="False">
        <AtomNode start="(281, 1)" end="(281, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(281, 9)" end="(281, 24)">
          <IdentNode start="(281, 9)" end="(281, 24)" leading="" trailing=" " raw_val="unzip_zip_right" val="unzip_zip_right"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(281, 25)" end="(282, 31)">
          <NullNode start="(281, 25)" end="(281, 60)">
            <OtherNode start="(281, 25)" end="(281, 42)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(281, 25)" end="(281, 26)" leading="" trailing="" val="{"/>
              <NullNode start="(281, 26)" end="(281, 28)">
                <IdentNode start="(281, 26)" end="(281, 28)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(281, 29)" end="(281, 41)">
                <AtomNode start="(281, 29)" end="(281, 30)" leading="" trailing=" " val=":"/>
                <OtherNode start="(281, 31)" end="(281, 41)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(281, 31)" end="(281, 37)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(281, 38)" end="(281, 41)">
                    <IdentNode start="(281, 38)" end="(281, 39)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(281, 40)" end="(281, 41)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(281, 41)" end="(281, 42)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(281, 43)" end="(281, 60)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(281, 43)" end="(281, 44)" leading="" trailing="" val="{"/>
              <NullNode start="(281, 44)" end="(281, 46)">
                <IdentNode start="(281, 44)" end="(281, 46)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(281, 47)" end="(281, 59)">
                <AtomNode start="(281, 47)" end="(281, 48)" leading="" trailing=" " val=":"/>
                <OtherNode start="(281, 49)" end="(281, 59)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(281, 49)" end="(281, 55)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(281, 56)" end="(281, 59)">
                    <IdentNode start="(281, 56)" end="(281, 57)" leading="" trailing=" " raw_val="β" val="β"/>
                    <IdentNode start="(281, 58)" end="(281, 59)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(281, 59)" end="(281, 60)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(281, 61)" end="(282, 31)">
            <AtomNode start="(281, 61)" end="(281, 62)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(282, 5)" end="(282, 31)" kind="«term_=_»">
              <OtherNode start="(282, 5)" end="(282, 26)" kind="Lean.Parser.Term.proj">
                <OtherNode start="(282, 5)" end="(282, 24)" kind="Lean.Parser.Term.paren">
                  <AtomNode start="(282, 5)" end="(282, 6)" leading="" trailing="" val="("/>
                  <OtherNode start="(282, 6)" end="(282, 23)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(282, 6)" end="(282, 11)" leading="" trailing=" " raw_val="unzip" val="unzip" full_name="Vector.unzip" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                    <NullNode start="(282, 12)" end="(282, 23)">
                      <OtherNode start="(282, 12)" end="(282, 23)" kind="Lean.Parser.Term.paren">
                        <AtomNode start="(282, 12)" end="(282, 13)" leading="" trailing="" val="("/>
                        <OtherNode start="(282, 13)" end="(282, 22)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(282, 13)" end="(282, 16)" leading="" trailing=" " raw_val="zip" val="zip" full_name="Vector.zip" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                          <NullNode start="(282, 17)" end="(282, 22)">
                            <IdentNode start="(282, 17)" end="(282, 19)" leading="" trailing=" " raw_val="as" val="as"/>
                            <IdentNode start="(282, 20)" end="(282, 22)" leading="" trailing="" raw_val="bs" val="bs"/>
                          </NullNode>
                        </OtherNode>
                        <AtomNode start="(282, 22)" end="(282, 23)" leading="" trailing="" val=")"/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(282, 23)" end="(282, 24)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(282, 24)" end="(282, 25)" leading="" trailing="" val="."/>
                <OtherNode start="(282, 25)" end="(282, 26)" kind="fieldIdx">
                  <AtomNode start="(282, 25)" end="(282, 26)" leading="" trailing=" " val="2"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(282, 27)" end="(282, 28)" leading="" trailing=" " val="="/>
              <IdentNode start="(282, 29)" end="(282, 31)" leading="" trailing=" " raw_val="bs" val="bs"/>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(282, 32)" end="(285, 53)">
          <AtomNode start="(282, 32)" end="(282, 34)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(282, 35)" end="(285, 53)">
            <AtomNode start="(282, 35)" end="(282, 37)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(283, 3)" end="(285, 53)">
              <TacticTacticseq1IndentedNode start="(283, 3)" end="(285, 53)">
                <NullNode start="(283, 3)" end="(285, 53)">
                  <OtherNode start="(283, 3)" end="(283, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;n : Nat&#10;β : Type u_2&#10;as : Vector α n&#10;bs : Vector β n&#10;⊢ (as.zip bs).unzip.snd = bs" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ ({ toArray := as, size_toArray := ⋯ }.zip bs).unzip.snd = bs" tactic="rcases as with ⟨as, rfl⟩">
                    <AtomNode start="(283, 3)" end="(283, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(283, 10)" end="(283, 12)">
                      <OtherNode start="(283, 10)" end="(283, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(283, 10)" end="(283, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(283, 13)" end="(283, 27)">
                      <AtomNode start="(283, 13)" end="(283, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(283, 18)" end="(283, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(283, 18)" end="(283, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(283, 18)" end="(283, 27)">
                            <OtherNode start="(283, 18)" end="(283, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(283, 18)" end="(283, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(283, 19)" end="(283, 26)">
                                <OtherNode start="(283, 19)" end="(283, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(283, 19)" end="(283, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(283, 19)" end="(283, 21)">
                                      <OtherNode start="(283, 19)" end="(283, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(283, 19)" end="(283, 21)" leading="" trailing="" raw_val="as" val="as"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(283, 21)" end="(283, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(283, 23)" end="(283, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(283, 23)" end="(283, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(283, 23)" end="(283, 26)">
                                      <OtherNode start="(283, 23)" end="(283, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(283, 23)" end="(283, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(283, 26)" end="(283, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(284, 3)" end="(284, 25)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ ({ toArray := as, size_toArray := ⋯ }.zip bs).unzip.snd = bs" state_after="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ ({ toArray := as, size_toArray := ⋯ }.zip { toArray := bs, size_toArray := h }).unzip.snd =&#10;    { toArray := bs, size_toArray := h }" tactic="rcases bs with ⟨bs, h⟩">
                    <AtomNode start="(284, 3)" end="(284, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(284, 10)" end="(284, 12)">
                      <OtherNode start="(284, 10)" end="(284, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(284, 10)" end="(284, 12)" leading="" trailing=" " raw_val="bs" val="bs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(284, 13)" end="(284, 25)">
                      <AtomNode start="(284, 13)" end="(284, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(284, 18)" end="(284, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(284, 18)" end="(284, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(284, 18)" end="(284, 25)">
                            <OtherNode start="(284, 18)" end="(284, 25)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(284, 18)" end="(284, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(284, 19)" end="(284, 24)">
                                <OtherNode start="(284, 19)" end="(284, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(284, 19)" end="(284, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(284, 19)" end="(284, 21)">
                                      <OtherNode start="(284, 19)" end="(284, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(284, 19)" end="(284, 21)" leading="" trailing="" raw_val="bs" val="bs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(284, 21)" end="(284, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(284, 23)" end="(284, 24)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(284, 23)" end="(284, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(284, 23)" end="(284, 24)">
                                      <OtherNode start="(284, 23)" end="(284, 24)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(284, 23)" end="(284, 24)" leading="" trailing="" raw_val="h" val="h"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(284, 24)" end="(284, 25)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(285, 3)" end="(285, 53)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ ({ toArray := as, size_toArray := ⋯ }.zip { toArray := bs, size_toArray := h }).unzip.snd =&#10;    { toArray := bs, size_toArray := h }" state_after="no goals" tactic="simp [Array.unzip_zip_right, h, Array.map_snd_zip]">
                    <AtomNode start="(285, 3)" end="(285, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(285, 8)" end="(285, 53)">
                      <AtomNode start="(285, 8)" end="(285, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(285, 9)" end="(285, 52)">
                        <OtherNode start="(285, 9)" end="(285, 30)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(285, 9)" end="(285, 30)" leading="" trailing="" raw_val="Array.unzip_zip_right" val="Array.unzip_zip_right" full_name="Array.unzip_zip_right" mod_name="Init.Data.Array.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Zip.lean"/>
                        </OtherNode>
                        <AtomNode start="(285, 30)" end="(285, 31)" leading="" trailing=" " val=","/>
                        <OtherNode start="(285, 32)" end="(285, 33)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(285, 32)" end="(285, 33)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                        <AtomNode start="(285, 33)" end="(285, 34)" leading="" trailing=" " val=","/>
                        <OtherNode start="(285, 35)" end="(285, 52)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(285, 35)" end="(285, 52)" leading="" trailing="" raw_val="Array.map_snd_zip" val="Array.map_snd_zip" full_name="Array.map_snd_zip" mod_name="Init.Data.Array.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Zip.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(285, 52)" end="(285, 53)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(287, 1)" end="(291, 66)" name="unzip_zip" full_name="Vector.unzip_zip">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(287, 1)" end="(291, 66)" name="unzip_zip" full_name="Vector.unzip_zip" _is_private_decl="False">
        <AtomNode start="(287, 1)" end="(287, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(287, 9)" end="(287, 18)">
          <IdentNode start="(287, 9)" end="(287, 18)" leading="" trailing=" " raw_val="unzip_zip" val="unzip_zip"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(287, 19)" end="(288, 33)">
          <NullNode start="(287, 19)" end="(287, 54)">
            <OtherNode start="(287, 19)" end="(287, 36)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(287, 19)" end="(287, 20)" leading="" trailing="" val="{"/>
              <NullNode start="(287, 20)" end="(287, 22)">
                <IdentNode start="(287, 20)" end="(287, 22)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(287, 23)" end="(287, 35)">
                <AtomNode start="(287, 23)" end="(287, 24)" leading="" trailing=" " val=":"/>
                <OtherNode start="(287, 25)" end="(287, 35)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(287, 25)" end="(287, 31)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(287, 32)" end="(287, 35)">
                    <IdentNode start="(287, 32)" end="(287, 33)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(287, 34)" end="(287, 35)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(287, 35)" end="(287, 36)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(287, 37)" end="(287, 54)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(287, 37)" end="(287, 38)" leading="" trailing="" val="{"/>
              <NullNode start="(287, 38)" end="(287, 40)">
                <IdentNode start="(287, 38)" end="(287, 40)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(287, 41)" end="(287, 53)">
                <AtomNode start="(287, 41)" end="(287, 42)" leading="" trailing=" " val=":"/>
                <OtherNode start="(287, 43)" end="(287, 53)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(287, 43)" end="(287, 49)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(287, 50)" end="(287, 53)">
                    <IdentNode start="(287, 50)" end="(287, 51)" leading="" trailing=" " raw_val="β" val="β"/>
                    <IdentNode start="(287, 52)" end="(287, 53)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(287, 53)" end="(287, 54)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(287, 55)" end="(288, 33)">
            <AtomNode start="(287, 55)" end="(287, 56)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(288, 5)" end="(288, 33)" kind="«term_=_»">
              <OtherNode start="(288, 5)" end="(288, 22)" kind="Lean.Parser.Term.app">
                <IdentNode start="(288, 5)" end="(288, 10)" leading="" trailing=" " raw_val="unzip" val="unzip" full_name="Vector.unzip" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(288, 11)" end="(288, 22)">
                  <OtherNode start="(288, 11)" end="(288, 22)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(288, 11)" end="(288, 12)" leading="" trailing="" val="("/>
                    <OtherNode start="(288, 12)" end="(288, 21)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(288, 12)" end="(288, 15)" leading="" trailing=" " raw_val="zip" val="zip" full_name="Vector.zip" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                      <NullNode start="(288, 16)" end="(288, 21)">
                        <IdentNode start="(288, 16)" end="(288, 18)" leading="" trailing=" " raw_val="as" val="as"/>
                        <IdentNode start="(288, 19)" end="(288, 21)" leading="" trailing="" raw_val="bs" val="bs"/>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(288, 21)" end="(288, 22)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(288, 23)" end="(288, 24)" leading="" trailing=" " val="="/>
              <OtherNode start="(288, 25)" end="(288, 33)" kind="Lean.Parser.Term.tuple">
                <AtomNode start="(288, 25)" end="(288, 26)" leading="" trailing="" val="("/>
                <NullNode start="(288, 26)" end="(288, 32)">
                  <IdentNode start="(288, 26)" end="(288, 28)" leading="" trailing="" raw_val="as" val="as"/>
                  <AtomNode start="(288, 28)" end="(288, 29)" leading="" trailing=" " val=","/>
                  <NullNode start="(288, 30)" end="(288, 32)">
                    <IdentNode start="(288, 30)" end="(288, 32)" leading="" trailing="" raw_val="bs" val="bs"/>
                  </NullNode>
                </NullNode>
                <AtomNode start="(288, 32)" end="(288, 33)" leading="" trailing=" " val=")"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(288, 34)" end="(291, 66)">
          <AtomNode start="(288, 34)" end="(288, 36)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(288, 37)" end="(291, 66)">
            <AtomNode start="(288, 37)" end="(288, 39)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(289, 3)" end="(291, 66)">
              <TacticTacticseq1IndentedNode start="(289, 3)" end="(291, 66)">
                <NullNode start="(289, 3)" end="(291, 66)">
                  <OtherNode start="(289, 3)" end="(289, 27)" kind="Lean.Parser.Tactic.rcases" state_before="α : Type u_1&#10;n : Nat&#10;β : Type u_2&#10;as : Vector α n&#10;bs : Vector β n&#10;⊢ (as.zip bs).unzip = (as, bs)" state_after="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ ({ toArray := as, size_toArray := ⋯ }.zip bs).unzip = ({ toArray := as, size_toArray := ⋯ }, bs)" tactic="rcases as with ⟨as, rfl⟩">
                    <AtomNode start="(289, 3)" end="(289, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(289, 10)" end="(289, 12)">
                      <OtherNode start="(289, 10)" end="(289, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(289, 10)" end="(289, 12)" leading="" trailing=" " raw_val="as" val="as"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(289, 13)" end="(289, 27)">
                      <AtomNode start="(289, 13)" end="(289, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(289, 18)" end="(289, 27)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(289, 18)" end="(289, 27)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(289, 18)" end="(289, 27)">
                            <OtherNode start="(289, 18)" end="(289, 27)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(289, 18)" end="(289, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(289, 19)" end="(289, 26)">
                                <OtherNode start="(289, 19)" end="(289, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(289, 19)" end="(289, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(289, 19)" end="(289, 21)">
                                      <OtherNode start="(289, 19)" end="(289, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(289, 19)" end="(289, 21)" leading="" trailing="" raw_val="as" val="as"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(289, 21)" end="(289, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(289, 23)" end="(289, 26)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(289, 23)" end="(289, 26)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(289, 23)" end="(289, 26)">
                                      <OtherNode start="(289, 23)" end="(289, 26)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(289, 23)" end="(289, 26)" leading="" trailing="" raw_val="rfl" val="rfl"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(289, 26)" end="(289, 27)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(290, 3)" end="(290, 25)" kind="Lean.Parser.Tactic.rcases" state_before="case mk&#10;α : Type u_1&#10;β : Type u_2&#10;as : Array α&#10;bs : Vector β as.size&#10;⊢ ({ toArray := as, size_toArray := ⋯ }.zip bs).unzip = ({ toArray := as, size_toArray := ⋯ }, bs)" state_after="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ ({ toArray := as, size_toArray := ⋯ }.zip { toArray := bs, size_toArray := h }).unzip =&#10;    ({ toArray := as, size_toArray := ⋯ }, { toArray := bs, size_toArray := h })" tactic="rcases bs with ⟨bs, h⟩">
                    <AtomNode start="(290, 3)" end="(290, 9)" leading="" trailing=" " val="rcases"/>
                    <NullNode start="(290, 10)" end="(290, 12)">
                      <OtherNode start="(290, 10)" end="(290, 12)" kind="Lean.Parser.Tactic.elimTarget">
                        <NullNode/>
                        <IdentNode start="(290, 10)" end="(290, 12)" leading="" trailing=" " raw_val="bs" val="bs"/>
                      </OtherNode>
                    </NullNode>
                    <NullNode start="(290, 13)" end="(290, 25)">
                      <AtomNode start="(290, 13)" end="(290, 17)" leading="" trailing=" " val="with"/>
                      <OtherNode start="(290, 18)" end="(290, 25)" kind="Lean.Parser.Tactic.rcasesPatLo">
                        <OtherNode start="(290, 18)" end="(290, 25)" kind="Lean.Parser.Tactic.rcasesPatMed">
                          <NullNode start="(290, 18)" end="(290, 25)">
                            <OtherNode start="(290, 18)" end="(290, 25)" kind="Lean.Parser.Tactic.rcasesPat.tuple">
                              <AtomNode start="(290, 18)" end="(290, 19)" leading="" trailing="" val="⟨"/>
                              <NullNode start="(290, 19)" end="(290, 24)">
                                <OtherNode start="(290, 19)" end="(290, 21)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(290, 19)" end="(290, 21)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(290, 19)" end="(290, 21)">
                                      <OtherNode start="(290, 19)" end="(290, 21)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(290, 19)" end="(290, 21)" leading="" trailing="" raw_val="bs" val="bs"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                                <AtomNode start="(290, 21)" end="(290, 22)" leading="" trailing=" " val=","/>
                                <OtherNode start="(290, 23)" end="(290, 24)" kind="Lean.Parser.Tactic.rcasesPatLo">
                                  <OtherNode start="(290, 23)" end="(290, 24)" kind="Lean.Parser.Tactic.rcasesPatMed">
                                    <NullNode start="(290, 23)" end="(290, 24)">
                                      <OtherNode start="(290, 23)" end="(290, 24)" kind="Lean.Parser.Tactic.rcasesPat.one">
                                        <IdentNode start="(290, 23)" end="(290, 24)" leading="" trailing="" raw_val="h" val="h"/>
                                      </OtherNode>
                                    </NullNode>
                                  </OtherNode>
                                  <NullNode/>
                                </OtherNode>
                              </NullNode>
                              <AtomNode start="(290, 24)" end="(290, 25)" leading="" trailing="&#10;  " val="⟩"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                  </OtherNode>
                  <NullNode/>
                  <OtherNode start="(291, 3)" end="(291, 66)" kind="Lean.Parser.Tactic.simp" state_before="case mk.mk&#10;α : Type u_1&#10;β : Type u_2&#10;as : Array α&#10;bs : Array β&#10;h : bs.size = as.size&#10;⊢ ({ toArray := as, size_toArray := ⋯ }.zip { toArray := bs, size_toArray := h }).unzip =&#10;    ({ toArray := as, size_toArray := ⋯ }, { toArray := bs, size_toArray := h })" state_after="no goals" tactic="simp [Array.unzip_zip, h, Array.map_fst_zip, Array.map_snd_zip]">
                    <AtomNode start="(291, 3)" end="(291, 7)" leading="" trailing=" " val="simp"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode start="(291, 8)" end="(291, 66)">
                      <AtomNode start="(291, 8)" end="(291, 9)" leading="" trailing="" val="["/>
                      <NullNode start="(291, 9)" end="(291, 65)">
                        <OtherNode start="(291, 9)" end="(291, 24)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(291, 9)" end="(291, 24)" leading="" trailing="" raw_val="Array.unzip_zip" val="Array.unzip_zip" full_name="Array.unzip_zip" mod_name="Init.Data.Array.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Zip.lean"/>
                        </OtherNode>
                        <AtomNode start="(291, 24)" end="(291, 25)" leading="" trailing=" " val=","/>
                        <OtherNode start="(291, 26)" end="(291, 27)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(291, 26)" end="(291, 27)" leading="" trailing="" raw_val="h" val="h"/>
                        </OtherNode>
                        <AtomNode start="(291, 27)" end="(291, 28)" leading="" trailing=" " val=","/>
                        <OtherNode start="(291, 29)" end="(291, 46)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(291, 29)" end="(291, 46)" leading="" trailing="" raw_val="Array.map_fst_zip" val="Array.map_fst_zip" full_name="Array.map_fst_zip" mod_name="Init.Data.Array.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Zip.lean"/>
                        </OtherNode>
                        <AtomNode start="(291, 46)" end="(291, 47)" leading="" trailing=" " val=","/>
                        <OtherNode start="(291, 48)" end="(291, 65)" kind="Lean.Parser.Tactic.simpLemma">
                          <NullNode/>
                          <NullNode/>
                          <IdentNode start="(291, 48)" end="(291, 65)" leading="" trailing="" raw_val="Array.map_snd_zip" val="Array.map_snd_zip" full_name="Array.map_snd_zip" mod_name="Init.Data.Array.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Array/Zip.lean"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(291, 65)" end="(291, 66)" leading="" trailing="&#10;&#10;" val="]"/>
                    </NullNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(293, 1)" end="(295, 82)" name="zip_of_prod" full_name="Vector.zip_of_prod">
      <CommandDeclmodifiersNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(293, 1)" end="(295, 82)" name="zip_of_prod" full_name="Vector.zip_of_prod" _is_private_decl="False">
        <AtomNode start="(293, 1)" end="(293, 8)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(293, 9)" end="(293, 20)">
          <IdentNode start="(293, 9)" end="(293, 20)" leading="" trailing=" " raw_val="zip_of_prod" val="zip_of_prod"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(293, 21)" end="(294, 49)">
          <NullNode start="(293, 21)" end="(294, 32)">
            <OtherNode start="(293, 21)" end="(293, 38)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(293, 21)" end="(293, 22)" leading="" trailing="" val="{"/>
              <NullNode start="(293, 22)" end="(293, 24)">
                <IdentNode start="(293, 22)" end="(293, 24)" leading="" trailing=" " raw_val="as" val="as"/>
              </NullNode>
              <NullNode start="(293, 25)" end="(293, 37)">
                <AtomNode start="(293, 25)" end="(293, 26)" leading="" trailing=" " val=":"/>
                <OtherNode start="(293, 27)" end="(293, 37)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(293, 27)" end="(293, 33)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(293, 34)" end="(293, 37)">
                    <IdentNode start="(293, 34)" end="(293, 35)" leading="" trailing=" " raw_val="α" val="α"/>
                    <IdentNode start="(293, 36)" end="(293, 37)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(293, 37)" end="(293, 38)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(293, 39)" end="(293, 56)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(293, 39)" end="(293, 40)" leading="" trailing="" val="{"/>
              <NullNode start="(293, 40)" end="(293, 42)">
                <IdentNode start="(293, 40)" end="(293, 42)" leading="" trailing=" " raw_val="bs" val="bs"/>
              </NullNode>
              <NullNode start="(293, 43)" end="(293, 55)">
                <AtomNode start="(293, 43)" end="(293, 44)" leading="" trailing=" " val=":"/>
                <OtherNode start="(293, 45)" end="(293, 55)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(293, 45)" end="(293, 51)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(293, 52)" end="(293, 55)">
                    <IdentNode start="(293, 52)" end="(293, 53)" leading="" trailing=" " raw_val="β" val="β"/>
                    <IdentNode start="(293, 54)" end="(293, 55)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(293, 55)" end="(293, 56)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(293, 57)" end="(293, 80)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(293, 57)" end="(293, 58)" leading="" trailing="" val="{"/>
              <NullNode start="(293, 58)" end="(293, 60)">
                <IdentNode start="(293, 58)" end="(293, 60)" leading="" trailing=" " raw_val="xs" val="xs"/>
              </NullNode>
              <NullNode start="(293, 61)" end="(293, 79)">
                <AtomNode start="(293, 61)" end="(293, 62)" leading="" trailing=" " val=":"/>
                <OtherNode start="(293, 63)" end="(293, 79)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(293, 63)" end="(293, 69)" leading="" trailing=" " raw_val="Vector" val="Vector" full_name="Vector" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                  <NullNode start="(293, 70)" end="(293, 79)">
                    <OtherNode start="(293, 70)" end="(293, 77)" kind="Lean.Parser.Term.paren">
                      <AtomNode start="(293, 70)" end="(293, 71)" leading="" trailing="" val="("/>
                      <OtherNode start="(293, 71)" end="(293, 76)" kind="«term_×_»">
                        <IdentNode start="(293, 71)" end="(293, 72)" leading="" trailing=" " raw_val="α" val="α"/>
                        <AtomNode start="(293, 73)" end="(293, 74)" leading="" trailing=" " val="×"/>
                        <IdentNode start="(293, 75)" end="(293, 76)" leading="" trailing="" raw_val="β" val="β"/>
                      </OtherNode>
                      <AtomNode start="(293, 76)" end="(293, 77)" leading="" trailing=" " val=")"/>
                    </OtherNode>
                    <IdentNode start="(293, 78)" end="(293, 79)" leading="" trailing="" raw_val="n" val="n"/>
                  </NullNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(293, 79)" end="(293, 80)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <TermExplicitbinderNode start="(293, 81)" end="(293, 108)">
              <AtomNode start="(293, 81)" end="(293, 82)" leading="" trailing="" val="("/>
              <NullNode start="(293, 82)" end="(293, 84)">
                <IdentNode start="(293, 82)" end="(293, 84)" leading="" trailing=" " raw_val="hl" val="hl"/>
              </NullNode>
              <NullNode start="(293, 85)" end="(293, 107)">
                <AtomNode start="(293, 85)" end="(293, 86)" leading="" trailing=" " val=":"/>
                <OtherNode start="(293, 87)" end="(293, 107)" kind="«term_=_»">
                  <OtherNode start="(293, 87)" end="(293, 102)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(293, 87)" end="(293, 93)" leading="" trailing=" " raw_val="xs.map" val="xs.map"/>
                    <NullNode start="(293, 94)" end="(293, 102)">
                      <IdentNode start="(293, 94)" end="(293, 102)" leading="" trailing=" " raw_val="Prod.fst" val="Prod.fst" full_name="Prod.fst" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(293, 103)" end="(293, 104)" leading="" trailing=" " val="="/>
                  <IdentNode start="(293, 105)" end="(293, 107)" leading="" trailing="" raw_val="as" val="as"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(293, 107)" end="(293, 108)" leading="" trailing="&#10;    " val=")"/>
            </TermExplicitbinderNode>
            <TermExplicitbinderNode start="(294, 5)" end="(294, 32)">
              <AtomNode start="(294, 5)" end="(294, 6)" leading="" trailing="" val="("/>
              <NullNode start="(294, 6)" end="(294, 8)">
                <IdentNode start="(294, 6)" end="(294, 8)" leading="" trailing=" " raw_val="hr" val="hr"/>
              </NullNode>
              <NullNode start="(294, 9)" end="(294, 31)">
                <AtomNode start="(294, 9)" end="(294, 10)" leading="" trailing=" " val=":"/>
                <OtherNode start="(294, 11)" end="(294, 31)" kind="«term_=_»">
                  <OtherNode start="(294, 11)" end="(294, 26)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(294, 11)" end="(294, 17)" leading="" trailing=" " raw_val="xs.map" val="xs.map"/>
                    <NullNode start="(294, 18)" end="(294, 26)">
                      <IdentNode start="(294, 18)" end="(294, 26)" leading="" trailing=" " raw_val="Prod.snd" val="Prod.snd" full_name="Prod.snd" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(294, 27)" end="(294, 28)" leading="" trailing=" " val="="/>
                  <IdentNode start="(294, 29)" end="(294, 31)" leading="" trailing="" raw_val="bs" val="bs"/>
                </OtherNode>
              </NullNode>
              <NullNode/>
              <AtomNode start="(294, 31)" end="(294, 32)" leading="" trailing=" " val=")"/>
            </TermExplicitbinderNode>
          </NullNode>
          <TermTypespecNode start="(294, 33)" end="(294, 49)">
            <AtomNode start="(294, 33)" end="(294, 34)" leading="" trailing=" " val=":"/>
            <OtherNode start="(294, 35)" end="(294, 49)" kind="«term_=_»">
              <IdentNode start="(294, 35)" end="(294, 37)" leading="" trailing=" " raw_val="xs" val="xs"/>
              <AtomNode start="(294, 38)" end="(294, 39)" leading="" trailing=" " val="="/>
              <OtherNode start="(294, 40)" end="(294, 49)" kind="Lean.Parser.Term.app">
                <IdentNode start="(294, 40)" end="(294, 46)" leading="" trailing=" " raw_val="as.zip" val="as.zip"/>
                <NullNode start="(294, 47)" end="(294, 49)">
                  <IdentNode start="(294, 47)" end="(294, 49)" leading="" trailing=" " raw_val="bs" val="bs"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(294, 50)" end="(295, 82)">
          <AtomNode start="(294, 50)" end="(294, 52)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(294, 53)" end="(295, 82)">
            <AtomNode start="(294, 53)" end="(294, 55)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(295, 3)" end="(295, 82)">
              <TacticTacticseq1IndentedNode start="(295, 3)" end="(295, 82)">
                <NullNode start="(295, 3)" end="(295, 82)">
                  <OtherNode start="(295, 3)" end="(295, 82)" kind="Lean.Parser.Tactic.rwSeq" state_before="α : Type u_1&#10;n : Nat&#10;β : Type u_2&#10;as : Vector α n&#10;bs : Vector β n&#10;xs : Vector (α × β) n&#10;hl : map Prod.fst xs = as&#10;hr : map Prod.snd xs = bs&#10;⊢ xs = as.zip bs" state_after="no goals" tactic="rw [← hl, ← hr, ← zip_unzip xs, ← unzip_fst, ← unzip_snd, zip_unzip, zip_unzip]">
                    <AtomNode start="(295, 3)" end="(295, 5)" leading="" trailing=" " val="rw"/>
                    <OtherNode kind="Lean.Parser.Tactic.optConfig">
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(295, 6)" end="(295, 82)" kind="Lean.Parser.Tactic.rwRuleSeq">
                      <AtomNode start="(295, 6)" end="(295, 7)" leading="" trailing="" val="["/>
                      <NullNode start="(295, 7)" end="(295, 81)">
                        <OtherNode start="(295, 7)" end="(295, 11)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(295, 7)" end="(295, 8)">
                            <OtherNode start="(295, 7)" end="(295, 8)" kind="patternIgnore">
                              <OtherNode start="(295, 7)" end="(295, 8)" kind="token.«← »">
                                <AtomNode start="(295, 7)" end="(295, 8)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(295, 9)" end="(295, 11)" leading="" trailing="" raw_val="hl" val="hl"/>
                        </OtherNode>
                        <AtomNode start="(295, 11)" end="(295, 12)" leading="" trailing=" " val=","/>
                        <OtherNode start="(295, 13)" end="(295, 17)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(295, 13)" end="(295, 14)">
                            <OtherNode start="(295, 13)" end="(295, 14)" kind="patternIgnore">
                              <OtherNode start="(295, 13)" end="(295, 14)" kind="token.«← »">
                                <AtomNode start="(295, 13)" end="(295, 14)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(295, 15)" end="(295, 17)" leading="" trailing="" raw_val="hr" val="hr"/>
                        </OtherNode>
                        <AtomNode start="(295, 17)" end="(295, 18)" leading="" trailing=" " val=","/>
                        <OtherNode start="(295, 19)" end="(295, 33)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(295, 19)" end="(295, 20)">
                            <OtherNode start="(295, 19)" end="(295, 20)" kind="patternIgnore">
                              <OtherNode start="(295, 19)" end="(295, 20)" kind="token.«← »">
                                <AtomNode start="(295, 19)" end="(295, 20)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <OtherNode start="(295, 21)" end="(295, 33)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(295, 21)" end="(295, 30)" leading="" trailing=" " raw_val="zip_unzip" val="zip_unzip" full_name="Vector.zip_unzip" mod_name="Init.Data.Vector.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Zip.lean" def_start="(271, 9)" def_end="(271, 18)"/>
                            <NullNode start="(295, 31)" end="(295, 33)">
                              <IdentNode start="(295, 31)" end="(295, 33)" leading="" trailing="" raw_val="xs" val="xs"/>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(295, 33)" end="(295, 34)" leading="" trailing=" " val=","/>
                        <OtherNode start="(295, 35)" end="(295, 46)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(295, 35)" end="(295, 36)">
                            <OtherNode start="(295, 35)" end="(295, 36)" kind="patternIgnore">
                              <OtherNode start="(295, 35)" end="(295, 36)" kind="token.«← »">
                                <AtomNode start="(295, 35)" end="(295, 36)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(295, 37)" end="(295, 46)" leading="" trailing="" raw_val="unzip_fst" val="unzip_fst" full_name="Vector.unzip_fst" mod_name="Init.Data.Vector.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Zip.lean" def_start="(258, 17)" def_end="(258, 26)"/>
                        </OtherNode>
                        <AtomNode start="(295, 46)" end="(295, 47)" leading="" trailing=" " val=","/>
                        <OtherNode start="(295, 48)" end="(295, 59)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode start="(295, 48)" end="(295, 49)">
                            <OtherNode start="(295, 48)" end="(295, 49)" kind="patternIgnore">
                              <OtherNode start="(295, 48)" end="(295, 49)" kind="token.«← »">
                                <AtomNode start="(295, 48)" end="(295, 49)" leading="" trailing=" " val="←"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <IdentNode start="(295, 50)" end="(295, 59)" leading="" trailing="" raw_val="unzip_snd" val="unzip_snd" full_name="Vector.unzip_snd" mod_name="Init.Data.Vector.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Zip.lean" def_start="(262, 17)" def_end="(262, 26)"/>
                        </OtherNode>
                        <AtomNode start="(295, 59)" end="(295, 60)" leading="" trailing=" " val=","/>
                        <OtherNode start="(295, 61)" end="(295, 70)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(295, 61)" end="(295, 70)" leading="" trailing="" raw_val="zip_unzip" val="zip_unzip" full_name="Vector.zip_unzip" mod_name="Init.Data.Vector.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Zip.lean" def_start="(271, 9)" def_end="(271, 18)"/>
                        </OtherNode>
                        <AtomNode start="(295, 70)" end="(295, 71)" leading="" trailing=" " val=","/>
                        <OtherNode start="(295, 72)" end="(295, 81)" kind="Lean.Parser.Tactic.rwRule">
                          <NullNode/>
                          <IdentNode start="(295, 72)" end="(295, 81)" leading="" trailing="" raw_val="zip_unzip" val="zip_unzip" full_name="Vector.zip_unzip" mod_name="Init.Data.Vector.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Zip.lean" def_start="(271, 9)" def_end="(271, 18)"/>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(295, 81)" end="(295, 82)" leading="" trailing="&#10;&#10;" val="]"/>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(297, 1)" end="(299, 16)" name="unzip_replicate" full_name="Vector.unzip_replicate">
      <CommandDeclmodifiersNode start="(297, 1)" end="(297, 8)">
        <NullNode/>
        <NullNode start="(297, 1)" end="(297, 8)">
          <OtherNode start="(297, 1)" end="(297, 8)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(297, 1)" end="(297, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(297, 3)" end="(297, 7)">
              <OtherNode start="(297, 3)" end="(297, 7)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(297, 3)" end="(297, 7)" kind="Lean.Parser.Attr.simp">
                  <AtomNode start="(297, 3)" end="(297, 7)" leading="" trailing="" val="simp"/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(297, 7)" end="(297, 8)" leading="" trailing=" " val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandTheoremNode start="(297, 9)" end="(299, 16)" name="unzip_replicate" full_name="Vector.unzip_replicate" _is_private_decl="False">
        <AtomNode start="(297, 9)" end="(297, 16)" leading="" trailing=" " val="theorem"/>
        <CommandDeclidNode start="(297, 17)" end="(297, 32)">
          <IdentNode start="(297, 17)" end="(297, 32)" leading="" trailing=" " raw_val="unzip_replicate" val="unzip_replicate"/>
          <NullNode/>
        </CommandDeclidNode>
        <CommandDeclsigNode start="(297, 33)" end="(298, 64)">
          <NullNode start="(297, 33)" end="(297, 58)">
            <OtherNode start="(297, 33)" end="(297, 40)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(297, 33)" end="(297, 34)" leading="" trailing="" val="{"/>
              <NullNode start="(297, 34)" end="(297, 35)">
                <IdentNode start="(297, 34)" end="(297, 35)" leading="" trailing=" " raw_val="a" val="a"/>
              </NullNode>
              <NullNode start="(297, 36)" end="(297, 39)">
                <AtomNode start="(297, 36)" end="(297, 37)" leading="" trailing=" " val=":"/>
                <IdentNode start="(297, 38)" end="(297, 39)" leading="" trailing="" raw_val="α" val="α"/>
              </NullNode>
              <AtomNode start="(297, 39)" end="(297, 40)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(297, 41)" end="(297, 48)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(297, 41)" end="(297, 42)" leading="" trailing="" val="{"/>
              <NullNode start="(297, 42)" end="(297, 43)">
                <IdentNode start="(297, 42)" end="(297, 43)" leading="" trailing=" " raw_val="b" val="b"/>
              </NullNode>
              <NullNode start="(297, 44)" end="(297, 47)">
                <AtomNode start="(297, 44)" end="(297, 45)" leading="" trailing=" " val=":"/>
                <IdentNode start="(297, 46)" end="(297, 47)" leading="" trailing="" raw_val="β" val="β"/>
              </NullNode>
              <AtomNode start="(297, 47)" end="(297, 48)" leading="" trailing=" " val="}"/>
            </OtherNode>
            <OtherNode start="(297, 49)" end="(297, 58)" kind="Lean.Parser.Term.implicitBinder">
              <AtomNode start="(297, 49)" end="(297, 50)" leading="" trailing="" val="{"/>
              <NullNode start="(297, 50)" end="(297, 51)">
                <IdentNode start="(297, 50)" end="(297, 51)" leading="" trailing=" " raw_val="n" val="n"/>
              </NullNode>
              <NullNode start="(297, 52)" end="(297, 57)">
                <AtomNode start="(297, 52)" end="(297, 53)" leading="" trailing=" " val=":"/>
                <IdentNode start="(297, 54)" end="(297, 57)" leading="" trailing="" raw_val="Nat" val="Nat" full_name="Nat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              </NullNode>
              <AtomNode start="(297, 57)" end="(297, 58)" leading="" trailing=" " val="}"/>
            </OtherNode>
          </NullNode>
          <TermTypespecNode start="(297, 59)" end="(298, 64)">
            <AtomNode start="(297, 59)" end="(297, 60)" leading="" trailing="&#10;    " val=":"/>
            <OtherNode start="(298, 5)" end="(298, 64)" kind="«term_=_»">
              <OtherNode start="(298, 5)" end="(298, 31)" kind="Lean.Parser.Term.app">
                <IdentNode start="(298, 5)" end="(298, 10)" leading="" trailing=" " raw_val="unzip" val="unzip" full_name="Vector.unzip" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                <NullNode start="(298, 11)" end="(298, 31)">
                  <OtherNode start="(298, 11)" end="(298, 31)" kind="Lean.Parser.Term.paren">
                    <AtomNode start="(298, 11)" end="(298, 12)" leading="" trailing="" val="("/>
                    <OtherNode start="(298, 12)" end="(298, 30)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(298, 12)" end="(298, 21)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Vector.replicate" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                      <NullNode start="(298, 22)" end="(298, 30)">
                        <IdentNode start="(298, 22)" end="(298, 23)" leading="" trailing=" " raw_val="n" val="n"/>
                        <OtherNode start="(298, 24)" end="(298, 30)" kind="Lean.Parser.Term.tuple">
                          <AtomNode start="(298, 24)" end="(298, 25)" leading="" trailing="" val="("/>
                          <NullNode start="(298, 25)" end="(298, 29)">
                            <IdentNode start="(298, 25)" end="(298, 26)" leading="" trailing="" raw_val="a" val="a"/>
                            <AtomNode start="(298, 26)" end="(298, 27)" leading="" trailing=" " val=","/>
                            <NullNode start="(298, 28)" end="(298, 29)">
                              <IdentNode start="(298, 28)" end="(298, 29)" leading="" trailing="" raw_val="b" val="b"/>
                            </NullNode>
                          </NullNode>
                          <AtomNode start="(298, 29)" end="(298, 30)" leading="" trailing="" val=")"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(298, 30)" end="(298, 31)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(298, 32)" end="(298, 33)" leading="" trailing=" " val="="/>
              <OtherNode start="(298, 34)" end="(298, 64)" kind="Lean.Parser.Term.tuple">
                <AtomNode start="(298, 34)" end="(298, 35)" leading="" trailing="" val="("/>
                <NullNode start="(298, 35)" end="(298, 63)">
                  <OtherNode start="(298, 35)" end="(298, 48)" kind="Lean.Parser.Term.app">
                    <IdentNode start="(298, 35)" end="(298, 44)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Vector.replicate" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                    <NullNode start="(298, 45)" end="(298, 48)">
                      <IdentNode start="(298, 45)" end="(298, 46)" leading="" trailing=" " raw_val="n" val="n"/>
                      <IdentNode start="(298, 47)" end="(298, 48)" leading="" trailing="" raw_val="a" val="a"/>
                    </NullNode>
                  </OtherNode>
                  <AtomNode start="(298, 48)" end="(298, 49)" leading="" trailing=" " val=","/>
                  <NullNode start="(298, 50)" end="(298, 63)">
                    <OtherNode start="(298, 50)" end="(298, 63)" kind="Lean.Parser.Term.app">
                      <IdentNode start="(298, 50)" end="(298, 59)" leading="" trailing=" " raw_val="replicate" val="replicate" full_name="Vector.replicate" mod_name="Init.Data.Vector.Basic" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Basic.lean"/>
                      <NullNode start="(298, 60)" end="(298, 63)">
                        <IdentNode start="(298, 60)" end="(298, 61)" leading="" trailing=" " raw_val="n" val="n"/>
                        <IdentNode start="(298, 62)" end="(298, 63)" leading="" trailing="" raw_val="b" val="b"/>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                </NullNode>
                <AtomNode start="(298, 63)" end="(298, 64)" leading="" trailing=" " val=")"/>
              </OtherNode>
            </OtherNode>
          </TermTypespecNode>
        </CommandDeclsigNode>
        <CommandDeclvalsimpleNode start="(298, 65)" end="(299, 16)">
          <AtomNode start="(298, 65)" end="(298, 67)" leading="" trailing=" " val=":="/>
          <TermBytacticNode start="(298, 68)" end="(299, 16)">
            <AtomNode start="(298, 68)" end="(298, 70)" leading="" trailing="&#10;  " val="by"/>
            <TacticTacticseqNode start="(299, 3)" end="(299, 16)">
              <TacticTacticseq1IndentedNode start="(299, 3)" end="(299, 16)">
                <NullNode start="(299, 3)" end="(299, 16)">
                  <OtherNode start="(299, 3)" end="(299, 16)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»" state_before="α : Type u_1&#10;β : Type u_2&#10;a : α&#10;b : β&#10;n : Nat&#10;⊢ (replicate n (a, b)).unzip = (replicate n a, replicate n b)" state_after="no goals" tactic="ext1 &amp;lt;;&amp;gt; simp">
                    <OtherNode start="(299, 3)" end="(299, 7)" kind="Lean.Elab.Tactic.Ext.tacticExt1___">
                      <AtomNode start="(299, 3)" end="(299, 7)" leading="" trailing=" " val="ext1"/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(299, 8)" end="(299, 11)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                    <OtherNode start="(299, 12)" end="(299, 16)" kind="Lean.Parser.Tactic.simp">
                      <AtomNode start="(299, 12)" end="(299, 16)" leading="" trailing="&#10;&#10;" val="simp"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </TacticTacticseq1IndentedNode>
            </TacticTacticseqNode>
          </TermBytacticNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandTheoremNode>
    </CommandDeclarationNode>
    <CommandDeclarationNode start="(301, 1)" end="(302, 42)" name="unzip_mkVector" full_name="Vector.unzip_mkVector">
      <CommandDeclmodifiersNode start="(301, 1)" end="(301, 54)">
        <NullNode/>
        <NullNode start="(301, 1)" end="(301, 54)">
          <OtherNode start="(301, 1)" end="(301, 54)" kind="Lean.Parser.Term.attributes">
            <AtomNode start="(301, 1)" end="(301, 3)" leading="" trailing="" val="@["/>
            <NullNode start="(301, 3)" end="(301, 53)">
              <OtherNode start="(301, 3)" end="(301, 53)" kind="Lean.Parser.Term.attrInstance">
                <TermAttrkindNode>
                  <NullNode/>
                </TermAttrkindNode>
                <OtherNode start="(301, 3)" end="(301, 53)" kind="Lean.deprecated">
                  <AtomNode start="(301, 3)" end="(301, 13)" leading="" trailing=" " val="deprecated"/>
                  <NullNode start="(301, 14)" end="(301, 29)">
                    <IdentNode start="(301, 14)" end="(301, 29)" leading="" trailing=" " raw_val="unzip_replicate" val="unzip_replicate" full_name="Vector.unzip_replicate" mod_name="Init.Data.Vector.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Zip.lean" def_start="(297, 17)" def_end="(297, 32)"/>
                  </NullNode>
                  <NullNode/>
                  <NullNode start="(301, 30)" end="(301, 53)">
                    <AtomNode start="(301, 30)" end="(301, 31)" leading="" trailing="" val="("/>
                    <AtomNode start="(301, 31)" end="(301, 36)" leading="" trailing=" " val="since"/>
                    <AtomNode start="(301, 37)" end="(301, 39)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(301, 40)" end="(301, 52)" kind="str">
                      <AtomNode start="(301, 40)" end="(301, 52)" leading="" trailing="" val="&amp;quot;2025-03-18&amp;quot;"/>
                    </OtherNode>
                    <AtomNode start="(301, 52)" end="(301, 53)" leading="" trailing="" val=")"/>
                  </NullNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(301, 53)" end="(301, 54)" leading="" trailing="&#10;" val="]"/>
          </OtherNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandAbbrevNode start="(302, 1)" end="(302, 42)" name="unzip_mkVector">
        <AtomNode start="(302, 1)" end="(302, 7)" leading="" trailing=" " val="abbrev"/>
        <CommandDeclidNode start="(302, 8)" end="(302, 22)">
          <IdentNode start="(302, 8)" end="(302, 22)" leading="" trailing=" " raw_val="unzip_mkVector" val="unzip_mkVector"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(302, 23)" end="(302, 42)">
          <AtomNode start="(302, 23)" end="(302, 25)" leading="" trailing=" " val=":="/>
          <OtherNode start="(302, 26)" end="(302, 42)" kind="Lean.Parser.Term.explicit">
            <AtomNode start="(302, 26)" end="(302, 27)" leading="" trailing="" val="@"/>
            <IdentNode start="(302, 27)" end="(302, 42)" leading="" trailing="&#10;&#10;" raw_val="unzip_replicate" val="unzip_replicate" full_name="Vector.unzip_replicate" mod_name="Init.Data.Vector.Zip" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Data/Vector/Zip.lean" def_start="(297, 17)" def_end="(297, 32)"/>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
      </CommandAbbrevNode>
    </CommandDeclarationNode>
    <CommandEndNode start="(304, 1)" end="(304, 11)" name="Vector">
      <AtomNode start="(304, 1)" end="(304, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(304, 5)" end="(304, 11)">
        <IdentNode start="(304, 5)" end="(304, 11)" leading="" trailing="&#10;" raw_val="Vector" val="Vector"/>
      </NullNode>
    </CommandEndNode>
  </FileNode>
  <Comments>
    <Comment start="(12, 1)" end="(14, 3)" text="# Lemmas about `Vector.zip`, `Vector.zipWith`, `Vector.zipWithAll`, and `Vector.unzip`.&#10;-/"/>
    <Comment start="(16, 38)" end="(17, 1)" text="-- Enforce naming conventions for `List`/`Array`/`Vector` variables.&#10;"/>
    <Comment start="(17, 39)" end="(19, 1)" text="-- Enforce naming conventions for index variables.&#10;&#10;"/>
    <Comment start="(23, 1)" end="(23, 18)" text="## Zippers -/"/>
    <Comment start="(25, 1)" end="(25, 19)" text="### zipWith -/"/>
    <Comment start="(43, 1)" end="(46, 3)" text="See also `getElem?_zipWith'` for a variant&#10;using `Option.map` and `Option.bind` rather than a `match`.&#10;-/"/>
    <Comment start="(55, 1)" end="(55, 97)" text="Variant of `getElem?_zipWith` using `Option.map` and `Option.bind` rather than a `match`. -/"/>
    <Comment start="(174, 1)" end="(174, 15)" text="### zip -/"/>
    <Comment start="(216, 1)" end="(217, 1)" text="-- The argument `as` is explicit so we can rewrite from right to left.&#10;"/>
    <Comment start="(223, 1)" end="(224, 1)" text="-- The argument `bs` is explicit so we can rewrite from right to left.&#10;"/>
    <Comment start="(256, 1)" end="(256, 17)" text="### unzip -/"/>
    <Comment start="(270, 1)" end="(271, 1)" text="-- The argument `xs` is explicit so we can rewrite from right to left.&#10;"/>
  </Comments>
</TracedFile>
