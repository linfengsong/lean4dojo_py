<TracedFile path="src/lean/Init/Tactics.lean" md5="aac5472a9a190e5af68a0ac38ed5f249">
  <FileNode start="(1, 1)" end="(1939, 71)">
    <ModuleHeaderNode start="(6, 1)" end="(9, 21)">
      <NullNode start="(6, 1)" end="(6, 7)">
        <OtherNode start="(6, 1)" end="(6, 7)" kind="Lean.Parser.Module.moduleTk">
          <AtomNode start="(6, 1)" end="(6, 7)" leading="" trailing="&#10;&#10;" val="module"/>
        </OtherNode>
      </NullNode>
      <NullNode start="(8, 1)" end="(8, 8)">
        <ModulePreludeNode start="(8, 1)" end="(8, 8)">
          <AtomNode start="(8, 1)" end="(8, 8)" leading="" trailing="&#10;" val="prelude"/>
        </ModulePreludeNode>
      </NullNode>
      <NullNode start="(9, 1)" end="(9, 21)">
        <ModuleImportNode start="(9, 1)" end="(9, 21)" module="Init.Notation" path="src/lean/Init/Notation.lean">
          <NullNode/>
          <AtomNode start="(9, 1)" end="(9, 7)" leading="" trailing=" " val="import"/>
          <NullNode/>
          <IdentNode start="(9, 8)" end="(9, 21)" leading="" trailing="&#10;" raw_val="Init.Notation" val="Init.Notation"/>
          <NullNode/>
        </ModuleImportNode>
      </NullNode>
    </ModuleHeaderNode>
    <OtherNode start="(10, 1)" end="(10, 35)" kind="Lean.Parser.Command.set_option">
      <AtomNode start="(10, 1)" end="(10, 11)" leading="" trailing=" " val="set_option"/>
      <IdentNode start="(10, 12)" end="(10, 30)" leading="" trailing=" " raw_val="linter.missingDocs" val="linter.missingDocs"/>
      <NullNode/>
      <AtomNode start="(10, 31)" end="(10, 35)" leading="" trailing=" -- keep it documented&#10;&#10;" val="true"/>
    </OtherNode>
    <CommandNamespaceNode start="(12, 1)" end="(12, 29)" name="Lean.Parser.Tactic">
      <AtomNode start="(12, 1)" end="(12, 10)" leading="" trailing=" " val="namespace"/>
      <IdentNode start="(12, 11)" end="(12, 29)" leading="" trailing="&#10;&#10;" raw_val="Lean.Parser.Tactic" val="Lean.Parser.Tactic"/>
    </CommandNamespaceNode>
    <OtherNode start="(14, 1)" end="(19, 71)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(14, 1)" end="(18, 3)">
        <CommandDoccommentNode start="(14, 1)" end="(18, 3)" comment="`as_aux_lemma =&amp;gt; tac` does the same as `tac`, except that it wraps the resulting expression&#10;into an auxiliary lemma. In some cases, this significantly reduces the size of expressions&#10;because the proof term is not duplicated.&#10;-/">
          <AtomNode start="(14, 1)" end="(14, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(15, 1)" end="(18, 3)" leading="" trailing="&#10;" val="`as_aux_lemma =&amp;gt; tac` does the same as `tac`, except that it wraps the resulting expression&#10;into an auxiliary lemma. In some cases, this significantly reduces the size of expressions&#10;because the proof term is not duplicated.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(19, 1)" end="(19, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(19, 8)" end="(19, 30)">
        <OtherNode start="(19, 8)" end="(19, 30)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(19, 8)" end="(19, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(19, 9)" end="(19, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(19, 14)" end="(19, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(19, 17)" end="(19, 29)" leading="" trailing="" raw_val="as_aux_lemma" val="as_aux_lemma"/>
          <AtomNode start="(19, 29)" end="(19, 30)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(19, 31)" end="(19, 62)">
        <OtherNode start="(19, 31)" end="(19, 45)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(19, 31)" end="(19, 45)" kind="str">
            <AtomNode start="(19, 31)" end="(19, 45)" leading="" trailing=" " val="&amp;quot;as_aux_lemma&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(19, 46)" end="(19, 52)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(19, 46)" end="(19, 52)" kind="str">
            <AtomNode start="(19, 46)" end="(19, 52)" leading="" trailing=" " val="&amp;quot; =&amp;gt; &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(19, 53)" end="(19, 62)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(19, 53)" end="(19, 62)" leading="" trailing=" " raw_val="tacticSeq" val="tacticSeq" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(19, 63)" end="(19, 64)" leading="" trailing=" " val=":"/>
      <IdentNode start="(19, 65)" end="(19, 71)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(21, 1)" end="(26, 56)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(21, 1)" end="(24, 3)">
        <CommandDoccommentNode start="(21, 1)" end="(24, 3)" comment="`with_annotate_state stx t` annotates the lexical range of `stx : Syntax` with&#10;the initial and final state of running tactic `t`.&#10;-/">
          <AtomNode start="(21, 1)" end="(21, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(22, 1)" end="(24, 3)" leading="" trailing="&#10;" val="`with_annotate_state stx t` annotates the lexical range of `stx : Syntax` with&#10;the initial and final state of running tactic `t`.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode start="(25, 1)" end="(25, 7)">
        <NullNode start="(25, 1)" end="(25, 7)">
          <OtherNode start="(25, 1)" end="(25, 7)" kind="Lean.Parser.Term.scoped">
            <AtomNode start="(25, 1)" end="(25, 7)" leading="" trailing=" " val="scoped"/>
          </OtherNode>
        </NullNode>
      </TermAttrkindNode>
      <AtomNode start="(25, 8)" end="(25, 14)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(25, 15)" end="(25, 42)">
        <OtherNode start="(25, 15)" end="(25, 42)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(25, 15)" end="(25, 16)" leading="" trailing="" val="("/>
          <AtomNode start="(25, 16)" end="(25, 20)" leading="" trailing=" " val="name"/>
          <AtomNode start="(25, 21)" end="(25, 23)" leading="" trailing=" " val=":="/>
          <IdentNode start="(25, 24)" end="(25, 41)" leading="" trailing="" raw_val="withAnnotateState" val="withAnnotateState"/>
          <AtomNode start="(25, 41)" end="(25, 42)" leading="" trailing="&#10;  " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(26, 3)" end="(26, 47)">
        <OtherNode start="(26, 3)" end="(26, 25)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(26, 3)" end="(26, 25)" kind="str">
            <AtomNode start="(26, 3)" end="(26, 25)" leading="" trailing=" " val="&amp;quot;with_annotate_state &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(26, 26)" end="(26, 32)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(26, 26)" end="(26, 32)" leading="" trailing=" " raw_val="rawStx" val="rawStx" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
        <OtherNode start="(26, 33)" end="(26, 40)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(26, 33)" end="(26, 40)" leading="" trailing=" " raw_val="ppSpace" val="ppSpace" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
        <OtherNode start="(26, 41)" end="(26, 47)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(26, 41)" end="(26, 47)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(26, 48)" end="(26, 49)" leading="" trailing=" " val=":"/>
      <IdentNode start="(26, 50)" end="(26, 56)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(28, 1)" end="(49, 85)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(28, 1)" end="(48, 3)">
        <CommandDoccommentNode start="(28, 1)" end="(48, 3)" comment="Introduces one or more hypotheses, optionally naming and/or pattern-matching them.&#10;For each hypothesis to be introduced, the remaining main goal's target type must&#10;be a `let` or function type.&#10;&#10;* `intro` by itself introduces one anonymous hypothesis, which can be accessed&#10;  by e.g. `assumption`.&#10;* `intro x y` introduces two hypotheses and names them. Individual hypotheses&#10;  can be anonymized via `_`, or matched against a pattern:&#10;  ```lean&#10;  -- ... ⊢ α × β → ...&#10;  intro (a, b)&#10;  -- ..., a : α, b : β ⊢ ...&#10;  ```&#10;* Alternatively, `intro` can be combined with pattern matching much like `fun`:&#10;  ```lean&#10;  intro&#10;  | n + 1, 0 =&amp;gt; tac&#10;  | ...&#10;  ```&#10;-/">
          <AtomNode start="(28, 1)" end="(28, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(29, 1)" end="(48, 3)" leading="" trailing="&#10;" val="Introduces one or more hypotheses, optionally naming and/or pattern-matching them.&#10;For each hypothesis to be introduced, the remaining main goal's target type must&#10;be a `let` or function type.&#10;&#10;* `intro` by itself introduces one anonymous hypothesis, which can be accessed&#10;  by e.g. `assumption`.&#10;* `intro x y` introduces two hypotheses and names them. Individual hypotheses&#10;  can be anonymized via `_`, or matched against a pattern:&#10;  ```lean&#10;  -- ... ⊢ α × β → ...&#10;  intro (a, b)&#10;  -- ..., a : α, b : β ⊢ ...&#10;  ```&#10;* Alternatively, `intro` can be combined with pattern matching much like `fun`:&#10;  ```lean&#10;  intro&#10;  | n + 1, 0 =&amp;gt; tac&#10;  | ...&#10;  ```&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(49, 1)" end="(49, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(49, 8)" end="(49, 23)">
        <OtherNode start="(49, 8)" end="(49, 23)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(49, 8)" end="(49, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(49, 9)" end="(49, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(49, 14)" end="(49, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(49, 17)" end="(49, 22)" leading="" trailing="" raw_val="intro" val="intro"/>
          <AtomNode start="(49, 22)" end="(49, 23)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(49, 24)" end="(49, 76)">
        <OtherNode start="(49, 24)" end="(49, 31)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(49, 24)" end="(49, 31)" kind="str">
            <AtomNode start="(49, 24)" end="(49, 31)" leading="" trailing=" " val="&amp;quot;intro&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(49, 32)" end="(49, 50)" kind="Lean.Parser.Syntax.unary">
          <IdentNode start="(49, 32)" end="(49, 45)" leading="" trailing="" raw_val="notFollowedBy" val="notFollowedBy"/>
          <AtomNode start="(49, 45)" end="(49, 46)" leading="" trailing="" val="("/>
          <NullNode start="(49, 46)" end="(49, 49)">
            <OtherNode start="(49, 46)" end="(49, 49)" kind="Lean.Parser.Syntax.atom">
              <OtherNode start="(49, 46)" end="(49, 49)" kind="str">
                <AtomNode start="(49, 46)" end="(49, 49)" leading="" trailing="" val="&amp;quot;|&amp;quot;"/>
              </OtherNode>
            </OtherNode>
          </NullNode>
          <AtomNode start="(49, 49)" end="(49, 50)" leading="" trailing=" " val=")"/>
        </OtherNode>
        <OtherNode start="(49, 51)" end="(49, 76)" kind="«stx_*»">
          <OtherNode start="(49, 51)" end="(49, 75)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(49, 51)" end="(49, 52)" leading="" trailing="" val="("/>
            <NullNode start="(49, 52)" end="(49, 74)">
              <OtherNode start="(49, 52)" end="(49, 59)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(49, 52)" end="(49, 59)" leading="" trailing=" " raw_val="ppSpace" val="ppSpace" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(49, 60)" end="(49, 65)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(49, 60)" end="(49, 65)" leading="" trailing=" " raw_val="colGt" val="colGt" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(49, 66)" end="(49, 74)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(49, 66)" end="(49, 70)" leading="" trailing="" raw_val="term" val="term" full_name="Lean.Parser.Category.term" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
                <NullNode start="(49, 70)" end="(49, 74)">
                  <OtherNode start="(49, 70)" end="(49, 74)" kind="Lean.Parser.precedence">
                    <AtomNode start="(49, 70)" end="(49, 71)" leading="" trailing="" val=":"/>
                    <OtherNode start="(49, 71)" end="(49, 74)" kind="precMax">
                      <AtomNode start="(49, 71)" end="(49, 74)" leading="" trailing="" val="max"/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(49, 74)" end="(49, 75)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(49, 75)" end="(49, 76)" leading="" trailing=" " val="*"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(49, 77)" end="(49, 78)" leading="" trailing=" " val=":"/>
      <IdentNode start="(49, 79)" end="(49, 85)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(51, 1)" end="(122, 76)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(51, 1)" end="(121, 3)">
        <CommandDoccommentNode start="(51, 1)" end="(121, 3)" comment="Introduces zero or more hypotheses, optionally naming them.&#10;&#10;- `intros` is equivalent to repeatedly applying `intro`&#10;  until the goal is not an obvious candidate for `intro`, which is to say&#10;  that so long as the goal is a `let` or a pi type (e.g. an implication, function, or universal quantifier),&#10;  the `intros` tactic will introduce an anonymous hypothesis.&#10;  This tactic does not unfold definitions.&#10;&#10;- `intros x y ...` is equivalent to `intro x y ...`,&#10;  introducing hypotheses for each supplied argument and unfolding definitions as necessary.&#10;  Each argument can be either an identifier or a `_`.&#10;  An identifier indicates a name to use for the corresponding introduced hypothesis,&#10;  and a `_` indicates that the hypotheses should be introduced anonymously.&#10;&#10;## Examples&#10;&#10;Basic properties:&#10;```lean&#10;def AllEven (f : Nat → Nat) := ∀ n, f n % 2 = 0&#10;&#10;-- Introduces the two obvious hypotheses automatically&#10;example : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k =&amp;gt; f (k + 1)) := by&#10;  intros&#10;  /- Tactic state&#10;     f✝ : Nat → Nat&#10;     a✝ : AllEven f✝&#10;     ⊢ AllEven fun k =&amp;gt; f✝ (k + 1) -/&#10;  sorry&#10;&#10;-- Introduces exactly two hypotheses, naming only the first&#10;example : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k =&amp;gt; f (k + 1)) := by&#10;  intros g _&#10;  /- Tactic state&#10;     g : Nat → Nat&#10;     a✝ : AllEven g&#10;     ⊢ AllEven fun k =&amp;gt; g (k + 1) -/&#10;  sorry&#10;&#10;-- Introduces exactly three hypotheses, which requires unfolding `AllEven`&#10;example : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k =&amp;gt; f (k + 1)) := by&#10;  intros f h n&#10;  /- Tactic state&#10;     f : Nat → Nat&#10;     h : AllEven f&#10;     n : Nat&#10;     ⊢ (fun k =&amp;gt; f (k + 1)) n % 2 = 0 -/&#10;  apply h&#10;```&#10;&#10;Implications:&#10;```lean&#10;example (p q : Prop) : p → q → p := by&#10;  intros&#10;  /- Tactic state&#10;     a✝¹ : p&#10;     a✝ : q&#10;     ⊢ p      -/&#10;  assumption&#10;```&#10;&#10;Let bindings:&#10;```lean&#10;example : let n := 1; let k := 2; n + k = 3 := by&#10;  intros&#10;  /- n✝ : Nat := 1&#10;     k✝ : Nat := 2&#10;     ⊢ n✝ + k✝ = 3 -/&#10;  rfl&#10;```&#10;-/">
          <AtomNode start="(51, 1)" end="(51, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(52, 1)" end="(121, 3)" leading="" trailing="&#10;" val="Introduces zero or more hypotheses, optionally naming them.&#10;&#10;- `intros` is equivalent to repeatedly applying `intro`&#10;  until the goal is not an obvious candidate for `intro`, which is to say&#10;  that so long as the goal is a `let` or a pi type (e.g. an implication, function, or universal quantifier),&#10;  the `intros` tactic will introduce an anonymous hypothesis.&#10;  This tactic does not unfold definitions.&#10;&#10;- `intros x y ...` is equivalent to `intro x y ...`,&#10;  introducing hypotheses for each supplied argument and unfolding definitions as necessary.&#10;  Each argument can be either an identifier or a `_`.&#10;  An identifier indicates a name to use for the corresponding introduced hypothesis,&#10;  and a `_` indicates that the hypotheses should be introduced anonymously.&#10;&#10;## Examples&#10;&#10;Basic properties:&#10;```lean&#10;def AllEven (f : Nat → Nat) := ∀ n, f n % 2 = 0&#10;&#10;-- Introduces the two obvious hypotheses automatically&#10;example : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k =&amp;gt; f (k + 1)) := by&#10;  intros&#10;  /- Tactic state&#10;     f✝ : Nat → Nat&#10;     a✝ : AllEven f✝&#10;     ⊢ AllEven fun k =&amp;gt; f✝ (k + 1) -/&#10;  sorry&#10;&#10;-- Introduces exactly two hypotheses, naming only the first&#10;example : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k =&amp;gt; f (k + 1)) := by&#10;  intros g _&#10;  /- Tactic state&#10;     g : Nat → Nat&#10;     a✝ : AllEven g&#10;     ⊢ AllEven fun k =&amp;gt; g (k + 1) -/&#10;  sorry&#10;&#10;-- Introduces exactly three hypotheses, which requires unfolding `AllEven`&#10;example : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k =&amp;gt; f (k + 1)) := by&#10;  intros f h n&#10;  /- Tactic state&#10;     f : Nat → Nat&#10;     h : AllEven f&#10;     n : Nat&#10;     ⊢ (fun k =&amp;gt; f (k + 1)) n % 2 = 0 -/&#10;  apply h&#10;```&#10;&#10;Implications:&#10;```lean&#10;example (p q : Prop) : p → q → p := by&#10;  intros&#10;  /- Tactic state&#10;     a✝¹ : p&#10;     a✝ : q&#10;     ⊢ p      -/&#10;  assumption&#10;```&#10;&#10;Let bindings:&#10;```lean&#10;example : let n := 1; let k := 2; n + k = 3 := by&#10;  intros&#10;  /- n✝ : Nat := 1&#10;     k✝ : Nat := 2&#10;     ⊢ n✝ + k✝ = 3 -/&#10;  rfl&#10;```&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(122, 1)" end="(122, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(122, 8)" end="(122, 24)">
        <OtherNode start="(122, 8)" end="(122, 24)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(122, 8)" end="(122, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(122, 9)" end="(122, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(122, 14)" end="(122, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(122, 17)" end="(122, 23)" leading="" trailing="" raw_val="intros" val="intros"/>
          <AtomNode start="(122, 23)" end="(122, 24)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(122, 25)" end="(122, 67)">
        <OtherNode start="(122, 25)" end="(122, 33)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(122, 25)" end="(122, 33)" kind="str">
            <AtomNode start="(122, 25)" end="(122, 33)" leading="" trailing=" " val="&amp;quot;intros&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(122, 34)" end="(122, 67)" kind="«stx_*»">
          <OtherNode start="(122, 34)" end="(122, 66)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(122, 34)" end="(122, 35)" leading="" trailing="" val="("/>
            <NullNode start="(122, 35)" end="(122, 65)">
              <OtherNode start="(122, 35)" end="(122, 42)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(122, 35)" end="(122, 42)" leading="" trailing=" " raw_val="ppSpace" val="ppSpace" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(122, 43)" end="(122, 48)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(122, 43)" end="(122, 48)" leading="" trailing=" " raw_val="colGt" val="colGt" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(122, 49)" end="(122, 65)" kind="Lean.Parser.Syntax.paren">
                <AtomNode start="(122, 49)" end="(122, 50)" leading="" trailing="" val="("/>
                <NullNode start="(122, 50)" end="(122, 64)">
                  <OtherNode start="(122, 50)" end="(122, 64)" kind="«stx_&amp;lt;|&amp;gt;_»">
                    <OtherNode start="(122, 50)" end="(122, 55)" kind="Lean.Parser.Syntax.cat">
                      <IdentNode start="(122, 50)" end="(122, 55)" leading="" trailing=" " raw_val="ident" val="ident" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(122, 56)" end="(122, 59)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
                    <OtherNode start="(122, 60)" end="(122, 64)" kind="Lean.Parser.Syntax.cat">
                      <IdentNode start="(122, 60)" end="(122, 64)" leading="" trailing="" raw_val="hole" val="hole" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
                <AtomNode start="(122, 64)" end="(122, 65)" leading="" trailing="" val=")"/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(122, 65)" end="(122, 66)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(122, 66)" end="(122, 67)" leading="" trailing=" " val="*"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(122, 68)" end="(122, 69)" leading="" trailing=" " val=":"/>
      <IdentNode start="(122, 70)" end="(122, 76)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(124, 1)" end="(128, 61)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(124, 1)" end="(127, 3)">
        <CommandDoccommentNode start="(124, 1)" end="(127, 3)" comment="`rename t =&amp;gt; x` renames the most recent hypothesis whose type matches `t`&#10;(which may contain placeholders) to `x`, or fails if no such hypothesis could be found.&#10;-/">
          <AtomNode start="(124, 1)" end="(124, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(125, 1)" end="(127, 3)" leading="" trailing="&#10;" val="`rename t =&amp;gt; x` renames the most recent hypothesis whose type matches `t`&#10;(which may contain placeholders) to `x`, or fails if no such hypothesis could be found.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(128, 1)" end="(128, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(128, 8)" end="(128, 24)">
        <OtherNode start="(128, 8)" end="(128, 24)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(128, 8)" end="(128, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(128, 9)" end="(128, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(128, 14)" end="(128, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(128, 17)" end="(128, 23)" leading="" trailing="" raw_val="rename" val="rename"/>
          <AtomNode start="(128, 23)" end="(128, 24)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(128, 25)" end="(128, 52)">
        <OtherNode start="(128, 25)" end="(128, 34)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(128, 25)" end="(128, 34)" kind="str">
            <AtomNode start="(128, 25)" end="(128, 34)" leading="" trailing=" " val="&amp;quot;rename &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(128, 35)" end="(128, 39)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(128, 35)" end="(128, 39)" leading="" trailing=" " raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
        <OtherNode start="(128, 40)" end="(128, 46)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(128, 40)" end="(128, 46)" kind="str">
            <AtomNode start="(128, 40)" end="(128, 46)" leading="" trailing=" " val="&amp;quot; =&amp;gt; &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(128, 47)" end="(128, 52)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(128, 47)" end="(128, 52)" leading="" trailing=" " raw_val="ident" val="ident" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(128, 53)" end="(128, 54)" leading="" trailing=" " val=":"/>
      <IdentNode start="(128, 55)" end="(128, 61)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(130, 1)" end="(134, 68)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(130, 1)" end="(133, 3)">
        <CommandDoccommentNode start="(130, 1)" end="(133, 3)" comment="`revert x...` is the inverse of `intro x...`: it moves the given hypotheses&#10;into the main goal's target type.&#10;-/">
          <AtomNode start="(130, 1)" end="(130, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(131, 1)" end="(133, 3)" leading="" trailing="&#10;" val="`revert x...` is the inverse of `intro x...`: it moves the given hypotheses&#10;into the main goal's target type.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(134, 1)" end="(134, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(134, 8)" end="(134, 24)">
        <OtherNode start="(134, 8)" end="(134, 24)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(134, 8)" end="(134, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(134, 9)" end="(134, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(134, 14)" end="(134, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(134, 17)" end="(134, 23)" leading="" trailing="" raw_val="revert" val="revert"/>
          <AtomNode start="(134, 23)" end="(134, 24)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(134, 25)" end="(134, 59)">
        <OtherNode start="(134, 25)" end="(134, 33)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(134, 25)" end="(134, 33)" kind="str">
            <AtomNode start="(134, 25)" end="(134, 33)" leading="" trailing=" " val="&amp;quot;revert&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(134, 34)" end="(134, 59)" kind="«stx_+»">
          <OtherNode start="(134, 34)" end="(134, 58)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(134, 34)" end="(134, 35)" leading="" trailing="" val="("/>
            <NullNode start="(134, 35)" end="(134, 57)">
              <OtherNode start="(134, 35)" end="(134, 42)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(134, 35)" end="(134, 42)" leading="" trailing=" " raw_val="ppSpace" val="ppSpace" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(134, 43)" end="(134, 48)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(134, 43)" end="(134, 48)" leading="" trailing=" " raw_val="colGt" val="colGt" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(134, 49)" end="(134, 57)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(134, 49)" end="(134, 53)" leading="" trailing="" raw_val="term" val="term" full_name="Lean.Parser.Category.term" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
                <NullNode start="(134, 53)" end="(134, 57)">
                  <OtherNode start="(134, 53)" end="(134, 57)" kind="Lean.Parser.precedence">
                    <AtomNode start="(134, 53)" end="(134, 54)" leading="" trailing="" val=":"/>
                    <OtherNode start="(134, 54)" end="(134, 57)" kind="precMax">
                      <AtomNode start="(134, 54)" end="(134, 57)" leading="" trailing="" val="max"/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(134, 57)" end="(134, 58)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(134, 58)" end="(134, 59)" leading="" trailing=" " val="+"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(134, 60)" end="(134, 61)" leading="" trailing=" " val=":"/>
      <IdentNode start="(134, 62)" end="(134, 68)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(136, 1)" end="(140, 66)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(136, 1)" end="(139, 3)">
        <CommandDoccommentNode start="(136, 1)" end="(139, 3)" comment="`clear x...` removes the given hypotheses, or fails if there are remaining&#10;references to a hypothesis.&#10;-/">
          <AtomNode start="(136, 1)" end="(136, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(137, 1)" end="(139, 3)" leading="" trailing="&#10;" val="`clear x...` removes the given hypotheses, or fails if there are remaining&#10;references to a hypothesis.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(140, 1)" end="(140, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(140, 8)" end="(140, 23)">
        <OtherNode start="(140, 8)" end="(140, 23)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(140, 8)" end="(140, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(140, 9)" end="(140, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(140, 14)" end="(140, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(140, 17)" end="(140, 22)" leading="" trailing="" raw_val="clear" val="clear"/>
          <AtomNode start="(140, 22)" end="(140, 23)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(140, 24)" end="(140, 57)">
        <OtherNode start="(140, 24)" end="(140, 31)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(140, 24)" end="(140, 31)" kind="str">
            <AtomNode start="(140, 24)" end="(140, 31)" leading="" trailing=" " val="&amp;quot;clear&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(140, 32)" end="(140, 57)" kind="«stx_+»">
          <OtherNode start="(140, 32)" end="(140, 56)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(140, 32)" end="(140, 33)" leading="" trailing="" val="("/>
            <NullNode start="(140, 33)" end="(140, 55)">
              <OtherNode start="(140, 33)" end="(140, 40)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(140, 33)" end="(140, 40)" leading="" trailing=" " raw_val="ppSpace" val="ppSpace" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(140, 41)" end="(140, 46)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(140, 41)" end="(140, 46)" leading="" trailing=" " raw_val="colGt" val="colGt" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(140, 47)" end="(140, 55)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(140, 47)" end="(140, 51)" leading="" trailing="" raw_val="term" val="term" full_name="Lean.Parser.Category.term" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
                <NullNode start="(140, 51)" end="(140, 55)">
                  <OtherNode start="(140, 51)" end="(140, 55)" kind="Lean.Parser.precedence">
                    <AtomNode start="(140, 51)" end="(140, 52)" leading="" trailing="" val=":"/>
                    <OtherNode start="(140, 52)" end="(140, 55)" kind="precMax">
                      <AtomNode start="(140, 52)" end="(140, 55)" leading="" trailing="" val="max"/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(140, 55)" end="(140, 56)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(140, 56)" end="(140, 57)" leading="" trailing=" " val="+"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(140, 58)" end="(140, 59)" leading="" trailing=" " val=":"/>
      <IdentNode start="(140, 60)" end="(140, 66)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(142, 1)" end="(147, 66)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(142, 1)" end="(146, 3)">
        <CommandDoccommentNode start="(142, 1)" end="(146, 3)" comment="`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis&#10;of type `x = e` or `e = x`.&#10;If `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead.&#10;-/">
          <AtomNode start="(142, 1)" end="(142, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(143, 1)" end="(146, 3)" leading="" trailing="&#10;" val="`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis&#10;of type `x = e` or `e = x`.&#10;If `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(147, 1)" end="(147, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(147, 8)" end="(147, 23)">
        <OtherNode start="(147, 8)" end="(147, 23)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(147, 8)" end="(147, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(147, 9)" end="(147, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(147, 14)" end="(147, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(147, 17)" end="(147, 22)" leading="" trailing="" raw_val="subst" val="subst"/>
          <AtomNode start="(147, 22)" end="(147, 23)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(147, 24)" end="(147, 57)">
        <OtherNode start="(147, 24)" end="(147, 31)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(147, 24)" end="(147, 31)" kind="str">
            <AtomNode start="(147, 24)" end="(147, 31)" leading="" trailing=" " val="&amp;quot;subst&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(147, 32)" end="(147, 57)" kind="«stx_+»">
          <OtherNode start="(147, 32)" end="(147, 56)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(147, 32)" end="(147, 33)" leading="" trailing="" val="("/>
            <NullNode start="(147, 33)" end="(147, 55)">
              <OtherNode start="(147, 33)" end="(147, 40)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(147, 33)" end="(147, 40)" leading="" trailing=" " raw_val="ppSpace" val="ppSpace" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(147, 41)" end="(147, 46)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(147, 41)" end="(147, 46)" leading="" trailing=" " raw_val="colGt" val="colGt" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(147, 47)" end="(147, 55)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(147, 47)" end="(147, 51)" leading="" trailing="" raw_val="term" val="term" full_name="Lean.Parser.Category.term" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
                <NullNode start="(147, 51)" end="(147, 55)">
                  <OtherNode start="(147, 51)" end="(147, 55)" kind="Lean.Parser.precedence">
                    <AtomNode start="(147, 51)" end="(147, 52)" leading="" trailing="" val=":"/>
                    <OtherNode start="(147, 52)" end="(147, 55)" kind="precMax">
                      <AtomNode start="(147, 52)" end="(147, 55)" leading="" trailing="" val="max"/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(147, 55)" end="(147, 56)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(147, 56)" end="(147, 57)" leading="" trailing=" " val="+"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(147, 58)" end="(147, 59)" leading="" trailing=" " val=":"/>
      <IdentNode start="(147, 60)" end="(147, 66)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(149, 1)" end="(152, 49)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(149, 1)" end="(151, 3)">
        <CommandDoccommentNode start="(149, 1)" end="(151, 3)" comment="Applies `subst` to all hypotheses of the form `h : x = t` or `h : t = x`.&#10;-/">
          <AtomNode start="(149, 1)" end="(149, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(150, 1)" end="(151, 3)" leading="" trailing="&#10;" val="Applies `subst` to all hypotheses of the form `h : x = t` or `h : t = x`.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(152, 1)" end="(152, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(152, 8)" end="(152, 27)">
        <OtherNode start="(152, 8)" end="(152, 27)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(152, 8)" end="(152, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(152, 9)" end="(152, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(152, 14)" end="(152, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(152, 17)" end="(152, 26)" leading="" trailing="" raw_val="substVars" val="substVars"/>
          <AtomNode start="(152, 26)" end="(152, 27)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(152, 28)" end="(152, 40)">
        <OtherNode start="(152, 28)" end="(152, 40)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(152, 28)" end="(152, 40)" kind="str">
            <AtomNode start="(152, 28)" end="(152, 40)" leading="" trailing=" " val="&amp;quot;subst_vars&amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(152, 41)" end="(152, 42)" leading="" trailing=" " val=":"/>
      <IdentNode start="(152, 43)" end="(152, 49)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(154, 1)" end="(158, 50)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(154, 1)" end="(157, 3)">
        <CommandDoccommentNode start="(154, 1)" end="(157, 3)" comment="`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.&#10;Note also the `‹t›` term notation, which is a shorthand for `show t by assumption`.&#10;-/">
          <AtomNode start="(154, 1)" end="(154, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(155, 1)" end="(157, 3)" leading="" trailing="&#10;" val="`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.&#10;Note also the `‹t›` term notation, which is a shorthand for `show t by assumption`.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(158, 1)" end="(158, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(158, 8)" end="(158, 28)">
        <OtherNode start="(158, 8)" end="(158, 28)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(158, 8)" end="(158, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(158, 9)" end="(158, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(158, 14)" end="(158, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(158, 17)" end="(158, 27)" leading="" trailing="" raw_val="assumption" val="assumption"/>
          <AtomNode start="(158, 27)" end="(158, 28)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(158, 29)" end="(158, 41)">
        <OtherNode start="(158, 29)" end="(158, 41)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(158, 29)" end="(158, 41)" kind="str">
            <AtomNode start="(158, 29)" end="(158, 41)" leading="" trailing=" " val="&amp;quot;assumption&amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(158, 42)" end="(158, 43)" leading="" trailing=" " val=":"/>
      <IdentNode start="(158, 44)" end="(158, 50)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(160, 1)" end="(184, 56)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(160, 1)" end="(183, 3)">
        <CommandDoccommentNode start="(160, 1)" end="(183, 3)" comment="`contradiction` closes the main goal if its hypotheses are &amp;quot;trivially contradictory&amp;quot;.&#10;&#10;- Inductive type/family with no applicable constructors&#10;  ```lean&#10;  example (h : False) : p := by contradiction&#10;  ```&#10;- Injectivity of constructors&#10;  ```lean&#10;  example (h : none = some true) : p := by contradiction  --&#10;  ```&#10;- Decidable false proposition&#10;  ```lean&#10;  example (h : 2 + 2 = 3) : p := by contradiction&#10;  ```&#10;- Contradictory hypotheses&#10;  ```lean&#10;  example (h : p) (h' : ¬ p) : q := by contradiction&#10;  ```&#10;- Other simple contradictions such as&#10;  ```lean&#10;  example (x : Nat) (h : x ≠ x) : p := by contradiction&#10;  ```&#10;-/">
          <AtomNode start="(160, 1)" end="(160, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(161, 1)" end="(183, 3)" leading="" trailing="&#10;" val="`contradiction` closes the main goal if its hypotheses are &amp;quot;trivially contradictory&amp;quot;.&#10;&#10;- Inductive type/family with no applicable constructors&#10;  ```lean&#10;  example (h : False) : p := by contradiction&#10;  ```&#10;- Injectivity of constructors&#10;  ```lean&#10;  example (h : none = some true) : p := by contradiction  --&#10;  ```&#10;- Decidable false proposition&#10;  ```lean&#10;  example (h : 2 + 2 = 3) : p := by contradiction&#10;  ```&#10;- Contradictory hypotheses&#10;  ```lean&#10;  example (h : p) (h' : ¬ p) : q := by contradiction&#10;  ```&#10;- Other simple contradictions such as&#10;  ```lean&#10;  example (x : Nat) (h : x ≠ x) : p := by contradiction&#10;  ```&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(184, 1)" end="(184, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(184, 8)" end="(184, 31)">
        <OtherNode start="(184, 8)" end="(184, 31)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(184, 8)" end="(184, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(184, 9)" end="(184, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(184, 14)" end="(184, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(184, 17)" end="(184, 30)" leading="" trailing="" raw_val="contradiction" val="contradiction"/>
          <AtomNode start="(184, 30)" end="(184, 31)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(184, 32)" end="(184, 47)">
        <OtherNode start="(184, 32)" end="(184, 47)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(184, 32)" end="(184, 47)" kind="str">
            <AtomNode start="(184, 32)" end="(184, 47)" leading="" trailing=" " val="&amp;quot;contradiction&amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(184, 48)" end="(184, 49)" leading="" trailing=" " val=":"/>
      <IdentNode start="(184, 50)" end="(184, 56)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(186, 1)" end="(197, 63)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(186, 1)" end="(196, 3)">
        <CommandDoccommentNode start="(186, 1)" end="(196, 3)" comment="Changes the goal to `False`, retaining as much information as possible:&#10;&#10;* If the goal is `False`, do nothing.&#10;* If the goal is an implication or a function type, introduce the argument and restart.&#10;  (In particular, if the goal is `x ≠ y`, introduce `x = y`.)&#10;* Otherwise, for a propositional goal `P`, replace it with `¬ ¬ P`&#10;  (attempting to find a `Decidable` instance, but otherwise falling back to working classically)&#10;  and introduce `¬ P`.&#10;* For a non-propositional goal use `False.elim`.&#10;-/">
          <AtomNode start="(186, 1)" end="(186, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(187, 1)" end="(196, 3)" leading="" trailing="&#10;" val="Changes the goal to `False`, retaining as much information as possible:&#10;&#10;* If the goal is `False`, do nothing.&#10;* If the goal is an implication or a function type, introduce the argument and restart.&#10;  (In particular, if the goal is `x ≠ y`, introduce `x = y`.)&#10;* Otherwise, for a propositional goal `P`, replace it with `¬ ¬ P`&#10;  (attempting to find a `Decidable` instance, but otherwise falling back to working classically)&#10;  and introduce `¬ P`.&#10;* For a non-propositional goal use `False.elim`.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(197, 1)" end="(197, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(197, 8)" end="(197, 33)">
        <OtherNode start="(197, 8)" end="(197, 33)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(197, 8)" end="(197, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(197, 9)" end="(197, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(197, 14)" end="(197, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(197, 17)" end="(197, 32)" leading="" trailing="" raw_val="falseOrByContra" val="falseOrByContra"/>
          <AtomNode start="(197, 32)" end="(197, 33)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(197, 34)" end="(197, 54)">
        <OtherNode start="(197, 34)" end="(197, 54)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(197, 34)" end="(197, 54)" kind="str">
            <AtomNode start="(197, 34)" end="(197, 54)" leading="" trailing=" " val="&amp;quot;false_or_by_contra&amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(197, 55)" end="(197, 56)" leading="" trailing=" " val=":"/>
      <IdentNode start="(197, 57)" end="(197, 63)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(199, 1)" end="(208, 46)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(199, 1)" end="(207, 3)">
        <CommandDoccommentNode start="(199, 1)" end="(207, 3)" comment="`apply e` tries to match the current goal against the conclusion of `e`'s type.&#10;If it succeeds, then the tactic returns as many subgoals as the number of premises that&#10;have not been fixed by type inference or type class resolution.&#10;Non-dependent premises are added before dependent ones.&#10;&#10;The `apply` tactic uses higher-order pattern matching, type class resolution,&#10;and first-order unification with dependent types.&#10;-/">
          <AtomNode start="(199, 1)" end="(199, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(200, 1)" end="(207, 3)" leading="" trailing="&#10;" val="`apply e` tries to match the current goal against the conclusion of `e`'s type.&#10;If it succeeds, then the tactic returns as many subgoals as the number of premises that&#10;have not been fixed by type inference or type class resolution.&#10;Non-dependent premises are added before dependent ones.&#10;&#10;The `apply` tactic uses higher-order pattern matching, type class resolution,&#10;and first-order unification with dependent types.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(208, 1)" end="(208, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(208, 8)" end="(208, 23)">
        <OtherNode start="(208, 8)" end="(208, 23)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(208, 8)" end="(208, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(208, 9)" end="(208, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(208, 14)" end="(208, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(208, 17)" end="(208, 22)" leading="" trailing="" raw_val="apply" val="apply"/>
          <AtomNode start="(208, 22)" end="(208, 23)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(208, 24)" end="(208, 37)">
        <OtherNode start="(208, 24)" end="(208, 32)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(208, 24)" end="(208, 32)" kind="str">
            <AtomNode start="(208, 24)" end="(208, 32)" leading="" trailing=" " val="&amp;quot;apply &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(208, 33)" end="(208, 37)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(208, 33)" end="(208, 37)" leading="" trailing=" " raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(208, 38)" end="(208, 39)" leading="" trailing=" " val=":"/>
      <IdentNode start="(208, 40)" end="(208, 46)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(210, 1)" end="(213, 46)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(210, 1)" end="(212, 3)">
        <CommandDoccommentNode start="(210, 1)" end="(212, 3)" comment="`exact e` closes the main goal if its target type matches that of `e`.&#10;-/">
          <AtomNode start="(210, 1)" end="(210, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(211, 1)" end="(212, 3)" leading="" trailing="&#10;" val="`exact e` closes the main goal if its target type matches that of `e`.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(213, 1)" end="(213, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(213, 8)" end="(213, 23)">
        <OtherNode start="(213, 8)" end="(213, 23)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(213, 8)" end="(213, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(213, 9)" end="(213, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(213, 14)" end="(213, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(213, 17)" end="(213, 22)" leading="" trailing="" raw_val="exact" val="exact"/>
          <AtomNode start="(213, 22)" end="(213, 23)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(213, 24)" end="(213, 37)">
        <OtherNode start="(213, 24)" end="(213, 32)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(213, 24)" end="(213, 32)" kind="str">
            <AtomNode start="(213, 24)" end="(213, 32)" leading="" trailing=" " val="&amp;quot;exact &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(213, 33)" end="(213, 37)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(213, 33)" end="(213, 37)" leading="" trailing=" " raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(213, 38)" end="(213, 39)" leading="" trailing=" " val=":"/>
      <IdentNode start="(213, 40)" end="(213, 46)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(215, 1)" end="(220, 48)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(215, 1)" end="(219, 3)">
        <CommandDoccommentNode start="(215, 1)" end="(219, 3)" comment="`refine e` behaves like `exact e`, except that named (`?x`) or unnamed (`?_`)&#10;holes in `e` that are not solved by unification with the main goal's target type&#10;are converted into new goals, using the hole's name, if any, as the goal case name.&#10;-/">
          <AtomNode start="(215, 1)" end="(215, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(216, 1)" end="(219, 3)" leading="" trailing="&#10;" val="`refine e` behaves like `exact e`, except that named (`?x`) or unnamed (`?_`)&#10;holes in `e` that are not solved by unification with the main goal's target type&#10;are converted into new goals, using the hole's name, if any, as the goal case name.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(220, 1)" end="(220, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(220, 8)" end="(220, 24)">
        <OtherNode start="(220, 8)" end="(220, 24)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(220, 8)" end="(220, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(220, 9)" end="(220, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(220, 14)" end="(220, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(220, 17)" end="(220, 23)" leading="" trailing="" raw_val="refine" val="refine"/>
          <AtomNode start="(220, 23)" end="(220, 24)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(220, 25)" end="(220, 39)">
        <OtherNode start="(220, 25)" end="(220, 34)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(220, 25)" end="(220, 34)" kind="str">
            <AtomNode start="(220, 25)" end="(220, 34)" leading="" trailing=" " val="&amp;quot;refine &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(220, 35)" end="(220, 39)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(220, 35)" end="(220, 39)" leading="" trailing=" " raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(220, 40)" end="(220, 41)" leading="" trailing=" " val=":"/>
      <IdentNode start="(220, 42)" end="(220, 48)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(222, 1)" end="(226, 50)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(222, 1)" end="(225, 3)">
        <CommandDoccommentNode start="(222, 1)" end="(225, 3)" comment="`refine' e` behaves like `refine e`, except that unsolved placeholders (`_`)&#10;and implicit parameters are also converted into new goals.&#10;-/">
          <AtomNode start="(222, 1)" end="(222, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(223, 1)" end="(225, 3)" leading="" trailing="&#10;" val="`refine' e` behaves like `refine e`, except that unsolved placeholders (`_`)&#10;and implicit parameters are also converted into new goals.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(226, 1)" end="(226, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(226, 8)" end="(226, 25)">
        <OtherNode start="(226, 8)" end="(226, 25)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(226, 8)" end="(226, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(226, 9)" end="(226, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(226, 14)" end="(226, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(226, 17)" end="(226, 24)" leading="" trailing="" raw_val="refine'" val="refine'"/>
          <AtomNode start="(226, 24)" end="(226, 25)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(226, 26)" end="(226, 41)">
        <OtherNode start="(226, 26)" end="(226, 36)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(226, 26)" end="(226, 36)" kind="str">
            <AtomNode start="(226, 26)" end="(226, 36)" leading="" trailing=" " val="&amp;quot;refine' &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(226, 37)" end="(226, 41)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(226, 37)" end="(226, 41)" leading="" trailing=" " raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(226, 42)" end="(226, 43)" leading="" trailing=" " val=":"/>
      <IdentNode start="(226, 44)" end="(226, 50)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(228, 1)" end="(229, 60)" kind="Lean.Parser.Command.macro">
      <NullNode start="(228, 1)" end="(228, 82)">
        <CommandDoccommentNode start="(228, 1)" end="(228, 82)" comment="`exfalso` converts a goal `⊢ tgt` into `⊢ False` by applying `False.elim`. -/">
          <AtomNode start="(228, 1)" end="(228, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(228, 5)" end="(228, 82)" leading="" trailing="&#10;" val="`exfalso` converts a goal `⊢ tgt` into `⊢ False` by applying `False.elim`. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(229, 1)" end="(229, 6)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(229, 7)" end="(229, 16)">
        <OtherNode start="(229, 7)" end="(229, 16)" kind="Lean.Parser.Command.macroArg">
          <NullNode/>
          <OtherNode start="(229, 7)" end="(229, 16)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(229, 7)" end="(229, 16)" kind="str">
              <AtomNode start="(229, 7)" end="(229, 16)" leading="" trailing=" " val="&amp;quot;exfalso&amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(229, 17)" end="(229, 60)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(229, 17)" end="(229, 18)" leading="" trailing=" " val=":"/>
        <IdentNode start="(229, 19)" end="(229, 25)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(229, 26)" end="(229, 28)" leading="" trailing=" " val="=&amp;gt;"/>
        <OtherNode start="(229, 29)" end="(229, 60)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(229, 29)" end="(229, 60)" kind="Lean.Parser.Tactic.quot">
            <AtomNode start="(229, 29)" end="(229, 38)" leading="" trailing=" " val="`(tactic|"/>
            <OtherNode start="(229, 39)" end="(229, 59)" kind="Lean.Parser.Tactic.refine">
              <AtomNode start="(229, 39)" end="(229, 45)" leading="" trailing=" " val="refine"/>
              <OtherNode start="(229, 46)" end="(229, 59)" kind="Lean.Parser.Term.app">
                <IdentNode start="(229, 46)" end="(229, 56)" leading="" trailing=" " raw_val="False.elim" val="False.elim"/>
                <NullNode start="(229, 57)" end="(229, 59)">
                  <OtherNode start="(229, 57)" end="(229, 59)" kind="Lean.Parser.Term.syntheticHole">
                    <AtomNode start="(229, 57)" end="(229, 58)" leading="" trailing="" val="?"/>
                    <AtomNode start="(229, 58)" end="(229, 59)" leading="" trailing="" val="_"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
            <AtomNode start="(229, 59)" end="(229, 60)" leading="" trailing="&#10;&#10;" val=")"/>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(231, 1)" end="(235, 52)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(231, 1)" end="(234, 3)">
        <CommandDoccommentNode start="(231, 1)" end="(234, 3)" comment="If the main goal's target type is an inductive type, `constructor` solves it with&#10;the first matching constructor, or else fails.&#10;-/">
          <AtomNode start="(231, 1)" end="(231, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(232, 1)" end="(234, 3)" leading="" trailing="&#10;" val="If the main goal's target type is an inductive type, `constructor` solves it with&#10;the first matching constructor, or else fails.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(235, 1)" end="(235, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(235, 8)" end="(235, 29)">
        <OtherNode start="(235, 8)" end="(235, 29)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(235, 8)" end="(235, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(235, 9)" end="(235, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(235, 14)" end="(235, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(235, 17)" end="(235, 28)" leading="" trailing="" raw_val="constructor" val="constructor"/>
          <AtomNode start="(235, 28)" end="(235, 29)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(235, 30)" end="(235, 43)">
        <OtherNode start="(235, 30)" end="(235, 43)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(235, 30)" end="(235, 43)" kind="str">
            <AtomNode start="(235, 30)" end="(235, 43)" leading="" trailing=" " val="&amp;quot;constructor&amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(235, 44)" end="(235, 45)" leading="" trailing=" " val=":"/>
      <IdentNode start="(235, 46)" end="(235, 52)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(237, 1)" end="(246, 38)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(237, 1)" end="(245, 3)">
        <CommandDoccommentNode start="(237, 1)" end="(245, 3)" comment="Applies the first constructor when&#10;the goal is an inductive type with exactly two constructors, or fails otherwise.&#10;```&#10;example : True ∨ False := by&#10;  left&#10;  trivial&#10;```&#10;-/">
          <AtomNode start="(237, 1)" end="(237, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(238, 1)" end="(245, 3)" leading="" trailing="&#10;" val="Applies the first constructor when&#10;the goal is an inductive type with exactly two constructors, or fails otherwise.&#10;```&#10;example : True ∨ False := by&#10;  left&#10;  trivial&#10;```&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(246, 1)" end="(246, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(246, 8)" end="(246, 22)">
        <OtherNode start="(246, 8)" end="(246, 22)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(246, 8)" end="(246, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(246, 9)" end="(246, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(246, 14)" end="(246, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(246, 17)" end="(246, 21)" leading="" trailing="" raw_val="left" val="left"/>
          <AtomNode start="(246, 21)" end="(246, 22)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(246, 23)" end="(246, 29)">
        <OtherNode start="(246, 23)" end="(246, 29)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(246, 23)" end="(246, 29)" kind="str">
            <AtomNode start="(246, 23)" end="(246, 29)" leading="" trailing=" " val="&amp;quot;left&amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(246, 30)" end="(246, 31)" leading="" trailing=" " val=":"/>
      <IdentNode start="(246, 32)" end="(246, 38)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(248, 1)" end="(257, 40)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(248, 1)" end="(256, 3)">
        <CommandDoccommentNode start="(248, 1)" end="(256, 3)" comment="Applies the second constructor when&#10;the goal is an inductive type with exactly two constructors, or fails otherwise.&#10;```&#10;example {p q : Prop} (h : q) : p ∨ q := by&#10;  right&#10;  exact h&#10;```&#10;-/">
          <AtomNode start="(248, 1)" end="(248, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(249, 1)" end="(256, 3)" leading="" trailing="&#10;" val="Applies the second constructor when&#10;the goal is an inductive type with exactly two constructors, or fails otherwise.&#10;```&#10;example {p q : Prop} (h : q) : p ∨ q := by&#10;  right&#10;  exact h&#10;```&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(257, 1)" end="(257, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(257, 8)" end="(257, 23)">
        <OtherNode start="(257, 8)" end="(257, 23)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(257, 8)" end="(257, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(257, 9)" end="(257, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(257, 14)" end="(257, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(257, 17)" end="(257, 22)" leading="" trailing="" raw_val="right" val="right"/>
          <AtomNode start="(257, 22)" end="(257, 23)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(257, 24)" end="(257, 31)">
        <OtherNode start="(257, 24)" end="(257, 31)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(257, 24)" end="(257, 31)" kind="str">
            <AtomNode start="(257, 24)" end="(257, 31)" leading="" trailing=" " val="&amp;quot;right&amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(257, 32)" end="(257, 33)" leading="" trailing=" " val=":"/>
      <IdentNode start="(257, 34)" end="(257, 40)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(259, 1)" end="(266, 79)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(259, 1)" end="(265, 3)">
        <CommandDoccommentNode start="(259, 1)" end="(265, 3)" comment="* `case tag =&amp;gt; tac` focuses on the goal with case name `tag` and solves it using `tac`,&#10;  or else fails.&#10;* `case tag x₁ ... xₙ =&amp;gt; tac` additionally renames the `n` most recent hypotheses&#10;  with inaccessible names to the given names.&#10;* `case tag₁ | tag₂ =&amp;gt; tac` is equivalent to `(case tag₁ =&amp;gt; tac); (case tag₂ =&amp;gt; tac)`.&#10;-/">
          <AtomNode start="(259, 1)" end="(259, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(260, 1)" end="(265, 3)" leading="" trailing="&#10;" val="* `case tag =&amp;gt; tac` focuses on the goal with case name `tag` and solves it using `tac`,&#10;  or else fails.&#10;* `case tag x₁ ... xₙ =&amp;gt; tac` additionally renames the `n` most recent hypotheses&#10;  with inaccessible names to the given names.&#10;* `case tag₁ | tag₂ =&amp;gt; tac` is equivalent to `(case tag₁ =&amp;gt; tac); (case tag₂ =&amp;gt; tac)`.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(266, 1)" end="(266, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(266, 8)" end="(266, 22)">
        <OtherNode start="(266, 8)" end="(266, 22)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(266, 8)" end="(266, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(266, 9)" end="(266, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(266, 14)" end="(266, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(266, 17)" end="(266, 21)" leading="" trailing="" raw_val="case" val="case"/>
          <AtomNode start="(266, 21)" end="(266, 22)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(266, 23)" end="(266, 70)">
        <OtherNode start="(266, 23)" end="(266, 30)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(266, 23)" end="(266, 30)" kind="str">
            <AtomNode start="(266, 23)" end="(266, 30)" leading="" trailing=" " val="&amp;quot;case &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(266, 31)" end="(266, 53)" kind="Lean.Parser.Syntax.sepBy1">
          <AtomNode start="(266, 31)" end="(266, 38)" leading="" trailing="" val="sepBy1("/>
          <NullNode start="(266, 38)" end="(266, 45)">
            <OtherNode start="(266, 38)" end="(266, 45)" kind="Lean.Parser.Syntax.cat">
              <IdentNode start="(266, 38)" end="(266, 45)" leading="" trailing="" raw_val="caseArg" val="caseArg" full_name="Lean.Parser.Tactic.caseArg" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
              <NullNode/>
            </OtherNode>
          </NullNode>
          <AtomNode start="(266, 45)" end="(266, 46)" leading="" trailing=" " val=","/>
          <OtherNode start="(266, 47)" end="(266, 52)" kind="str">
            <AtomNode start="(266, 47)" end="(266, 52)" leading="" trailing="" val="&amp;quot; | &amp;quot;"/>
          </OtherNode>
          <NullNode/>
          <NullNode/>
          <AtomNode start="(266, 52)" end="(266, 53)" leading="" trailing=" " val=")"/>
        </OtherNode>
        <OtherNode start="(266, 54)" end="(266, 60)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(266, 54)" end="(266, 60)" kind="str">
            <AtomNode start="(266, 54)" end="(266, 60)" leading="" trailing=" " val="&amp;quot; =&amp;gt; &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(266, 61)" end="(266, 70)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(266, 61)" end="(266, 70)" leading="" trailing=" " raw_val="tacticSeq" val="tacticSeq" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(266, 71)" end="(266, 72)" leading="" trailing=" " val=":"/>
      <IdentNode start="(266, 73)" end="(266, 79)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(268, 1)" end="(274, 81)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(268, 1)" end="(273, 3)">
        <CommandDoccommentNode start="(268, 1)" end="(273, 3)" comment="`case'` is similar to the `case tag =&amp;gt; tac` tactic, but does not ensure the goal&#10;has been solved after applying `tac`, nor admits the goal if `tac` failed.&#10;Recall that `case` closes the goal using `sorry` when `tac` fails, and&#10;the tactic execution is not interrupted.&#10;-/">
          <AtomNode start="(268, 1)" end="(268, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(269, 1)" end="(273, 3)" leading="" trailing="&#10;" val="`case'` is similar to the `case tag =&amp;gt; tac` tactic, but does not ensure the goal&#10;has been solved after applying `tac`, nor admits the goal if `tac` failed.&#10;Recall that `case` closes the goal using `sorry` when `tac` fails, and&#10;the tactic execution is not interrupted.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(274, 1)" end="(274, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(274, 8)" end="(274, 23)">
        <OtherNode start="(274, 8)" end="(274, 23)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(274, 8)" end="(274, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(274, 9)" end="(274, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(274, 14)" end="(274, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(274, 17)" end="(274, 22)" leading="" trailing="" raw_val="case'" val="case'"/>
          <AtomNode start="(274, 22)" end="(274, 23)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(274, 24)" end="(274, 72)">
        <OtherNode start="(274, 24)" end="(274, 32)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(274, 24)" end="(274, 32)" kind="str">
            <AtomNode start="(274, 24)" end="(274, 32)" leading="" trailing=" " val="&amp;quot;case' &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(274, 33)" end="(274, 55)" kind="Lean.Parser.Syntax.sepBy1">
          <AtomNode start="(274, 33)" end="(274, 40)" leading="" trailing="" val="sepBy1("/>
          <NullNode start="(274, 40)" end="(274, 47)">
            <OtherNode start="(274, 40)" end="(274, 47)" kind="Lean.Parser.Syntax.cat">
              <IdentNode start="(274, 40)" end="(274, 47)" leading="" trailing="" raw_val="caseArg" val="caseArg" full_name="Lean.Parser.Tactic.caseArg" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
              <NullNode/>
            </OtherNode>
          </NullNode>
          <AtomNode start="(274, 47)" end="(274, 48)" leading="" trailing=" " val=","/>
          <OtherNode start="(274, 49)" end="(274, 54)" kind="str">
            <AtomNode start="(274, 49)" end="(274, 54)" leading="" trailing="" val="&amp;quot; | &amp;quot;"/>
          </OtherNode>
          <NullNode/>
          <NullNode/>
          <AtomNode start="(274, 54)" end="(274, 55)" leading="" trailing=" " val=")"/>
        </OtherNode>
        <OtherNode start="(274, 56)" end="(274, 62)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(274, 56)" end="(274, 62)" kind="str">
            <AtomNode start="(274, 56)" end="(274, 62)" leading="" trailing=" " val="&amp;quot; =&amp;gt; &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(274, 63)" end="(274, 72)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(274, 63)" end="(274, 72)" leading="" trailing=" " raw_val="tacticSeq" val="tacticSeq" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(274, 73)" end="(274, 74)" leading="" trailing=" " val=":"/>
      <IdentNode start="(274, 75)" end="(274, 81)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(276, 1)" end="(283, 68)" kind="Lean.Parser.Command.macro">
      <NullNode start="(276, 1)" end="(280, 3)">
        <CommandDoccommentNode start="(276, 1)" end="(280, 3)" comment="`next =&amp;gt; tac` focuses on the next goal and solves it using `tac`, or else fails.&#10;`next x₁ ... xₙ =&amp;gt; tac` additionally renames the `n` most recent hypotheses with&#10;inaccessible names to the given names.&#10;-/">
          <AtomNode start="(276, 1)" end="(276, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(277, 1)" end="(280, 3)" leading="" trailing="&#10;" val="`next =&amp;gt; tac` focuses on the next goal and solves it using `tac`, or else fails.&#10;`next x₁ ... xₙ =&amp;gt; tac` additionally renames the `n` most recent hypotheses with&#10;inaccessible names to the given names.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(281, 1)" end="(281, 6)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(281, 7)" end="(281, 68)">
        <OtherNode start="(281, 7)" end="(281, 21)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(281, 7)" end="(281, 14)">
            <IdentNode start="(281, 7)" end="(281, 13)" leading="" trailing="" raw_val="nextTk" val="nextTk"/>
            <AtomNode start="(281, 13)" end="(281, 14)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(281, 14)" end="(281, 21)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(281, 14)" end="(281, 21)" kind="str">
              <AtomNode start="(281, 14)" end="(281, 21)" leading="" trailing=" " val="&amp;quot;next &amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(281, 22)" end="(281, 39)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(281, 22)" end="(281, 27)">
            <IdentNode start="(281, 22)" end="(281, 26)" leading="" trailing="" raw_val="args" val="args"/>
            <AtomNode start="(281, 26)" end="(281, 27)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(281, 27)" end="(281, 39)" kind="«stx_*»">
            <OtherNode start="(281, 27)" end="(281, 38)" kind="Lean.Parser.Syntax.cat">
              <IdentNode start="(281, 27)" end="(281, 38)" leading="" trailing="" raw_val="binderIdent" val="binderIdent" full_name="Lean.binderIdent" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
              <NullNode/>
            </OtherNode>
            <AtomNode start="(281, 38)" end="(281, 39)" leading="" trailing=" " val="*"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(281, 40)" end="(281, 54)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(281, 40)" end="(281, 48)">
            <IdentNode start="(281, 40)" end="(281, 47)" leading="" trailing="" raw_val="arrowTk" val="arrowTk"/>
            <AtomNode start="(281, 47)" end="(281, 48)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(281, 48)" end="(281, 54)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(281, 48)" end="(281, 54)" kind="str">
              <AtomNode start="(281, 48)" end="(281, 54)" leading="" trailing=" " val="&amp;quot; =&amp;gt; &amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(281, 55)" end="(281, 68)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(281, 55)" end="(281, 59)">
            <IdentNode start="(281, 55)" end="(281, 58)" leading="" trailing="" raw_val="tac" val="tac"/>
            <AtomNode start="(281, 58)" end="(281, 59)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(281, 59)" end="(281, 68)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(281, 59)" end="(281, 68)" leading="" trailing=" " raw_val="tacticSeq" val="tacticSeq" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(281, 69)" end="(283, 68)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(281, 69)" end="(281, 70)" leading="" trailing=" " val=":"/>
        <IdentNode start="(281, 71)" end="(281, 77)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(281, 78)" end="(281, 80)" leading="" trailing="&#10;  -- Limit ref variability for incrementality; see Note [Incremental Macros]&#10;  " val="=&amp;gt;"/>
        <OtherNode start="(283, 3)" end="(283, 68)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(283, 3)" end="(283, 68)" kind="Lean.Parser.Term.app">
            <IdentNode start="(283, 3)" end="(283, 10)" leading="" trailing=" " raw_val="withRef" val="withRef" full_name="Lean.withRef" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            <NullNode start="(283, 11)" end="(283, 68)">
              <IdentNode start="(283, 11)" end="(283, 18)" leading="" trailing=" " raw_val="arrowTk" val="arrowTk"/>
              <OtherNode start="(283, 19)" end="(283, 68)" kind="Lean.Parser.Tactic.quot">
                <AtomNode start="(283, 19)" end="(283, 28)" leading="" trailing=" " val="`(tactic|"/>
                <OtherNode start="(283, 29)" end="(283, 67)" kind="Lean.Parser.Tactic.case">
                  <TokenAntiquotNode start="(283, 29)" end="(283, 41)">
                    <AtomNode start="(283, 29)" end="(283, 33)" leading="" trailing="" val="case"/>
                    <AtomNode start="(283, 33)" end="(283, 34)" leading="" trailing="" val="%"/>
                    <AtomNode start="(283, 34)" end="(283, 35)" leading="" trailing="" val="$"/>
                    <IdentNode start="(283, 35)" end="(283, 41)" leading="" trailing=" " raw_val="nextTk" val="nextTk"/>
                  </TokenAntiquotNode>
                  <NullNode start="(283, 42)" end="(283, 50)">
                    <OtherNode start="(283, 42)" end="(283, 50)" kind="Lean.Parser.Tactic.caseArg">
                      <LeanBinderidentNode start="(283, 42)" end="(283, 43)">
                        <TermHoleNode start="(283, 42)" end="(283, 43)">
                          <AtomNode start="(283, 42)" end="(283, 43)" leading="" trailing=" " val="_"/>
                        </TermHoleNode>
                      </LeanBinderidentNode>
                      <NullNode start="(283, 44)" end="(283, 50)">
                        <OtherNode start="(283, 44)" end="(283, 50)" kind="many.antiquot_suffix_splice">
                          <LeanBinderidentAntiquotNode start="(283, 44)" end="(283, 49)">
                            <AtomNode start="(283, 44)" end="(283, 45)" leading="" trailing="" val="$"/>
                            <NullNode/>
                            <IdentNode start="(283, 45)" end="(283, 49)" leading="" trailing="" raw_val="args" val="args"/>
                            <NullNode/>
                          </LeanBinderidentAntiquotNode>
                          <AtomNode start="(283, 49)" end="(283, 50)" leading="" trailing=" " val="*"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <TokenAntiquotNode start="(283, 51)" end="(283, 62)">
                    <AtomNode start="(283, 51)" end="(283, 53)" leading="" trailing="" val="=&amp;gt;"/>
                    <AtomNode start="(283, 53)" end="(283, 54)" leading="" trailing="" val="%"/>
                    <AtomNode start="(283, 54)" end="(283, 55)" leading="" trailing="" val="$"/>
                    <IdentNode start="(283, 55)" end="(283, 62)" leading="" trailing=" " raw_val="arrowTk" val="arrowTk"/>
                  </TokenAntiquotNode>
                  <OtherNode start="(283, 63)" end="(283, 67)" kind="Lean.Parser.Tactic.tacticSeq.antiquot">
                    <AtomNode start="(283, 63)" end="(283, 64)" leading="" trailing="" val="$"/>
                    <NullNode/>
                    <IdentNode start="(283, 64)" end="(283, 67)" leading="" trailing="" raw_val="tac" val="tac"/>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(283, 67)" end="(283, 68)" leading="" trailing="&#10;&#10;" val=")"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(285, 1)" end="(291, 58)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(285, 1)" end="(290, 3)">
        <CommandDoccommentNode start="(285, 1)" end="(290, 3)" comment="`all_goals tac` runs `tac` on each goal, concatenating the resulting goals.&#10;If the tactic fails on any goal, the entire `all_goals` tactic fails.&#10;&#10;See also `any_goals tac`.&#10;-/">
          <AtomNode start="(285, 1)" end="(285, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(286, 1)" end="(290, 3)" leading="" trailing="&#10;" val="`all_goals tac` runs `tac` on each goal, concatenating the resulting goals.&#10;If the tactic fails on any goal, the entire `all_goals` tactic fails.&#10;&#10;See also `any_goals tac`.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(291, 1)" end="(291, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(291, 8)" end="(291, 26)">
        <OtherNode start="(291, 8)" end="(291, 26)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(291, 8)" end="(291, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(291, 9)" end="(291, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(291, 14)" end="(291, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(291, 17)" end="(291, 25)" leading="" trailing="" raw_val="allGoals" val="allGoals"/>
          <AtomNode start="(291, 25)" end="(291, 26)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(291, 27)" end="(291, 49)">
        <OtherNode start="(291, 27)" end="(291, 39)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(291, 27)" end="(291, 39)" kind="str">
            <AtomNode start="(291, 27)" end="(291, 39)" leading="" trailing=" " val="&amp;quot;all_goals &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(291, 40)" end="(291, 49)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(291, 40)" end="(291, 49)" leading="" trailing=" " raw_val="tacticSeq" val="tacticSeq" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(291, 50)" end="(291, 51)" leading="" trailing=" " val=":"/>
      <IdentNode start="(291, 52)" end="(291, 58)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(293, 1)" end="(300, 58)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(293, 1)" end="(299, 3)">
        <CommandDoccommentNode start="(293, 1)" end="(299, 3)" comment="`any_goals tac` applies the tactic `tac` to every goal,&#10;concatenating the resulting goals for successful tactic applications.&#10;If the tactic fails on all of the goals, the entire `any_goals` tactic fails.&#10;&#10;This tactic is like `all_goals try tac` except that it fails if none of the applications of `tac` succeeds.&#10;-/">
          <AtomNode start="(293, 1)" end="(293, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(294, 1)" end="(299, 3)" leading="" trailing="&#10;" val="`any_goals tac` applies the tactic `tac` to every goal,&#10;concatenating the resulting goals for successful tactic applications.&#10;If the tactic fails on all of the goals, the entire `any_goals` tactic fails.&#10;&#10;This tactic is like `all_goals try tac` except that it fails if none of the applications of `tac` succeeds.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(300, 1)" end="(300, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(300, 8)" end="(300, 26)">
        <OtherNode start="(300, 8)" end="(300, 26)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(300, 8)" end="(300, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(300, 9)" end="(300, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(300, 14)" end="(300, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(300, 17)" end="(300, 25)" leading="" trailing="" raw_val="anyGoals" val="anyGoals"/>
          <AtomNode start="(300, 25)" end="(300, 26)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(300, 27)" end="(300, 49)">
        <OtherNode start="(300, 27)" end="(300, 39)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(300, 27)" end="(300, 39)" kind="str">
            <AtomNode start="(300, 27)" end="(300, 39)" leading="" trailing=" " val="&amp;quot;any_goals &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(300, 40)" end="(300, 49)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(300, 40)" end="(300, 49)" leading="" trailing=" " raw_val="tacticSeq" val="tacticSeq" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(300, 50)" end="(300, 51)" leading="" trailing=" " val=":"/>
      <IdentNode start="(300, 52)" end="(300, 58)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(302, 1)" end="(306, 51)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(302, 1)" end="(305, 3)">
        <CommandDoccommentNode start="(302, 1)" end="(305, 3)" comment="`focus tac` focuses on the main goal, suppressing all other goals, and runs `tac` on it.&#10;Usually `· tac`, which enforces that the goal is closed by `tac`, should be preferred.&#10;-/">
          <AtomNode start="(302, 1)" end="(302, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(303, 1)" end="(305, 3)" leading="" trailing="&#10;" val="`focus tac` focuses on the main goal, suppressing all other goals, and runs `tac` on it.&#10;Usually `· tac`, which enforces that the goal is closed by `tac`, should be preferred.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(306, 1)" end="(306, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(306, 8)" end="(306, 23)">
        <OtherNode start="(306, 8)" end="(306, 23)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(306, 8)" end="(306, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(306, 9)" end="(306, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(306, 14)" end="(306, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(306, 17)" end="(306, 22)" leading="" trailing="" raw_val="focus" val="focus"/>
          <AtomNode start="(306, 22)" end="(306, 23)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(306, 24)" end="(306, 42)">
        <OtherNode start="(306, 24)" end="(306, 32)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(306, 24)" end="(306, 32)" kind="str">
            <AtomNode start="(306, 24)" end="(306, 32)" leading="" trailing=" " val="&amp;quot;focus &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(306, 33)" end="(306, 42)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(306, 33)" end="(306, 42)" leading="" trailing=" " raw_val="tacticSeq" val="tacticSeq" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(306, 43)" end="(306, 44)" leading="" trailing=" " val=":"/>
      <IdentNode start="(306, 45)" end="(306, 51)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(308, 1)" end="(309, 38)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(308, 1)" end="(308, 28)">
        <CommandDoccommentNode start="(308, 1)" end="(308, 28)" comment="`skip` does nothing. -/">
          <AtomNode start="(308, 1)" end="(308, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(308, 5)" end="(308, 28)" leading="" trailing="&#10;" val="`skip` does nothing. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(309, 1)" end="(309, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(309, 8)" end="(309, 22)">
        <OtherNode start="(309, 8)" end="(309, 22)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(309, 8)" end="(309, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(309, 9)" end="(309, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(309, 14)" end="(309, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(309, 17)" end="(309, 21)" leading="" trailing="" raw_val="skip" val="skip"/>
          <AtomNode start="(309, 21)" end="(309, 22)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(309, 23)" end="(309, 29)">
        <OtherNode start="(309, 23)" end="(309, 29)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(309, 23)" end="(309, 29)" kind="str">
            <AtomNode start="(309, 23)" end="(309, 29)" leading="" trailing=" " val="&amp;quot;skip&amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(309, 30)" end="(309, 31)" leading="" trailing=" " val=":"/>
      <IdentNode start="(309, 32)" end="(309, 38)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(311, 1)" end="(312, 38)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(311, 1)" end="(311, 57)">
        <CommandDoccommentNode start="(311, 1)" end="(311, 57)" comment="`done` succeeds iff there are no remaining goals. -/">
          <AtomNode start="(311, 1)" end="(311, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(311, 5)" end="(311, 57)" leading="" trailing="&#10;" val="`done` succeeds iff there are no remaining goals. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(312, 1)" end="(312, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(312, 8)" end="(312, 22)">
        <OtherNode start="(312, 8)" end="(312, 22)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(312, 8)" end="(312, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(312, 9)" end="(312, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(312, 14)" end="(312, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(312, 17)" end="(312, 21)" leading="" trailing="" raw_val="done" val="done"/>
          <AtomNode start="(312, 21)" end="(312, 22)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(312, 23)" end="(312, 29)">
        <OtherNode start="(312, 23)" end="(312, 29)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(312, 23)" end="(312, 29)" kind="str">
            <AtomNode start="(312, 23)" end="(312, 29)" leading="" trailing=" " val="&amp;quot;done&amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(312, 30)" end="(312, 31)" leading="" trailing=" " val=":"/>
      <IdentNode start="(312, 32)" end="(312, 38)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(314, 1)" end="(315, 51)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(314, 1)" end="(314, 66)">
        <CommandDoccommentNode start="(314, 1)" end="(314, 66)" comment="`trace_state` displays the current state in the info view. -/">
          <AtomNode start="(314, 1)" end="(314, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(314, 5)" end="(314, 66)" leading="" trailing="&#10;" val="`trace_state` displays the current state in the info view. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(315, 1)" end="(315, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(315, 8)" end="(315, 28)">
        <OtherNode start="(315, 8)" end="(315, 28)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(315, 8)" end="(315, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(315, 9)" end="(315, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(315, 14)" end="(315, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(315, 17)" end="(315, 27)" leading="" trailing="" raw_val="traceState" val="traceState"/>
          <AtomNode start="(315, 27)" end="(315, 28)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(315, 29)" end="(315, 42)">
        <OtherNode start="(315, 29)" end="(315, 42)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(315, 29)" end="(315, 42)" kind="str">
            <AtomNode start="(315, 29)" end="(315, 42)" leading="" trailing=" " val="&amp;quot;trace_state&amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(315, 43)" end="(315, 44)" leading="" trailing=" " val=":"/>
      <IdentNode start="(315, 45)" end="(315, 51)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(317, 1)" end="(318, 52)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(317, 1)" end="(317, 52)">
        <CommandDoccommentNode start="(317, 1)" end="(317, 52)" comment="`trace msg` displays `msg` in the info view. -/">
          <AtomNode start="(317, 1)" end="(317, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(317, 5)" end="(317, 52)" leading="" trailing="&#10;" val="`trace msg` displays `msg` in the info view. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(318, 1)" end="(318, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(318, 8)" end="(318, 30)">
        <OtherNode start="(318, 8)" end="(318, 30)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(318, 8)" end="(318, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(318, 9)" end="(318, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(318, 14)" end="(318, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(318, 17)" end="(318, 29)" leading="" trailing="" raw_val="traceMessage" val="traceMessage"/>
          <AtomNode start="(318, 29)" end="(318, 30)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(318, 31)" end="(318, 43)">
        <OtherNode start="(318, 31)" end="(318, 39)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(318, 31)" end="(318, 39)" kind="str">
            <AtomNode start="(318, 31)" end="(318, 39)" leading="" trailing=" " val="&amp;quot;trace &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(318, 40)" end="(318, 43)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(318, 40)" end="(318, 43)" leading="" trailing=" " raw_val="str" val="str" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(318, 44)" end="(318, 45)" leading="" trailing=" " val=":"/>
      <IdentNode start="(318, 46)" end="(318, 52)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(320, 1)" end="(321, 69)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(320, 1)" end="(320, 61)">
        <CommandDoccommentNode start="(320, 1)" end="(320, 61)" comment="`fail_if_success t` fails if the tactic `t` succeeds. -/">
          <AtomNode start="(320, 1)" end="(320, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(320, 5)" end="(320, 61)" leading="" trailing="&#10;" val="`fail_if_success t` fails if the tactic `t` succeeds. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(321, 1)" end="(321, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(321, 8)" end="(321, 31)">
        <OtherNode start="(321, 8)" end="(321, 31)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(321, 8)" end="(321, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(321, 9)" end="(321, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(321, 14)" end="(321, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(321, 17)" end="(321, 30)" leading="" trailing="" raw_val="failIfSuccess" val="failIfSuccess"/>
          <AtomNode start="(321, 30)" end="(321, 31)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(321, 32)" end="(321, 60)">
        <OtherNode start="(321, 32)" end="(321, 50)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(321, 32)" end="(321, 50)" kind="str">
            <AtomNode start="(321, 32)" end="(321, 50)" leading="" trailing=" " val="&amp;quot;fail_if_success &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(321, 51)" end="(321, 60)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(321, 51)" end="(321, 60)" leading="" trailing=" " raw_val="tacticSeq" val="tacticSeq" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(321, 61)" end="(321, 62)" leading="" trailing=" " val=":"/>
      <IdentNode start="(321, 63)" end="(321, 69)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(323, 1)" end="(328, 67)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(323, 1)" end="(327, 3)">
        <CommandDoccommentNode start="(323, 1)" end="(327, 3)" comment="`(tacs)` executes a list of tactics in sequence, without requiring that&#10;the goal be closed at the end like `· tacs`. Like `by` itself, the tactics&#10;can be either separated by newlines or `;`.&#10;-/">
          <AtomNode start="(323, 1)" end="(323, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(324, 1)" end="(327, 3)" leading="" trailing="&#10;" val="`(tacs)` executes a list of tactics in sequence, without requiring that&#10;the goal be closed at the end like `· tacs`. Like `by` itself, the tactics&#10;can be either separated by newlines or `;`.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(328, 1)" end="(328, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(328, 8)" end="(328, 23)">
        <OtherNode start="(328, 8)" end="(328, 23)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(328, 8)" end="(328, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(328, 9)" end="(328, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(328, 14)" end="(328, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(328, 17)" end="(328, 22)" leading="" trailing="" raw_val="paren" val="paren"/>
          <AtomNode start="(328, 22)" end="(328, 23)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(328, 24)" end="(328, 58)">
        <OtherNode start="(328, 24)" end="(328, 27)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(328, 24)" end="(328, 27)" kind="str">
            <AtomNode start="(328, 24)" end="(328, 27)" leading="" trailing=" " val="&amp;quot;(&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(328, 28)" end="(328, 54)" kind="Lean.Parser.Syntax.unary">
          <IdentNode start="(328, 28)" end="(328, 43)" leading="" trailing="" raw_val="withoutPosition" val="withoutPosition"/>
          <AtomNode start="(328, 43)" end="(328, 44)" leading="" trailing="" val="("/>
          <NullNode start="(328, 44)" end="(328, 53)">
            <OtherNode start="(328, 44)" end="(328, 53)" kind="Lean.Parser.Syntax.cat">
              <IdentNode start="(328, 44)" end="(328, 53)" leading="" trailing="" raw_val="tacticSeq" val="tacticSeq" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              <NullNode/>
            </OtherNode>
          </NullNode>
          <AtomNode start="(328, 53)" end="(328, 54)" leading="" trailing=" " val=")"/>
        </OtherNode>
        <OtherNode start="(328, 55)" end="(328, 58)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(328, 55)" end="(328, 58)" kind="str">
            <AtomNode start="(328, 55)" end="(328, 58)" leading="" trailing=" " val="&amp;quot;)&amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(328, 59)" end="(328, 60)" leading="" trailing=" " val=":"/>
      <IdentNode start="(328, 61)" end="(328, 67)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(330, 1)" end="(334, 68)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(330, 1)" end="(333, 3)">
        <CommandDoccommentNode start="(330, 1)" end="(333, 3)" comment="`with_reducible tacs` executes `tacs` using the reducible transparency setting.&#10;In this setting only definitions tagged as `[reducible]` are unfolded.&#10;-/">
          <AtomNode start="(330, 1)" end="(330, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(331, 1)" end="(333, 3)" leading="" trailing="&#10;" val="`with_reducible tacs` executes `tacs` using the reducible transparency setting.&#10;In this setting only definitions tagged as `[reducible]` are unfolded.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(334, 1)" end="(334, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(334, 8)" end="(334, 31)">
        <OtherNode start="(334, 8)" end="(334, 31)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(334, 8)" end="(334, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(334, 9)" end="(334, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(334, 14)" end="(334, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(334, 17)" end="(334, 30)" leading="" trailing="" raw_val="withReducible" val="withReducible"/>
          <AtomNode start="(334, 30)" end="(334, 31)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(334, 32)" end="(334, 59)">
        <OtherNode start="(334, 32)" end="(334, 49)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(334, 32)" end="(334, 49)" kind="str">
            <AtomNode start="(334, 32)" end="(334, 49)" leading="" trailing=" " val="&amp;quot;with_reducible &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(334, 50)" end="(334, 59)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(334, 50)" end="(334, 59)" leading="" trailing=" " raw_val="tacticSeq" val="tacticSeq" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(334, 60)" end="(334, 61)" leading="" trailing=" " val=":"/>
      <IdentNode start="(334, 62)" end="(334, 68)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(336, 1)" end="(340, 94)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(336, 1)" end="(339, 3)">
        <CommandDoccommentNode start="(336, 1)" end="(339, 3)" comment="`with_reducible_and_instances tacs` executes `tacs` using the `.instances` transparency setting.&#10;In this setting only definitions tagged as `[reducible]` or type class instances are unfolded.&#10;-/">
          <AtomNode start="(336, 1)" end="(336, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(337, 1)" end="(339, 3)" leading="" trailing="&#10;" val="`with_reducible_and_instances tacs` executes `tacs` using the `.instances` transparency setting.&#10;In this setting only definitions tagged as `[reducible]` or type class instances are unfolded.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(340, 1)" end="(340, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(340, 8)" end="(340, 43)">
        <OtherNode start="(340, 8)" end="(340, 43)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(340, 8)" end="(340, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(340, 9)" end="(340, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(340, 14)" end="(340, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(340, 17)" end="(340, 42)" leading="" trailing="" raw_val="withReducibleAndInstances" val="withReducibleAndInstances"/>
          <AtomNode start="(340, 42)" end="(340, 43)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(340, 44)" end="(340, 85)">
        <OtherNode start="(340, 44)" end="(340, 75)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(340, 44)" end="(340, 75)" kind="str">
            <AtomNode start="(340, 44)" end="(340, 75)" leading="" trailing=" " val="&amp;quot;with_reducible_and_instances &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(340, 76)" end="(340, 85)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(340, 76)" end="(340, 85)" leading="" trailing=" " raw_val="tacticSeq" val="tacticSeq" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(340, 86)" end="(340, 87)" leading="" trailing=" " val=":"/>
      <IdentNode start="(340, 88)" end="(340, 94)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(342, 1)" end="(346, 75)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(342, 1)" end="(345, 3)">
        <CommandDoccommentNode start="(342, 1)" end="(345, 3)" comment="`with_unfolding_all tacs` executes `tacs` using the `.all` transparency setting.&#10;In this setting all definitions that are not opaque are unfolded.&#10;-/">
          <AtomNode start="(342, 1)" end="(342, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(343, 1)" end="(345, 3)" leading="" trailing="&#10;" val="`with_unfolding_all tacs` executes `tacs` using the `.all` transparency setting.&#10;In this setting all definitions that are not opaque are unfolded.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(346, 1)" end="(346, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(346, 8)" end="(346, 34)">
        <OtherNode start="(346, 8)" end="(346, 34)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(346, 8)" end="(346, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(346, 9)" end="(346, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(346, 14)" end="(346, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(346, 17)" end="(346, 33)" leading="" trailing="" raw_val="withUnfoldingAll" val="withUnfoldingAll"/>
          <AtomNode start="(346, 33)" end="(346, 34)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(346, 35)" end="(346, 66)">
        <OtherNode start="(346, 35)" end="(346, 56)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(346, 35)" end="(346, 56)" kind="str">
            <AtomNode start="(346, 35)" end="(346, 56)" leading="" trailing=" " val="&amp;quot;with_unfolding_all &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(346, 57)" end="(346, 66)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(346, 57)" end="(346, 66)" leading="" trailing=" " raw_val="tacticSeq" val="tacticSeq" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(346, 67)" end="(346, 68)" leading="" trailing=" " val=":"/>
      <IdentNode start="(346, 69)" end="(346, 75)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(348, 1)" end="(349, 96)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(348, 1)" end="(348, 78)">
        <CommandDoccommentNode start="(348, 1)" end="(348, 78)" comment="`first | tac | ...` runs each `tac` until one succeeds, or else fails. -/">
          <AtomNode start="(348, 1)" end="(348, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(348, 5)" end="(348, 78)" leading="" trailing="&#10;" val="`first | tac | ...` runs each `tac` until one succeeds, or else fails. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(349, 1)" end="(349, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(349, 8)" end="(349, 23)">
        <OtherNode start="(349, 8)" end="(349, 23)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(349, 8)" end="(349, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(349, 9)" end="(349, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(349, 14)" end="(349, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(349, 17)" end="(349, 22)" leading="" trailing="" raw_val="first" val="first"/>
          <AtomNode start="(349, 22)" end="(349, 23)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(349, 24)" end="(349, 87)">
        <OtherNode start="(349, 24)" end="(349, 32)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(349, 24)" end="(349, 32)" kind="str">
            <AtomNode start="(349, 24)" end="(349, 32)" leading="" trailing=" " val="&amp;quot;first &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(349, 33)" end="(349, 87)" kind="Lean.Parser.Syntax.unary">
          <IdentNode start="(349, 33)" end="(349, 45)" leading="" trailing="" raw_val="withPosition" val="withPosition"/>
          <AtomNode start="(349, 45)" end="(349, 46)" leading="" trailing="" val="("/>
          <NullNode start="(349, 46)" end="(349, 86)">
            <OtherNode start="(349, 46)" end="(349, 86)" kind="«stx_+»">
              <OtherNode start="(349, 46)" end="(349, 85)" kind="Lean.Parser.Syntax.paren">
                <AtomNode start="(349, 46)" end="(349, 47)" leading="" trailing="" val="("/>
                <NullNode start="(349, 47)" end="(349, 84)">
                  <OtherNode start="(349, 47)" end="(349, 63)" kind="Lean.Parser.Syntax.unary">
                    <IdentNode start="(349, 47)" end="(349, 55)" leading="" trailing="" raw_val="ppDedent" val="ppDedent"/>
                    <AtomNode start="(349, 55)" end="(349, 56)" leading="" trailing="" val="("/>
                    <NullNode start="(349, 56)" end="(349, 62)">
                      <OtherNode start="(349, 56)" end="(349, 62)" kind="Lean.Parser.Syntax.cat">
                        <IdentNode start="(349, 56)" end="(349, 62)" leading="" trailing="" raw_val="ppLine" val="ppLine" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(349, 62)" end="(349, 63)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <OtherNode start="(349, 64)" end="(349, 69)" kind="Lean.Parser.Syntax.cat">
                    <IdentNode start="(349, 64)" end="(349, 69)" leading="" trailing=" " raw_val="colGe" val="colGe" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode/>
                  </OtherNode>
                  <OtherNode start="(349, 70)" end="(349, 74)" kind="Lean.Parser.Syntax.atom">
                    <OtherNode start="(349, 70)" end="(349, 74)" kind="str">
                      <AtomNode start="(349, 70)" end="(349, 74)" leading="" trailing=" " val="&amp;quot;| &amp;quot;"/>
                    </OtherNode>
                  </OtherNode>
                  <OtherNode start="(349, 75)" end="(349, 84)" kind="Lean.Parser.Syntax.cat">
                    <IdentNode start="(349, 75)" end="(349, 84)" leading="" trailing="" raw_val="tacticSeq" val="tacticSeq" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
                <AtomNode start="(349, 84)" end="(349, 85)" leading="" trailing="" val=")"/>
              </OtherNode>
              <AtomNode start="(349, 85)" end="(349, 86)" leading="" trailing="" val="+"/>
            </OtherNode>
          </NullNode>
          <AtomNode start="(349, 86)" end="(349, 87)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(349, 88)" end="(349, 89)" leading="" trailing=" " val=":"/>
      <IdentNode start="(349, 90)" end="(349, 96)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(351, 1)" end="(356, 66)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(351, 1)" end="(355, 3)">
        <CommandDoccommentNode start="(351, 1)" end="(355, 3)" comment="`rotate_left n` rotates goals to the left by `n`. That is, `rotate_left 1`&#10;takes the main goal and puts it to the back of the subgoal list.&#10;If `n` is omitted, it defaults to `1`.&#10;-/">
          <AtomNode start="(351, 1)" end="(351, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(352, 1)" end="(355, 3)" leading="" trailing="&#10;" val="`rotate_left n` rotates goals to the left by `n`. That is, `rotate_left 1`&#10;takes the main goal and puts it to the back of the subgoal list.&#10;If `n` is omitted, it defaults to `1`.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(356, 1)" end="(356, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(356, 8)" end="(356, 28)">
        <OtherNode start="(356, 8)" end="(356, 28)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(356, 8)" end="(356, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(356, 9)" end="(356, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(356, 14)" end="(356, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(356, 17)" end="(356, 27)" leading="" trailing="" raw_val="rotateLeft" val="rotateLeft"/>
          <AtomNode start="(356, 27)" end="(356, 28)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(356, 29)" end="(356, 57)">
        <OtherNode start="(356, 29)" end="(356, 42)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(356, 29)" end="(356, 42)" kind="str">
            <AtomNode start="(356, 29)" end="(356, 42)" leading="" trailing=" " val="&amp;quot;rotate_left&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(356, 43)" end="(356, 57)" kind="stx_?">
          <OtherNode start="(356, 43)" end="(356, 56)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(356, 43)" end="(356, 44)" leading="" trailing="" val="("/>
            <NullNode start="(356, 44)" end="(356, 55)">
              <OtherNode start="(356, 44)" end="(356, 51)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(356, 44)" end="(356, 51)" leading="" trailing=" " raw_val="ppSpace" val="ppSpace" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(356, 52)" end="(356, 55)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(356, 52)" end="(356, 55)" leading="" trailing="" raw_val="num" val="num" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(356, 55)" end="(356, 56)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(356, 56)" end="(356, 57)" leading="" trailing=" " val="?"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(356, 58)" end="(356, 59)" leading="" trailing=" " val=":"/>
      <IdentNode start="(356, 60)" end="(356, 66)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(358, 1)" end="(362, 68)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(358, 1)" end="(361, 3)">
        <CommandDoccommentNode start="(358, 1)" end="(361, 3)" comment="Rotate the goals to the right by `n`. That is, take the goal at the back&#10;and push it to the front `n` times. If `n` is omitted, it defaults to `1`.&#10;-/">
          <AtomNode start="(358, 1)" end="(358, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(359, 1)" end="(361, 3)" leading="" trailing="&#10;" val="Rotate the goals to the right by `n`. That is, take the goal at the back&#10;and push it to the front `n` times. If `n` is omitted, it defaults to `1`.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(362, 1)" end="(362, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(362, 8)" end="(362, 29)">
        <OtherNode start="(362, 8)" end="(362, 29)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(362, 8)" end="(362, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(362, 9)" end="(362, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(362, 14)" end="(362, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(362, 17)" end="(362, 28)" leading="" trailing="" raw_val="rotateRight" val="rotateRight"/>
          <AtomNode start="(362, 28)" end="(362, 29)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(362, 30)" end="(362, 59)">
        <OtherNode start="(362, 30)" end="(362, 44)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(362, 30)" end="(362, 44)" kind="str">
            <AtomNode start="(362, 30)" end="(362, 44)" leading="" trailing=" " val="&amp;quot;rotate_right&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(362, 45)" end="(362, 59)" kind="stx_?">
          <OtherNode start="(362, 45)" end="(362, 58)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(362, 45)" end="(362, 46)" leading="" trailing="" val="("/>
            <NullNode start="(362, 46)" end="(362, 57)">
              <OtherNode start="(362, 46)" end="(362, 53)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(362, 46)" end="(362, 53)" leading="" trailing=" " raw_val="ppSpace" val="ppSpace" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(362, 54)" end="(362, 57)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(362, 54)" end="(362, 57)" leading="" trailing="" raw_val="num" val="num" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(362, 57)" end="(362, 58)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(362, 58)" end="(362, 59)" leading="" trailing=" " val="?"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(362, 60)" end="(362, 61)" leading="" trailing=" " val=":"/>
      <IdentNode start="(362, 62)" end="(362, 68)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(364, 1)" end="(365, 66)" kind="Lean.Parser.Command.macro">
      <NullNode start="(364, 1)" end="(364, 63)">
        <CommandDoccommentNode start="(364, 1)" end="(364, 63)" comment="`try tac` runs `tac` and succeeds even if `tac` failed. -/">
          <AtomNode start="(364, 1)" end="(364, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(364, 5)" end="(364, 63)" leading="" trailing="&#10;" val="`try tac` runs `tac` and succeeds even if `tac` failed. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(365, 1)" end="(365, 6)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(365, 7)" end="(365, 25)">
        <OtherNode start="(365, 7)" end="(365, 13)" kind="Lean.Parser.Command.macroArg">
          <NullNode/>
          <OtherNode start="(365, 7)" end="(365, 13)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(365, 7)" end="(365, 13)" kind="str">
              <AtomNode start="(365, 7)" end="(365, 13)" leading="" trailing=" " val="&amp;quot;try &amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(365, 14)" end="(365, 25)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(365, 14)" end="(365, 16)">
            <IdentNode start="(365, 14)" end="(365, 15)" leading="" trailing="" raw_val="t" val="t"/>
            <AtomNode start="(365, 15)" end="(365, 16)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(365, 16)" end="(365, 25)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(365, 16)" end="(365, 25)" leading="" trailing=" " raw_val="tacticSeq" val="tacticSeq" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(365, 26)" end="(365, 66)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(365, 26)" end="(365, 27)" leading="" trailing=" " val=":"/>
        <IdentNode start="(365, 28)" end="(365, 34)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(365, 35)" end="(365, 37)" leading="" trailing=" " val="=&amp;gt;"/>
        <OtherNode start="(365, 38)" end="(365, 66)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(365, 38)" end="(365, 66)" kind="Lean.Parser.Tactic.quot">
            <AtomNode start="(365, 38)" end="(365, 47)" leading="" trailing=" " val="`(tactic|"/>
            <OtherNode start="(365, 48)" end="(365, 65)" kind="Lean.Parser.Tactic.first">
              <AtomNode start="(365, 48)" end="(365, 53)" leading="" trailing=" " val="first"/>
              <NullNode start="(365, 54)" end="(365, 65)">
                <GroupNode start="(365, 54)" end="(365, 58)">
                  <AtomNode start="(365, 54)" end="(365, 55)" leading="" trailing=" " val="|"/>
                  <OtherNode start="(365, 56)" end="(365, 58)" kind="Lean.Parser.Tactic.tacticSeq.antiquot">
                    <AtomNode start="(365, 56)" end="(365, 57)" leading="" trailing="" val="$"/>
                    <NullNode/>
                    <IdentNode start="(365, 57)" end="(365, 58)" leading="" trailing=" " raw_val="t" val="t"/>
                    <NullNode/>
                  </OtherNode>
                </GroupNode>
                <GroupNode start="(365, 59)" end="(365, 65)">
                  <AtomNode start="(365, 59)" end="(365, 60)" leading="" trailing=" " val="|"/>
                  <TacticTacticseqNode start="(365, 61)" end="(365, 65)">
                    <TacticTacticseq1IndentedNode start="(365, 61)" end="(365, 65)">
                      <NullNode start="(365, 61)" end="(365, 65)">
                        <OtherNode start="(365, 61)" end="(365, 65)" kind="Lean.Parser.Tactic.skip">
                          <AtomNode start="(365, 61)" end="(365, 65)" leading="" trailing="" val="skip"/>
                        </OtherNode>
                      </NullNode>
                    </TacticTacticseq1IndentedNode>
                  </TacticTacticseqNode>
                </GroupNode>
              </NullNode>
            </OtherNode>
            <AtomNode start="(365, 65)" end="(365, 66)" leading="" trailing="&#10;&#10;" val=")"/>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(367, 1)" end="(376, 25)" kind="Lean.Parser.Command.macro">
      <NullNode start="(367, 1)" end="(370, 3)">
        <CommandDoccommentNode start="(367, 1)" end="(370, 3)" comment="`tac &amp;lt;;&amp;gt; tac'` runs `tac` on the main goal and `tac'` on each produced goal,&#10;concatenating all goals produced by `tac'`.&#10;-/">
          <AtomNode start="(367, 1)" end="(367, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(368, 1)" end="(370, 3)" leading="" trailing="&#10;" val="`tac &amp;lt;;&amp;gt; tac'` runs `tac` on the main goal and `tac'` on each produced goal,&#10;concatenating all goals produced by `tac'`.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(371, 1)" end="(371, 6)" leading="" trailing="" val="macro"/>
      <NullNode start="(371, 6)" end="(371, 8)">
        <OtherNode start="(371, 6)" end="(371, 8)" kind="Lean.Parser.precedence">
          <AtomNode start="(371, 6)" end="(371, 7)" leading="" trailing="" val=":"/>
          <OtherNode start="(371, 7)" end="(371, 8)" kind="num">
            <AtomNode start="(371, 7)" end="(371, 8)" leading="" trailing=" " val="1"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode/>
      <NullNode start="(371, 9)" end="(371, 39)">
        <OtherNode start="(371, 9)" end="(371, 17)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(371, 9)" end="(371, 11)">
            <IdentNode start="(371, 9)" end="(371, 10)" leading="" trailing="" raw_val="x" val="x"/>
            <AtomNode start="(371, 10)" end="(371, 11)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(371, 11)" end="(371, 17)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(371, 11)" end="(371, 17)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(371, 18)" end="(371, 28)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(371, 18)" end="(371, 21)">
            <IdentNode start="(371, 18)" end="(371, 20)" leading="" trailing="" raw_val="tk" val="tk"/>
            <AtomNode start="(371, 20)" end="(371, 21)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(371, 21)" end="(371, 28)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(371, 21)" end="(371, 28)" kind="str">
              <AtomNode start="(371, 21)" end="(371, 28)" leading="" trailing=" " val="&amp;quot; &amp;lt;;&amp;gt; &amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(371, 29)" end="(371, 39)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(371, 29)" end="(371, 31)">
            <IdentNode start="(371, 29)" end="(371, 30)" leading="" trailing="" raw_val="y" val="y"/>
            <AtomNode start="(371, 30)" end="(371, 31)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(371, 31)" end="(371, 39)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(371, 31)" end="(371, 37)" leading="" trailing="" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
            <NullNode start="(371, 37)" end="(371, 39)">
              <OtherNode start="(371, 37)" end="(371, 39)" kind="Lean.Parser.precedence">
                <AtomNode start="(371, 37)" end="(371, 38)" leading="" trailing="" val=":"/>
                <OtherNode start="(371, 38)" end="(371, 39)" kind="num">
                  <AtomNode start="(371, 38)" end="(371, 39)" leading="" trailing=" " val="2"/>
                </OtherNode>
              </OtherNode>
            </NullNode>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(371, 40)" end="(376, 25)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(371, 40)" end="(371, 41)" leading="" trailing=" " val=":"/>
        <IdentNode start="(371, 42)" end="(371, 48)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(371, 49)" end="(371, 51)" leading="" trailing=" " val="=&amp;gt;"/>
        <OtherNode start="(371, 52)" end="(376, 25)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(371, 52)" end="(376, 25)" kind="Lean.Parser.Tactic.quot">
            <AtomNode start="(371, 52)" end="(371, 61)" leading="" trailing="&#10;  " val="`(tactic|"/>
            <OtherNode start="(372, 3)" end="(376, 24)" kind="Lean.Parser.Tactic.focus">
              <AtomNode start="(372, 3)" end="(372, 8)" leading="" trailing="&#10;    " val="focus"/>
              <TacticTacticseqNode start="(373, 5)" end="(376, 24)">
                <TacticTacticseq1IndentedNode start="(373, 5)" end="(376, 24)">
                  <NullNode start="(373, 5)" end="(376, 24)">
                    <OtherNode start="(373, 5)" end="(373, 14)" kind="tactic.pseudo.antiquot">
                      <AtomNode start="(373, 5)" end="(373, 6)" leading="" trailing="" val="$"/>
                      <NullNode/>
                      <IdentNode start="(373, 6)" end="(373, 7)" leading="" trailing="" raw_val="x" val="x"/>
                      <OtherNode start="(373, 7)" end="(373, 14)" kind="antiquotName">
                        <AtomNode start="(373, 7)" end="(373, 8)" leading="" trailing="" val=":"/>
                        <AtomNode start="(373, 8)" end="(373, 14)" leading="" trailing="&#10;    -- annotate token with state after executing `x`&#10;    " val="tactic"/>
                      </OtherNode>
                    </OtherNode>
                    <NullNode/>
                    <OtherNode start="(375, 5)" end="(375, 33)" kind="Lean.Parser.Tactic.withAnnotateState">
                      <AtomNode start="(375, 5)" end="(375, 24)" leading="" trailing=" " val="with_annotate_state"/>
                      <OtherNode start="(375, 25)" end="(375, 28)" kind="rawStx.pseudo.antiquot">
                        <AtomNode start="(375, 25)" end="(375, 26)" leading="" trailing="" val="$"/>
                        <NullNode/>
                        <IdentNode start="(375, 26)" end="(375, 28)" leading="" trailing=" " raw_val="tk" val="tk"/>
                        <NullNode/>
                      </OtherNode>
                      <OtherNode start="(375, 29)" end="(375, 33)" kind="Lean.Parser.Tactic.skip">
                        <AtomNode start="(375, 29)" end="(375, 33)" leading="" trailing="&#10;    " val="skip"/>
                      </OtherNode>
                    </OtherNode>
                    <NullNode/>
                    <OtherNode start="(376, 5)" end="(376, 24)" kind="Lean.Parser.Tactic.allGoals">
                      <AtomNode start="(376, 5)" end="(376, 14)" leading="" trailing=" " val="all_goals"/>
                      <TacticTacticseqNode start="(376, 15)" end="(376, 24)">
                        <TacticTacticseq1IndentedNode start="(376, 15)" end="(376, 24)">
                          <NullNode start="(376, 15)" end="(376, 24)">
                            <OtherNode start="(376, 15)" end="(376, 24)" kind="tactic.pseudo.antiquot">
                              <AtomNode start="(376, 15)" end="(376, 16)" leading="" trailing="" val="$"/>
                              <NullNode/>
                              <IdentNode start="(376, 16)" end="(376, 17)" leading="" trailing="" raw_val="y" val="y"/>
                              <OtherNode start="(376, 17)" end="(376, 24)" kind="antiquotName">
                                <AtomNode start="(376, 17)" end="(376, 18)" leading="" trailing="" val=":"/>
                                <AtomNode start="(376, 18)" end="(376, 24)" leading="" trailing="" val="tactic"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </OtherNode>
                  </NullNode>
                </TacticTacticseq1IndentedNode>
              </TacticTacticseqNode>
            </OtherNode>
            <AtomNode start="(376, 24)" end="(376, 25)" leading="" trailing="&#10;&#10;" val=")"/>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(378, 1)" end="(379, 53)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(378, 1)" end="(378, 96)">
        <CommandDoccommentNode start="(378, 1)" end="(378, 96)" comment="`fail msg` is a tactic that always fails, and produces an error using the given message. -/">
          <AtomNode start="(378, 1)" end="(378, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(378, 5)" end="(378, 96)" leading="" trailing="&#10;" val="`fail msg` is a tactic that always fails, and produces an error using the given message. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(379, 1)" end="(379, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(379, 8)" end="(379, 22)">
        <OtherNode start="(379, 8)" end="(379, 22)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(379, 8)" end="(379, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(379, 9)" end="(379, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(379, 14)" end="(379, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(379, 17)" end="(379, 21)" leading="" trailing="" raw_val="fail" val="fail"/>
          <AtomNode start="(379, 21)" end="(379, 22)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(379, 23)" end="(379, 44)">
        <OtherNode start="(379, 23)" end="(379, 29)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(379, 23)" end="(379, 29)" kind="str">
            <AtomNode start="(379, 23)" end="(379, 29)" leading="" trailing=" " val="&amp;quot;fail&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(379, 30)" end="(379, 44)" kind="stx_?">
          <OtherNode start="(379, 30)" end="(379, 43)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(379, 30)" end="(379, 31)" leading="" trailing="" val="("/>
            <NullNode start="(379, 31)" end="(379, 42)">
              <OtherNode start="(379, 31)" end="(379, 38)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(379, 31)" end="(379, 38)" leading="" trailing=" " raw_val="ppSpace" val="ppSpace" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(379, 39)" end="(379, 42)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(379, 39)" end="(379, 42)" leading="" trailing="" raw_val="str" val="str" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(379, 42)" end="(379, 43)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(379, 43)" end="(379, 44)" leading="" trailing=" " val="?"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(379, 45)" end="(379, 46)" leading="" trailing=" " val=":"/>
      <IdentNode start="(379, 47)" end="(379, 53)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(381, 1)" end="(382, 43)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(381, 1)" end="(381, 76)">
        <CommandDoccommentNode start="(381, 1)" end="(381, 76)" comment="`eq_refl` is equivalent to `exact rfl`, but has a few optimizations. -/">
          <AtomNode start="(381, 1)" end="(381, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(381, 5)" end="(381, 76)" leading="" trailing="&#10;" val="`eq_refl` is equivalent to `exact rfl`, but has a few optimizations. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(382, 1)" end="(382, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(382, 8)" end="(382, 24)">
        <OtherNode start="(382, 8)" end="(382, 24)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(382, 8)" end="(382, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(382, 9)" end="(382, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(382, 14)" end="(382, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(382, 17)" end="(382, 23)" leading="" trailing="" raw_val="eqRefl" val="eqRefl"/>
          <AtomNode start="(382, 23)" end="(382, 24)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(382, 25)" end="(382, 34)">
        <OtherNode start="(382, 25)" end="(382, 34)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(382, 25)" end="(382, 34)" kind="str">
            <AtomNode start="(382, 25)" end="(382, 34)" leading="" trailing=" " val="&amp;quot;eq_refl&amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(382, 35)" end="(382, 36)" leading="" trailing=" " val=":"/>
      <IdentNode start="(382, 37)" end="(382, 43)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(384, 1)" end="(389, 22)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(384, 1)" end="(388, 3)">
        <CommandDoccommentNode start="(384, 1)" end="(388, 3)" comment="This tactic applies to a goal whose target has the form `x ~ x`,&#10;where `~` is equality, heterogeneous equality or any relation that&#10;has a reflexivity lemma tagged with the attribute @[refl].&#10;-/">
          <AtomNode start="(384, 1)" end="(384, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(385, 1)" end="(388, 3)" leading="" trailing="&#10;" val="This tactic applies to a goal whose target has the form `x ~ x`,&#10;where `~` is equality, heterogeneous equality or any relation that&#10;has a reflexivity lemma tagged with the attribute @[refl].&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(389, 1)" end="(389, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(389, 8)" end="(389, 13)">
        <OtherNode start="(389, 8)" end="(389, 13)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(389, 8)" end="(389, 13)" kind="str">
            <AtomNode start="(389, 8)" end="(389, 13)" leading="" trailing=" " val="&amp;quot;rfl&amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(389, 14)" end="(389, 15)" leading="" trailing=" " val=":"/>
      <IdentNode start="(389, 16)" end="(389, 22)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(391, 1)" end="(394, 47)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(391, 1)" end="(393, 3)">
        <CommandDoccommentNode start="(391, 1)" end="(393, 3)" comment="The same as `rfl`, but without trying `eq_refl` at the end.&#10;-/">
          <AtomNode start="(391, 1)" end="(391, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(392, 1)" end="(393, 3)" leading="" trailing="&#10;" val="The same as `rfl`, but without trying `eq_refl` at the end.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(394, 1)" end="(394, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(394, 8)" end="(394, 26)">
        <OtherNode start="(394, 8)" end="(394, 26)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(394, 8)" end="(394, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(394, 9)" end="(394, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(394, 14)" end="(394, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(394, 17)" end="(394, 25)" leading="" trailing="" raw_val="applyRfl" val="applyRfl"/>
          <AtomNode start="(394, 25)" end="(394, 26)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(394, 27)" end="(394, 38)">
        <OtherNode start="(394, 27)" end="(394, 38)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(394, 27)" end="(394, 38)" kind="str">
            <AtomNode start="(394, 27)" end="(394, 38)" leading="" trailing=" " val="&amp;quot;apply_rfl&amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(394, 39)" end="(394, 40)" leading="" trailing=" " val=":"/>
      <IdentNode start="(394, 41)" end="(394, 47)" leading="" trailing="&#10;&#10;-- We try `apply_rfl` first, because it produces a nice error message&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(397, 1)" end="(397, 53)" kind="Lean.Parser.Command.macro_rules">
      <NullNode/>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(397, 1)" end="(397, 12)" leading="" trailing=" " val="macro_rules"/>
      <NullNode/>
      <OtherNode start="(397, 13)" end="(397, 53)" kind="Lean.Parser.Term.matchAlts">
        <NullNode start="(397, 13)" end="(397, 53)">
          <OtherNode start="(397, 13)" end="(397, 53)" kind="Lean.Parser.Term.matchAlt">
            <AtomNode start="(397, 13)" end="(397, 14)" leading="" trailing=" " val="|"/>
            <NullNode start="(397, 15)" end="(397, 29)">
              <NullNode start="(397, 15)" end="(397, 29)">
                <OtherNode start="(397, 15)" end="(397, 29)" kind="Lean.Parser.Tactic.quot">
                  <AtomNode start="(397, 15)" end="(397, 24)" leading="" trailing=" " val="`(tactic|"/>
                  <OtherNode start="(397, 25)" end="(397, 28)" kind="Lean.Parser.Tactic.tacticRfl">
                    <AtomNode start="(397, 25)" end="(397, 28)" leading="" trailing="" val="rfl"/>
                  </OtherNode>
                  <AtomNode start="(397, 28)" end="(397, 29)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </NullNode>
            </NullNode>
            <AtomNode start="(397, 30)" end="(397, 32)" leading="" trailing=" " val="=&amp;gt;"/>
            <OtherNode start="(397, 33)" end="(397, 53)" kind="Lean.Parser.Tactic.quot">
              <AtomNode start="(397, 33)" end="(397, 42)" leading="" trailing=" " val="`(tactic|"/>
              <OtherNode start="(397, 43)" end="(397, 52)" kind="Lean.Parser.Tactic.applyRfl">
                <AtomNode start="(397, 43)" end="(397, 52)" leading="" trailing="" val="apply_rfl"/>
              </OtherNode>
              <AtomNode start="(397, 52)" end="(397, 53)" leading="" trailing="&#10;&#10;-- But, mostly for backward compatibility, we try `eq_refl` too (reduces more aggressively)&#10;" val=")"/>
            </OtherNode>
          </OtherNode>
        </NullNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(400, 1)" end="(400, 51)" kind="Lean.Parser.Command.macro_rules">
      <NullNode/>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(400, 1)" end="(400, 12)" leading="" trailing=" " val="macro_rules"/>
      <NullNode/>
      <OtherNode start="(400, 13)" end="(400, 51)" kind="Lean.Parser.Term.matchAlts">
        <NullNode start="(400, 13)" end="(400, 51)">
          <OtherNode start="(400, 13)" end="(400, 51)" kind="Lean.Parser.Term.matchAlt">
            <AtomNode start="(400, 13)" end="(400, 14)" leading="" trailing=" " val="|"/>
            <NullNode start="(400, 15)" end="(400, 29)">
              <NullNode start="(400, 15)" end="(400, 29)">
                <OtherNode start="(400, 15)" end="(400, 29)" kind="Lean.Parser.Tactic.quot">
                  <AtomNode start="(400, 15)" end="(400, 24)" leading="" trailing=" " val="`(tactic|"/>
                  <OtherNode start="(400, 25)" end="(400, 28)" kind="Lean.Parser.Tactic.tacticRfl">
                    <AtomNode start="(400, 25)" end="(400, 28)" leading="" trailing="" val="rfl"/>
                  </OtherNode>
                  <AtomNode start="(400, 28)" end="(400, 29)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </NullNode>
            </NullNode>
            <AtomNode start="(400, 30)" end="(400, 32)" leading="" trailing=" " val="=&amp;gt;"/>
            <OtherNode start="(400, 33)" end="(400, 51)" kind="Lean.Parser.Tactic.quot">
              <AtomNode start="(400, 33)" end="(400, 42)" leading="" trailing=" " val="`(tactic|"/>
              <OtherNode start="(400, 43)" end="(400, 50)" kind="Lean.Parser.Tactic.eqRefl">
                <AtomNode start="(400, 43)" end="(400, 50)" leading="" trailing="" val="eq_refl"/>
              </OtherNode>
              <AtomNode start="(400, 50)" end="(400, 51)" leading="" trailing="&#10;-- Also for backward compatibility, because `exact` can trigger the implicit lambda feature (see #5366)&#10;" val=")"/>
            </OtherNode>
          </OtherNode>
        </NullNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(402, 1)" end="(402, 57)" kind="Lean.Parser.Command.macro_rules">
      <NullNode/>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(402, 1)" end="(402, 12)" leading="" trailing=" " val="macro_rules"/>
      <NullNode/>
      <OtherNode start="(402, 13)" end="(402, 57)" kind="Lean.Parser.Term.matchAlts">
        <NullNode start="(402, 13)" end="(402, 57)">
          <OtherNode start="(402, 13)" end="(402, 57)" kind="Lean.Parser.Term.matchAlt">
            <AtomNode start="(402, 13)" end="(402, 14)" leading="" trailing=" " val="|"/>
            <NullNode start="(402, 15)" end="(402, 29)">
              <NullNode start="(402, 15)" end="(402, 29)">
                <OtherNode start="(402, 15)" end="(402, 29)" kind="Lean.Parser.Tactic.quot">
                  <AtomNode start="(402, 15)" end="(402, 24)" leading="" trailing=" " val="`(tactic|"/>
                  <OtherNode start="(402, 25)" end="(402, 28)" kind="Lean.Parser.Tactic.tacticRfl">
                    <AtomNode start="(402, 25)" end="(402, 28)" leading="" trailing="" val="rfl"/>
                  </OtherNode>
                  <AtomNode start="(402, 28)" end="(402, 29)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </NullNode>
            </NullNode>
            <AtomNode start="(402, 30)" end="(402, 32)" leading="" trailing=" " val="=&amp;gt;"/>
            <OtherNode start="(402, 33)" end="(402, 57)" kind="Lean.Parser.Tactic.quot">
              <AtomNode start="(402, 33)" end="(402, 42)" leading="" trailing=" " val="`(tactic|"/>
              <OtherNode start="(402, 43)" end="(402, 56)" kind="Lean.Parser.Tactic.exact">
                <AtomNode start="(402, 43)" end="(402, 48)" leading="" trailing=" " val="exact"/>
                <IdentNode start="(402, 49)" end="(402, 56)" leading="" trailing="" raw_val="HEq.rfl" val="HEq.rfl"/>
              </OtherNode>
              <AtomNode start="(402, 56)" end="(402, 57)" leading="" trailing="&#10;" val=")"/>
            </OtherNode>
          </OtherNode>
        </NullNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(403, 1)" end="(407, 94)" kind="Lean.Parser.Command.macro">
      <NullNode start="(403, 1)" end="(406, 3)">
        <CommandDoccommentNode start="(403, 1)" end="(406, 3)" comment="`rfl'` is similar to `rfl`, but disables smart unfolding and unfolds all kinds of definitions,&#10;theorems included (relevant for declarations defined by well-founded recursion).&#10;-/">
          <AtomNode start="(403, 1)" end="(403, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(404, 1)" end="(406, 3)" leading="" trailing="&#10;" val="`rfl'` is similar to `rfl`, but disables smart unfolding and unfolds all kinds of definitions,&#10;theorems included (relevant for declarations defined by well-founded recursion).&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(407, 1)" end="(407, 6)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(407, 7)" end="(407, 13)">
        <OtherNode start="(407, 7)" end="(407, 13)" kind="Lean.Parser.Command.macroArg">
          <NullNode/>
          <OtherNode start="(407, 7)" end="(407, 13)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(407, 7)" end="(407, 13)" kind="str">
              <AtomNode start="(407, 7)" end="(407, 13)" leading="" trailing=" " val="&amp;quot;rfl'&amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(407, 14)" end="(407, 94)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(407, 14)" end="(407, 15)" leading="" trailing=" " val=":"/>
        <IdentNode start="(407, 16)" end="(407, 22)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(407, 23)" end="(407, 25)" leading="" trailing=" " val="=&amp;gt;"/>
        <OtherNode start="(407, 26)" end="(407, 94)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(407, 26)" end="(407, 94)" kind="Lean.Parser.Tactic.quot">
            <AtomNode start="(407, 26)" end="(407, 35)" leading="" trailing=" " val="`(tactic|"/>
            <OtherNode start="(407, 36)" end="(407, 93)" kind="Lean.Parser.Tactic.set_option">
              <AtomNode start="(407, 36)" end="(407, 46)" leading="" trailing=" " val="set_option"/>
              <IdentNode start="(407, 47)" end="(407, 61)" leading="" trailing=" " raw_val="smartUnfolding" val="smartUnfolding"/>
              <NullNode/>
              <AtomNode start="(407, 62)" end="(407, 67)" leading="" trailing=" " val="false"/>
              <AtomNode start="(407, 68)" end="(407, 70)" leading="" trailing=" " val="in"/>
              <TacticTacticseqNode start="(407, 71)" end="(407, 93)">
                <TacticTacticseq1IndentedNode start="(407, 71)" end="(407, 93)">
                  <NullNode start="(407, 71)" end="(407, 93)">
                    <OtherNode start="(407, 71)" end="(407, 93)" kind="Lean.Parser.Tactic.withUnfoldingAll">
                      <AtomNode start="(407, 71)" end="(407, 89)" leading="" trailing=" " val="with_unfolding_all"/>
                      <TacticTacticseqNode start="(407, 90)" end="(407, 93)">
                        <TacticTacticseq1IndentedNode start="(407, 90)" end="(407, 93)">
                          <NullNode start="(407, 90)" end="(407, 93)">
                            <OtherNode start="(407, 90)" end="(407, 93)" kind="Lean.Parser.Tactic.tacticRfl">
                              <AtomNode start="(407, 90)" end="(407, 93)" leading="" trailing="" val="rfl"/>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </OtherNode>
                  </NullNode>
                </TacticTacticseq1IndentedNode>
              </TacticTacticseqNode>
            </OtherNode>
            <AtomNode start="(407, 93)" end="(407, 94)" leading="" trailing="&#10;&#10;" val=")"/>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(409, 1)" end="(418, 41)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(409, 1)" end="(417, 3)">
        <CommandDoccommentNode start="(409, 1)" end="(417, 3)" comment="`ac_rfl` proves equalities up to application of an associative and commutative operator.&#10;```&#10;instance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩&#10;instance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩&#10;&#10;example (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by ac_rfl&#10;```&#10;-/">
          <AtomNode start="(409, 1)" end="(409, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(410, 1)" end="(417, 3)" leading="" trailing="&#10;" val="`ac_rfl` proves equalities up to application of an associative and commutative operator.&#10;```&#10;instance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩&#10;instance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩&#10;&#10;example (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by ac_rfl&#10;```&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(418, 1)" end="(418, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(418, 8)" end="(418, 23)">
        <OtherNode start="(418, 8)" end="(418, 23)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(418, 8)" end="(418, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(418, 9)" end="(418, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(418, 14)" end="(418, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(418, 17)" end="(418, 22)" leading="" trailing="" raw_val="acRfl" val="acRfl"/>
          <AtomNode start="(418, 22)" end="(418, 23)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(418, 24)" end="(418, 32)">
        <OtherNode start="(418, 24)" end="(418, 32)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(418, 24)" end="(418, 32)" kind="str">
            <AtomNode start="(418, 24)" end="(418, 32)" leading="" trailing=" " val="&amp;quot;ac_rfl&amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(418, 33)" end="(418, 34)" leading="" trailing=" " val=":"/>
      <IdentNode start="(418, 35)" end="(418, 41)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(420, 1)" end="(429, 49)" kind="Lean.Parser.Command.macro">
      <NullNode start="(420, 1)" end="(428, 3)">
        <CommandDoccommentNode start="(420, 1)" end="(428, 3)" comment="The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,&#10;closing the main goal using `exact sorry`.&#10;&#10;This is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.&#10;Lean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,&#10;but you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output&#10;of the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.&#10;-/">
          <AtomNode start="(420, 1)" end="(420, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(421, 1)" end="(428, 3)" leading="" trailing="&#10;" val="The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,&#10;closing the main goal using `exact sorry`.&#10;&#10;This is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.&#10;Lean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,&#10;but you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output&#10;of the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(429, 1)" end="(429, 6)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(429, 7)" end="(429, 14)">
        <OtherNode start="(429, 7)" end="(429, 14)" kind="Lean.Parser.Command.macroArg">
          <NullNode/>
          <OtherNode start="(429, 7)" end="(429, 14)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(429, 7)" end="(429, 14)" kind="str">
              <AtomNode start="(429, 7)" end="(429, 14)" leading="" trailing=" " val="&amp;quot;sorry&amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(429, 15)" end="(429, 49)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(429, 15)" end="(429, 16)" leading="" trailing=" " val=":"/>
        <IdentNode start="(429, 17)" end="(429, 23)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(429, 24)" end="(429, 26)" leading="" trailing=" " val="=&amp;gt;"/>
        <OtherNode start="(429, 27)" end="(429, 49)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(429, 27)" end="(429, 49)" kind="Lean.Parser.Tactic.quot">
            <AtomNode start="(429, 27)" end="(429, 36)" leading="" trailing=" " val="`(tactic|"/>
            <OtherNode start="(429, 37)" end="(429, 48)" kind="Lean.Parser.Tactic.exact">
              <AtomNode start="(429, 37)" end="(429, 42)" leading="" trailing=" " val="exact"/>
              <OtherNode start="(429, 43)" end="(429, 48)" kind="Lean.Parser.Term.sorry">
                <AtomNode start="(429, 43)" end="(429, 48)" leading="" trailing="" val="sorry"/>
              </OtherNode>
            </OtherNode>
            <AtomNode start="(429, 48)" end="(429, 49)" leading="" trailing="&#10;&#10;" val=")"/>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(431, 1)" end="(432, 43)" kind="Lean.Parser.Command.macro">
      <NullNode start="(431, 1)" end="(431, 41)">
        <CommandDoccommentNode start="(431, 1)" end="(431, 41)" comment="`admit` is a synonym for `sorry`. -/">
          <AtomNode start="(431, 1)" end="(431, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(431, 5)" end="(431, 41)" leading="" trailing="&#10;" val="`admit` is a synonym for `sorry`. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(432, 1)" end="(432, 6)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(432, 7)" end="(432, 14)">
        <OtherNode start="(432, 7)" end="(432, 14)" kind="Lean.Parser.Command.macroArg">
          <NullNode/>
          <OtherNode start="(432, 7)" end="(432, 14)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(432, 7)" end="(432, 14)" kind="str">
              <AtomNode start="(432, 7)" end="(432, 14)" leading="" trailing=" " val="&amp;quot;admit&amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(432, 15)" end="(432, 43)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(432, 15)" end="(432, 16)" leading="" trailing=" " val=":"/>
        <IdentNode start="(432, 17)" end="(432, 23)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(432, 24)" end="(432, 26)" leading="" trailing=" " val="=&amp;gt;"/>
        <OtherNode start="(432, 27)" end="(432, 43)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(432, 27)" end="(432, 43)" kind="Lean.Parser.Tactic.quot">
            <AtomNode start="(432, 27)" end="(432, 36)" leading="" trailing=" " val="`(tactic|"/>
            <OtherNode start="(432, 37)" end="(432, 42)" kind="Lean.Parser.Tactic.tacticSorry">
              <AtomNode start="(432, 37)" end="(432, 42)" leading="" trailing="" val="sorry"/>
            </OtherNode>
            <AtomNode start="(432, 42)" end="(432, 43)" leading="" trailing="&#10;&#10;" val=")"/>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(434, 1)" end="(438, 66)" kind="Lean.Parser.Command.macro">
      <NullNode start="(434, 1)" end="(437, 3)">
        <CommandDoccommentNode start="(434, 1)" end="(437, 3)" comment="`infer_instance` is an abbreviation for `exact inferInstance`.&#10;It synthesizes a value of any target type by typeclass inference.&#10;-/">
          <AtomNode start="(434, 1)" end="(434, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(435, 1)" end="(437, 3)" leading="" trailing="&#10;" val="`infer_instance` is an abbreviation for `exact inferInstance`.&#10;It synthesizes a value of any target type by typeclass inference.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(438, 1)" end="(438, 6)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(438, 7)" end="(438, 23)">
        <OtherNode start="(438, 7)" end="(438, 23)" kind="Lean.Parser.Command.macroArg">
          <NullNode/>
          <OtherNode start="(438, 7)" end="(438, 23)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(438, 7)" end="(438, 23)" kind="str">
              <AtomNode start="(438, 7)" end="(438, 23)" leading="" trailing=" " val="&amp;quot;infer_instance&amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(438, 24)" end="(438, 66)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(438, 24)" end="(438, 25)" leading="" trailing=" " val=":"/>
        <IdentNode start="(438, 26)" end="(438, 32)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(438, 33)" end="(438, 35)" leading="" trailing=" " val="=&amp;gt;"/>
        <OtherNode start="(438, 36)" end="(438, 66)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(438, 36)" end="(438, 66)" kind="Lean.Parser.Tactic.quot">
            <AtomNode start="(438, 36)" end="(438, 45)" leading="" trailing=" " val="`(tactic|"/>
            <OtherNode start="(438, 46)" end="(438, 65)" kind="Lean.Parser.Tactic.exact">
              <AtomNode start="(438, 46)" end="(438, 51)" leading="" trailing=" " val="exact"/>
              <IdentNode start="(438, 52)" end="(438, 65)" leading="" trailing="" raw_val="inferInstance" val="inferInstance"/>
            </OtherNode>
            <AtomNode start="(438, 65)" end="(438, 66)" leading="" trailing="&#10;&#10;" val=")"/>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(440, 1)" end="(443, 40)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(440, 1)" end="(442, 3)">
        <CommandDoccommentNode start="(440, 1)" end="(442, 3)" comment="`+opt` is short for `(opt := true)`. It sets the `opt` configuration option to `true`.&#10;-/">
          <AtomNode start="(440, 1)" end="(440, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(441, 1)" end="(442, 3)" leading="" trailing="&#10;" val="`+opt` is short for `(opt := true)`. It sets the `opt` configuration option to `true`.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(443, 1)" end="(443, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(443, 8)" end="(443, 21)" leading="" trailing=" " raw_val="posConfigItem" val="posConfigItem"/>
      <AtomNode start="(443, 22)" end="(443, 24)" leading="" trailing=" " val=":="/>
      <NullNode start="(443, 25)" end="(443, 40)">
        <OtherNode start="(443, 25)" end="(443, 29)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(443, 25)" end="(443, 29)" kind="str">
            <AtomNode start="(443, 25)" end="(443, 29)" leading="" trailing=" " val="&amp;quot; +&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(443, 30)" end="(443, 34)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(443, 30)" end="(443, 34)" leading="" trailing=" " raw_val="noWs" val="noWs" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
        <OtherNode start="(443, 35)" end="(443, 40)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(443, 35)" end="(443, 40)" leading="" trailing="&#10;" raw_val="ident" val="ident" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(444, 1)" end="(447, 40)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(444, 1)" end="(446, 3)">
        <CommandDoccommentNode start="(444, 1)" end="(446, 3)" comment="`-opt` is short for `(opt := false)`. It sets the `opt` configuration option to `false`.&#10;-/">
          <AtomNode start="(444, 1)" end="(444, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(445, 1)" end="(446, 3)" leading="" trailing="&#10;" val="`-opt` is short for `(opt := false)`. It sets the `opt` configuration option to `false`.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(447, 1)" end="(447, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(447, 8)" end="(447, 21)" leading="" trailing=" " raw_val="negConfigItem" val="negConfigItem"/>
      <AtomNode start="(447, 22)" end="(447, 24)" leading="" trailing=" " val=":="/>
      <NullNode start="(447, 25)" end="(447, 40)">
        <OtherNode start="(447, 25)" end="(447, 29)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(447, 25)" end="(447, 29)" kind="str">
            <AtomNode start="(447, 25)" end="(447, 29)" leading="" trailing=" " val="&amp;quot; -&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(447, 30)" end="(447, 34)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(447, 30)" end="(447, 34)" leading="" trailing=" " raw_val="noWs" val="noWs" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
        <OtherNode start="(447, 35)" end="(447, 40)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(447, 35)" end="(447, 40)" leading="" trailing="&#10;" raw_val="ident" val="ident" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(448, 1)" end="(453, 134)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(448, 1)" end="(452, 3)">
        <CommandDoccommentNode start="(448, 1)" end="(452, 3)" comment="`(opt := val)` sets the `opt` configuration option to `val`.&#10;&#10;As a special case, `(config := ...)` sets the entire configuration.&#10;-/">
          <AtomNode start="(448, 1)" end="(448, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(449, 1)" end="(452, 3)" leading="" trailing="&#10;" val="`(opt := val)` sets the `opt` configuration option to `val`.&#10;&#10;As a special case, `(config := ...)` sets the entire configuration.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(453, 1)" end="(453, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(453, 8)" end="(453, 21)" leading="" trailing=" " raw_val="valConfigItem" val="valConfigItem"/>
      <AtomNode start="(453, 22)" end="(453, 24)" leading="" trailing=" " val=":="/>
      <NullNode start="(453, 25)" end="(453, 134)">
        <OtherNode start="(453, 25)" end="(453, 101)" kind="Lean.Parser.Syntax.unary">
          <IdentNode start="(453, 25)" end="(453, 31)" leading="" trailing="" raw_val="atomic" val="atomic"/>
          <AtomNode start="(453, 31)" end="(453, 32)" leading="" trailing="" val="("/>
          <NullNode start="(453, 32)" end="(453, 100)">
            <OtherNode start="(453, 32)" end="(453, 36)" kind="Lean.Parser.Syntax.atom">
              <OtherNode start="(453, 32)" end="(453, 36)" kind="str">
                <AtomNode start="(453, 32)" end="(453, 36)" leading="" trailing=" " val="&amp;quot; (&amp;quot;"/>
              </OtherNode>
            </OtherNode>
            <OtherNode start="(453, 37)" end="(453, 78)" kind="Lean.Parser.Syntax.unary">
              <IdentNode start="(453, 37)" end="(453, 50)" leading="" trailing="" raw_val="notFollowedBy" val="notFollowedBy"/>
              <AtomNode start="(453, 50)" end="(453, 51)" leading="" trailing="" val="("/>
              <NullNode start="(453, 51)" end="(453, 77)">
                <OtherNode start="(453, 51)" end="(453, 77)" kind="«stx_&amp;lt;|&amp;gt;_»">
                  <OtherNode start="(453, 51)" end="(453, 64)" kind="Lean.Parser.Syntax.nonReserved">
                    <AtomNode start="(453, 51)" end="(453, 52)" leading="" trailing="" val="&amp;amp;"/>
                    <OtherNode start="(453, 52)" end="(453, 64)" kind="str">
                      <AtomNode start="(453, 52)" end="(453, 64)" leading="" trailing=" " val="&amp;quot;discharger&amp;quot;"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(453, 65)" end="(453, 68)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
                  <OtherNode start="(453, 69)" end="(453, 77)" kind="Lean.Parser.Syntax.nonReserved">
                    <AtomNode start="(453, 69)" end="(453, 70)" leading="" trailing="" val="&amp;amp;"/>
                    <OtherNode start="(453, 70)" end="(453, 77)" kind="str">
                      <AtomNode start="(453, 70)" end="(453, 77)" leading="" trailing="" val="&amp;quot;disch&amp;quot;"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(453, 77)" end="(453, 78)" leading="" trailing=" " val=")"/>
            </OtherNode>
            <OtherNode start="(453, 79)" end="(453, 100)" kind="Lean.Parser.Syntax.paren">
              <AtomNode start="(453, 79)" end="(453, 80)" leading="" trailing="" val="("/>
              <NullNode start="(453, 80)" end="(453, 99)">
                <OtherNode start="(453, 80)" end="(453, 99)" kind="«stx_&amp;lt;|&amp;gt;_»">
                  <OtherNode start="(453, 80)" end="(453, 85)" kind="Lean.Parser.Syntax.cat">
                    <IdentNode start="(453, 80)" end="(453, 85)" leading="" trailing=" " raw_val="ident" val="ident" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(453, 86)" end="(453, 89)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
                  <OtherNode start="(453, 90)" end="(453, 99)" kind="Lean.Parser.Syntax.nonReserved">
                    <AtomNode start="(453, 90)" end="(453, 91)" leading="" trailing="" val="&amp;amp;"/>
                    <OtherNode start="(453, 91)" end="(453, 99)" kind="str">
                      <AtomNode start="(453, 91)" end="(453, 99)" leading="" trailing="" val="&amp;quot;config&amp;quot;"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(453, 99)" end="(453, 100)" leading="" trailing="" val=")"/>
            </OtherNode>
          </NullNode>
          <AtomNode start="(453, 100)" end="(453, 101)" leading="" trailing=" " val=")"/>
        </OtherNode>
        <OtherNode start="(453, 102)" end="(453, 108)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(453, 102)" end="(453, 108)" kind="str">
            <AtomNode start="(453, 102)" end="(453, 108)" leading="" trailing=" " val="&amp;quot; := &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(453, 109)" end="(453, 130)" kind="Lean.Parser.Syntax.unary">
          <IdentNode start="(453, 109)" end="(453, 124)" leading="" trailing="" raw_val="withoutPosition" val="withoutPosition"/>
          <AtomNode start="(453, 124)" end="(453, 125)" leading="" trailing="" val="("/>
          <NullNode start="(453, 125)" end="(453, 129)">
            <OtherNode start="(453, 125)" end="(453, 129)" kind="Lean.Parser.Syntax.cat">
              <IdentNode start="(453, 125)" end="(453, 129)" leading="" trailing="" raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              <NullNode/>
            </OtherNode>
          </NullNode>
          <AtomNode start="(453, 129)" end="(453, 130)" leading="" trailing=" " val=")"/>
        </OtherNode>
        <OtherNode start="(453, 131)" end="(453, 134)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(453, 131)" end="(453, 134)" kind="str">
            <AtomNode start="(453, 131)" end="(453, 134)" leading="" trailing="&#10;" val="&amp;quot;)&amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(454, 1)" end="(455, 71)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(454, 1)" end="(454, 56)">
        <CommandDoccommentNode start="(454, 1)" end="(454, 56)" comment="A configuration item for a tactic configuration. -/">
          <AtomNode start="(454, 1)" end="(454, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(454, 5)" end="(454, 56)" leading="" trailing="&#10;" val="A configuration item for a tactic configuration. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(455, 1)" end="(455, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(455, 8)" end="(455, 18)" leading="" trailing=" " raw_val="configItem" val="configItem"/>
      <AtomNode start="(455, 19)" end="(455, 21)" leading="" trailing=" " val=":="/>
      <NullNode start="(455, 22)" end="(455, 71)">
        <OtherNode start="(455, 22)" end="(455, 71)" kind="«stx_&amp;lt;|&amp;gt;_»">
          <OtherNode start="(455, 22)" end="(455, 35)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(455, 22)" end="(455, 35)" leading="" trailing=" " raw_val="posConfigItem" val="posConfigItem" full_name="Lean.Parser.Tactic.posConfigItem" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(443, 8)" def_end="(443, 21)"/>
            <NullNode/>
          </OtherNode>
          <AtomNode start="(455, 36)" end="(455, 39)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
          <OtherNode start="(455, 40)" end="(455, 71)" kind="«stx_&amp;lt;|&amp;gt;_»">
            <OtherNode start="(455, 40)" end="(455, 53)" kind="Lean.Parser.Syntax.cat">
              <IdentNode start="(455, 40)" end="(455, 53)" leading="" trailing=" " raw_val="negConfigItem" val="negConfigItem" full_name="Lean.Parser.Tactic.negConfigItem" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(447, 8)" def_end="(447, 21)"/>
              <NullNode/>
            </OtherNode>
            <AtomNode start="(455, 54)" end="(455, 57)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
            <OtherNode start="(455, 58)" end="(455, 71)" kind="Lean.Parser.Syntax.cat">
              <IdentNode start="(455, 58)" end="(455, 71)" leading="" trailing="&#10;&#10;" raw_val="valConfigItem" val="valConfigItem" full_name="Lean.Parser.Tactic.valConfigItem" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(453, 8)" def_end="(453, 21)"/>
              <NullNode/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(457, 1)" end="(458, 40)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(457, 1)" end="(457, 42)">
        <CommandDoccommentNode start="(457, 1)" end="(457, 42)" comment="Configuration options for tactics. -/">
          <AtomNode start="(457, 1)" end="(457, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(457, 5)" end="(457, 42)" leading="" trailing="&#10;" val="Configuration options for tactics. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(458, 1)" end="(458, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(458, 8)" end="(458, 17)" leading="" trailing=" " raw_val="optConfig" val="optConfig"/>
      <AtomNode start="(458, 18)" end="(458, 20)" leading="" trailing=" " val=":="/>
      <NullNode start="(458, 21)" end="(458, 40)">
        <OtherNode start="(458, 21)" end="(458, 40)" kind="«stx_*»">
          <OtherNode start="(458, 21)" end="(458, 39)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(458, 21)" end="(458, 22)" leading="" trailing="" val="("/>
            <NullNode start="(458, 22)" end="(458, 38)">
              <OtherNode start="(458, 22)" end="(458, 27)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(458, 22)" end="(458, 27)" leading="" trailing=" " raw_val="colGt" val="colGt" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(458, 28)" end="(458, 38)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(458, 28)" end="(458, 38)" leading="" trailing="" raw_val="configItem" val="configItem" full_name="Lean.Parser.Tactic.configItem" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(455, 8)" def_end="(455, 18)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(458, 38)" end="(458, 39)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(458, 39)" end="(458, 40)" leading="" trailing="&#10;&#10;" val="*"/>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(460, 1)" end="(461, 73)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(460, 1)" end="(460, 102)">
        <CommandDoccommentNode start="(460, 1)" end="(460, 102)" comment="Optional configuration option for tactics. (Deprecated. Replace `(config)?` with `optConfig`.) -/">
          <AtomNode start="(460, 1)" end="(460, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(460, 5)" end="(460, 102)" leading="" trailing="&#10;" val="Optional configuration option for tactics. (Deprecated. Replace `(config)?` with `optConfig`.) -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(461, 1)" end="(461, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(461, 8)" end="(461, 14)" leading="" trailing=" " raw_val="config" val="config"/>
      <AtomNode start="(461, 15)" end="(461, 17)" leading="" trailing=" " val=":="/>
      <NullNode start="(461, 18)" end="(461, 73)">
        <OtherNode start="(461, 18)" end="(461, 40)" kind="Lean.Parser.Syntax.unary">
          <IdentNode start="(461, 18)" end="(461, 24)" leading="" trailing="" raw_val="atomic" val="atomic"/>
          <AtomNode start="(461, 24)" end="(461, 25)" leading="" trailing="" val="("/>
          <NullNode start="(461, 25)" end="(461, 39)">
            <OtherNode start="(461, 25)" end="(461, 29)" kind="Lean.Parser.Syntax.atom">
              <OtherNode start="(461, 25)" end="(461, 29)" kind="str">
                <AtomNode start="(461, 25)" end="(461, 29)" leading="" trailing=" " val="&amp;quot; (&amp;quot;"/>
              </OtherNode>
            </OtherNode>
            <OtherNode start="(461, 30)" end="(461, 39)" kind="Lean.Parser.Syntax.nonReserved">
              <AtomNode start="(461, 30)" end="(461, 31)" leading="" trailing="" val="&amp;amp;"/>
              <OtherNode start="(461, 31)" end="(461, 39)" kind="str">
                <AtomNode start="(461, 31)" end="(461, 39)" leading="" trailing="" val="&amp;quot;config&amp;quot;"/>
              </OtherNode>
            </OtherNode>
          </NullNode>
          <AtomNode start="(461, 39)" end="(461, 40)" leading="" trailing=" " val=")"/>
        </OtherNode>
        <OtherNode start="(461, 41)" end="(461, 47)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(461, 41)" end="(461, 47)" kind="str">
            <AtomNode start="(461, 41)" end="(461, 47)" leading="" trailing=" " val="&amp;quot; := &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(461, 48)" end="(461, 69)" kind="Lean.Parser.Syntax.unary">
          <IdentNode start="(461, 48)" end="(461, 63)" leading="" trailing="" raw_val="withoutPosition" val="withoutPosition"/>
          <AtomNode start="(461, 63)" end="(461, 64)" leading="" trailing="" val="("/>
          <NullNode start="(461, 64)" end="(461, 68)">
            <OtherNode start="(461, 64)" end="(461, 68)" kind="Lean.Parser.Syntax.cat">
              <IdentNode start="(461, 64)" end="(461, 68)" leading="" trailing="" raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              <NullNode/>
            </OtherNode>
          </NullNode>
          <AtomNode start="(461, 68)" end="(461, 69)" leading="" trailing=" " val=")"/>
        </OtherNode>
        <OtherNode start="(461, 70)" end="(461, 73)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(461, 70)" end="(461, 73)" kind="str">
            <AtomNode start="(461, 70)" end="(461, 73)" leading="" trailing="&#10;&#10;" val="&amp;quot;)&amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(463, 1)" end="(464, 32)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(463, 1)" end="(463, 63)">
        <CommandDoccommentNode start="(463, 1)" end="(463, 63)" comment="The `*` location refers to all hypotheses and the goal. -/">
          <AtomNode start="(463, 1)" end="(463, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(463, 5)" end="(463, 63)" leading="" trailing="&#10;" val="The `*` location refers to all hypotheses and the goal. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(464, 1)" end="(464, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(464, 8)" end="(464, 24)" leading="" trailing=" " raw_val="locationWildcard" val="locationWildcard"/>
      <AtomNode start="(464, 25)" end="(464, 27)" leading="" trailing=" " val=":="/>
      <NullNode start="(464, 28)" end="(464, 32)">
        <OtherNode start="(464, 28)" end="(464, 32)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(464, 28)" end="(464, 32)" kind="str">
            <AtomNode start="(464, 28)" end="(464, 32)" leading="" trailing="&#10;&#10;" val="&amp;quot; *&amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(466, 1)" end="(467, 67)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(466, 1)" end="(466, 52)">
        <CommandDoccommentNode start="(466, 1)" end="(466, 52)" comment="The `⊢` location refers to the current goal. -/">
          <AtomNode start="(466, 1)" end="(466, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(466, 5)" end="(466, 52)" leading="" trailing="&#10;" val="The `⊢` location refers to the current goal. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(467, 1)" end="(467, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(467, 8)" end="(467, 20)" leading="" trailing=" " raw_val="locationType" val="locationType"/>
      <AtomNode start="(467, 21)" end="(467, 23)" leading="" trailing=" " val=":="/>
      <NullNode start="(467, 24)" end="(467, 67)">
        <OtherNode start="(467, 24)" end="(467, 67)" kind="Lean.Parser.Syntax.unary">
          <IdentNode start="(467, 24)" end="(467, 37)" leading="" trailing="" raw_val="patternIgnore" val="patternIgnore"/>
          <AtomNode start="(467, 37)" end="(467, 38)" leading="" trailing="" val="("/>
          <NullNode start="(467, 38)" end="(467, 66)">
            <OtherNode start="(467, 38)" end="(467, 66)" kind="«stx_&amp;lt;|&amp;gt;_»">
              <OtherNode start="(467, 38)" end="(467, 58)" kind="Lean.Parser.Syntax.unary">
                <IdentNode start="(467, 38)" end="(467, 44)" leading="" trailing="" raw_val="atomic" val="atomic"/>
                <AtomNode start="(467, 44)" end="(467, 45)" leading="" trailing="" val="("/>
                <NullNode start="(467, 45)" end="(467, 57)">
                  <OtherNode start="(467, 45)" end="(467, 48)" kind="Lean.Parser.Syntax.atom">
                    <OtherNode start="(467, 45)" end="(467, 48)" kind="str">
                      <AtomNode start="(467, 45)" end="(467, 48)" leading="" trailing=" " val="&amp;quot;|&amp;quot;"/>
                    </OtherNode>
                  </OtherNode>
                  <OtherNode start="(467, 49)" end="(467, 53)" kind="Lean.Parser.Syntax.cat">
                    <IdentNode start="(467, 49)" end="(467, 53)" leading="" trailing=" " raw_val="noWs" val="noWs" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode/>
                  </OtherNode>
                  <OtherNode start="(467, 54)" end="(467, 57)" kind="Lean.Parser.Syntax.atom">
                    <OtherNode start="(467, 54)" end="(467, 57)" kind="str">
                      <AtomNode start="(467, 54)" end="(467, 57)" leading="" trailing="" val="&amp;quot;-&amp;quot;"/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
                <AtomNode start="(467, 57)" end="(467, 58)" leading="" trailing=" " val=")"/>
              </OtherNode>
              <AtomNode start="(467, 59)" end="(467, 62)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
              <OtherNode start="(467, 63)" end="(467, 66)" kind="Lean.Parser.Syntax.atom">
                <OtherNode start="(467, 63)" end="(467, 66)" kind="str">
                  <AtomNode start="(467, 63)" end="(467, 66)" leading="" trailing="" val="&amp;quot;⊢&amp;quot;"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
          </NullNode>
          <AtomNode start="(467, 66)" end="(467, 67)" leading="" trailing="&#10;&#10;" val=")"/>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(469, 1)" end="(473, 67)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(469, 1)" end="(472, 3)">
        <CommandDoccommentNode start="(469, 1)" end="(472, 3)" comment="A sequence of one or more locations at which a tactic should operate. These can include local&#10;hypotheses and `⊢`, which denotes the goal.&#10;-/">
          <AtomNode start="(469, 1)" end="(469, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(470, 1)" end="(472, 3)" leading="" trailing="&#10;" val="A sequence of one or more locations at which a tactic should operate. These can include local&#10;hypotheses and `⊢`, which denotes the goal.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(473, 1)" end="(473, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(473, 8)" end="(473, 19)" leading="" trailing=" " raw_val="locationHyp" val="locationHyp"/>
      <AtomNode start="(473, 20)" end="(473, 22)" leading="" trailing=" " val=":="/>
      <NullNode start="(473, 23)" end="(473, 67)">
        <OtherNode start="(473, 23)" end="(473, 67)" kind="«stx_+»">
          <OtherNode start="(473, 23)" end="(473, 66)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(473, 23)" end="(473, 24)" leading="" trailing="" val="("/>
            <NullNode start="(473, 24)" end="(473, 65)">
              <OtherNode start="(473, 24)" end="(473, 31)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(473, 24)" end="(473, 31)" leading="" trailing=" " raw_val="ppSpace" val="ppSpace" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(473, 32)" end="(473, 37)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(473, 32)" end="(473, 37)" leading="" trailing=" " raw_val="colGt" val="colGt" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(473, 38)" end="(473, 65)" kind="Lean.Parser.Syntax.paren">
                <AtomNode start="(473, 38)" end="(473, 39)" leading="" trailing="" val="("/>
                <NullNode start="(473, 39)" end="(473, 64)">
                  <OtherNode start="(473, 39)" end="(473, 64)" kind="«stx_&amp;lt;|&amp;gt;_»">
                    <OtherNode start="(473, 39)" end="(473, 47)" kind="Lean.Parser.Syntax.cat">
                      <IdentNode start="(473, 39)" end="(473, 43)" leading="" trailing="" raw_val="term" val="term" full_name="Lean.Parser.Category.term" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
                      <NullNode start="(473, 43)" end="(473, 47)">
                        <OtherNode start="(473, 43)" end="(473, 47)" kind="Lean.Parser.precedence">
                          <AtomNode start="(473, 43)" end="(473, 44)" leading="" trailing="" val=":"/>
                          <OtherNode start="(473, 44)" end="(473, 47)" kind="precMax">
                            <AtomNode start="(473, 44)" end="(473, 47)" leading="" trailing=" " val="max"/>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(473, 48)" end="(473, 51)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
                    <OtherNode start="(473, 52)" end="(473, 64)" kind="Lean.Parser.Syntax.cat">
                      <IdentNode start="(473, 52)" end="(473, 64)" leading="" trailing="" raw_val="locationType" val="locationType" full_name="Lean.Parser.Tactic.locationType" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(467, 8)" def_end="(467, 20)"/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
                <AtomNode start="(473, 64)" end="(473, 65)" leading="" trailing="" val=")"/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(473, 65)" end="(473, 66)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(473, 66)" end="(473, 67)" leading="" trailing="&#10;&#10;" val="+"/>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(475, 1)" end="(484, 83)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(475, 1)" end="(483, 3)">
        <CommandDoccommentNode start="(475, 1)" end="(483, 3)" comment="Location specifications are used by many tactics that can operate on either the&#10;hypotheses or the goal. It can have one of the forms:&#10;* 'empty' is not actually present in this syntax, but most tactics use&#10;  `(location)?` matchers. It means to target the goal only.&#10;* `at h₁ ... hₙ`: target the hypotheses `h₁`, ..., `hₙ`&#10;* `at h₁ h₂ ⊢`: target the hypotheses `h₁` and `h₂`, and the goal&#10;* `at *`: target all hypotheses and the goal&#10;-/">
          <AtomNode start="(475, 1)" end="(475, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(476, 1)" end="(483, 3)" leading="" trailing="&#10;" val="Location specifications are used by many tactics that can operate on either the&#10;hypotheses or the goal. It can have one of the forms:&#10;* 'empty' is not actually present in this syntax, but most tactics use&#10;  `(location)?` matchers. It means to target the goal only.&#10;* `at h₁ ... hₙ`: target the hypotheses `h₁`, ..., `hₙ`&#10;* `at h₁ h₂ ⊢`: target the hypotheses `h₁` and `h₂`, and the goal&#10;* `at *`: target all hypotheses and the goal&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(484, 1)" end="(484, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(484, 8)" end="(484, 16)" leading="" trailing=" " raw_val="location" val="location"/>
      <AtomNode start="(484, 17)" end="(484, 19)" leading="" trailing=" " val=":="/>
      <NullNode start="(484, 20)" end="(484, 83)">
        <OtherNode start="(484, 20)" end="(484, 83)" kind="Lean.Parser.Syntax.unary">
          <IdentNode start="(484, 20)" end="(484, 32)" leading="" trailing="" raw_val="withPosition" val="withPosition"/>
          <AtomNode start="(484, 32)" end="(484, 33)" leading="" trailing="" val="("/>
          <NullNode start="(484, 33)" end="(484, 82)">
            <OtherNode start="(484, 33)" end="(484, 82)" kind="Lean.Parser.Syntax.unary">
              <IdentNode start="(484, 33)" end="(484, 40)" leading="" trailing="" raw_val="ppGroup" val="ppGroup"/>
              <AtomNode start="(484, 40)" end="(484, 41)" leading="" trailing="" val="("/>
              <NullNode start="(484, 41)" end="(484, 81)">
                <OtherNode start="(484, 41)" end="(484, 46)" kind="Lean.Parser.Syntax.atom">
                  <OtherNode start="(484, 41)" end="(484, 46)" kind="str">
                    <AtomNode start="(484, 41)" end="(484, 46)" leading="" trailing=" " val="&amp;quot; at&amp;quot;"/>
                  </OtherNode>
                </OtherNode>
                <OtherNode start="(484, 47)" end="(484, 81)" kind="Lean.Parser.Syntax.paren">
                  <AtomNode start="(484, 47)" end="(484, 48)" leading="" trailing="" val="("/>
                  <NullNode start="(484, 48)" end="(484, 80)">
                    <OtherNode start="(484, 48)" end="(484, 80)" kind="«stx_&amp;lt;|&amp;gt;_»">
                      <OtherNode start="(484, 48)" end="(484, 64)" kind="Lean.Parser.Syntax.cat">
                        <IdentNode start="(484, 48)" end="(484, 64)" leading="" trailing=" " raw_val="locationWildcard" val="locationWildcard" full_name="Lean.Parser.Tactic.locationWildcard" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(464, 8)" def_end="(464, 24)"/>
                        <NullNode/>
                      </OtherNode>
                      <AtomNode start="(484, 65)" end="(484, 68)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
                      <OtherNode start="(484, 69)" end="(484, 80)" kind="Lean.Parser.Syntax.cat">
                        <IdentNode start="(484, 69)" end="(484, 80)" leading="" trailing="" raw_val="locationHyp" val="locationHyp" full_name="Lean.Parser.Tactic.locationHyp" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(473, 8)" def_end="(473, 19)"/>
                        <NullNode/>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(484, 80)" end="(484, 81)" leading="" trailing="" val=")"/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(484, 81)" end="(484, 82)" leading="" trailing="" val=")"/>
            </OtherNode>
          </NullNode>
          <AtomNode start="(484, 82)" end="(484, 83)" leading="" trailing="&#10;&#10;" val=")"/>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(486, 1)" end="(492, 60)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(486, 1)" end="(491, 3)">
        <CommandDoccommentNode start="(486, 1)" end="(491, 3)" comment="* `change tgt'` will change the goal from `tgt` to `tgt'`,&#10;  assuming these are definitionally equal.&#10;* `change t' at h` will change hypothesis `h : t` to have type `t'`, assuming&#10;  assuming `t` and `t'` are definitionally equal.&#10;-/">
          <AtomNode start="(486, 1)" end="(486, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(487, 1)" end="(491, 3)" leading="" trailing="&#10;" val="* `change tgt'` will change the goal from `tgt` to `tgt'`,&#10;  assuming these are definitionally equal.&#10;* `change t' at h` will change hypothesis `h : t` to have type `t'`, assuming&#10;  assuming `t` and `t'` are definitionally equal.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(492, 1)" end="(492, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(492, 8)" end="(492, 24)">
        <OtherNode start="(492, 8)" end="(492, 24)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(492, 8)" end="(492, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(492, 9)" end="(492, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(492, 14)" end="(492, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(492, 17)" end="(492, 23)" leading="" trailing="" raw_val="change" val="change"/>
          <AtomNode start="(492, 23)" end="(492, 24)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(492, 25)" end="(492, 51)">
        <OtherNode start="(492, 25)" end="(492, 34)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(492, 25)" end="(492, 34)" kind="str">
            <AtomNode start="(492, 25)" end="(492, 34)" leading="" trailing=" " val="&amp;quot;change &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(492, 35)" end="(492, 39)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(492, 35)" end="(492, 39)" leading="" trailing=" " raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
        <OtherNode start="(492, 40)" end="(492, 51)" kind="stx_?">
          <OtherNode start="(492, 40)" end="(492, 50)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(492, 40)" end="(492, 41)" leading="" trailing="" val="("/>
            <NullNode start="(492, 41)" end="(492, 49)">
              <OtherNode start="(492, 41)" end="(492, 49)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(492, 41)" end="(492, 49)" leading="" trailing="" raw_val="location" val="location" full_name="Lean.Parser.Tactic.location" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(484, 8)" def_end="(484, 16)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(492, 49)" end="(492, 50)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(492, 50)" end="(492, 51)" leading="" trailing=" " val="?"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(492, 52)" end="(492, 53)" leading="" trailing=" " val=":"/>
      <IdentNode start="(492, 54)" end="(492, 60)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(494, 1)" end="(499, 78)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(494, 1)" end="(498, 3)">
        <CommandDoccommentNode start="(494, 1)" end="(498, 3)" comment="* `change a with b` will change occurrences of `a` to `b` in the goal,&#10;  assuming `a` and `b` are definitionally equal.&#10;* `change a with b at h` similarly changes `a` to `b` in the type of hypothesis `h`.&#10;-/">
          <AtomNode start="(494, 1)" end="(494, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(495, 1)" end="(498, 3)" leading="" trailing="&#10;" val="* `change a with b` will change occurrences of `a` to `b` in the goal,&#10;  assuming `a` and `b` are definitionally equal.&#10;* `change a with b at h` similarly changes `a` to `b` in the type of hypothesis `h`.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(499, 1)" end="(499, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(499, 8)" end="(499, 28)">
        <OtherNode start="(499, 8)" end="(499, 28)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(499, 8)" end="(499, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(499, 9)" end="(499, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(499, 14)" end="(499, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(499, 17)" end="(499, 27)" leading="" trailing="" raw_val="changeWith" val="changeWith"/>
          <AtomNode start="(499, 27)" end="(499, 28)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(499, 29)" end="(499, 69)">
        <OtherNode start="(499, 29)" end="(499, 38)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(499, 29)" end="(499, 38)" kind="str">
            <AtomNode start="(499, 29)" end="(499, 38)" leading="" trailing=" " val="&amp;quot;change &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(499, 39)" end="(499, 43)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(499, 39)" end="(499, 43)" leading="" trailing=" " raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
        <OtherNode start="(499, 44)" end="(499, 52)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(499, 44)" end="(499, 52)" kind="str">
            <AtomNode start="(499, 44)" end="(499, 52)" leading="" trailing=" " val="&amp;quot; with &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(499, 53)" end="(499, 57)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(499, 53)" end="(499, 57)" leading="" trailing=" " raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
        <OtherNode start="(499, 58)" end="(499, 69)" kind="stx_?">
          <OtherNode start="(499, 58)" end="(499, 68)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(499, 58)" end="(499, 59)" leading="" trailing="" val="("/>
            <NullNode start="(499, 59)" end="(499, 67)">
              <OtherNode start="(499, 59)" end="(499, 67)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(499, 59)" end="(499, 67)" leading="" trailing="" raw_val="location" val="location" full_name="Lean.Parser.Tactic.location" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(484, 8)" def_end="(484, 16)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(499, 67)" end="(499, 68)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(499, 68)" end="(499, 69)" leading="" trailing=" " val="?"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(499, 70)" end="(499, 71)" leading="" trailing=" " val=":"/>
      <IdentNode start="(499, 72)" end="(499, 78)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(501, 1)" end="(513, 110)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(501, 1)" end="(512, 3)">
        <CommandDoccommentNode start="(501, 1)" end="(512, 3)" comment="Extracts `let` and `let_fun` expressions from within the target or a local hypothesis,&#10;introducing new local definitions.&#10;&#10;- `extract_lets` extracts all the lets from the target.&#10;- `extract_lets x y z` extracts all the lets from the target and uses `x`, `y`, and `z` for the first names.&#10;  Using `_` for a name leaves it unnamed.&#10;- `extract_lets x y z at h` operates on the local hypothesis `h` instead of the target.&#10;&#10;For example, given a local hypotheses if the form `h : let x := v; b x`, then `extract_lets z at h`&#10;introduces a new local definition `z := v` and changes `h` to be `h : b z`.&#10;-/">
          <AtomNode start="(501, 1)" end="(501, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(502, 1)" end="(512, 3)" leading="" trailing="&#10;" val="Extracts `let` and `let_fun` expressions from within the target or a local hypothesis,&#10;introducing new local definitions.&#10;&#10;- `extract_lets` extracts all the lets from the target.&#10;- `extract_lets x y z` extracts all the lets from the target and uses `x`, `y`, and `z` for the first names.&#10;  Using `_` for a name leaves it unnamed.&#10;- `extract_lets x y z at h` operates on the local hypothesis `h` instead of the target.&#10;&#10;For example, given a local hypotheses if the form `h : let x := v; b x`, then `extract_lets z at h`&#10;introduces a new local definition `z := v` and changes `h` to be `h : b z`.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(513, 1)" end="(513, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(513, 8)" end="(513, 29)">
        <OtherNode start="(513, 8)" end="(513, 29)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(513, 8)" end="(513, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(513, 9)" end="(513, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(513, 14)" end="(513, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(513, 17)" end="(513, 28)" leading="" trailing="" raw_val="extractLets" val="extractLets"/>
          <AtomNode start="(513, 28)" end="(513, 29)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(513, 30)" end="(513, 101)">
        <OtherNode start="(513, 30)" end="(513, 45)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(513, 30)" end="(513, 45)" kind="str">
            <AtomNode start="(513, 30)" end="(513, 45)" leading="" trailing=" " val="&amp;quot;extract_lets &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(513, 46)" end="(513, 55)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(513, 46)" end="(513, 55)" leading="" trailing=" " raw_val="optConfig" val="optConfig" full_name="Lean.Parser.Tactic.optConfig" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(458, 8)" def_end="(458, 17)"/>
          <NullNode/>
        </OtherNode>
        <OtherNode start="(513, 56)" end="(513, 89)" kind="«stx_*»">
          <OtherNode start="(513, 56)" end="(513, 88)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(513, 56)" end="(513, 57)" leading="" trailing="" val="("/>
            <NullNode start="(513, 57)" end="(513, 87)">
              <OtherNode start="(513, 57)" end="(513, 64)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(513, 57)" end="(513, 64)" leading="" trailing=" " raw_val="ppSpace" val="ppSpace" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(513, 65)" end="(513, 70)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(513, 65)" end="(513, 70)" leading="" trailing=" " raw_val="colGt" val="colGt" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(513, 71)" end="(513, 87)" kind="Lean.Parser.Syntax.paren">
                <AtomNode start="(513, 71)" end="(513, 72)" leading="" trailing="" val="("/>
                <NullNode start="(513, 72)" end="(513, 86)">
                  <OtherNode start="(513, 72)" end="(513, 86)" kind="«stx_&amp;lt;|&amp;gt;_»">
                    <OtherNode start="(513, 72)" end="(513, 77)" kind="Lean.Parser.Syntax.cat">
                      <IdentNode start="(513, 72)" end="(513, 77)" leading="" trailing=" " raw_val="ident" val="ident" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(513, 78)" end="(513, 81)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
                    <OtherNode start="(513, 82)" end="(513, 86)" kind="Lean.Parser.Syntax.cat">
                      <IdentNode start="(513, 82)" end="(513, 86)" leading="" trailing="" raw_val="hole" val="hole" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
                <AtomNode start="(513, 86)" end="(513, 87)" leading="" trailing="" val=")"/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(513, 87)" end="(513, 88)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(513, 88)" end="(513, 89)" leading="" trailing=" " val="*"/>
        </OtherNode>
        <OtherNode start="(513, 90)" end="(513, 101)" kind="stx_?">
          <OtherNode start="(513, 90)" end="(513, 100)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(513, 90)" end="(513, 91)" leading="" trailing="" val="("/>
            <NullNode start="(513, 91)" end="(513, 99)">
              <OtherNode start="(513, 91)" end="(513, 99)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(513, 91)" end="(513, 99)" leading="" trailing="" raw_val="location" val="location" full_name="Lean.Parser.Tactic.location" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(484, 8)" def_end="(484, 16)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(513, 99)" end="(513, 100)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(513, 100)" end="(513, 101)" leading="" trailing=" " val="?"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(513, 102)" end="(513, 103)" leading="" trailing=" " val=":"/>
      <IdentNode start="(513, 104)" end="(513, 110)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(515, 1)" end="(531, 70)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(515, 1)" end="(530, 3)">
        <CommandDoccommentNode start="(515, 1)" end="(530, 3)" comment="Lifts `let` and `let_fun` expressions within a term as far out as possible.&#10;It is like `extract_lets +lift`, but the top-level lets at the end of the procedure&#10;are not extracted as local hypotheses.&#10;&#10;- `lift_lets` lifts let expressions in the target.&#10;- `lift_lets at h` lifts let expressions at the given local hypothesis.&#10;&#10;For example,&#10;```lean&#10;example : (let x := 1; x) = 1 := by&#10;  lift_lets&#10;  -- ⊢ let x := 1; x = 1&#10;  ...&#10;```&#10;-/">
          <AtomNode start="(515, 1)" end="(515, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(516, 1)" end="(530, 3)" leading="" trailing="&#10;" val="Lifts `let` and `let_fun` expressions within a term as far out as possible.&#10;It is like `extract_lets +lift`, but the top-level lets at the end of the procedure&#10;are not extracted as local hypotheses.&#10;&#10;- `lift_lets` lifts let expressions in the target.&#10;- `lift_lets at h` lifts let expressions at the given local hypothesis.&#10;&#10;For example,&#10;```lean&#10;example : (let x := 1; x) = 1 := by&#10;  lift_lets&#10;  -- ⊢ let x := 1; x = 1&#10;  ...&#10;```&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(531, 1)" end="(531, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(531, 8)" end="(531, 26)">
        <OtherNode start="(531, 8)" end="(531, 26)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(531, 8)" end="(531, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(531, 9)" end="(531, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(531, 14)" end="(531, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(531, 17)" end="(531, 25)" leading="" trailing="" raw_val="liftLets" val="liftLets"/>
          <AtomNode start="(531, 25)" end="(531, 26)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(531, 27)" end="(531, 61)">
        <OtherNode start="(531, 27)" end="(531, 39)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(531, 27)" end="(531, 39)" kind="str">
            <AtomNode start="(531, 27)" end="(531, 39)" leading="" trailing=" " val="&amp;quot;lift_lets &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(531, 40)" end="(531, 49)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(531, 40)" end="(531, 49)" leading="" trailing=" " raw_val="optConfig" val="optConfig" full_name="Lean.Parser.Tactic.optConfig" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(458, 8)" def_end="(458, 17)"/>
          <NullNode/>
        </OtherNode>
        <OtherNode start="(531, 50)" end="(531, 61)" kind="stx_?">
          <OtherNode start="(531, 50)" end="(531, 60)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(531, 50)" end="(531, 51)" leading="" trailing="" val="("/>
            <NullNode start="(531, 51)" end="(531, 59)">
              <OtherNode start="(531, 51)" end="(531, 59)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(531, 51)" end="(531, 59)" leading="" trailing="" raw_val="location" val="location" full_name="Lean.Parser.Tactic.location" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(484, 8)" def_end="(484, 16)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(531, 59)" end="(531, 60)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(531, 60)" end="(531, 61)" leading="" trailing=" " val="?"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(531, 62)" end="(531, 63)" leading="" trailing=" " val=":"/>
      <IdentNode start="(531, 64)" end="(531, 70)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(533, 1)" end="(538, 56)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(533, 1)" end="(537, 3)">
        <CommandDoccommentNode start="(533, 1)" end="(537, 3)" comment="If `thm` is a theorem `a = b`, then as a rewrite rule,&#10;* `thm` means to replace `a` with `b`, and&#10;* `← thm` means to replace `b` with `a`.&#10;-/">
          <AtomNode start="(533, 1)" end="(533, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(534, 1)" end="(537, 3)" leading="" trailing="&#10;" val="If `thm` is a theorem `a = b`, then as a rewrite rule,&#10;* `thm` means to replace `a` with `b`, and&#10;* `← thm` means to replace `b` with `a`.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(538, 1)" end="(538, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(538, 8)" end="(538, 14)" leading="" trailing="    " raw_val="rwRule" val="rwRule"/>
      <AtomNode start="(538, 18)" end="(538, 20)" leading="" trailing=" " val=":="/>
      <NullNode start="(538, 21)" end="(538, 56)">
        <OtherNode start="(538, 21)" end="(538, 51)" kind="stx_?">
          <OtherNode start="(538, 21)" end="(538, 50)" kind="Lean.Parser.Syntax.unary">
            <IdentNode start="(538, 21)" end="(538, 34)" leading="" trailing="" raw_val="patternIgnore" val="patternIgnore"/>
            <AtomNode start="(538, 34)" end="(538, 35)" leading="" trailing="" val="("/>
            <NullNode start="(538, 35)" end="(538, 49)">
              <OtherNode start="(538, 35)" end="(538, 49)" kind="«stx_&amp;lt;|&amp;gt;_»">
                <OtherNode start="(538, 35)" end="(538, 39)" kind="Lean.Parser.Syntax.atom">
                  <OtherNode start="(538, 35)" end="(538, 39)" kind="str">
                    <AtomNode start="(538, 35)" end="(538, 39)" leading="" trailing=" " val="&amp;quot;← &amp;quot;"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(538, 40)" end="(538, 43)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
                <OtherNode start="(538, 44)" end="(538, 49)" kind="Lean.Parser.Syntax.atom">
                  <OtherNode start="(538, 44)" end="(538, 49)" kind="str">
                    <AtomNode start="(538, 44)" end="(538, 49)" leading="" trailing="" val="&amp;quot;&amp;lt;- &amp;quot;"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(538, 49)" end="(538, 50)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(538, 50)" end="(538, 51)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(538, 52)" end="(538, 56)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(538, 52)" end="(538, 56)" leading="" trailing="&#10;" raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(539, 1)" end="(540, 57)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(539, 1)" end="(539, 56)">
        <CommandDoccommentNode start="(539, 1)" end="(539, 56)" comment="A `rwRuleSeq` is a list of `rwRule` in brackets. -/">
          <AtomNode start="(539, 1)" end="(539, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(539, 5)" end="(539, 56)" leading="" trailing="&#10;" val="A `rwRuleSeq` is a list of `rwRule` in brackets. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(540, 1)" end="(540, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(540, 8)" end="(540, 17)" leading="" trailing=" " raw_val="rwRuleSeq" val="rwRuleSeq"/>
      <AtomNode start="(540, 18)" end="(540, 20)" leading="" trailing=" " val=":="/>
      <NullNode start="(540, 21)" end="(540, 57)">
        <OtherNode start="(540, 21)" end="(540, 25)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(540, 21)" end="(540, 25)" kind="str">
            <AtomNode start="(540, 21)" end="(540, 25)" leading="" trailing=" " val="&amp;quot; [&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(540, 26)" end="(540, 53)" kind="Lean.Parser.Syntax.unary">
          <IdentNode start="(540, 26)" end="(540, 41)" leading="" trailing="" raw_val="withoutPosition" val="withoutPosition"/>
          <AtomNode start="(540, 41)" end="(540, 42)" leading="" trailing="" val="("/>
          <NullNode start="(540, 42)" end="(540, 52)">
            <OtherNode start="(540, 42)" end="(540, 52)" kind="«stx_,*,?»">
              <OtherNode start="(540, 42)" end="(540, 48)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(540, 42)" end="(540, 48)" leading="" trailing="" raw_val="rwRule" val="rwRule" full_name="Lean.Parser.Tactic.rwRule" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(538, 8)" def_end="(538, 14)"/>
                <NullNode/>
              </OtherNode>
              <AtomNode start="(540, 48)" end="(540, 52)" leading="" trailing="" val=",*,?"/>
            </OtherNode>
          </NullNode>
          <AtomNode start="(540, 52)" end="(540, 53)" leading="" trailing=" " val=")"/>
        </OtherNode>
        <OtherNode start="(540, 54)" end="(540, 57)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(540, 54)" end="(540, 57)" kind="str">
            <AtomNode start="(540, 54)" end="(540, 57)" leading="" trailing="&#10;&#10;" val="&amp;quot;]&amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(542, 1)" end="(561, 79)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(542, 1)" end="(560, 3)">
        <CommandDoccommentNode start="(542, 1)" end="(560, 3)" comment="`rewrite [e]` applies identity `e` as a rewrite rule to the target of the main goal.&#10;If `e` is preceded by left arrow (`←` or `&amp;lt;-`), the rewrite is applied in the reverse direction.&#10;If `e` is a defined constant, then the equational theorems associated with `e` are used.&#10;This provides a convenient way to unfold `e`.&#10;- `rewrite [e₁, ..., eₙ]` applies the given rules sequentially.&#10;- `rewrite [e] at l` rewrites `e` at location(s) `l`, where `l` is either `*` or a&#10;  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`&#10;  can also be used, to signify the target of the goal.&#10;&#10;Using `rw (occs := .pos L) [e]`,&#10;where `L : List Nat`, you can control which &amp;quot;occurrences&amp;quot; are rewritten.&#10;(This option applies to each rule, so usually this will only be used with a single rule.)&#10;Occurrences count from `1`.&#10;At each allowed occurrence, arguments of the rewrite rule `e` may be instantiated,&#10;restricting which later rewrites can be found.&#10;(Disallowed occurrences do not result in instantiation.)&#10;`(occs := .neg L)` allows skipping specified occurrences.&#10;-/">
          <AtomNode start="(542, 1)" end="(542, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(543, 1)" end="(560, 3)" leading="" trailing="&#10;" val="`rewrite [e]` applies identity `e` as a rewrite rule to the target of the main goal.&#10;If `e` is preceded by left arrow (`←` or `&amp;lt;-`), the rewrite is applied in the reverse direction.&#10;If `e` is a defined constant, then the equational theorems associated with `e` are used.&#10;This provides a convenient way to unfold `e`.&#10;- `rewrite [e₁, ..., eₙ]` applies the given rules sequentially.&#10;- `rewrite [e] at l` rewrites `e` at location(s) `l`, where `l` is either `*` or a&#10;  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`&#10;  can also be used, to signify the target of the goal.&#10;&#10;Using `rw (occs := .pos L) [e]`,&#10;where `L : List Nat`, you can control which &amp;quot;occurrences&amp;quot; are rewritten.&#10;(This option applies to each rule, so usually this will only be used with a single rule.)&#10;Occurrences count from `1`.&#10;At each allowed occurrence, arguments of the rewrite rule `e` may be instantiated,&#10;restricting which later rewrites can be found.&#10;(Disallowed occurrences do not result in instantiation.)&#10;`(occs := .neg L)` allows skipping specified occurrences.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(561, 1)" end="(561, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(561, 8)" end="(561, 28)">
        <OtherNode start="(561, 8)" end="(561, 28)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(561, 8)" end="(561, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(561, 9)" end="(561, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(561, 14)" end="(561, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(561, 17)" end="(561, 27)" leading="" trailing="" raw_val="rewriteSeq" val="rewriteSeq"/>
          <AtomNode start="(561, 27)" end="(561, 28)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(561, 29)" end="(561, 70)">
        <OtherNode start="(561, 29)" end="(561, 38)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(561, 29)" end="(561, 38)" kind="str">
            <AtomNode start="(561, 29)" end="(561, 38)" leading="" trailing=" " val="&amp;quot;rewrite&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(561, 39)" end="(561, 48)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(561, 39)" end="(561, 48)" leading="" trailing=" " raw_val="optConfig" val="optConfig" full_name="Lean.Parser.Tactic.optConfig" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(458, 8)" def_end="(458, 17)"/>
          <NullNode/>
        </OtherNode>
        <OtherNode start="(561, 49)" end="(561, 58)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(561, 49)" end="(561, 58)" leading="" trailing=" " raw_val="rwRuleSeq" val="rwRuleSeq" full_name="Lean.Parser.Tactic.rwRuleSeq" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(540, 8)" def_end="(540, 17)"/>
          <NullNode/>
        </OtherNode>
        <OtherNode start="(561, 59)" end="(561, 70)" kind="stx_?">
          <OtherNode start="(561, 59)" end="(561, 69)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(561, 59)" end="(561, 60)" leading="" trailing="" val="("/>
            <NullNode start="(561, 60)" end="(561, 68)">
              <OtherNode start="(561, 60)" end="(561, 68)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(561, 60)" end="(561, 68)" leading="" trailing="" raw_val="location" val="location" full_name="Lean.Parser.Tactic.location" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(484, 8)" def_end="(484, 16)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(561, 68)" end="(561, 69)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(561, 69)" end="(561, 70)" leading="" trailing=" " val="?"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(561, 71)" end="(561, 72)" leading="" trailing=" " val=":"/>
      <IdentNode start="(561, 73)" end="(561, 79)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(563, 1)" end="(571, 32)" kind="Lean.Parser.Command.macro">
      <NullNode start="(563, 1)" end="(565, 3)">
        <CommandDoccommentNode start="(563, 1)" end="(565, 3)" comment="`rw` is like `rewrite`, but also tries to close the goal by &amp;quot;cheap&amp;quot; (reducible) `rfl` afterwards.&#10;-/">
          <AtomNode start="(563, 1)" end="(563, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(564, 1)" end="(565, 3)" leading="" trailing="&#10;" val="`rw` is like `rewrite`, but also tries to close the goal by &amp;quot;cheap&amp;quot; (reducible) `rfl` afterwards.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(566, 1)" end="(566, 6)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode start="(566, 7)" end="(566, 22)">
        <OtherNode start="(566, 7)" end="(566, 22)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(566, 7)" end="(566, 8)" leading="" trailing="" val="("/>
          <AtomNode start="(566, 8)" end="(566, 12)" leading="" trailing=" " val="name"/>
          <AtomNode start="(566, 13)" end="(566, 15)" leading="" trailing=" " val=":="/>
          <IdentNode start="(566, 16)" end="(566, 21)" leading="" trailing="" raw_val="rwSeq" val="rwSeq"/>
          <AtomNode start="(566, 21)" end="(566, 22)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(566, 23)" end="(566, 66)">
        <OtherNode start="(566, 23)" end="(566, 28)" kind="Lean.Parser.Command.macroArg">
          <NullNode/>
          <OtherNode start="(566, 23)" end="(566, 28)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(566, 23)" end="(566, 28)" kind="str">
              <AtomNode start="(566, 23)" end="(566, 28)" leading="" trailing=" " val="&amp;quot;rw &amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(566, 29)" end="(566, 40)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(566, 29)" end="(566, 31)">
            <IdentNode start="(566, 29)" end="(566, 30)" leading="" trailing="" raw_val="c" val="c"/>
            <AtomNode start="(566, 30)" end="(566, 31)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(566, 31)" end="(566, 40)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(566, 31)" end="(566, 40)" leading="" trailing=" " raw_val="optConfig" val="optConfig" full_name="Lean.Parser.Tactic.optConfig" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(458, 8)" def_end="(458, 17)"/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(566, 41)" end="(566, 52)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(566, 41)" end="(566, 43)">
            <IdentNode start="(566, 41)" end="(566, 42)" leading="" trailing="" raw_val="s" val="s"/>
            <AtomNode start="(566, 42)" end="(566, 43)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(566, 43)" end="(566, 52)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(566, 43)" end="(566, 52)" leading="" trailing=" " raw_val="rwRuleSeq" val="rwRuleSeq" full_name="Lean.Parser.Tactic.rwRuleSeq" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(540, 8)" def_end="(540, 17)"/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(566, 53)" end="(566, 66)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(566, 53)" end="(566, 55)">
            <IdentNode start="(566, 53)" end="(566, 54)" leading="" trailing="" raw_val="l" val="l"/>
            <AtomNode start="(566, 54)" end="(566, 55)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(566, 55)" end="(566, 66)" kind="stx_?">
            <OtherNode start="(566, 55)" end="(566, 65)" kind="Lean.Parser.Syntax.paren">
              <AtomNode start="(566, 55)" end="(566, 56)" leading="" trailing="" val="("/>
              <NullNode start="(566, 56)" end="(566, 64)">
                <OtherNode start="(566, 56)" end="(566, 64)" kind="Lean.Parser.Syntax.cat">
                  <IdentNode start="(566, 56)" end="(566, 64)" leading="" trailing="" raw_val="location" val="location" full_name="Lean.Parser.Tactic.location" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(484, 8)" def_end="(484, 16)"/>
                  <NullNode/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(566, 64)" end="(566, 65)" leading="" trailing="" val=")"/>
            </OtherNode>
            <AtomNode start="(566, 65)" end="(566, 66)" leading="" trailing=" " val="?"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(566, 67)" end="(571, 32)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(566, 67)" end="(566, 68)" leading="" trailing=" " val=":"/>
        <IdentNode start="(566, 69)" end="(566, 75)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(566, 76)" end="(566, 78)" leading="" trailing="&#10;  " val="=&amp;gt;"/>
        <OtherNode start="(567, 3)" end="(571, 32)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(567, 3)" end="(571, 32)" kind="Lean.Parser.Term.match">
            <AtomNode start="(567, 3)" end="(567, 8)" leading="" trailing=" " val="match"/>
            <NullNode/>
            <NullNode/>
            <NullNode start="(567, 9)" end="(567, 10)">
              <OtherNode start="(567, 9)" end="(567, 10)" kind="Lean.Parser.Term.matchDiscr">
                <NullNode/>
                <IdentNode start="(567, 9)" end="(567, 10)" leading="" trailing=" " raw_val="s" val="s"/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(567, 11)" end="(567, 15)" leading="" trailing="&#10;  " val="with"/>
            <OtherNode start="(568, 3)" end="(571, 32)" kind="Lean.Parser.Term.matchAlts">
              <NullNode start="(568, 3)" end="(571, 32)">
                <OtherNode start="(568, 3)" end="(570, 97)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(568, 3)" end="(568, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(568, 5)" end="(568, 33)">
                    <NullNode start="(568, 5)" end="(568, 33)">
                      <OtherNode start="(568, 5)" end="(568, 33)" kind="Lean.Parser.Term.dynamicQuot">
                        <AtomNode start="(568, 5)" end="(568, 7)" leading="" trailing="" val="`("/>
                        <IdentNode start="(568, 7)" end="(568, 16)" leading="" trailing="" raw_val="rwRuleSeq" val="rwRuleSeq" full_name="Lean.Parser.Tactic.rwRuleSeq" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(540, 8)" def_end="(540, 17)"/>
                        <AtomNode start="(568, 16)" end="(568, 17)" leading="" trailing=" " val="|"/>
                        <OtherNode start="(568, 18)" end="(568, 32)" kind="Lean.Parser.Tactic.rwRuleSeq">
                          <AtomNode start="(568, 18)" end="(568, 19)" leading="" trailing="" val="["/>
                          <NullNode start="(568, 19)" end="(568, 24)">
                            <OtherNode start="(568, 19)" end="(568, 24)" kind="sepBy.antiquot_suffix_splice">
                              <OtherNode start="(568, 19)" end="(568, 22)" kind="Lean.Parser.Tactic.rwRule.antiquot">
                                <AtomNode start="(568, 19)" end="(568, 20)" leading="" trailing="" val="$"/>
                                <NullNode/>
                                <IdentNode start="(568, 20)" end="(568, 22)" leading="" trailing="" raw_val="rs" val="rs"/>
                                <NullNode/>
                              </OtherNode>
                              <AtomNode start="(568, 22)" end="(568, 24)" leading="" trailing="" val=",*"/>
                            </OtherNode>
                          </NullNode>
                          <TokenAntiquotNode start="(568, 24)" end="(568, 32)">
                            <AtomNode start="(568, 24)" end="(568, 25)" leading="" trailing="" val="]"/>
                            <AtomNode start="(568, 25)" end="(568, 26)" leading="" trailing="" val="%"/>
                            <AtomNode start="(568, 26)" end="(568, 27)" leading="" trailing="" val="$"/>
                            <IdentNode start="(568, 27)" end="(568, 32)" leading="" trailing="" raw_val="rbrak" val="rbrak"/>
                          </TokenAntiquotNode>
                        </OtherNode>
                        <AtomNode start="(568, 32)" end="(568, 33)" leading="" trailing=" " val=")"/>
                      </OtherNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(568, 34)" end="(568, 36)" leading="" trailing="&#10;    -- We show the `rfl` state on `]`&#10;    " val="=&amp;gt;"/>
                  <OtherNode start="(570, 5)" end="(570, 97)" kind="Lean.Parser.Tactic.quot">
                    <AtomNode start="(570, 5)" end="(570, 14)" leading="" trailing=" " val="`(tactic|"/>
                    <OtherNode start="(570, 15)" end="(570, 96)" kind="Lean.Parser.Tactic.paren">
                      <AtomNode start="(570, 15)" end="(570, 16)" leading="" trailing="" val="("/>
                      <TacticTacticseqNode start="(570, 16)" end="(570, 95)">
                        <TacticTacticseq1IndentedNode start="(570, 16)" end="(570, 95)">
                          <NullNode start="(570, 16)" end="(570, 95)">
                            <OtherNode start="(570, 16)" end="(570, 40)" kind="Lean.Parser.Tactic.rewriteSeq">
                              <AtomNode start="(570, 16)" end="(570, 23)" leading="" trailing=" " val="rewrite"/>
                              <OtherNode start="(570, 24)" end="(570, 26)" kind="Lean.Parser.Tactic.optConfig.antiquot">
                                <AtomNode start="(570, 24)" end="(570, 25)" leading="" trailing="" val="$"/>
                                <NullNode/>
                                <IdentNode start="(570, 25)" end="(570, 26)" leading="" trailing=" " raw_val="c" val="c"/>
                                <NullNode/>
                              </OtherNode>
                              <OtherNode start="(570, 27)" end="(570, 34)" kind="Lean.Parser.Tactic.rwRuleSeq">
                                <AtomNode start="(570, 27)" end="(570, 28)" leading="" trailing="" val="["/>
                                <NullNode start="(570, 28)" end="(570, 33)">
                                  <OtherNode start="(570, 28)" end="(570, 33)" kind="sepBy.antiquot_suffix_splice">
                                    <OtherNode start="(570, 28)" end="(570, 31)" kind="Lean.Parser.Tactic.rwRule.antiquot">
                                      <AtomNode start="(570, 28)" end="(570, 29)" leading="" trailing="" val="$"/>
                                      <NullNode/>
                                      <IdentNode start="(570, 29)" end="(570, 31)" leading="" trailing="" raw_val="rs" val="rs"/>
                                      <NullNode/>
                                    </OtherNode>
                                    <AtomNode start="(570, 31)" end="(570, 33)" leading="" trailing="" val=",*"/>
                                  </OtherNode>
                                </NullNode>
                                <AtomNode start="(570, 33)" end="(570, 34)" leading="" trailing=" " val="]"/>
                              </OtherNode>
                              <NullNode start="(570, 35)" end="(570, 40)">
                                <OtherNode start="(570, 35)" end="(570, 40)" kind="optional.antiquot_suffix_splice">
                                  <OtherNode start="(570, 35)" end="(570, 39)" kind="Lean.Parser.Tactic.location.antiquot">
                                    <AtomNode start="(570, 35)" end="(570, 36)" leading="" trailing="" val="$"/>
                                    <NullNode/>
                                    <OtherNode start="(570, 36)" end="(570, 39)" kind="antiquotNestedExpr">
                                      <AtomNode start="(570, 36)" end="(570, 37)" leading="" trailing="" val="("/>
                                      <IdentNode start="(570, 37)" end="(570, 38)" leading="" trailing="" raw_val="l" val="l"/>
                                      <AtomNode start="(570, 38)" end="(570, 39)" leading="" trailing="" val=")"/>
                                    </OtherNode>
                                    <NullNode/>
                                  </OtherNode>
                                  <AtomNode start="(570, 39)" end="(570, 40)" leading="" trailing="" val="?"/>
                                </OtherNode>
                              </NullNode>
                            </OtherNode>
                            <AtomNode start="(570, 40)" end="(570, 41)" leading="" trailing=" " val=";"/>
                            <OtherNode start="(570, 42)" end="(570, 95)" kind="Lean.Parser.Tactic.withAnnotateState">
                              <AtomNode start="(570, 42)" end="(570, 61)" leading="" trailing=" " val="with_annotate_state"/>
                              <OtherNode start="(570, 62)" end="(570, 68)" kind="rawStx.pseudo.antiquot">
                                <AtomNode start="(570, 62)" end="(570, 63)" leading="" trailing="" val="$"/>
                                <NullNode/>
                                <IdentNode start="(570, 63)" end="(570, 68)" leading="" trailing=" " raw_val="rbrak" val="rbrak"/>
                                <NullNode/>
                              </OtherNode>
                              <OtherNode start="(570, 69)" end="(570, 95)" kind="Lean.Parser.Tactic.paren">
                                <AtomNode start="(570, 69)" end="(570, 70)" leading="" trailing="" val="("/>
                                <TacticTacticseqNode start="(570, 70)" end="(570, 94)">
                                  <TacticTacticseq1IndentedNode start="(570, 70)" end="(570, 94)">
                                    <NullNode start="(570, 70)" end="(570, 94)">
                                      <OtherNode start="(570, 70)" end="(570, 94)" kind="Lean.Parser.Tactic.tacticTry_">
                                        <AtomNode start="(570, 70)" end="(570, 73)" leading="" trailing=" " val="try"/>
                                        <TacticTacticseqNode start="(570, 74)" end="(570, 94)">
                                          <TacticTacticseq1IndentedNode start="(570, 74)" end="(570, 94)">
                                            <NullNode start="(570, 74)" end="(570, 94)">
                                              <OtherNode start="(570, 74)" end="(570, 94)" kind="Lean.Parser.Tactic.paren">
                                                <AtomNode start="(570, 74)" end="(570, 75)" leading="" trailing="" val="("/>
                                                <TacticTacticseqNode start="(570, 75)" end="(570, 93)">
                                                  <TacticTacticseq1IndentedNode start="(570, 75)" end="(570, 93)">
                                                    <NullNode start="(570, 75)" end="(570, 93)">
                                                      <OtherNode start="(570, 75)" end="(570, 93)" kind="Lean.Parser.Tactic.withReducible">
                                                        <AtomNode start="(570, 75)" end="(570, 89)" leading="" trailing=" " val="with_reducible"/>
                                                        <TacticTacticseqNode start="(570, 90)" end="(570, 93)">
                                                          <TacticTacticseq1IndentedNode start="(570, 90)" end="(570, 93)">
                                                            <NullNode start="(570, 90)" end="(570, 93)">
                                                            <OtherNode start="(570, 90)" end="(570, 93)" kind="Lean.Parser.Tactic.tacticRfl">
                                                            <AtomNode start="(570, 90)" end="(570, 93)" leading="" trailing="" val="rfl"/>
                                                            </OtherNode>
                                                            </NullNode>
                                                          </TacticTacticseq1IndentedNode>
                                                        </TacticTacticseqNode>
                                                      </OtherNode>
                                                    </NullNode>
                                                  </TacticTacticseq1IndentedNode>
                                                </TacticTacticseqNode>
                                                <AtomNode start="(570, 93)" end="(570, 94)" leading="" trailing="" val=")"/>
                                              </OtherNode>
                                            </NullNode>
                                          </TacticTacticseq1IndentedNode>
                                        </TacticTacticseqNode>
                                      </OtherNode>
                                    </NullNode>
                                  </TacticTacticseq1IndentedNode>
                                </TacticTacticseqNode>
                                <AtomNode start="(570, 94)" end="(570, 95)" leading="" trailing="" val=")"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                      <AtomNode start="(570, 95)" end="(570, 96)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(570, 96)" end="(570, 97)" leading="" trailing="&#10;  " val=")"/>
                  </OtherNode>
                </OtherNode>
                <OtherNode start="(571, 3)" end="(571, 32)" kind="Lean.Parser.Term.matchAlt">
                  <AtomNode start="(571, 3)" end="(571, 4)" leading="" trailing=" " val="|"/>
                  <NullNode start="(571, 5)" end="(571, 6)">
                    <NullNode start="(571, 5)" end="(571, 6)">
                      <TermHoleNode start="(571, 5)" end="(571, 6)">
                        <AtomNode start="(571, 5)" end="(571, 6)" leading="" trailing=" " val="_"/>
                      </TermHoleNode>
                    </NullNode>
                  </NullNode>
                  <AtomNode start="(571, 7)" end="(571, 9)" leading="" trailing=" " val="=&amp;gt;"/>
                  <IdentNode start="(571, 10)" end="(571, 32)" leading="" trailing="&#10;&#10;" raw_val="Macro.throwUnsupported" val="Macro.throwUnsupported" full_name="Lean.Macro.throwUnsupported" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </OtherNode>
              </NullNode>
            </OtherNode>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(573, 1)" end="(575, 63)" kind="Lean.Parser.Command.macro">
      <NullNode start="(573, 1)" end="(573, 49)">
        <CommandDoccommentNode start="(573, 1)" end="(573, 49)" comment="`rwa` is short-hand for `rw; assumption`. -/">
          <AtomNode start="(573, 1)" end="(573, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(573, 5)" end="(573, 49)" leading="" trailing="&#10;" val="`rwa` is short-hand for `rw; assumption`. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(574, 1)" end="(574, 6)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(574, 7)" end="(574, 43)">
        <OtherNode start="(574, 7)" end="(574, 13)" kind="Lean.Parser.Command.macroArg">
          <NullNode/>
          <OtherNode start="(574, 7)" end="(574, 13)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(574, 7)" end="(574, 13)" kind="str">
              <AtomNode start="(574, 7)" end="(574, 13)" leading="" trailing=" " val="&amp;quot;rwa &amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(574, 14)" end="(574, 27)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(574, 14)" end="(574, 18)">
            <IdentNode start="(574, 14)" end="(574, 17)" leading="" trailing="" raw_val="rws" val="rws"/>
            <AtomNode start="(574, 17)" end="(574, 18)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(574, 18)" end="(574, 27)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(574, 18)" end="(574, 27)" leading="" trailing=" " raw_val="rwRuleSeq" val="rwRuleSeq" full_name="Lean.Parser.Tactic.rwRuleSeq" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(540, 8)" def_end="(540, 17)"/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(574, 28)" end="(574, 43)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(574, 28)" end="(574, 32)">
            <IdentNode start="(574, 28)" end="(574, 31)" leading="" trailing="" raw_val="loc" val="loc"/>
            <AtomNode start="(574, 31)" end="(574, 32)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(574, 32)" end="(574, 43)" kind="stx_?">
            <OtherNode start="(574, 32)" end="(574, 42)" kind="Lean.Parser.Syntax.paren">
              <AtomNode start="(574, 32)" end="(574, 33)" leading="" trailing="" val="("/>
              <NullNode start="(574, 33)" end="(574, 41)">
                <OtherNode start="(574, 33)" end="(574, 41)" kind="Lean.Parser.Syntax.cat">
                  <IdentNode start="(574, 33)" end="(574, 41)" leading="" trailing="" raw_val="location" val="location" full_name="Lean.Parser.Tactic.location" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(484, 8)" def_end="(484, 16)"/>
                  <NullNode/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(574, 41)" end="(574, 42)" leading="" trailing="" val=")"/>
            </OtherNode>
            <AtomNode start="(574, 42)" end="(574, 43)" leading="" trailing=" " val="?"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(574, 44)" end="(575, 63)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(574, 44)" end="(574, 45)" leading="" trailing=" " val=":"/>
        <IdentNode start="(574, 46)" end="(574, 52)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(574, 53)" end="(574, 55)" leading="" trailing="&#10;  " val="=&amp;gt;"/>
        <OtherNode start="(575, 3)" end="(575, 63)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(575, 3)" end="(575, 63)" kind="Lean.Parser.Tactic.quot">
            <AtomNode start="(575, 3)" end="(575, 12)" leading="" trailing=" " val="`(tactic|"/>
            <OtherNode start="(575, 13)" end="(575, 62)" kind="Lean.Parser.Tactic.paren">
              <AtomNode start="(575, 13)" end="(575, 14)" leading="" trailing="" val="("/>
              <TacticTacticseqNode start="(575, 14)" end="(575, 61)">
                <TacticTacticseq1IndentedNode start="(575, 14)" end="(575, 61)">
                  <NullNode start="(575, 14)" end="(575, 61)">
                    <OtherNode start="(575, 14)" end="(575, 49)" kind="Lean.Parser.Tactic.rwSeq">
                      <AtomNode start="(575, 14)" end="(575, 16)" leading="" trailing=" " val="rw"/>
                      <OtherNode kind="Lean.Parser.Tactic.optConfig">
                        <NullNode/>
                      </OtherNode>
                      <OtherNode start="(575, 17)" end="(575, 31)" kind="Lean.Parser.Tactic.rwRuleSeq.antiquot">
                        <AtomNode start="(575, 17)" end="(575, 18)" leading="" trailing="" val="$"/>
                        <NullNode/>
                        <IdentNode start="(575, 18)" end="(575, 21)" leading="" trailing="" raw_val="rws" val="rws"/>
                        <OtherNode start="(575, 21)" end="(575, 31)" kind="antiquotName">
                          <AtomNode start="(575, 21)" end="(575, 22)" leading="" trailing="" val=":"/>
                          <AtomNode start="(575, 22)" end="(575, 31)" leading="" trailing=" " val="rwRuleSeq"/>
                        </OtherNode>
                      </OtherNode>
                      <NullNode start="(575, 32)" end="(575, 49)">
                        <OtherNode start="(575, 32)" end="(575, 49)" kind="optional.antiquot_scope">
                          <AtomNode start="(575, 32)" end="(575, 33)" leading="" trailing="" val="$"/>
                          <NullNode/>
                          <AtomNode start="(575, 33)" end="(575, 34)" leading="" trailing="" val="["/>
                          <NullNode start="(575, 34)" end="(575, 47)">
                            <OtherNode start="(575, 34)" end="(575, 47)" kind="Lean.Parser.Tactic.location.antiquot">
                              <AtomNode start="(575, 34)" end="(575, 35)" leading="" trailing="" val="$"/>
                              <NullNode/>
                              <IdentNode start="(575, 35)" end="(575, 38)" leading="" trailing="" raw_val="loc" val="loc"/>
                              <OtherNode start="(575, 38)" end="(575, 47)" kind="antiquotName">
                                <AtomNode start="(575, 38)" end="(575, 39)" leading="" trailing="" val=":"/>
                                <AtomNode start="(575, 39)" end="(575, 47)" leading="" trailing="" val="location"/>
                              </OtherNode>
                            </OtherNode>
                          </NullNode>
                          <AtomNode start="(575, 47)" end="(575, 48)" leading="" trailing="" val="]"/>
                          <AtomNode start="(575, 48)" end="(575, 49)" leading="" trailing="" val="?"/>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <AtomNode start="(575, 49)" end="(575, 50)" leading="" trailing=" " val=";"/>
                    <OtherNode start="(575, 51)" end="(575, 61)" kind="Lean.Parser.Tactic.assumption">
                      <AtomNode start="(575, 51)" end="(575, 61)" leading="" trailing="" val="assumption"/>
                    </OtherNode>
                  </NullNode>
                </TacticTacticseq1IndentedNode>
              </TacticTacticseqNode>
              <AtomNode start="(575, 61)" end="(575, 62)" leading="" trailing="" val=")"/>
            </OtherNode>
            <AtomNode start="(575, 62)" end="(575, 63)" leading="" trailing="&#10;&#10;" val=")"/>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(577, 1)" end="(590, 99)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(577, 1)" end="(589, 3)">
        <CommandDoccommentNode start="(577, 1)" end="(589, 3)" comment="The `injection` tactic is based on the fact that constructors of inductive data&#10;types are injections.&#10;That means that if `c` is a constructor of an inductive datatype, and if `(c t₁)`&#10;and `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.&#10;If `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies&#10;injectivity to derive the equality of all arguments of `t₁` and `t₂` placed in&#10;the same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`.&#10;To use this tactic `t₁` and `t₂` should be constructor applications of the same constructor.&#10;Given `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types&#10;`a = c` and `b = d` to the main goal.&#10;The tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.&#10;-/">
          <AtomNode start="(577, 1)" end="(577, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(578, 1)" end="(589, 3)" leading="" trailing="&#10;" val="The `injection` tactic is based on the fact that constructors of inductive data&#10;types are injections.&#10;That means that if `c` is a constructor of an inductive datatype, and if `(c t₁)`&#10;and `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.&#10;If `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies&#10;injectivity to derive the equality of all arguments of `t₁` and `t₂` placed in&#10;the same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`.&#10;To use this tactic `t₁` and `t₂` should be constructor applications of the same constructor.&#10;Given `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types&#10;`a = c` and `b = d` to the main goal.&#10;The tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(590, 1)" end="(590, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(590, 8)" end="(590, 27)">
        <OtherNode start="(590, 8)" end="(590, 27)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(590, 8)" end="(590, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(590, 9)" end="(590, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(590, 14)" end="(590, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(590, 17)" end="(590, 26)" leading="" trailing="" raw_val="injection" val="injection"/>
          <AtomNode start="(590, 26)" end="(590, 27)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(590, 28)" end="(590, 90)">
        <OtherNode start="(590, 28)" end="(590, 40)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(590, 28)" end="(590, 40)" kind="str">
            <AtomNode start="(590, 28)" end="(590, 40)" leading="" trailing=" " val="&amp;quot;injection &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(590, 41)" end="(590, 45)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(590, 41)" end="(590, 45)" leading="" trailing=" " raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
        <OtherNode start="(590, 46)" end="(590, 90)" kind="stx_?">
          <OtherNode start="(590, 46)" end="(590, 89)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(590, 46)" end="(590, 47)" leading="" trailing="" val="("/>
            <NullNode start="(590, 47)" end="(590, 88)">
              <OtherNode start="(590, 47)" end="(590, 54)" kind="Lean.Parser.Syntax.atom">
                <OtherNode start="(590, 47)" end="(590, 54)" kind="str">
                  <AtomNode start="(590, 47)" end="(590, 54)" leading="" trailing=" " val="&amp;quot; with&amp;quot;"/>
                </OtherNode>
              </OtherNode>
              <OtherNode start="(590, 55)" end="(590, 88)" kind="«stx_+»">
                <OtherNode start="(590, 55)" end="(590, 87)" kind="Lean.Parser.Syntax.paren">
                  <AtomNode start="(590, 55)" end="(590, 56)" leading="" trailing="" val="("/>
                  <NullNode start="(590, 56)" end="(590, 86)">
                    <OtherNode start="(590, 56)" end="(590, 63)" kind="Lean.Parser.Syntax.cat">
                      <IdentNode start="(590, 56)" end="(590, 63)" leading="" trailing=" " raw_val="ppSpace" val="ppSpace" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(590, 64)" end="(590, 69)" kind="Lean.Parser.Syntax.cat">
                      <IdentNode start="(590, 64)" end="(590, 69)" leading="" trailing=" " raw_val="colGt" val="colGt" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(590, 70)" end="(590, 86)" kind="Lean.Parser.Syntax.paren">
                      <AtomNode start="(590, 70)" end="(590, 71)" leading="" trailing="" val="("/>
                      <NullNode start="(590, 71)" end="(590, 85)">
                        <OtherNode start="(590, 71)" end="(590, 85)" kind="«stx_&amp;lt;|&amp;gt;_»">
                          <OtherNode start="(590, 71)" end="(590, 76)" kind="Lean.Parser.Syntax.cat">
                            <IdentNode start="(590, 71)" end="(590, 76)" leading="" trailing=" " raw_val="ident" val="ident" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            <NullNode/>
                          </OtherNode>
                          <AtomNode start="(590, 77)" end="(590, 80)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
                          <OtherNode start="(590, 81)" end="(590, 85)" kind="Lean.Parser.Syntax.cat">
                            <IdentNode start="(590, 81)" end="(590, 85)" leading="" trailing="" raw_val="hole" val="hole" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            <NullNode/>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(590, 85)" end="(590, 86)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(590, 86)" end="(590, 87)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(590, 87)" end="(590, 88)" leading="" trailing="" val="+"/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(590, 88)" end="(590, 89)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(590, 89)" end="(590, 90)" leading="" trailing=" " val="?"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(590, 91)" end="(590, 92)" leading="" trailing=" " val=":"/>
      <IdentNode start="(590, 93)" end="(590, 99)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(592, 1)" end="(596, 84)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(592, 1)" end="(594, 56)">
        <CommandDoccommentNode start="(592, 1)" end="(594, 56)" comment="`injections` applies `injection` to all hypotheses recursively&#10;(since `injection` can produce new hypotheses). Useful for destructing nested&#10;constructor equalities like `(a::b::c) = (d::e::f)`. -/">
          <AtomNode start="(592, 1)" end="(592, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(592, 5)" end="(594, 56)" leading="" trailing="&#10;-- TODO: add with&#10;" val="`injections` applies `injection` to all hypotheses recursively&#10;(since `injection` can produce new hypotheses). Useful for destructing nested&#10;constructor equalities like `(a::b::c) = (d::e::f)`. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(596, 1)" end="(596, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(596, 8)" end="(596, 28)">
        <OtherNode start="(596, 8)" end="(596, 28)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(596, 8)" end="(596, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(596, 9)" end="(596, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(596, 14)" end="(596, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(596, 17)" end="(596, 27)" leading="" trailing="" raw_val="injections" val="injections"/>
          <AtomNode start="(596, 27)" end="(596, 28)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(596, 29)" end="(596, 75)">
        <OtherNode start="(596, 29)" end="(596, 41)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(596, 29)" end="(596, 41)" kind="str">
            <AtomNode start="(596, 29)" end="(596, 41)" leading="" trailing=" " val="&amp;quot;injections&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(596, 42)" end="(596, 75)" kind="«stx_*»">
          <OtherNode start="(596, 42)" end="(596, 74)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(596, 42)" end="(596, 43)" leading="" trailing="" val="("/>
            <NullNode start="(596, 43)" end="(596, 73)">
              <OtherNode start="(596, 43)" end="(596, 50)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(596, 43)" end="(596, 50)" leading="" trailing=" " raw_val="ppSpace" val="ppSpace" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(596, 51)" end="(596, 56)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(596, 51)" end="(596, 56)" leading="" trailing=" " raw_val="colGt" val="colGt" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(596, 57)" end="(596, 73)" kind="Lean.Parser.Syntax.paren">
                <AtomNode start="(596, 57)" end="(596, 58)" leading="" trailing="" val="("/>
                <NullNode start="(596, 58)" end="(596, 72)">
                  <OtherNode start="(596, 58)" end="(596, 72)" kind="«stx_&amp;lt;|&amp;gt;_»">
                    <OtherNode start="(596, 58)" end="(596, 63)" kind="Lean.Parser.Syntax.cat">
                      <IdentNode start="(596, 58)" end="(596, 63)" leading="" trailing=" " raw_val="ident" val="ident" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(596, 64)" end="(596, 67)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
                    <OtherNode start="(596, 68)" end="(596, 72)" kind="Lean.Parser.Syntax.cat">
                      <IdentNode start="(596, 68)" end="(596, 72)" leading="" trailing="" raw_val="hole" val="hole" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
                <AtomNode start="(596, 72)" end="(596, 73)" leading="" trailing="" val=")"/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(596, 73)" end="(596, 74)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(596, 74)" end="(596, 75)" leading="" trailing=" " val="*"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(596, 76)" end="(596, 77)" leading="" trailing=" " val=":"/>
      <IdentNode start="(596, 78)" end="(596, 84)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(598, 1)" end="(602, 114)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(598, 1)" end="(601, 3)">
        <CommandDoccommentNode start="(598, 1)" end="(601, 3)" comment="The discharger clause of `simp` and related tactics.&#10;This is a tactic used to discharge the side conditions on conditional rewrite rules.&#10;-/">
          <AtomNode start="(598, 1)" end="(598, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(599, 1)" end="(601, 3)" leading="" trailing="&#10;" val="The discharger clause of `simp` and related tactics.&#10;This is a tactic used to discharge the side conditions on conditional rewrite rules.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(602, 1)" end="(602, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(602, 8)" end="(602, 18)" leading="" trailing=" " raw_val="discharger" val="discharger"/>
      <AtomNode start="(602, 19)" end="(602, 21)" leading="" trailing=" " val=":="/>
      <NullNode start="(602, 22)" end="(602, 114)">
        <OtherNode start="(602, 22)" end="(602, 76)" kind="Lean.Parser.Syntax.unary">
          <IdentNode start="(602, 22)" end="(602, 28)" leading="" trailing="" raw_val="atomic" val="atomic"/>
          <AtomNode start="(602, 28)" end="(602, 29)" leading="" trailing="" val="("/>
          <NullNode start="(602, 29)" end="(602, 75)">
            <OtherNode start="(602, 29)" end="(602, 33)" kind="Lean.Parser.Syntax.atom">
              <OtherNode start="(602, 29)" end="(602, 33)" kind="str">
                <AtomNode start="(602, 29)" end="(602, 33)" leading="" trailing=" " val="&amp;quot; (&amp;quot;"/>
              </OtherNode>
            </OtherNode>
            <OtherNode start="(602, 34)" end="(602, 75)" kind="Lean.Parser.Syntax.unary">
              <IdentNode start="(602, 34)" end="(602, 47)" leading="" trailing="" raw_val="patternIgnore" val="patternIgnore"/>
              <AtomNode start="(602, 47)" end="(602, 48)" leading="" trailing="" val="("/>
              <NullNode start="(602, 48)" end="(602, 74)">
                <OtherNode start="(602, 48)" end="(602, 74)" kind="«stx_&amp;lt;|&amp;gt;_»">
                  <OtherNode start="(602, 48)" end="(602, 61)" kind="Lean.Parser.Syntax.nonReserved">
                    <AtomNode start="(602, 48)" end="(602, 49)" leading="" trailing="" val="&amp;amp;"/>
                    <OtherNode start="(602, 49)" end="(602, 61)" kind="str">
                      <AtomNode start="(602, 49)" end="(602, 61)" leading="" trailing=" " val="&amp;quot;discharger&amp;quot;"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(602, 62)" end="(602, 65)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
                  <OtherNode start="(602, 66)" end="(602, 74)" kind="Lean.Parser.Syntax.nonReserved">
                    <AtomNode start="(602, 66)" end="(602, 67)" leading="" trailing="" val="&amp;amp;"/>
                    <OtherNode start="(602, 67)" end="(602, 74)" kind="str">
                      <AtomNode start="(602, 67)" end="(602, 74)" leading="" trailing="" val="&amp;quot;disch&amp;quot;"/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(602, 74)" end="(602, 75)" leading="" trailing="" val=")"/>
            </OtherNode>
          </NullNode>
          <AtomNode start="(602, 75)" end="(602, 76)" leading="" trailing=" " val=")"/>
        </OtherNode>
        <OtherNode start="(602, 77)" end="(602, 83)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(602, 77)" end="(602, 83)" kind="str">
            <AtomNode start="(602, 77)" end="(602, 83)" leading="" trailing=" " val="&amp;quot; := &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(602, 84)" end="(602, 110)" kind="Lean.Parser.Syntax.unary">
          <IdentNode start="(602, 84)" end="(602, 99)" leading="" trailing="" raw_val="withoutPosition" val="withoutPosition"/>
          <AtomNode start="(602, 99)" end="(602, 100)" leading="" trailing="" val="("/>
          <NullNode start="(602, 100)" end="(602, 109)">
            <OtherNode start="(602, 100)" end="(602, 109)" kind="Lean.Parser.Syntax.cat">
              <IdentNode start="(602, 100)" end="(602, 109)" leading="" trailing="" raw_val="tacticSeq" val="tacticSeq" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              <NullNode/>
            </OtherNode>
          </NullNode>
          <AtomNode start="(602, 109)" end="(602, 110)" leading="" trailing=" " val=")"/>
        </OtherNode>
        <OtherNode start="(602, 111)" end="(602, 114)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(602, 111)" end="(602, 114)" kind="str">
            <AtomNode start="(602, 111)" end="(602, 114)" leading="" trailing="&#10;&#10;" val="&amp;quot;)&amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(604, 1)" end="(605, 24)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(604, 1)" end="(604, 58)">
        <CommandDoccommentNode start="(604, 1)" end="(604, 58)" comment="Use this rewrite rule before entering the subterms -/">
          <AtomNode start="(604, 1)" end="(604, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(604, 5)" end="(604, 58)" leading="" trailing="&#10;" val="Use this rewrite rule before entering the subterms -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(605, 1)" end="(605, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(605, 8)" end="(605, 15)" leading="" trailing="   " raw_val="simpPre" val="simpPre"/>
      <AtomNode start="(605, 18)" end="(605, 20)" leading="" trailing=" " val=":="/>
      <NullNode start="(605, 21)" end="(605, 24)">
        <OtherNode start="(605, 21)" end="(605, 24)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(605, 21)" end="(605, 24)" kind="str">
            <AtomNode start="(605, 21)" end="(605, 24)" leading="" trailing="&#10;" val="&amp;quot;↓&amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(606, 1)" end="(607, 24)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(606, 1)" end="(606, 57)">
        <CommandDoccommentNode start="(606, 1)" end="(606, 57)" comment="Use this rewrite rule after entering the subterms -/">
          <AtomNode start="(606, 1)" end="(606, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(606, 5)" end="(606, 57)" leading="" trailing="&#10;" val="Use this rewrite rule after entering the subterms -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(607, 1)" end="(607, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(607, 8)" end="(607, 16)" leading="" trailing="  " raw_val="simpPost" val="simpPost"/>
      <AtomNode start="(607, 18)" end="(607, 20)" leading="" trailing=" " val=":="/>
      <NullNode start="(607, 21)" end="(607, 24)">
        <OtherNode start="(607, 21)" end="(607, 24)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(607, 21)" end="(607, 24)" kind="str">
            <AtomNode start="(607, 21)" end="(607, 24)" leading="" trailing="&#10;" val="&amp;quot;↑&amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(608, 1)" end="(614, 80)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(608, 1)" end="(613, 3)">
        <CommandDoccommentNode start="(608, 1)" end="(613, 3)" comment="A simp lemma specification is:&#10;* optional `↑` or `↓` to specify use before or after entering the subterm&#10;* optional `←` to use the lemma backward&#10;* `thm` for the theorem to rewrite with&#10;-/">
          <AtomNode start="(608, 1)" end="(608, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(609, 1)" end="(613, 3)" leading="" trailing="&#10;" val="A simp lemma specification is:&#10;* optional `↑` or `↓` to specify use before or after entering the subterm&#10;* optional `←` to use the lemma backward&#10;* `thm` for the theorem to rewrite with&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(614, 1)" end="(614, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(614, 8)" end="(614, 17)" leading="" trailing=" " raw_val="simpLemma" val="simpLemma"/>
      <AtomNode start="(614, 18)" end="(614, 20)" leading="" trailing=" " val=":="/>
      <NullNode start="(614, 21)" end="(614, 80)">
        <OtherNode start="(614, 21)" end="(614, 44)" kind="stx_?">
          <OtherNode start="(614, 21)" end="(614, 43)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(614, 21)" end="(614, 22)" leading="" trailing="" val="("/>
            <NullNode start="(614, 22)" end="(614, 42)">
              <OtherNode start="(614, 22)" end="(614, 42)" kind="«stx_&amp;lt;|&amp;gt;_»">
                <OtherNode start="(614, 22)" end="(614, 29)" kind="Lean.Parser.Syntax.cat">
                  <IdentNode start="(614, 22)" end="(614, 29)" leading="" trailing=" " raw_val="simpPre" val="simpPre" full_name="Lean.Parser.Tactic.simpPre" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(605, 8)" def_end="(605, 15)"/>
                  <NullNode/>
                </OtherNode>
                <AtomNode start="(614, 30)" end="(614, 33)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
                <OtherNode start="(614, 34)" end="(614, 42)" kind="Lean.Parser.Syntax.cat">
                  <IdentNode start="(614, 34)" end="(614, 42)" leading="" trailing="" raw_val="simpPost" val="simpPost" full_name="Lean.Parser.Tactic.simpPost" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(607, 8)" def_end="(607, 16)"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(614, 42)" end="(614, 43)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(614, 43)" end="(614, 44)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(614, 45)" end="(614, 75)" kind="stx_?">
          <OtherNode start="(614, 45)" end="(614, 74)" kind="Lean.Parser.Syntax.unary">
            <IdentNode start="(614, 45)" end="(614, 58)" leading="" trailing="" raw_val="patternIgnore" val="patternIgnore"/>
            <AtomNode start="(614, 58)" end="(614, 59)" leading="" trailing="" val="("/>
            <NullNode start="(614, 59)" end="(614, 73)">
              <OtherNode start="(614, 59)" end="(614, 73)" kind="«stx_&amp;lt;|&amp;gt;_»">
                <OtherNode start="(614, 59)" end="(614, 63)" kind="Lean.Parser.Syntax.atom">
                  <OtherNode start="(614, 59)" end="(614, 63)" kind="str">
                    <AtomNode start="(614, 59)" end="(614, 63)" leading="" trailing=" " val="&amp;quot;← &amp;quot;"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(614, 64)" end="(614, 67)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
                <OtherNode start="(614, 68)" end="(614, 73)" kind="Lean.Parser.Syntax.atom">
                  <OtherNode start="(614, 68)" end="(614, 73)" kind="str">
                    <AtomNode start="(614, 68)" end="(614, 73)" leading="" trailing="" val="&amp;quot;&amp;lt;- &amp;quot;"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(614, 73)" end="(614, 74)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(614, 74)" end="(614, 75)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(614, 76)" end="(614, 80)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(614, 76)" end="(614, 80)" leading="" trailing="&#10;" raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(615, 1)" end="(616, 33)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(615, 1)" end="(615, 78)">
        <CommandDoccommentNode start="(615, 1)" end="(615, 78)" comment="An erasure specification `-thm` says to remove `thm` from the simp set -/">
          <AtomNode start="(615, 1)" end="(615, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(615, 5)" end="(615, 78)" leading="" trailing="&#10;" val="An erasure specification `-thm` says to remove `thm` from the simp set -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(616, 1)" end="(616, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(616, 8)" end="(616, 17)" leading="" trailing=" " raw_val="simpErase" val="simpErase"/>
      <AtomNode start="(616, 18)" end="(616, 20)" leading="" trailing=" " val=":="/>
      <NullNode start="(616, 21)" end="(616, 33)">
        <OtherNode start="(616, 21)" end="(616, 24)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(616, 21)" end="(616, 24)" kind="str">
            <AtomNode start="(616, 21)" end="(616, 24)" leading="" trailing=" " val="&amp;quot;-&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(616, 25)" end="(616, 33)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(616, 25)" end="(616, 29)" leading="" trailing="" raw_val="term" val="term" full_name="Lean.Parser.Category.term" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
          <NullNode start="(616, 29)" end="(616, 33)">
            <OtherNode start="(616, 29)" end="(616, 33)" kind="Lean.Parser.precedence">
              <AtomNode start="(616, 29)" end="(616, 30)" leading="" trailing="" val=":"/>
              <OtherNode start="(616, 30)" end="(616, 33)" kind="precMax">
                <AtomNode start="(616, 30)" end="(616, 33)" leading="" trailing="&#10;" val="max"/>
              </OtherNode>
            </OtherNode>
          </NullNode>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(617, 1)" end="(618, 24)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(617, 1)" end="(617, 77)">
        <CommandDoccommentNode start="(617, 1)" end="(617, 77)" comment="The simp lemma specification `*` means to rewrite with all hypotheses -/">
          <AtomNode start="(617, 1)" end="(617, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(617, 5)" end="(617, 77)" leading="" trailing="&#10;" val="The simp lemma specification `*` means to rewrite with all hypotheses -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(618, 1)" end="(618, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(618, 8)" end="(618, 16)" leading="" trailing="  " raw_val="simpStar" val="simpStar"/>
      <AtomNode start="(618, 18)" end="(618, 20)" leading="" trailing=" " val=":="/>
      <NullNode start="(618, 21)" end="(618, 24)">
        <OtherNode start="(618, 21)" end="(618, 24)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(618, 21)" end="(618, 24)" kind="str">
            <AtomNode start="(618, 21)" end="(618, 24)" leading="" trailing="&#10;" val="&amp;quot;*&amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(619, 1)" end="(640, 95)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(619, 1)" end="(638, 3)">
        <CommandDoccommentNode start="(619, 1)" end="(638, 3)" comment="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or&#10;non-dependent hypotheses. It has many variants:&#10;- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.&#10;- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged&#10;  with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions.-&#10;- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated&#10;  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.&#10;- `simp [*]` simplifies the main goal target using the lemmas tagged with the&#10;  attribute `[simp]` and all hypotheses.&#10;- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.&#10;- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged&#10;  with the attribute `[simp]`, but removes the ones named `idᵢ`.&#10;- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If&#10;  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis&#10;  `hᵢ` is introduced, but the old one remains in the local context.&#10;- `simp at *` simplifies all the hypotheses and the target.&#10;- `simp [*] at *` simplifies target and all (propositional) hypotheses using the&#10;  other hypotheses.&#10;-/">
          <AtomNode start="(619, 1)" end="(619, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(620, 1)" end="(638, 3)" leading="" trailing="&#10;" val="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or&#10;non-dependent hypotheses. It has many variants:&#10;- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.&#10;- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged&#10;  with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions.-&#10;- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated&#10;  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.&#10;- `simp [*]` simplifies the main goal target using the lemmas tagged with the&#10;  attribute `[simp]` and all hypotheses.&#10;- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.&#10;- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged&#10;  with the attribute `[simp]`, but removes the ones named `idᵢ`.&#10;- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If&#10;  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis&#10;  `hᵢ` is introduced, but the old one remains in the local context.&#10;- `simp at *` simplifies all the hypotheses and the target.&#10;- `simp [*] at *` simplifies target and all (propositional) hypotheses using the&#10;  other hypotheses.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(639, 1)" end="(639, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(639, 8)" end="(639, 22)">
        <OtherNode start="(639, 8)" end="(639, 22)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(639, 8)" end="(639, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(639, 9)" end="(639, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(639, 14)" end="(639, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(639, 17)" end="(639, 21)" leading="" trailing="" raw_val="simp" val="simp"/>
          <AtomNode start="(639, 21)" end="(639, 22)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(639, 23)" end="(640, 86)">
        <OtherNode start="(639, 23)" end="(639, 29)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(639, 23)" end="(639, 29)" kind="str">
            <AtomNode start="(639, 23)" end="(639, 29)" leading="" trailing=" " val="&amp;quot;simp&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(639, 30)" end="(639, 39)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(639, 30)" end="(639, 39)" leading="" trailing=" " raw_val="optConfig" val="optConfig" full_name="Lean.Parser.Tactic.optConfig" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(458, 8)" def_end="(458, 17)"/>
          <NullNode/>
        </OtherNode>
        <OtherNode start="(639, 40)" end="(639, 53)" kind="stx_?">
          <OtherNode start="(639, 40)" end="(639, 52)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(639, 40)" end="(639, 41)" leading="" trailing="" val="("/>
            <NullNode start="(639, 41)" end="(639, 51)">
              <OtherNode start="(639, 41)" end="(639, 51)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(639, 41)" end="(639, 51)" leading="" trailing="" raw_val="discharger" val="discharger" full_name="Lean.Parser.Tactic.discharger" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(602, 8)" def_end="(602, 18)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(639, 51)" end="(639, 52)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(639, 52)" end="(639, 53)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(639, 54)" end="(639, 65)" kind="stx_?">
          <OtherNode start="(639, 54)" end="(639, 64)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(639, 54)" end="(639, 55)" leading="" trailing="" val="("/>
            <NullNode start="(639, 55)" end="(639, 63)">
              <OtherNode start="(639, 55)" end="(639, 63)" kind="Lean.Parser.Syntax.nonReserved">
                <AtomNode start="(639, 55)" end="(639, 56)" leading="" trailing="" val="&amp;amp;"/>
                <OtherNode start="(639, 56)" end="(639, 63)" kind="str">
                  <AtomNode start="(639, 56)" end="(639, 63)" leading="" trailing="" val="&amp;quot; only&amp;quot;"/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(639, 63)" end="(639, 64)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(639, 64)" end="(639, 65)" leading="" trailing="&#10;  " val="?"/>
        </OtherNode>
        <OtherNode start="(640, 3)" end="(640, 74)" kind="stx_?">
          <OtherNode start="(640, 3)" end="(640, 73)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(640, 3)" end="(640, 4)" leading="" trailing="" val="("/>
            <NullNode start="(640, 4)" end="(640, 72)">
              <OtherNode start="(640, 4)" end="(640, 8)" kind="Lean.Parser.Syntax.atom">
                <OtherNode start="(640, 4)" end="(640, 8)" kind="str">
                  <AtomNode start="(640, 4)" end="(640, 8)" leading="" trailing=" " val="&amp;quot; [&amp;quot;"/>
                </OtherNode>
              </OtherNode>
              <OtherNode start="(640, 9)" end="(640, 68)" kind="Lean.Parser.Syntax.unary">
                <IdentNode start="(640, 9)" end="(640, 24)" leading="" trailing="" raw_val="withoutPosition" val="withoutPosition"/>
                <AtomNode start="(640, 24)" end="(640, 25)" leading="" trailing="" val="("/>
                <NullNode start="(640, 25)" end="(640, 67)">
                  <OtherNode start="(640, 25)" end="(640, 67)" kind="«stx_,*,?»">
                    <OtherNode start="(640, 25)" end="(640, 63)" kind="Lean.Parser.Syntax.paren">
                      <AtomNode start="(640, 25)" end="(640, 26)" leading="" trailing="" val="("/>
                      <NullNode start="(640, 26)" end="(640, 62)">
                        <OtherNode start="(640, 26)" end="(640, 62)" kind="«stx_&amp;lt;|&amp;gt;_»">
                          <OtherNode start="(640, 26)" end="(640, 34)" kind="Lean.Parser.Syntax.cat">
                            <IdentNode start="(640, 26)" end="(640, 34)" leading="" trailing=" " raw_val="simpStar" val="simpStar" full_name="Lean.Parser.Tactic.simpStar" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(618, 8)" def_end="(618, 16)"/>
                            <NullNode/>
                          </OtherNode>
                          <AtomNode start="(640, 35)" end="(640, 38)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
                          <OtherNode start="(640, 39)" end="(640, 62)" kind="«stx_&amp;lt;|&amp;gt;_»">
                            <OtherNode start="(640, 39)" end="(640, 48)" kind="Lean.Parser.Syntax.cat">
                              <IdentNode start="(640, 39)" end="(640, 48)" leading="" trailing=" " raw_val="simpErase" val="simpErase" full_name="Lean.Parser.Tactic.simpErase" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(616, 8)" def_end="(616, 17)"/>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(640, 49)" end="(640, 52)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
                            <OtherNode start="(640, 53)" end="(640, 62)" kind="Lean.Parser.Syntax.cat">
                              <IdentNode start="(640, 53)" end="(640, 62)" leading="" trailing="" raw_val="simpLemma" val="simpLemma" full_name="Lean.Parser.Tactic.simpLemma" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(614, 8)" def_end="(614, 17)"/>
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(640, 62)" end="(640, 63)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(640, 63)" end="(640, 67)" leading="" trailing="" val=",*,?"/>
                  </OtherNode>
                </NullNode>
                <AtomNode start="(640, 67)" end="(640, 68)" leading="" trailing=" " val=")"/>
              </OtherNode>
              <OtherNode start="(640, 69)" end="(640, 72)" kind="Lean.Parser.Syntax.atom">
                <OtherNode start="(640, 69)" end="(640, 72)" kind="str">
                  <AtomNode start="(640, 69)" end="(640, 72)" leading="" trailing="" val="&amp;quot;]&amp;quot;"/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(640, 72)" end="(640, 73)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(640, 73)" end="(640, 74)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(640, 75)" end="(640, 86)" kind="stx_?">
          <OtherNode start="(640, 75)" end="(640, 85)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(640, 75)" end="(640, 76)" leading="" trailing="" val="("/>
            <NullNode start="(640, 76)" end="(640, 84)">
              <OtherNode start="(640, 76)" end="(640, 84)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(640, 76)" end="(640, 84)" leading="" trailing="" raw_val="location" val="location" full_name="Lean.Parser.Tactic.location" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(484, 8)" def_end="(484, 16)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(640, 84)" end="(640, 85)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(640, 85)" end="(640, 86)" leading="" trailing=" " val="?"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(640, 87)" end="(640, 88)" leading="" trailing=" " val=":"/>
      <IdentNode start="(640, 89)" end="(640, 95)" leading="" trailing="&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(641, 1)" end="(647, 70)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(641, 1)" end="(645, 3)">
        <CommandDoccommentNode start="(641, 1)" end="(645, 3)" comment="`simp_all` is a stronger version of `simp [*] at *` where the hypotheses and target&#10;are simplified multiple times until no simplification is applicable.&#10;Only non-dependent propositional hypotheses are considered.&#10;-/">
          <AtomNode start="(641, 1)" end="(641, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(642, 1)" end="(645, 3)" leading="" trailing="&#10;" val="`simp_all` is a stronger version of `simp [*] at *` where the hypotheses and target&#10;are simplified multiple times until no simplification is applicable.&#10;Only non-dependent propositional hypotheses are considered.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(646, 1)" end="(646, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(646, 8)" end="(646, 25)">
        <OtherNode start="(646, 8)" end="(646, 25)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(646, 8)" end="(646, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(646, 9)" end="(646, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(646, 14)" end="(646, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(646, 17)" end="(646, 24)" leading="" trailing="" raw_val="simpAll" val="simpAll"/>
          <AtomNode start="(646, 24)" end="(646, 25)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(646, 26)" end="(647, 61)">
        <OtherNode start="(646, 26)" end="(646, 36)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(646, 26)" end="(646, 36)" kind="str">
            <AtomNode start="(646, 26)" end="(646, 36)" leading="" trailing=" " val="&amp;quot;simp_all&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(646, 37)" end="(646, 46)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(646, 37)" end="(646, 46)" leading="" trailing=" " raw_val="optConfig" val="optConfig" full_name="Lean.Parser.Tactic.optConfig" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(458, 8)" def_end="(458, 17)"/>
          <NullNode/>
        </OtherNode>
        <OtherNode start="(646, 47)" end="(646, 60)" kind="stx_?">
          <OtherNode start="(646, 47)" end="(646, 59)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(646, 47)" end="(646, 48)" leading="" trailing="" val="("/>
            <NullNode start="(646, 48)" end="(646, 58)">
              <OtherNode start="(646, 48)" end="(646, 58)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(646, 48)" end="(646, 58)" leading="" trailing="" raw_val="discharger" val="discharger" full_name="Lean.Parser.Tactic.discharger" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(602, 8)" def_end="(602, 18)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(646, 58)" end="(646, 59)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(646, 59)" end="(646, 60)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(646, 61)" end="(646, 72)" kind="stx_?">
          <OtherNode start="(646, 61)" end="(646, 71)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(646, 61)" end="(646, 62)" leading="" trailing="" val="("/>
            <NullNode start="(646, 62)" end="(646, 70)">
              <OtherNode start="(646, 62)" end="(646, 70)" kind="Lean.Parser.Syntax.nonReserved">
                <AtomNode start="(646, 62)" end="(646, 63)" leading="" trailing="" val="&amp;amp;"/>
                <OtherNode start="(646, 63)" end="(646, 70)" kind="str">
                  <AtomNode start="(646, 63)" end="(646, 70)" leading="" trailing="" val="&amp;quot; only&amp;quot;"/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(646, 70)" end="(646, 71)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(646, 71)" end="(646, 72)" leading="" trailing="&#10;  " val="?"/>
        </OtherNode>
        <OtherNode start="(647, 3)" end="(647, 61)" kind="stx_?">
          <OtherNode start="(647, 3)" end="(647, 60)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(647, 3)" end="(647, 4)" leading="" trailing="" val="("/>
            <NullNode start="(647, 4)" end="(647, 59)">
              <OtherNode start="(647, 4)" end="(647, 8)" kind="Lean.Parser.Syntax.atom">
                <OtherNode start="(647, 4)" end="(647, 8)" kind="str">
                  <AtomNode start="(647, 4)" end="(647, 8)" leading="" trailing=" " val="&amp;quot; [&amp;quot;"/>
                </OtherNode>
              </OtherNode>
              <OtherNode start="(647, 9)" end="(647, 55)" kind="Lean.Parser.Syntax.unary">
                <IdentNode start="(647, 9)" end="(647, 24)" leading="" trailing="" raw_val="withoutPosition" val="withoutPosition"/>
                <AtomNode start="(647, 24)" end="(647, 25)" leading="" trailing="" val="("/>
                <NullNode start="(647, 25)" end="(647, 54)">
                  <OtherNode start="(647, 25)" end="(647, 54)" kind="«stx_,*,?»">
                    <OtherNode start="(647, 25)" end="(647, 50)" kind="Lean.Parser.Syntax.paren">
                      <AtomNode start="(647, 25)" end="(647, 26)" leading="" trailing="" val="("/>
                      <NullNode start="(647, 26)" end="(647, 49)">
                        <OtherNode start="(647, 26)" end="(647, 49)" kind="«stx_&amp;lt;|&amp;gt;_»">
                          <OtherNode start="(647, 26)" end="(647, 35)" kind="Lean.Parser.Syntax.cat">
                            <IdentNode start="(647, 26)" end="(647, 35)" leading="" trailing=" " raw_val="simpErase" val="simpErase" full_name="Lean.Parser.Tactic.simpErase" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(616, 8)" def_end="(616, 17)"/>
                            <NullNode/>
                          </OtherNode>
                          <AtomNode start="(647, 36)" end="(647, 39)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
                          <OtherNode start="(647, 40)" end="(647, 49)" kind="Lean.Parser.Syntax.cat">
                            <IdentNode start="(647, 40)" end="(647, 49)" leading="" trailing="" raw_val="simpLemma" val="simpLemma" full_name="Lean.Parser.Tactic.simpLemma" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(614, 8)" def_end="(614, 17)"/>
                            <NullNode/>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(647, 49)" end="(647, 50)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(647, 50)" end="(647, 54)" leading="" trailing="" val=",*,?"/>
                  </OtherNode>
                </NullNode>
                <AtomNode start="(647, 54)" end="(647, 55)" leading="" trailing=" " val=")"/>
              </OtherNode>
              <OtherNode start="(647, 56)" end="(647, 59)" kind="Lean.Parser.Syntax.atom">
                <OtherNode start="(647, 56)" end="(647, 59)" kind="str">
                  <AtomNode start="(647, 56)" end="(647, 59)" leading="" trailing="" val="&amp;quot;]&amp;quot;"/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(647, 59)" end="(647, 60)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(647, 60)" end="(647, 61)" leading="" trailing=" " val="?"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(647, 62)" end="(647, 63)" leading="" trailing=" " val=":"/>
      <IdentNode start="(647, 64)" end="(647, 70)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(649, 1)" end="(655, 82)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(649, 1)" end="(653, 3)">
        <CommandDoccommentNode start="(649, 1)" end="(653, 3)" comment="The `dsimp` tactic is the definitional simplifier. It is similar to `simp` but only&#10;applies theorems that hold by reflexivity. Thus, the result is guaranteed to be&#10;definitionally equal to the input.&#10;-/">
          <AtomNode start="(649, 1)" end="(649, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(650, 1)" end="(653, 3)" leading="" trailing="&#10;" val="The `dsimp` tactic is the definitional simplifier. It is similar to `simp` but only&#10;applies theorems that hold by reflexivity. Thus, the result is guaranteed to be&#10;definitionally equal to the input.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(654, 1)" end="(654, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(654, 8)" end="(654, 23)">
        <OtherNode start="(654, 8)" end="(654, 23)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(654, 8)" end="(654, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(654, 9)" end="(654, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(654, 14)" end="(654, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(654, 17)" end="(654, 22)" leading="" trailing="" raw_val="dsimp" val="dsimp"/>
          <AtomNode start="(654, 22)" end="(654, 23)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(654, 24)" end="(655, 73)">
        <OtherNode start="(654, 24)" end="(654, 31)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(654, 24)" end="(654, 31)" kind="str">
            <AtomNode start="(654, 24)" end="(654, 31)" leading="" trailing=" " val="&amp;quot;dsimp&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(654, 32)" end="(654, 41)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(654, 32)" end="(654, 41)" leading="" trailing=" " raw_val="optConfig" val="optConfig" full_name="Lean.Parser.Tactic.optConfig" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(458, 8)" def_end="(458, 17)"/>
          <NullNode/>
        </OtherNode>
        <OtherNode start="(654, 42)" end="(654, 55)" kind="stx_?">
          <OtherNode start="(654, 42)" end="(654, 54)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(654, 42)" end="(654, 43)" leading="" trailing="" val="("/>
            <NullNode start="(654, 43)" end="(654, 53)">
              <OtherNode start="(654, 43)" end="(654, 53)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(654, 43)" end="(654, 53)" leading="" trailing="" raw_val="discharger" val="discharger" full_name="Lean.Parser.Tactic.discharger" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(602, 8)" def_end="(602, 18)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(654, 53)" end="(654, 54)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(654, 54)" end="(654, 55)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(654, 56)" end="(654, 67)" kind="stx_?">
          <OtherNode start="(654, 56)" end="(654, 66)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(654, 56)" end="(654, 57)" leading="" trailing="" val="("/>
            <NullNode start="(654, 57)" end="(654, 65)">
              <OtherNode start="(654, 57)" end="(654, 65)" kind="Lean.Parser.Syntax.nonReserved">
                <AtomNode start="(654, 57)" end="(654, 58)" leading="" trailing="" val="&amp;amp;"/>
                <OtherNode start="(654, 58)" end="(654, 65)" kind="str">
                  <AtomNode start="(654, 58)" end="(654, 65)" leading="" trailing="" val="&amp;quot; only&amp;quot;"/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(654, 65)" end="(654, 66)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(654, 66)" end="(654, 67)" leading="" trailing="&#10;  " val="?"/>
        </OtherNode>
        <OtherNode start="(655, 3)" end="(655, 61)" kind="stx_?">
          <OtherNode start="(655, 3)" end="(655, 60)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(655, 3)" end="(655, 4)" leading="" trailing="" val="("/>
            <NullNode start="(655, 4)" end="(655, 59)">
              <OtherNode start="(655, 4)" end="(655, 8)" kind="Lean.Parser.Syntax.atom">
                <OtherNode start="(655, 4)" end="(655, 8)" kind="str">
                  <AtomNode start="(655, 4)" end="(655, 8)" leading="" trailing=" " val="&amp;quot; [&amp;quot;"/>
                </OtherNode>
              </OtherNode>
              <OtherNode start="(655, 9)" end="(655, 55)" kind="Lean.Parser.Syntax.unary">
                <IdentNode start="(655, 9)" end="(655, 24)" leading="" trailing="" raw_val="withoutPosition" val="withoutPosition"/>
                <AtomNode start="(655, 24)" end="(655, 25)" leading="" trailing="" val="("/>
                <NullNode start="(655, 25)" end="(655, 54)">
                  <OtherNode start="(655, 25)" end="(655, 54)" kind="«stx_,*,?»">
                    <OtherNode start="(655, 25)" end="(655, 50)" kind="Lean.Parser.Syntax.paren">
                      <AtomNode start="(655, 25)" end="(655, 26)" leading="" trailing="" val="("/>
                      <NullNode start="(655, 26)" end="(655, 49)">
                        <OtherNode start="(655, 26)" end="(655, 49)" kind="«stx_&amp;lt;|&amp;gt;_»">
                          <OtherNode start="(655, 26)" end="(655, 35)" kind="Lean.Parser.Syntax.cat">
                            <IdentNode start="(655, 26)" end="(655, 35)" leading="" trailing=" " raw_val="simpErase" val="simpErase" full_name="Lean.Parser.Tactic.simpErase" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(616, 8)" def_end="(616, 17)"/>
                            <NullNode/>
                          </OtherNode>
                          <AtomNode start="(655, 36)" end="(655, 39)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
                          <OtherNode start="(655, 40)" end="(655, 49)" kind="Lean.Parser.Syntax.cat">
                            <IdentNode start="(655, 40)" end="(655, 49)" leading="" trailing="" raw_val="simpLemma" val="simpLemma" full_name="Lean.Parser.Tactic.simpLemma" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(614, 8)" def_end="(614, 17)"/>
                            <NullNode/>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                      <AtomNode start="(655, 49)" end="(655, 50)" leading="" trailing="" val=")"/>
                    </OtherNode>
                    <AtomNode start="(655, 50)" end="(655, 54)" leading="" trailing="" val=",*,?"/>
                  </OtherNode>
                </NullNode>
                <AtomNode start="(655, 54)" end="(655, 55)" leading="" trailing=" " val=")"/>
              </OtherNode>
              <OtherNode start="(655, 56)" end="(655, 59)" kind="Lean.Parser.Syntax.atom">
                <OtherNode start="(655, 56)" end="(655, 59)" kind="str">
                  <AtomNode start="(655, 56)" end="(655, 59)" leading="" trailing="" val="&amp;quot;]&amp;quot;"/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(655, 59)" end="(655, 60)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(655, 60)" end="(655, 61)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(655, 62)" end="(655, 73)" kind="stx_?">
          <OtherNode start="(655, 62)" end="(655, 72)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(655, 62)" end="(655, 63)" leading="" trailing="" val="("/>
            <NullNode start="(655, 63)" end="(655, 71)">
              <OtherNode start="(655, 63)" end="(655, 71)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(655, 63)" end="(655, 71)" leading="" trailing="" raw_val="location" val="location" full_name="Lean.Parser.Tactic.location" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(484, 8)" def_end="(484, 16)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(655, 71)" end="(655, 72)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(655, 72)" end="(655, 73)" leading="" trailing=" " val="?"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(655, 74)" end="(655, 75)" leading="" trailing=" " val=":"/>
      <IdentNode start="(655, 76)" end="(655, 82)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <CommandDeclarationNode start="(657, 1)" end="(661, 76)" name="simpArg" full_name="Lean.Parser.Tactic.simpArg">
      <CommandDeclmodifiersNode start="(657, 1)" end="(660, 3)">
        <NullNode start="(657, 1)" end="(660, 3)">
          <CommandDoccommentNode start="(657, 1)" end="(660, 3)" comment="A `simpArg` is either a `*`, `-lemma` or a simp lemma specification&#10;(which includes the `↑` `↓` `←` specifications for pre, post, reverse rewriting).&#10;-/">
            <AtomNode start="(657, 1)" end="(657, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(658, 1)" end="(660, 3)" leading="" trailing="&#10;" val="A `simpArg` is either a `*`, `-lemma` or a simp lemma specification&#10;(which includes the `↑` `↓` `←` specifications for pre, post, reverse rewriting).&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(661, 1)" end="(661, 76)" name="simpArg">
        <AtomNode start="(661, 1)" end="(661, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(661, 5)" end="(661, 12)">
          <IdentNode start="(661, 5)" end="(661, 12)" leading="" trailing=" " raw_val="simpArg" val="simpArg"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(661, 13)" end="(661, 76)">
          <AtomNode start="(661, 13)" end="(661, 15)" leading="" trailing=" " val=":="/>
          <OtherNode start="(661, 16)" end="(661, 76)" kind="Lean.Parser.Term.app">
            <IdentNode start="(661, 16)" end="(661, 31)" leading="" trailing=" " raw_val="simpStar.binary" val="simpStar.binary"/>
            <NullNode start="(661, 32)" end="(661, 76)">
              <OtherNode start="(661, 32)" end="(661, 39)" kind="Lean.Parser.Term.quotedName">
                <OtherNode start="(661, 32)" end="(661, 39)" kind="name">
                  <AtomNode start="(661, 32)" end="(661, 39)" leading="" trailing=" " val="`orelse"/>
                </OtherNode>
              </OtherNode>
              <OtherNode start="(661, 40)" end="(661, 76)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(661, 40)" end="(661, 41)" leading="" trailing="" val="("/>
                <OtherNode start="(661, 41)" end="(661, 75)" kind="Lean.Parser.Term.app">
                  <IdentNode start="(661, 41)" end="(661, 57)" leading="" trailing=" " raw_val="simpErase.binary" val="simpErase.binary"/>
                  <NullNode start="(661, 58)" end="(661, 75)">
                    <OtherNode start="(661, 58)" end="(661, 65)" kind="Lean.Parser.Term.quotedName">
                      <OtherNode start="(661, 58)" end="(661, 65)" kind="name">
                        <AtomNode start="(661, 58)" end="(661, 65)" leading="" trailing=" " val="`orelse"/>
                      </OtherNode>
                    </OtherNode>
                    <IdentNode start="(661, 66)" end="(661, 75)" leading="" trailing="" raw_val="simpLemma" val="simpLemma" full_name="Lean.Parser.Tactic.simpLemma" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(614, 8)" def_end="(614, 17)"/>
                  </NullNode>
                </OtherNode>
                <AtomNode start="(661, 75)" end="(661, 76)" leading="" trailing="&#10;&#10;" val=")"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <OtherNode start="(663, 1)" end="(664, 38)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(663, 1)" end="(663, 85)">
        <CommandDoccommentNode start="(663, 1)" end="(663, 85)" comment="A simp args list is a list of `simpArg`. This is the main argument to `simp`. -/">
          <AtomNode start="(663, 1)" end="(663, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(663, 5)" end="(663, 85)" leading="" trailing="&#10;" val="A simp args list is a list of `simpArg`. This is the main argument to `simp`. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(664, 1)" end="(664, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(664, 8)" end="(664, 16)" leading="" trailing=" " raw_val="simpArgs" val="simpArgs"/>
      <AtomNode start="(664, 17)" end="(664, 19)" leading="" trailing=" " val=":="/>
      <NullNode start="(664, 20)" end="(664, 38)">
        <OtherNode start="(664, 20)" end="(664, 24)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(664, 20)" end="(664, 24)" kind="str">
            <AtomNode start="(664, 20)" end="(664, 24)" leading="" trailing=" " val="&amp;quot; [&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(664, 25)" end="(664, 34)" kind="«stx_,*»">
          <OtherNode start="(664, 25)" end="(664, 32)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(664, 25)" end="(664, 32)" leading="" trailing="" raw_val="simpArg" val="simpArg" full_name="Lean.Parser.Tactic.simpArg" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(661, 5)" def_end="(661, 12)"/>
            <NullNode/>
          </OtherNode>
          <AtomNode start="(664, 32)" end="(664, 34)" leading="" trailing=" " val=",*"/>
        </OtherNode>
        <OtherNode start="(664, 35)" end="(664, 38)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(664, 35)" end="(664, 38)" kind="str">
            <AtomNode start="(664, 35)" end="(664, 38)" leading="" trailing="&#10;&#10;" val="&amp;quot;]&amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <CommandDeclarationNode start="(666, 1)" end="(670, 51)" name="dsimpArg" full_name="Lean.Parser.Tactic.dsimpArg">
      <CommandDeclmodifiersNode start="(666, 1)" end="(669, 3)">
        <NullNode start="(666, 1)" end="(669, 3)">
          <CommandDoccommentNode start="(666, 1)" end="(669, 3)" comment="A `dsimpArg` is similar to `simpArg`, but it does not have the `simpStar` form&#10;because it does not make sense to use hypotheses in `dsimp`.&#10;-/">
            <AtomNode start="(666, 1)" end="(666, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(667, 1)" end="(669, 3)" leading="" trailing="&#10;" val="A `dsimpArg` is similar to `simpArg`, but it does not have the `simpStar` form&#10;because it does not make sense to use hypotheses in `dsimp`.&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandDefinitionNode start="(670, 1)" end="(670, 51)" name="dsimpArg">
        <AtomNode start="(670, 1)" end="(670, 4)" leading="" trailing=" " val="def"/>
        <CommandDeclidNode start="(670, 5)" end="(670, 13)">
          <IdentNode start="(670, 5)" end="(670, 13)" leading="" trailing=" " raw_val="dsimpArg" val="dsimpArg"/>
          <NullNode/>
        </CommandDeclidNode>
        <OtherNode kind="Lean.Parser.Command.optDeclSig">
          <NullNode/>
          <NullNode/>
        </OtherNode>
        <CommandDeclvalsimpleNode start="(670, 14)" end="(670, 51)">
          <AtomNode start="(670, 14)" end="(670, 16)" leading="" trailing=" " val=":="/>
          <OtherNode start="(670, 17)" end="(670, 51)" kind="Lean.Parser.Term.app">
            <IdentNode start="(670, 17)" end="(670, 33)" leading="" trailing=" " raw_val="simpErase.binary" val="simpErase.binary"/>
            <NullNode start="(670, 34)" end="(670, 51)">
              <OtherNode start="(670, 34)" end="(670, 41)" kind="Lean.Parser.Term.quotedName">
                <OtherNode start="(670, 34)" end="(670, 41)" kind="name">
                  <AtomNode start="(670, 34)" end="(670, 41)" leading="" trailing=" " val="`orelse"/>
                </OtherNode>
              </OtherNode>
              <IdentNode start="(670, 42)" end="(670, 51)" leading="" trailing="&#10;&#10;" raw_val="simpLemma" val="simpLemma" full_name="Lean.Parser.Tactic.simpLemma" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(614, 8)" def_end="(614, 17)"/>
            </NullNode>
          </OtherNode>
          <OtherNode kind="Lean.Parser.Termination.suffix">
            <NullNode/>
            <NullNode/>
          </OtherNode>
          <NullNode/>
        </CommandDeclvalsimpleNode>
        <NullNode/>
      </CommandDefinitionNode>
    </CommandDeclarationNode>
    <OtherNode start="(672, 1)" end="(673, 40)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(672, 1)" end="(672, 88)">
        <CommandDoccommentNode start="(672, 1)" end="(672, 88)" comment="A dsimp args list is a list of `dsimpArg`. This is the main argument to `dsimp`. -/">
          <AtomNode start="(672, 1)" end="(672, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(672, 5)" end="(672, 88)" leading="" trailing="&#10;" val="A dsimp args list is a list of `dsimpArg`. This is the main argument to `dsimp`. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(673, 1)" end="(673, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(673, 8)" end="(673, 17)" leading="" trailing=" " raw_val="dsimpArgs" val="dsimpArgs"/>
      <AtomNode start="(673, 18)" end="(673, 20)" leading="" trailing=" " val=":="/>
      <NullNode start="(673, 21)" end="(673, 40)">
        <OtherNode start="(673, 21)" end="(673, 25)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(673, 21)" end="(673, 25)" kind="str">
            <AtomNode start="(673, 21)" end="(673, 25)" leading="" trailing=" " val="&amp;quot; [&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(673, 26)" end="(673, 36)" kind="«stx_,*»">
          <OtherNode start="(673, 26)" end="(673, 34)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(673, 26)" end="(673, 34)" leading="" trailing="" raw_val="dsimpArg" val="dsimpArg" full_name="Lean.Parser.Tactic.dsimpArg" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(670, 5)" def_end="(670, 13)"/>
            <NullNode/>
          </OtherNode>
          <AtomNode start="(673, 34)" end="(673, 36)" leading="" trailing=" " val=",*"/>
        </OtherNode>
        <OtherNode start="(673, 37)" end="(673, 40)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(673, 37)" end="(673, 40)" kind="str">
            <AtomNode start="(673, 37)" end="(673, 40)" leading="" trailing="&#10;&#10;" val="&amp;quot;]&amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(675, 1)" end="(676, 96)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(675, 1)" end="(675, 53)">
        <CommandDoccommentNode start="(675, 1)" end="(675, 53)" comment="The common arguments of `simp?` and `simp?!`. -/">
          <AtomNode start="(675, 1)" end="(675, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(675, 5)" end="(675, 53)" leading="" trailing="&#10;" val="The common arguments of `simp?` and `simp?!`. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(676, 1)" end="(676, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(676, 8)" end="(676, 25)" leading="" trailing=" " raw_val="simpTraceArgsRest" val="simpTraceArgsRest"/>
      <AtomNode start="(676, 26)" end="(676, 28)" leading="" trailing=" " val=":="/>
      <NullNode start="(676, 29)" end="(676, 96)">
        <OtherNode start="(676, 29)" end="(676, 38)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(676, 29)" end="(676, 38)" leading="" trailing=" " raw_val="optConfig" val="optConfig" full_name="Lean.Parser.Tactic.optConfig" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(458, 8)" def_end="(458, 17)"/>
          <NullNode/>
        </OtherNode>
        <OtherNode start="(676, 39)" end="(676, 52)" kind="stx_?">
          <OtherNode start="(676, 39)" end="(676, 51)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(676, 39)" end="(676, 40)" leading="" trailing="" val="("/>
            <NullNode start="(676, 40)" end="(676, 50)">
              <OtherNode start="(676, 40)" end="(676, 50)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(676, 40)" end="(676, 50)" leading="" trailing="" raw_val="discharger" val="discharger" full_name="Lean.Parser.Tactic.discharger" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(602, 8)" def_end="(602, 18)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(676, 50)" end="(676, 51)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(676, 51)" end="(676, 52)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(676, 53)" end="(676, 64)" kind="stx_?">
          <OtherNode start="(676, 53)" end="(676, 63)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(676, 53)" end="(676, 54)" leading="" trailing="" val="("/>
            <NullNode start="(676, 54)" end="(676, 62)">
              <OtherNode start="(676, 54)" end="(676, 62)" kind="Lean.Parser.Syntax.nonReserved">
                <AtomNode start="(676, 54)" end="(676, 55)" leading="" trailing="" val="&amp;amp;"/>
                <OtherNode start="(676, 55)" end="(676, 62)" kind="str">
                  <AtomNode start="(676, 55)" end="(676, 62)" leading="" trailing="" val="&amp;quot; only&amp;quot;"/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(676, 62)" end="(676, 63)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(676, 63)" end="(676, 64)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(676, 65)" end="(676, 76)" kind="stx_?">
          <OtherNode start="(676, 65)" end="(676, 75)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(676, 65)" end="(676, 66)" leading="" trailing="" val="("/>
            <NullNode start="(676, 66)" end="(676, 74)">
              <OtherNode start="(676, 66)" end="(676, 74)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(676, 66)" end="(676, 74)" leading="" trailing="" raw_val="simpArgs" val="simpArgs" full_name="Lean.Parser.Tactic.simpArgs" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(664, 8)" def_end="(664, 16)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(676, 74)" end="(676, 75)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(676, 75)" end="(676, 76)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(676, 77)" end="(676, 96)" kind="stx_?">
          <OtherNode start="(676, 77)" end="(676, 95)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(676, 77)" end="(676, 78)" leading="" trailing="" val="("/>
            <NullNode start="(676, 78)" end="(676, 94)">
              <OtherNode start="(676, 78)" end="(676, 85)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(676, 78)" end="(676, 85)" leading="" trailing=" " raw_val="ppSpace" val="ppSpace" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(676, 86)" end="(676, 94)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(676, 86)" end="(676, 94)" leading="" trailing="" raw_val="location" val="location" full_name="Lean.Parser.Tactic.location" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(484, 8)" def_end="(484, 16)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(676, 94)" end="(676, 95)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(676, 95)" end="(676, 96)" leading="" trailing="&#10;&#10;" val="?"/>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(678, 1)" end="(689, 67)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(678, 1)" end="(688, 3)">
        <CommandDoccommentNode start="(678, 1)" end="(688, 3)" comment="`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`&#10;that would be sufficient to close the goal. This is useful for reducing the size of the simp&#10;set in a local invocation to speed up processing.&#10;```&#10;example (x : Nat) : (if True then x + 2 else 3) = x + 2 := by&#10;  simp? -- prints &amp;quot;Try this: simp only [ite_true]&amp;quot;&#10;```&#10;&#10;This command can also be used in `simp_all` and `dsimp`.&#10;-/">
          <AtomNode start="(678, 1)" end="(678, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(679, 1)" end="(688, 3)" leading="" trailing="&#10;" val="`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`&#10;that would be sufficient to close the goal. This is useful for reducing the size of the simp&#10;set in a local invocation to speed up processing.&#10;```&#10;example (x : Nat) : (if True then x + 2 else 3) = x + 2 := by&#10;  simp? -- prints &amp;quot;Try this: simp only [ite_true]&amp;quot;&#10;```&#10;&#10;This command can also be used in `simp_all` and `dsimp`.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(689, 1)" end="(689, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(689, 8)" end="(689, 27)">
        <OtherNode start="(689, 8)" end="(689, 27)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(689, 8)" end="(689, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(689, 9)" end="(689, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(689, 14)" end="(689, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(689, 17)" end="(689, 26)" leading="" trailing="" raw_val="simpTrace" val="simpTrace"/>
          <AtomNode start="(689, 26)" end="(689, 27)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(689, 28)" end="(689, 58)">
        <OtherNode start="(689, 28)" end="(689, 35)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(689, 28)" end="(689, 35)" kind="str">
            <AtomNode start="(689, 28)" end="(689, 35)" leading="" trailing=" " val="&amp;quot;simp?&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(689, 36)" end="(689, 40)" kind="stx_?">
          <OtherNode start="(689, 36)" end="(689, 39)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(689, 36)" end="(689, 39)" kind="str">
              <AtomNode start="(689, 36)" end="(689, 39)" leading="" trailing="" val="&amp;quot;!&amp;quot;"/>
            </OtherNode>
          </OtherNode>
          <AtomNode start="(689, 39)" end="(689, 40)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(689, 41)" end="(689, 58)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(689, 41)" end="(689, 58)" leading="" trailing=" " raw_val="simpTraceArgsRest" val="simpTraceArgsRest" full_name="Lean.Parser.Tactic.simpTraceArgsRest" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(676, 8)" def_end="(676, 25)"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(689, 59)" end="(689, 60)" leading="" trailing=" " val=":"/>
      <IdentNode start="(689, 61)" end="(689, 67)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(691, 1)" end="(692, 82)" kind="Lean.Parser.Command.macro">
      <NullNode/>
      <NullNode start="(691, 1)" end="(691, 25)">
        <OtherNode start="(691, 1)" end="(691, 25)" kind="Lean.Parser.Term.attributes">
          <AtomNode start="(691, 1)" end="(691, 3)" leading="" trailing="" val="@["/>
          <NullNode start="(691, 3)" end="(691, 24)">
            <OtherNode start="(691, 3)" end="(691, 24)" kind="Lean.Parser.Term.attrInstance">
              <TermAttrkindNode>
                <NullNode/>
              </TermAttrkindNode>
              <OtherNode start="(691, 3)" end="(691, 24)" kind="Lean.Parser.Attr.simple">
                <IdentNode start="(691, 3)" end="(691, 14)" leading="" trailing=" " raw_val="inherit_doc" val="inherit_doc"/>
                <NullNode start="(691, 15)" end="(691, 24)">
                  <IdentNode start="(691, 15)" end="(691, 24)" leading="" trailing="" raw_val="simpTrace" val="simpTrace" full_name="Lean.Parser.Tactic.simpTrace" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(689, 17)" def_end="(689, 26)"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </NullNode>
          <AtomNode start="(691, 24)" end="(691, 25)" leading="" trailing="&#10;" val="]"/>
        </OtherNode>
      </NullNode>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(692, 1)" end="(692, 6)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(692, 7)" end="(692, 41)">
        <OtherNode start="(692, 7)" end="(692, 18)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(692, 7)" end="(692, 10)">
            <IdentNode start="(692, 7)" end="(692, 9)" leading="" trailing="" raw_val="tk" val="tk"/>
            <AtomNode start="(692, 9)" end="(692, 10)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(692, 10)" end="(692, 18)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(692, 10)" end="(692, 18)" kind="str">
              <AtomNode start="(692, 10)" end="(692, 18)" leading="" trailing=" " val="&amp;quot;simp?!&amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(692, 19)" end="(692, 41)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(692, 19)" end="(692, 24)">
            <IdentNode start="(692, 19)" end="(692, 23)" leading="" trailing="" raw_val="rest" val="rest"/>
            <AtomNode start="(692, 23)" end="(692, 24)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(692, 24)" end="(692, 41)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(692, 24)" end="(692, 41)" leading="" trailing=" " raw_val="simpTraceArgsRest" val="simpTraceArgsRest" full_name="Lean.Parser.Tactic.simpTraceArgsRest" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(676, 8)" def_end="(676, 25)"/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(692, 42)" end="(692, 82)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(692, 42)" end="(692, 43)" leading="" trailing=" " val=":"/>
        <IdentNode start="(692, 44)" end="(692, 50)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(692, 51)" end="(692, 53)" leading="" trailing=" " val="=&amp;gt;"/>
        <OtherNode start="(692, 54)" end="(692, 82)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(692, 54)" end="(692, 82)" kind="Lean.Parser.Tactic.quot">
            <AtomNode start="(692, 54)" end="(692, 63)" leading="" trailing=" " val="`(tactic|"/>
            <OtherNode start="(692, 64)" end="(692, 81)" kind="Lean.Parser.Tactic.simpTrace">
              <TokenAntiquotNode start="(692, 64)" end="(692, 73)">
                <AtomNode start="(692, 64)" end="(692, 69)" leading="" trailing="" val="simp?"/>
                <AtomNode start="(692, 69)" end="(692, 70)" leading="" trailing="" val="%"/>
                <AtomNode start="(692, 70)" end="(692, 71)" leading="" trailing="" val="$"/>
                <IdentNode start="(692, 71)" end="(692, 73)" leading="" trailing=" " raw_val="tk" val="tk"/>
              </TokenAntiquotNode>
              <NullNode start="(692, 74)" end="(692, 75)">
                <AtomNode start="(692, 74)" end="(692, 75)" leading="" trailing=" " val="!"/>
              </NullNode>
              <OtherNode start="(692, 76)" end="(692, 81)" kind="Lean.Parser.Tactic.simpTraceArgsRest.antiquot">
                <AtomNode start="(692, 76)" end="(692, 77)" leading="" trailing="" val="$"/>
                <NullNode/>
                <IdentNode start="(692, 77)" end="(692, 81)" leading="" trailing="" raw_val="rest" val="rest"/>
                <NullNode/>
              </OtherNode>
            </OtherNode>
            <AtomNode start="(692, 81)" end="(692, 82)" leading="" trailing="&#10;&#10;" val=")"/>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(694, 1)" end="(695, 80)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(694, 1)" end="(694, 61)">
        <CommandDoccommentNode start="(694, 1)" end="(694, 61)" comment="The common arguments of `simp_all?` and `simp_all?!`. -/">
          <AtomNode start="(694, 1)" end="(694, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(694, 5)" end="(694, 61)" leading="" trailing="&#10;" val="The common arguments of `simp_all?` and `simp_all?!`. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(695, 1)" end="(695, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(695, 8)" end="(695, 28)" leading="" trailing=" " raw_val="simpAllTraceArgsRest" val="simpAllTraceArgsRest"/>
      <AtomNode start="(695, 29)" end="(695, 31)" leading="" trailing=" " val=":="/>
      <NullNode start="(695, 32)" end="(695, 80)">
        <OtherNode start="(695, 32)" end="(695, 41)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(695, 32)" end="(695, 41)" leading="" trailing=" " raw_val="optConfig" val="optConfig" full_name="Lean.Parser.Tactic.optConfig" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(458, 8)" def_end="(458, 17)"/>
          <NullNode/>
        </OtherNode>
        <OtherNode start="(695, 42)" end="(695, 55)" kind="stx_?">
          <OtherNode start="(695, 42)" end="(695, 54)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(695, 42)" end="(695, 43)" leading="" trailing="" val="("/>
            <NullNode start="(695, 43)" end="(695, 53)">
              <OtherNode start="(695, 43)" end="(695, 53)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(695, 43)" end="(695, 53)" leading="" trailing="" raw_val="discharger" val="discharger" full_name="Lean.Parser.Tactic.discharger" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(602, 8)" def_end="(602, 18)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(695, 53)" end="(695, 54)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(695, 54)" end="(695, 55)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(695, 56)" end="(695, 67)" kind="stx_?">
          <OtherNode start="(695, 56)" end="(695, 66)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(695, 56)" end="(695, 57)" leading="" trailing="" val="("/>
            <NullNode start="(695, 57)" end="(695, 65)">
              <OtherNode start="(695, 57)" end="(695, 65)" kind="Lean.Parser.Syntax.nonReserved">
                <AtomNode start="(695, 57)" end="(695, 58)" leading="" trailing="" val="&amp;amp;"/>
                <OtherNode start="(695, 58)" end="(695, 65)" kind="str">
                  <AtomNode start="(695, 58)" end="(695, 65)" leading="" trailing="" val="&amp;quot; only&amp;quot;"/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(695, 65)" end="(695, 66)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(695, 66)" end="(695, 67)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(695, 68)" end="(695, 80)" kind="stx_?">
          <OtherNode start="(695, 68)" end="(695, 79)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(695, 68)" end="(695, 69)" leading="" trailing="" val="("/>
            <NullNode start="(695, 69)" end="(695, 78)">
              <OtherNode start="(695, 69)" end="(695, 78)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(695, 69)" end="(695, 78)" leading="" trailing="" raw_val="dsimpArgs" val="dsimpArgs" full_name="Lean.Parser.Tactic.dsimpArgs" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(673, 8)" def_end="(673, 17)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(695, 78)" end="(695, 79)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(695, 79)" end="(695, 80)" leading="" trailing="&#10;&#10;" val="?"/>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(697, 1)" end="(698, 77)" kind="Lean.Parser.Command.syntax">
      <NullNode/>
      <NullNode start="(697, 1)" end="(697, 25)">
        <OtherNode start="(697, 1)" end="(697, 25)" kind="Lean.Parser.Term.attributes">
          <AtomNode start="(697, 1)" end="(697, 3)" leading="" trailing="" val="@["/>
          <NullNode start="(697, 3)" end="(697, 24)">
            <OtherNode start="(697, 3)" end="(697, 24)" kind="Lean.Parser.Term.attrInstance">
              <TermAttrkindNode>
                <NullNode/>
              </TermAttrkindNode>
              <OtherNode start="(697, 3)" end="(697, 24)" kind="Lean.Parser.Attr.simple">
                <IdentNode start="(697, 3)" end="(697, 14)" leading="" trailing=" " raw_val="inherit_doc" val="inherit_doc"/>
                <NullNode start="(697, 15)" end="(697, 24)">
                  <IdentNode start="(697, 15)" end="(697, 24)" leading="" trailing="" raw_val="simpTrace" val="simpTrace" full_name="Lean.Parser.Tactic.simpTrace" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(689, 17)" def_end="(689, 26)"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </NullNode>
          <AtomNode start="(697, 24)" end="(697, 25)" leading="" trailing="&#10;" val="]"/>
        </OtherNode>
      </NullNode>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(698, 1)" end="(698, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(698, 8)" end="(698, 30)">
        <OtherNode start="(698, 8)" end="(698, 30)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(698, 8)" end="(698, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(698, 9)" end="(698, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(698, 14)" end="(698, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(698, 17)" end="(698, 29)" leading="" trailing="" raw_val="simpAllTrace" val="simpAllTrace"/>
          <AtomNode start="(698, 29)" end="(698, 30)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(698, 31)" end="(698, 68)">
        <OtherNode start="(698, 31)" end="(698, 42)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(698, 31)" end="(698, 42)" kind="str">
            <AtomNode start="(698, 31)" end="(698, 42)" leading="" trailing=" " val="&amp;quot;simp_all?&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(698, 43)" end="(698, 47)" kind="stx_?">
          <OtherNode start="(698, 43)" end="(698, 46)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(698, 43)" end="(698, 46)" kind="str">
              <AtomNode start="(698, 43)" end="(698, 46)" leading="" trailing="" val="&amp;quot;!&amp;quot;"/>
            </OtherNode>
          </OtherNode>
          <AtomNode start="(698, 46)" end="(698, 47)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(698, 48)" end="(698, 68)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(698, 48)" end="(698, 68)" leading="" trailing=" " raw_val="simpAllTraceArgsRest" val="simpAllTraceArgsRest" full_name="Lean.Parser.Tactic.simpAllTraceArgsRest" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(695, 8)" def_end="(695, 28)"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(698, 69)" end="(698, 70)" leading="" trailing=" " val=":"/>
      <IdentNode start="(698, 71)" end="(698, 77)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(700, 1)" end="(701, 93)" kind="Lean.Parser.Command.macro">
      <NullNode/>
      <NullNode start="(700, 1)" end="(700, 25)">
        <OtherNode start="(700, 1)" end="(700, 25)" kind="Lean.Parser.Term.attributes">
          <AtomNode start="(700, 1)" end="(700, 3)" leading="" trailing="" val="@["/>
          <NullNode start="(700, 3)" end="(700, 24)">
            <OtherNode start="(700, 3)" end="(700, 24)" kind="Lean.Parser.Term.attrInstance">
              <TermAttrkindNode>
                <NullNode/>
              </TermAttrkindNode>
              <OtherNode start="(700, 3)" end="(700, 24)" kind="Lean.Parser.Attr.simple">
                <IdentNode start="(700, 3)" end="(700, 14)" leading="" trailing=" " raw_val="inherit_doc" val="inherit_doc"/>
                <NullNode start="(700, 15)" end="(700, 24)">
                  <IdentNode start="(700, 15)" end="(700, 24)" leading="" trailing="" raw_val="simpTrace" val="simpTrace" full_name="Lean.Parser.Tactic.simpTrace" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(689, 17)" def_end="(689, 26)"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </NullNode>
          <AtomNode start="(700, 24)" end="(700, 25)" leading="" trailing="&#10;" val="]"/>
        </OtherNode>
      </NullNode>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(701, 1)" end="(701, 6)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(701, 7)" end="(701, 48)">
        <OtherNode start="(701, 7)" end="(701, 22)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(701, 7)" end="(701, 10)">
            <IdentNode start="(701, 7)" end="(701, 9)" leading="" trailing="" raw_val="tk" val="tk"/>
            <AtomNode start="(701, 9)" end="(701, 10)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(701, 10)" end="(701, 22)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(701, 10)" end="(701, 22)" kind="str">
              <AtomNode start="(701, 10)" end="(701, 22)" leading="" trailing=" " val="&amp;quot;simp_all?!&amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(701, 23)" end="(701, 48)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(701, 23)" end="(701, 28)">
            <IdentNode start="(701, 23)" end="(701, 27)" leading="" trailing="" raw_val="rest" val="rest"/>
            <AtomNode start="(701, 27)" end="(701, 28)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(701, 28)" end="(701, 48)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(701, 28)" end="(701, 48)" leading="" trailing=" " raw_val="simpAllTraceArgsRest" val="simpAllTraceArgsRest" full_name="Lean.Parser.Tactic.simpAllTraceArgsRest" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(695, 8)" def_end="(695, 28)"/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(701, 49)" end="(701, 93)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(701, 49)" end="(701, 50)" leading="" trailing=" " val=":"/>
        <IdentNode start="(701, 51)" end="(701, 57)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(701, 58)" end="(701, 60)" leading="" trailing=" " val="=&amp;gt;"/>
        <OtherNode start="(701, 61)" end="(701, 93)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(701, 61)" end="(701, 93)" kind="Lean.Parser.Tactic.quot">
            <AtomNode start="(701, 61)" end="(701, 70)" leading="" trailing=" " val="`(tactic|"/>
            <OtherNode start="(701, 71)" end="(701, 92)" kind="Lean.Parser.Tactic.simpAllTrace">
              <TokenAntiquotNode start="(701, 71)" end="(701, 84)">
                <AtomNode start="(701, 71)" end="(701, 80)" leading="" trailing="" val="simp_all?"/>
                <AtomNode start="(701, 80)" end="(701, 81)" leading="" trailing="" val="%"/>
                <AtomNode start="(701, 81)" end="(701, 82)" leading="" trailing="" val="$"/>
                <IdentNode start="(701, 82)" end="(701, 84)" leading="" trailing=" " raw_val="tk" val="tk"/>
              </TokenAntiquotNode>
              <NullNode start="(701, 85)" end="(701, 86)">
                <AtomNode start="(701, 85)" end="(701, 86)" leading="" trailing=" " val="!"/>
              </NullNode>
              <OtherNode start="(701, 87)" end="(701, 92)" kind="Lean.Parser.Tactic.simpAllTraceArgsRest.antiquot">
                <AtomNode start="(701, 87)" end="(701, 88)" leading="" trailing="" val="$"/>
                <NullNode/>
                <IdentNode start="(701, 88)" end="(701, 92)" leading="" trailing="" raw_val="rest" val="rest"/>
                <NullNode/>
              </OtherNode>
            </OtherNode>
            <AtomNode start="(701, 92)" end="(701, 93)" leading="" trailing="&#10;&#10;" val=")"/>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(703, 1)" end="(704, 84)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(703, 1)" end="(703, 55)">
        <CommandDoccommentNode start="(703, 1)" end="(703, 55)" comment="The common arguments of `dsimp?` and `dsimp?!`. -/">
          <AtomNode start="(703, 1)" end="(703, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(703, 5)" end="(703, 55)" leading="" trailing="&#10;" val="The common arguments of `dsimp?` and `dsimp?!`. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(704, 1)" end="(704, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(704, 8)" end="(704, 26)" leading="" trailing=" " raw_val="dsimpTraceArgsRest" val="dsimpTraceArgsRest"/>
      <AtomNode start="(704, 27)" end="(704, 29)" leading="" trailing=" " val=":="/>
      <NullNode start="(704, 30)" end="(704, 84)">
        <OtherNode start="(704, 30)" end="(704, 39)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(704, 30)" end="(704, 39)" leading="" trailing=" " raw_val="optConfig" val="optConfig" full_name="Lean.Parser.Tactic.optConfig" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(458, 8)" def_end="(458, 17)"/>
          <NullNode/>
        </OtherNode>
        <OtherNode start="(704, 40)" end="(704, 51)" kind="stx_?">
          <OtherNode start="(704, 40)" end="(704, 50)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(704, 40)" end="(704, 41)" leading="" trailing="" val="("/>
            <NullNode start="(704, 41)" end="(704, 49)">
              <OtherNode start="(704, 41)" end="(704, 49)" kind="Lean.Parser.Syntax.nonReserved">
                <AtomNode start="(704, 41)" end="(704, 42)" leading="" trailing="" val="&amp;amp;"/>
                <OtherNode start="(704, 42)" end="(704, 49)" kind="str">
                  <AtomNode start="(704, 42)" end="(704, 49)" leading="" trailing="" val="&amp;quot; only&amp;quot;"/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(704, 49)" end="(704, 50)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(704, 50)" end="(704, 51)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(704, 52)" end="(704, 64)" kind="stx_?">
          <OtherNode start="(704, 52)" end="(704, 63)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(704, 52)" end="(704, 53)" leading="" trailing="" val="("/>
            <NullNode start="(704, 53)" end="(704, 62)">
              <OtherNode start="(704, 53)" end="(704, 62)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(704, 53)" end="(704, 62)" leading="" trailing="" raw_val="dsimpArgs" val="dsimpArgs" full_name="Lean.Parser.Tactic.dsimpArgs" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(673, 8)" def_end="(673, 17)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(704, 62)" end="(704, 63)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(704, 63)" end="(704, 64)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(704, 65)" end="(704, 84)" kind="stx_?">
          <OtherNode start="(704, 65)" end="(704, 83)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(704, 65)" end="(704, 66)" leading="" trailing="" val="("/>
            <NullNode start="(704, 66)" end="(704, 82)">
              <OtherNode start="(704, 66)" end="(704, 73)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(704, 66)" end="(704, 73)" leading="" trailing=" " raw_val="ppSpace" val="ppSpace" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(704, 74)" end="(704, 82)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(704, 74)" end="(704, 82)" leading="" trailing="" raw_val="location" val="location" full_name="Lean.Parser.Tactic.location" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(484, 8)" def_end="(484, 16)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(704, 82)" end="(704, 83)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(704, 83)" end="(704, 84)" leading="" trailing="&#10;&#10;" val="?"/>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(706, 1)" end="(707, 70)" kind="Lean.Parser.Command.syntax">
      <NullNode/>
      <NullNode start="(706, 1)" end="(706, 25)">
        <OtherNode start="(706, 1)" end="(706, 25)" kind="Lean.Parser.Term.attributes">
          <AtomNode start="(706, 1)" end="(706, 3)" leading="" trailing="" val="@["/>
          <NullNode start="(706, 3)" end="(706, 24)">
            <OtherNode start="(706, 3)" end="(706, 24)" kind="Lean.Parser.Term.attrInstance">
              <TermAttrkindNode>
                <NullNode/>
              </TermAttrkindNode>
              <OtherNode start="(706, 3)" end="(706, 24)" kind="Lean.Parser.Attr.simple">
                <IdentNode start="(706, 3)" end="(706, 14)" leading="" trailing=" " raw_val="inherit_doc" val="inherit_doc"/>
                <NullNode start="(706, 15)" end="(706, 24)">
                  <IdentNode start="(706, 15)" end="(706, 24)" leading="" trailing="" raw_val="simpTrace" val="simpTrace" full_name="Lean.Parser.Tactic.simpTrace" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(689, 17)" def_end="(689, 26)"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </NullNode>
          <AtomNode start="(706, 24)" end="(706, 25)" leading="" trailing="&#10;" val="]"/>
        </OtherNode>
      </NullNode>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(707, 1)" end="(707, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(707, 8)" end="(707, 28)">
        <OtherNode start="(707, 8)" end="(707, 28)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(707, 8)" end="(707, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(707, 9)" end="(707, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(707, 14)" end="(707, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(707, 17)" end="(707, 27)" leading="" trailing="" raw_val="dsimpTrace" val="dsimpTrace"/>
          <AtomNode start="(707, 27)" end="(707, 28)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(707, 29)" end="(707, 61)">
        <OtherNode start="(707, 29)" end="(707, 37)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(707, 29)" end="(707, 37)" kind="str">
            <AtomNode start="(707, 29)" end="(707, 37)" leading="" trailing=" " val="&amp;quot;dsimp?&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(707, 38)" end="(707, 42)" kind="stx_?">
          <OtherNode start="(707, 38)" end="(707, 41)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(707, 38)" end="(707, 41)" kind="str">
              <AtomNode start="(707, 38)" end="(707, 41)" leading="" trailing="" val="&amp;quot;!&amp;quot;"/>
            </OtherNode>
          </OtherNode>
          <AtomNode start="(707, 41)" end="(707, 42)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(707, 43)" end="(707, 61)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(707, 43)" end="(707, 61)" leading="" trailing=" " raw_val="dsimpTraceArgsRest" val="dsimpTraceArgsRest" full_name="Lean.Parser.Tactic.dsimpTraceArgsRest" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(704, 8)" def_end="(704, 26)"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(707, 62)" end="(707, 63)" leading="" trailing=" " val=":"/>
      <IdentNode start="(707, 64)" end="(707, 70)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(709, 1)" end="(710, 85)" kind="Lean.Parser.Command.macro">
      <NullNode/>
      <NullNode start="(709, 1)" end="(709, 25)">
        <OtherNode start="(709, 1)" end="(709, 25)" kind="Lean.Parser.Term.attributes">
          <AtomNode start="(709, 1)" end="(709, 3)" leading="" trailing="" val="@["/>
          <NullNode start="(709, 3)" end="(709, 24)">
            <OtherNode start="(709, 3)" end="(709, 24)" kind="Lean.Parser.Term.attrInstance">
              <TermAttrkindNode>
                <NullNode/>
              </TermAttrkindNode>
              <OtherNode start="(709, 3)" end="(709, 24)" kind="Lean.Parser.Attr.simple">
                <IdentNode start="(709, 3)" end="(709, 14)" leading="" trailing=" " raw_val="inherit_doc" val="inherit_doc"/>
                <NullNode start="(709, 15)" end="(709, 24)">
                  <IdentNode start="(709, 15)" end="(709, 24)" leading="" trailing="" raw_val="simpTrace" val="simpTrace" full_name="Lean.Parser.Tactic.simpTrace" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(689, 17)" def_end="(689, 26)"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </NullNode>
          <AtomNode start="(709, 24)" end="(709, 25)" leading="" trailing="&#10;" val="]"/>
        </OtherNode>
      </NullNode>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(710, 1)" end="(710, 6)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(710, 7)" end="(710, 43)">
        <OtherNode start="(710, 7)" end="(710, 19)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(710, 7)" end="(710, 10)">
            <IdentNode start="(710, 7)" end="(710, 9)" leading="" trailing="" raw_val="tk" val="tk"/>
            <AtomNode start="(710, 9)" end="(710, 10)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(710, 10)" end="(710, 19)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(710, 10)" end="(710, 19)" kind="str">
              <AtomNode start="(710, 10)" end="(710, 19)" leading="" trailing=" " val="&amp;quot;dsimp?!&amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(710, 20)" end="(710, 43)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(710, 20)" end="(710, 25)">
            <IdentNode start="(710, 20)" end="(710, 24)" leading="" trailing="" raw_val="rest" val="rest"/>
            <AtomNode start="(710, 24)" end="(710, 25)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(710, 25)" end="(710, 43)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(710, 25)" end="(710, 43)" leading="" trailing=" " raw_val="dsimpTraceArgsRest" val="dsimpTraceArgsRest" full_name="Lean.Parser.Tactic.dsimpTraceArgsRest" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(704, 8)" def_end="(704, 26)"/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(710, 44)" end="(710, 85)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(710, 44)" end="(710, 45)" leading="" trailing=" " val=":"/>
        <IdentNode start="(710, 46)" end="(710, 52)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(710, 53)" end="(710, 55)" leading="" trailing=" " val="=&amp;gt;"/>
        <OtherNode start="(710, 56)" end="(710, 85)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(710, 56)" end="(710, 85)" kind="Lean.Parser.Tactic.quot">
            <AtomNode start="(710, 56)" end="(710, 65)" leading="" trailing=" " val="`(tactic|"/>
            <OtherNode start="(710, 66)" end="(710, 84)" kind="Lean.Parser.Tactic.dsimpTrace">
              <TokenAntiquotNode start="(710, 66)" end="(710, 76)">
                <AtomNode start="(710, 66)" end="(710, 72)" leading="" trailing="" val="dsimp?"/>
                <AtomNode start="(710, 72)" end="(710, 73)" leading="" trailing="" val="%"/>
                <AtomNode start="(710, 73)" end="(710, 74)" leading="" trailing="" val="$"/>
                <IdentNode start="(710, 74)" end="(710, 76)" leading="" trailing=" " raw_val="tk" val="tk"/>
              </TokenAntiquotNode>
              <NullNode start="(710, 77)" end="(710, 78)">
                <AtomNode start="(710, 77)" end="(710, 78)" leading="" trailing=" " val="!"/>
              </NullNode>
              <OtherNode start="(710, 79)" end="(710, 84)" kind="Lean.Parser.Tactic.dsimpTraceArgsRest.antiquot">
                <AtomNode start="(710, 79)" end="(710, 80)" leading="" trailing="" val="$"/>
                <NullNode/>
                <IdentNode start="(710, 80)" end="(710, 84)" leading="" trailing="" raw_val="rest" val="rest"/>
                <NullNode/>
              </OtherNode>
            </OtherNode>
            <AtomNode start="(710, 84)" end="(710, 85)" leading="" trailing="&#10;&#10;" val=")"/>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(712, 1)" end="(713, 89)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(712, 1)" end="(712, 52)">
        <CommandDoccommentNode start="(712, 1)" end="(712, 52)" comment="The arguments to the `simpa` family tactics. -/">
          <AtomNode start="(712, 1)" end="(712, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(712, 5)" end="(712, 52)" leading="" trailing="&#10;" val="The arguments to the `simpa` family tactics. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(713, 1)" end="(713, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(713, 8)" end="(713, 21)" leading="" trailing=" " raw_val="simpaArgsRest" val="simpaArgsRest"/>
      <AtomNode start="(713, 22)" end="(713, 24)" leading="" trailing=" " val=":="/>
      <NullNode start="(713, 25)" end="(713, 89)">
        <OtherNode start="(713, 25)" end="(713, 34)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(713, 25)" end="(713, 34)" leading="" trailing=" " raw_val="optConfig" val="optConfig" full_name="Lean.Parser.Tactic.optConfig" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(458, 8)" def_end="(458, 17)"/>
          <NullNode/>
        </OtherNode>
        <OtherNode start="(713, 35)" end="(713, 48)" kind="stx_?">
          <OtherNode start="(713, 35)" end="(713, 47)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(713, 35)" end="(713, 36)" leading="" trailing="" val="("/>
            <NullNode start="(713, 36)" end="(713, 46)">
              <OtherNode start="(713, 36)" end="(713, 46)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(713, 36)" end="(713, 46)" leading="" trailing="" raw_val="discharger" val="discharger" full_name="Lean.Parser.Tactic.discharger" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(602, 8)" def_end="(602, 18)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(713, 46)" end="(713, 47)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(713, 47)" end="(713, 48)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(713, 49)" end="(713, 59)" kind="stx_?">
          <OtherNode start="(713, 49)" end="(713, 58)" kind="Lean.Parser.Syntax.nonReserved">
            <AtomNode start="(713, 49)" end="(713, 50)" leading="" trailing="" val="&amp;amp;"/>
            <OtherNode start="(713, 50)" end="(713, 58)" kind="str">
              <AtomNode start="(713, 50)" end="(713, 58)" leading="" trailing="" val="&amp;quot; only &amp;quot;"/>
            </OtherNode>
          </OtherNode>
          <AtomNode start="(713, 58)" end="(713, 59)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(713, 60)" end="(713, 71)" kind="stx_?">
          <OtherNode start="(713, 60)" end="(713, 70)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(713, 60)" end="(713, 61)" leading="" trailing="" val="("/>
            <NullNode start="(713, 61)" end="(713, 69)">
              <OtherNode start="(713, 61)" end="(713, 69)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(713, 61)" end="(713, 69)" leading="" trailing="" raw_val="simpArgs" val="simpArgs" full_name="Lean.Parser.Tactic.simpArgs" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(664, 8)" def_end="(664, 16)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(713, 69)" end="(713, 70)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(713, 70)" end="(713, 71)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(713, 72)" end="(713, 89)" kind="stx_?">
          <OtherNode start="(713, 72)" end="(713, 88)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(713, 72)" end="(713, 73)" leading="" trailing="" val="("/>
            <NullNode start="(713, 73)" end="(713, 87)">
              <OtherNode start="(713, 73)" end="(713, 82)" kind="Lean.Parser.Syntax.atom">
                <OtherNode start="(713, 73)" end="(713, 82)" kind="str">
                  <AtomNode start="(713, 73)" end="(713, 82)" leading="" trailing=" " val="&amp;quot; using &amp;quot;"/>
                </OtherNode>
              </OtherNode>
              <OtherNode start="(713, 83)" end="(713, 87)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(713, 83)" end="(713, 87)" leading="" trailing="" raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(713, 87)" end="(713, 88)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(713, 88)" end="(713, 89)" leading="" trailing="&#10;&#10;" val="?"/>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(715, 1)" end="(729, 64)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(715, 1)" end="(728, 3)">
        <CommandDoccommentNode start="(715, 1)" end="(728, 3)" comment="This is a &amp;quot;finishing&amp;quot; tactic modification of `simp`. It has two forms.&#10;&#10;* `simpa [rules, ⋯] using e` will simplify the goal and the type of&#10;  `e` using `rules`, then try to close the goal using `e`.&#10;&#10;  Simplifying the type of `e` makes it more likely to match the goal&#10;  (which has also been simplified). This construction also tends to be&#10;  more robust under changes to the simp lemma set.&#10;&#10;* `simpa [rules, ⋯]` will simplify the goal and the type of a&#10;  hypothesis `this` if present in the context, then try to close the goal using&#10;  the `assumption` tactic.&#10;-/">
          <AtomNode start="(715, 1)" end="(715, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(716, 1)" end="(728, 3)" leading="" trailing="&#10;" val="This is a &amp;quot;finishing&amp;quot; tactic modification of `simp`. It has two forms.&#10;&#10;* `simpa [rules, ⋯] using e` will simplify the goal and the type of&#10;  `e` using `rules`, then try to close the goal using `e`.&#10;&#10;  Simplifying the type of `e` makes it more likely to match the goal&#10;  (which has also been simplified). This construction also tends to be&#10;  more robust under changes to the simp lemma set.&#10;&#10;* `simpa [rules, ⋯]` will simplify the goal and the type of a&#10;  hypothesis `this` if present in the context, then try to close the goal using&#10;  the `assumption` tactic.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(729, 1)" end="(729, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(729, 8)" end="(729, 23)">
        <OtherNode start="(729, 8)" end="(729, 23)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(729, 8)" end="(729, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(729, 9)" end="(729, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(729, 14)" end="(729, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(729, 17)" end="(729, 22)" leading="" trailing="" raw_val="simpa" val="simpa"/>
          <AtomNode start="(729, 22)" end="(729, 23)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(729, 24)" end="(729, 55)">
        <OtherNode start="(729, 24)" end="(729, 31)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(729, 24)" end="(729, 31)" kind="str">
            <AtomNode start="(729, 24)" end="(729, 31)" leading="" trailing=" " val="&amp;quot;simpa&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(729, 32)" end="(729, 36)" kind="stx_?">
          <OtherNode start="(729, 32)" end="(729, 35)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(729, 32)" end="(729, 35)" kind="str">
              <AtomNode start="(729, 32)" end="(729, 35)" leading="" trailing="" val="&amp;quot;?&amp;quot;"/>
            </OtherNode>
          </OtherNode>
          <AtomNode start="(729, 35)" end="(729, 36)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(729, 37)" end="(729, 41)" kind="stx_?">
          <OtherNode start="(729, 37)" end="(729, 40)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(729, 37)" end="(729, 40)" kind="str">
              <AtomNode start="(729, 37)" end="(729, 40)" leading="" trailing="" val="&amp;quot;!&amp;quot;"/>
            </OtherNode>
          </OtherNode>
          <AtomNode start="(729, 40)" end="(729, 41)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(729, 42)" end="(729, 55)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(729, 42)" end="(729, 55)" leading="" trailing=" " raw_val="simpaArgsRest" val="simpaArgsRest" full_name="Lean.Parser.Tactic.simpaArgsRest" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(713, 8)" def_end="(713, 21)"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(729, 56)" end="(729, 57)" leading="" trailing=" " val=":"/>
      <IdentNode start="(729, 58)" end="(729, 64)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(731, 1)" end="(732, 41)" kind="Lean.Parser.Command.macro">
      <NullNode/>
      <NullNode start="(731, 1)" end="(731, 21)">
        <OtherNode start="(731, 1)" end="(731, 21)" kind="Lean.Parser.Term.attributes">
          <AtomNode start="(731, 1)" end="(731, 3)" leading="" trailing="" val="@["/>
          <NullNode start="(731, 3)" end="(731, 20)">
            <OtherNode start="(731, 3)" end="(731, 20)" kind="Lean.Parser.Term.attrInstance">
              <TermAttrkindNode>
                <NullNode/>
              </TermAttrkindNode>
              <OtherNode start="(731, 3)" end="(731, 20)" kind="Lean.Parser.Attr.simple">
                <IdentNode start="(731, 3)" end="(731, 14)" leading="" trailing=" " raw_val="inherit_doc" val="inherit_doc"/>
                <NullNode start="(731, 15)" end="(731, 20)">
                  <IdentNode start="(731, 15)" end="(731, 20)" leading="" trailing="" raw_val="simpa" val="simpa" full_name="Lean.Parser.Tactic.simpa" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(729, 17)" def_end="(729, 22)"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </NullNode>
          <AtomNode start="(731, 20)" end="(731, 21)" leading="" trailing=" " val="]"/>
        </OtherNode>
      </NullNode>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(731, 22)" end="(731, 27)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(731, 28)" end="(731, 55)">
        <OtherNode start="(731, 28)" end="(731, 36)" kind="Lean.Parser.Command.macroArg">
          <NullNode/>
          <OtherNode start="(731, 28)" end="(731, 36)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(731, 28)" end="(731, 36)" kind="str">
              <AtomNode start="(731, 28)" end="(731, 36)" leading="" trailing=" " val="&amp;quot;simpa!&amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(731, 37)" end="(731, 55)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(731, 37)" end="(731, 42)">
            <IdentNode start="(731, 37)" end="(731, 41)" leading="" trailing="" raw_val="rest" val="rest"/>
            <AtomNode start="(731, 41)" end="(731, 42)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(731, 42)" end="(731, 55)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(731, 42)" end="(731, 55)" leading="" trailing=" " raw_val="simpaArgsRest" val="simpaArgsRest" full_name="Lean.Parser.Tactic.simpaArgsRest" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(713, 8)" def_end="(713, 21)"/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(731, 56)" end="(732, 41)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(731, 56)" end="(731, 57)" leading="" trailing=" " val=":"/>
        <IdentNode start="(731, 58)" end="(731, 64)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(731, 65)" end="(731, 67)" leading="" trailing="&#10;  " val="=&amp;gt;"/>
        <OtherNode start="(732, 3)" end="(732, 41)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(732, 3)" end="(732, 41)" kind="Lean.Parser.Tactic.quot">
            <AtomNode start="(732, 3)" end="(732, 12)" leading="" trailing=" " val="`(tactic|"/>
            <OtherNode start="(732, 13)" end="(732, 40)" kind="Lean.Parser.Tactic.simpa">
              <AtomNode start="(732, 13)" end="(732, 18)" leading="" trailing=" " val="simpa"/>
              <NullNode/>
              <NullNode start="(732, 19)" end="(732, 20)">
                <AtomNode start="(732, 19)" end="(732, 20)" leading="" trailing=" " val="!"/>
              </NullNode>
              <OtherNode start="(732, 21)" end="(732, 40)" kind="Lean.Parser.Tactic.simpaArgsRest.antiquot">
                <AtomNode start="(732, 21)" end="(732, 22)" leading="" trailing="" val="$"/>
                <NullNode/>
                <IdentNode start="(732, 22)" end="(732, 26)" leading="" trailing="" raw_val="rest" val="rest"/>
                <OtherNode start="(732, 26)" end="(732, 40)" kind="antiquotName">
                  <AtomNode start="(732, 26)" end="(732, 27)" leading="" trailing="" val=":"/>
                  <AtomNode start="(732, 27)" end="(732, 40)" leading="" trailing="" val="simpaArgsRest"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
            <AtomNode start="(732, 40)" end="(732, 41)" leading="" trailing="&#10;&#10;" val=")"/>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(734, 1)" end="(735, 41)" kind="Lean.Parser.Command.macro">
      <NullNode/>
      <NullNode start="(734, 1)" end="(734, 21)">
        <OtherNode start="(734, 1)" end="(734, 21)" kind="Lean.Parser.Term.attributes">
          <AtomNode start="(734, 1)" end="(734, 3)" leading="" trailing="" val="@["/>
          <NullNode start="(734, 3)" end="(734, 20)">
            <OtherNode start="(734, 3)" end="(734, 20)" kind="Lean.Parser.Term.attrInstance">
              <TermAttrkindNode>
                <NullNode/>
              </TermAttrkindNode>
              <OtherNode start="(734, 3)" end="(734, 20)" kind="Lean.Parser.Attr.simple">
                <IdentNode start="(734, 3)" end="(734, 14)" leading="" trailing=" " raw_val="inherit_doc" val="inherit_doc"/>
                <NullNode start="(734, 15)" end="(734, 20)">
                  <IdentNode start="(734, 15)" end="(734, 20)" leading="" trailing="" raw_val="simpa" val="simpa" full_name="Lean.Parser.Tactic.simpa" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(729, 17)" def_end="(729, 22)"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </NullNode>
          <AtomNode start="(734, 20)" end="(734, 21)" leading="" trailing=" " val="]"/>
        </OtherNode>
      </NullNode>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(734, 22)" end="(734, 27)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(734, 28)" end="(734, 55)">
        <OtherNode start="(734, 28)" end="(734, 36)" kind="Lean.Parser.Command.macroArg">
          <NullNode/>
          <OtherNode start="(734, 28)" end="(734, 36)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(734, 28)" end="(734, 36)" kind="str">
              <AtomNode start="(734, 28)" end="(734, 36)" leading="" trailing=" " val="&amp;quot;simpa?&amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(734, 37)" end="(734, 55)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(734, 37)" end="(734, 42)">
            <IdentNode start="(734, 37)" end="(734, 41)" leading="" trailing="" raw_val="rest" val="rest"/>
            <AtomNode start="(734, 41)" end="(734, 42)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(734, 42)" end="(734, 55)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(734, 42)" end="(734, 55)" leading="" trailing=" " raw_val="simpaArgsRest" val="simpaArgsRest" full_name="Lean.Parser.Tactic.simpaArgsRest" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(713, 8)" def_end="(713, 21)"/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(734, 56)" end="(735, 41)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(734, 56)" end="(734, 57)" leading="" trailing=" " val=":"/>
        <IdentNode start="(734, 58)" end="(734, 64)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(734, 65)" end="(734, 67)" leading="" trailing="&#10;  " val="=&amp;gt;"/>
        <OtherNode start="(735, 3)" end="(735, 41)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(735, 3)" end="(735, 41)" kind="Lean.Parser.Tactic.quot">
            <AtomNode start="(735, 3)" end="(735, 12)" leading="" trailing=" " val="`(tactic|"/>
            <OtherNode start="(735, 13)" end="(735, 40)" kind="Lean.Parser.Tactic.simpa">
              <AtomNode start="(735, 13)" end="(735, 18)" leading="" trailing=" " val="simpa"/>
              <NullNode start="(735, 19)" end="(735, 20)">
                <AtomNode start="(735, 19)" end="(735, 20)" leading="" trailing=" " val="?"/>
              </NullNode>
              <NullNode/>
              <OtherNode start="(735, 21)" end="(735, 40)" kind="Lean.Parser.Tactic.simpaArgsRest.antiquot">
                <AtomNode start="(735, 21)" end="(735, 22)" leading="" trailing="" val="$"/>
                <NullNode/>
                <IdentNode start="(735, 22)" end="(735, 26)" leading="" trailing="" raw_val="rest" val="rest"/>
                <OtherNode start="(735, 26)" end="(735, 40)" kind="antiquotName">
                  <AtomNode start="(735, 26)" end="(735, 27)" leading="" trailing="" val=":"/>
                  <AtomNode start="(735, 27)" end="(735, 40)" leading="" trailing="" val="simpaArgsRest"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
            <AtomNode start="(735, 40)" end="(735, 41)" leading="" trailing="&#10;&#10;" val=")"/>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(737, 1)" end="(738, 42)" kind="Lean.Parser.Command.macro">
      <NullNode/>
      <NullNode start="(737, 1)" end="(737, 21)">
        <OtherNode start="(737, 1)" end="(737, 21)" kind="Lean.Parser.Term.attributes">
          <AtomNode start="(737, 1)" end="(737, 3)" leading="" trailing="" val="@["/>
          <NullNode start="(737, 3)" end="(737, 20)">
            <OtherNode start="(737, 3)" end="(737, 20)" kind="Lean.Parser.Term.attrInstance">
              <TermAttrkindNode>
                <NullNode/>
              </TermAttrkindNode>
              <OtherNode start="(737, 3)" end="(737, 20)" kind="Lean.Parser.Attr.simple">
                <IdentNode start="(737, 3)" end="(737, 14)" leading="" trailing=" " raw_val="inherit_doc" val="inherit_doc"/>
                <NullNode start="(737, 15)" end="(737, 20)">
                  <IdentNode start="(737, 15)" end="(737, 20)" leading="" trailing="" raw_val="simpa" val="simpa" full_name="Lean.Parser.Tactic.simpa" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(729, 17)" def_end="(729, 22)"/>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </NullNode>
          <AtomNode start="(737, 20)" end="(737, 21)" leading="" trailing=" " val="]"/>
        </OtherNode>
      </NullNode>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(737, 22)" end="(737, 27)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(737, 28)" end="(737, 56)">
        <OtherNode start="(737, 28)" end="(737, 37)" kind="Lean.Parser.Command.macroArg">
          <NullNode/>
          <OtherNode start="(737, 28)" end="(737, 37)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(737, 28)" end="(737, 37)" kind="str">
              <AtomNode start="(737, 28)" end="(737, 37)" leading="" trailing=" " val="&amp;quot;simpa?!&amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(737, 38)" end="(737, 56)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(737, 38)" end="(737, 43)">
            <IdentNode start="(737, 38)" end="(737, 42)" leading="" trailing="" raw_val="rest" val="rest"/>
            <AtomNode start="(737, 42)" end="(737, 43)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(737, 43)" end="(737, 56)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(737, 43)" end="(737, 56)" leading="" trailing=" " raw_val="simpaArgsRest" val="simpaArgsRest" full_name="Lean.Parser.Tactic.simpaArgsRest" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(713, 8)" def_end="(713, 21)"/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(737, 57)" end="(738, 42)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(737, 57)" end="(737, 58)" leading="" trailing=" " val=":"/>
        <IdentNode start="(737, 59)" end="(737, 65)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(737, 66)" end="(737, 68)" leading="" trailing="&#10;  " val="=&amp;gt;"/>
        <OtherNode start="(738, 3)" end="(738, 42)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(738, 3)" end="(738, 42)" kind="Lean.Parser.Tactic.quot">
            <AtomNode start="(738, 3)" end="(738, 12)" leading="" trailing=" " val="`(tactic|"/>
            <OtherNode start="(738, 13)" end="(738, 41)" kind="Lean.Parser.Tactic.simpa">
              <AtomNode start="(738, 13)" end="(738, 18)" leading="" trailing=" " val="simpa"/>
              <NullNode start="(738, 19)" end="(738, 20)">
                <AtomNode start="(738, 19)" end="(738, 20)" leading="" trailing="" val="?"/>
              </NullNode>
              <NullNode start="(738, 20)" end="(738, 21)">
                <AtomNode start="(738, 20)" end="(738, 21)" leading="" trailing=" " val="!"/>
              </NullNode>
              <OtherNode start="(738, 22)" end="(738, 41)" kind="Lean.Parser.Tactic.simpaArgsRest.antiquot">
                <AtomNode start="(738, 22)" end="(738, 23)" leading="" trailing="" val="$"/>
                <NullNode/>
                <IdentNode start="(738, 23)" end="(738, 27)" leading="" trailing="" raw_val="rest" val="rest"/>
                <OtherNode start="(738, 27)" end="(738, 41)" kind="antiquotName">
                  <AtomNode start="(738, 27)" end="(738, 28)" leading="" trailing="" val=":"/>
                  <AtomNode start="(738, 28)" end="(738, 41)" leading="" trailing="" val="simpaArgsRest"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
            <AtomNode start="(738, 41)" end="(738, 42)" leading="" trailing="&#10;&#10;" val=")"/>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(740, 1)" end="(745, 75)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(740, 1)" end="(744, 3)">
        <CommandDoccommentNode start="(740, 1)" end="(744, 3)" comment="`delta id1 id2 ...` delta-expands the definitions `id1`, `id2`, ....&#10;This is a low-level tactic, it will expose how recursive definitions have been&#10;compiled by Lean.&#10;-/">
          <AtomNode start="(740, 1)" end="(740, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(741, 1)" end="(744, 3)" leading="" trailing="&#10;" val="`delta id1 id2 ...` delta-expands the definitions `id1`, `id2`, ....&#10;This is a low-level tactic, it will expose how recursive definitions have been&#10;compiled by Lean.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(745, 1)" end="(745, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(745, 8)" end="(745, 23)">
        <OtherNode start="(745, 8)" end="(745, 23)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(745, 8)" end="(745, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(745, 9)" end="(745, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(745, 14)" end="(745, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(745, 17)" end="(745, 22)" leading="" trailing="" raw_val="delta" val="delta"/>
          <AtomNode start="(745, 22)" end="(745, 23)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(745, 24)" end="(745, 66)">
        <OtherNode start="(745, 24)" end="(745, 31)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(745, 24)" end="(745, 31)" kind="str">
            <AtomNode start="(745, 24)" end="(745, 31)" leading="" trailing=" " val="&amp;quot;delta&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(745, 32)" end="(745, 54)" kind="«stx_+»">
          <OtherNode start="(745, 32)" end="(745, 53)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(745, 32)" end="(745, 33)" leading="" trailing="" val="("/>
            <NullNode start="(745, 33)" end="(745, 52)">
              <OtherNode start="(745, 33)" end="(745, 40)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(745, 33)" end="(745, 40)" leading="" trailing=" " raw_val="ppSpace" val="ppSpace" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(745, 41)" end="(745, 46)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(745, 41)" end="(745, 46)" leading="" trailing=" " raw_val="colGt" val="colGt" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(745, 47)" end="(745, 52)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(745, 47)" end="(745, 52)" leading="" trailing="" raw_val="ident" val="ident" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(745, 52)" end="(745, 53)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(745, 53)" end="(745, 54)" leading="" trailing=" " val="+"/>
        </OtherNode>
        <OtherNode start="(745, 55)" end="(745, 66)" kind="stx_?">
          <OtherNode start="(745, 55)" end="(745, 65)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(745, 55)" end="(745, 56)" leading="" trailing="" val="("/>
            <NullNode start="(745, 56)" end="(745, 64)">
              <OtherNode start="(745, 56)" end="(745, 64)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(745, 56)" end="(745, 64)" leading="" trailing="" raw_val="location" val="location" full_name="Lean.Parser.Tactic.location" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(484, 8)" def_end="(484, 16)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(745, 64)" end="(745, 65)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(745, 65)" end="(745, 66)" leading="" trailing=" " val="?"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(745, 67)" end="(745, 68)" leading="" trailing=" " val=":"/>
      <IdentNode start="(745, 69)" end="(745, 75)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(747, 1)" end="(759, 77)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(747, 1)" end="(758, 3)">
        <CommandDoccommentNode start="(747, 1)" end="(758, 3)" comment="* `unfold id` unfolds all occurrences of definition `id` in the target.&#10;* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.&#10;* `unfold id at h` unfolds at the hypothesis `h`.&#10;&#10;Definitions can be either global or local definitions.&#10;&#10;For non-recursive global definitions, this tactic is identical to `delta`.&#10;For recursive global definitions, it uses the &amp;quot;unfolding lemma&amp;quot; `id.eq_def`,&#10;which is generated for each recursive definition, to unfold according to the recursive definition given by the user.&#10;Only one level of unfolding is performed, in contrast to `simp only [id]`, which unfolds definition `id` recursively.&#10;-/">
          <AtomNode start="(747, 1)" end="(747, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(748, 1)" end="(758, 3)" leading="" trailing="&#10;" val="* `unfold id` unfolds all occurrences of definition `id` in the target.&#10;* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.&#10;* `unfold id at h` unfolds at the hypothesis `h`.&#10;&#10;Definitions can be either global or local definitions.&#10;&#10;For non-recursive global definitions, this tactic is identical to `delta`.&#10;For recursive global definitions, it uses the &amp;quot;unfolding lemma&amp;quot; `id.eq_def`,&#10;which is generated for each recursive definition, to unfold according to the recursive definition given by the user.&#10;Only one level of unfolding is performed, in contrast to `simp only [id]`, which unfolds definition `id` recursively.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(759, 1)" end="(759, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(759, 8)" end="(759, 24)">
        <OtherNode start="(759, 8)" end="(759, 24)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(759, 8)" end="(759, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(759, 9)" end="(759, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(759, 14)" end="(759, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(759, 17)" end="(759, 23)" leading="" trailing="" raw_val="unfold" val="unfold"/>
          <AtomNode start="(759, 23)" end="(759, 24)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(759, 25)" end="(759, 68)">
        <OtherNode start="(759, 25)" end="(759, 33)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(759, 25)" end="(759, 33)" kind="str">
            <AtomNode start="(759, 25)" end="(759, 33)" leading="" trailing=" " val="&amp;quot;unfold&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(759, 34)" end="(759, 56)" kind="«stx_+»">
          <OtherNode start="(759, 34)" end="(759, 55)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(759, 34)" end="(759, 35)" leading="" trailing="" val="("/>
            <NullNode start="(759, 35)" end="(759, 54)">
              <OtherNode start="(759, 35)" end="(759, 42)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(759, 35)" end="(759, 42)" leading="" trailing=" " raw_val="ppSpace" val="ppSpace" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(759, 43)" end="(759, 48)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(759, 43)" end="(759, 48)" leading="" trailing=" " raw_val="colGt" val="colGt" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(759, 49)" end="(759, 54)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(759, 49)" end="(759, 54)" leading="" trailing="" raw_val="ident" val="ident" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(759, 54)" end="(759, 55)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(759, 55)" end="(759, 56)" leading="" trailing=" " val="+"/>
        </OtherNode>
        <OtherNode start="(759, 57)" end="(759, 68)" kind="stx_?">
          <OtherNode start="(759, 57)" end="(759, 67)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(759, 57)" end="(759, 58)" leading="" trailing="" val="("/>
            <NullNode start="(759, 58)" end="(759, 66)">
              <OtherNode start="(759, 58)" end="(759, 66)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(759, 58)" end="(759, 66)" leading="" trailing="" raw_val="location" val="location" full_name="Lean.Parser.Tactic.location" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(484, 8)" def_end="(484, 16)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(759, 66)" end="(759, 67)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(759, 67)" end="(759, 68)" leading="" trailing=" " val="?"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(759, 69)" end="(759, 70)" leading="" trailing=" " val=":"/>
      <IdentNode start="(759, 71)" end="(759, 77)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(761, 1)" end="(765, 103)" kind="Lean.Parser.Command.macro">
      <NullNode start="(761, 1)" end="(764, 3)">
        <CommandDoccommentNode start="(761, 1)" end="(764, 3)" comment="Auxiliary macro for lifting have/suffices/let/...&#10;It makes sure the &amp;quot;continuation&amp;quot; `?_` is the main goal after refining.&#10;-/">
          <AtomNode start="(761, 1)" end="(761, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(762, 1)" end="(764, 3)" leading="" trailing="&#10;" val="Auxiliary macro for lifting have/suffices/let/...&#10;It makes sure the &amp;quot;continuation&amp;quot; `?_` is the main goal after refining.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(765, 1)" end="(765, 6)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(765, 7)" end="(765, 28)">
        <OtherNode start="(765, 7)" end="(765, 21)" kind="Lean.Parser.Command.macroArg">
          <NullNode/>
          <OtherNode start="(765, 7)" end="(765, 21)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(765, 7)" end="(765, 21)" kind="str">
              <AtomNode start="(765, 7)" end="(765, 21)" leading="" trailing=" " val="&amp;quot;refine_lift &amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(765, 22)" end="(765, 28)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(765, 22)" end="(765, 24)">
            <IdentNode start="(765, 22)" end="(765, 23)" leading="" trailing="" raw_val="e" val="e"/>
            <AtomNode start="(765, 23)" end="(765, 24)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(765, 24)" end="(765, 28)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(765, 24)" end="(765, 28)" leading="" trailing=" " raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(765, 29)" end="(765, 103)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(765, 29)" end="(765, 30)" leading="" trailing=" " val=":"/>
        <IdentNode start="(765, 31)" end="(765, 37)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(765, 38)" end="(765, 40)" leading="" trailing=" " val="=&amp;gt;"/>
        <OtherNode start="(765, 41)" end="(765, 103)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(765, 41)" end="(765, 103)" kind="Lean.Parser.Tactic.quot">
            <AtomNode start="(765, 41)" end="(765, 50)" leading="" trailing=" " val="`(tactic|"/>
            <OtherNode start="(765, 51)" end="(765, 102)" kind="Lean.Parser.Tactic.focus">
              <AtomNode start="(765, 51)" end="(765, 56)" leading="" trailing=" " val="focus"/>
              <TacticTacticseqNode start="(765, 57)" end="(765, 102)">
                <TacticTacticseq1IndentedNode start="(765, 57)" end="(765, 102)">
                  <NullNode start="(765, 57)" end="(765, 102)">
                    <OtherNode start="(765, 57)" end="(765, 102)" kind="Lean.Parser.Tactic.paren">
                      <AtomNode start="(765, 57)" end="(765, 58)" leading="" trailing="" val="("/>
                      <TacticTacticseqNode start="(765, 58)" end="(765, 101)">
                        <TacticTacticseq1IndentedNode start="(765, 58)" end="(765, 101)">
                          <NullNode start="(765, 58)" end="(765, 101)">
                            <OtherNode start="(765, 58)" end="(765, 87)" kind="Lean.Parser.Tactic.refine">
                              <AtomNode start="(765, 58)" end="(765, 64)" leading="" trailing=" " val="refine"/>
                              <OtherNode start="(765, 65)" end="(765, 87)" kind="Lean.Parser.Term.noImplicitLambda">
                                <AtomNode start="(765, 65)" end="(765, 84)" leading="" trailing=" " val="no_implicit_lambda%"/>
                                <OtherNode start="(765, 85)" end="(765, 87)" kind="term.pseudo.antiquot">
                                  <AtomNode start="(765, 85)" end="(765, 86)" leading="" trailing="" val="$"/>
                                  <NullNode/>
                                  <IdentNode start="(765, 86)" end="(765, 87)" leading="" trailing="" raw_val="e" val="e"/>
                                  <NullNode/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <AtomNode start="(765, 87)" end="(765, 88)" leading="" trailing=" " val=";"/>
                            <OtherNode start="(765, 89)" end="(765, 101)" kind="Lean.Parser.Tactic.rotateRight">
                              <AtomNode start="(765, 89)" end="(765, 101)" leading="" trailing="" val="rotate_right"/>
                              <NullNode/>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                      <AtomNode start="(765, 101)" end="(765, 102)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </TacticTacticseq1IndentedNode>
              </TacticTacticseqNode>
            </OtherNode>
            <AtomNode start="(765, 102)" end="(765, 103)" leading="" trailing="&#10;&#10;" val=")"/>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(767, 1)" end="(778, 33)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(767, 1)" end="(777, 3)">
        <CommandDoccommentNode start="(767, 1)" end="(777, 3)" comment="The `have` tactic is for adding hypotheses to the local context of the main goal.&#10;* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.&#10;* `have h := e` uses the type of `e` for `t`.&#10;* `have : t := e` and `have := e` use `this` for the name of the hypothesis.&#10;* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&amp;gt; _`,&#10;  where `_` stands for the tactics that follow this one.&#10;  It is convenient for types that have only one applicable constructor.&#10;  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the&#10;  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.&#10;-/">
          <AtomNode start="(767, 1)" end="(767, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(768, 1)" end="(777, 3)" leading="" trailing="&#10;" val="The `have` tactic is for adding hypotheses to the local context of the main goal.&#10;* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.&#10;* `have h := e` uses the type of `e` for `t`.&#10;* `have : t := e` and `have := e` use `this` for the name of the hypothesis.&#10;* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&amp;gt; _`,&#10;  where `_` stands for the tactics that follow this one.&#10;  It is convenient for types that have only one applicable constructor.&#10;  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the&#10;  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(778, 1)" end="(778, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(778, 8)" end="(778, 24)">
        <OtherNode start="(778, 8)" end="(778, 15)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(778, 8)" end="(778, 15)" kind="str">
            <AtomNode start="(778, 8)" end="(778, 15)" leading="" trailing=" " val="&amp;quot;have &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(778, 16)" end="(778, 24)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(778, 16)" end="(778, 24)" leading="" trailing=" " raw_val="haveDecl" val="haveDecl" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(778, 25)" end="(778, 26)" leading="" trailing=" " val=":"/>
      <IdentNode start="(778, 27)" end="(778, 33)" leading="" trailing="&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(779, 1)" end="(808, 79)" kind="Lean.Parser.Command.macro_rules">
      <NullNode/>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(779, 1)" end="(779, 12)" leading="" trailing="&#10;  -- special case: when given a nested `by` block, move it outside of the `refine` to enable&#10;  -- incrementality&#10;  " val="macro_rules"/>
      <NullNode/>
      <OtherNode start="(782, 3)" end="(808, 79)" kind="Lean.Parser.Term.matchAlts">
        <NullNode start="(782, 3)" end="(808, 79)">
          <OtherNode start="(782, 3)" end="(807, 12)" kind="Lean.Parser.Term.matchAlt">
            <AtomNode start="(782, 3)" end="(782, 4)" leading="" trailing=" " val="|"/>
            <NullNode start="(782, 5)" end="(782, 71)">
              <NullNode start="(782, 5)" end="(782, 71)">
                <OtherNode start="(782, 5)" end="(782, 71)" kind="Lean.Parser.Tactic.quot">
                  <AtomNode start="(782, 5)" end="(782, 14)" leading="" trailing=" " val="`(tactic|"/>
                  <OtherNode start="(782, 15)" end="(782, 70)" kind="Lean.Parser.Tactic.tacticHave_">
                    <TokenAntiquotNode start="(782, 15)" end="(782, 27)">
                      <AtomNode start="(782, 15)" end="(782, 19)" leading="" trailing="" val="have"/>
                      <AtomNode start="(782, 19)" end="(782, 20)" leading="" trailing="" val="%"/>
                      <AtomNode start="(782, 20)" end="(782, 21)" leading="" trailing="" val="$"/>
                      <IdentNode start="(782, 21)" end="(782, 27)" leading="" trailing=" " raw_val="haveTk" val="haveTk"/>
                    </TokenAntiquotNode>
                    <OtherNode start="(782, 28)" end="(782, 70)" kind="Lean.Parser.Term.haveDecl">
                      <OtherNode start="(782, 28)" end="(782, 70)" kind="Lean.Parser.Term.haveIdDecl">
                        <OtherNode start="(782, 28)" end="(782, 38)" kind="Lean.Parser.Term.haveId.antiquot">
                          <AtomNode start="(782, 28)" end="(782, 29)" leading="" trailing="" val="$"/>
                          <NullNode/>
                          <IdentNode start="(782, 29)" end="(782, 31)" leading="" trailing="" raw_val="id" val="id"/>
                          <OtherNode start="(782, 31)" end="(782, 38)" kind="antiquotName">
                            <AtomNode start="(782, 31)" end="(782, 32)" leading="" trailing="" val=":"/>
                            <AtomNode start="(782, 32)" end="(782, 38)" leading="" trailing=" " val="haveId"/>
                          </OtherNode>
                        </OtherNode>
                        <NullNode start="(782, 39)" end="(782, 43)">
                          <OtherNode start="(782, 39)" end="(782, 43)" kind="many.antiquot_suffix_splice">
                            <OtherNode start="(782, 39)" end="(782, 42)" kind="Lean.Parser.Term.letIdBinder.pseudo.antiquot">
                              <AtomNode start="(782, 39)" end="(782, 40)" leading="" trailing="" val="$"/>
                              <NullNode/>
                              <IdentNode start="(782, 40)" end="(782, 42)" leading="" trailing="" raw_val="bs" val="bs"/>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(782, 42)" end="(782, 43)" leading="" trailing=" " val="*"/>
                          </OtherNode>
                        </NullNode>
                        <NullNode start="(782, 44)" end="(782, 51)">
                          <TermTypespecNode start="(782, 44)" end="(782, 51)">
                            <AtomNode start="(782, 44)" end="(782, 45)" leading="" trailing=" " val=":"/>
                            <OtherNode start="(782, 46)" end="(782, 51)" kind="term.pseudo.antiquot">
                              <AtomNode start="(782, 46)" end="(782, 47)" leading="" trailing="" val="$"/>
                              <NullNode/>
                              <IdentNode start="(782, 47)" end="(782, 51)" leading="" trailing=" " raw_val="type" val="type"/>
                              <NullNode/>
                            </OtherNode>
                          </TermTypespecNode>
                        </NullNode>
                        <AtomNode start="(782, 52)" end="(782, 54)" leading="" trailing=" " val=":="/>
                        <TermBytacticNode start="(782, 55)" end="(782, 70)">
                          <TokenAntiquotNode start="(782, 55)" end="(782, 63)">
                            <AtomNode start="(782, 55)" end="(782, 57)" leading="" trailing="" val="by"/>
                            <AtomNode start="(782, 57)" end="(782, 58)" leading="" trailing="" val="%"/>
                            <AtomNode start="(782, 58)" end="(782, 59)" leading="" trailing="" val="$"/>
                            <IdentNode start="(782, 59)" end="(782, 63)" leading="" trailing=" " raw_val="byTk" val="byTk"/>
                          </TokenAntiquotNode>
                          <TacticTacticseqNode start="(782, 64)" end="(782, 70)">
                            <TacticTacticseq1IndentedNode start="(782, 64)" end="(782, 70)">
                              <NullNode start="(782, 64)" end="(782, 70)">
                                <OtherNode start="(782, 64)" end="(782, 70)" kind="sepBy.antiquot_suffix_splice">
                                  <OtherNode start="(782, 64)" end="(782, 69)" kind="tactic.pseudo.antiquot">
                                    <AtomNode start="(782, 64)" end="(782, 65)" leading="" trailing="" val="$"/>
                                    <NullNode/>
                                    <IdentNode start="(782, 65)" end="(782, 69)" leading="" trailing="" raw_val="tacs" val="tacs"/>
                                    <NullNode/>
                                  </OtherNode>
                                  <AtomNode start="(782, 69)" end="(782, 70)" leading="" trailing="" val="*"/>
                                </OtherNode>
                              </NullNode>
                            </TacticTacticseq1IndentedNode>
                          </TacticTacticseqNode>
                        </TermBytacticNode>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(782, 70)" end="(782, 71)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </NullNode>
            </NullNode>
            <AtomNode start="(782, 72)" end="(782, 74)" leading="" trailing=" " val="=&amp;gt;"/>
            <OtherNode start="(782, 75)" end="(807, 12)" kind="Lean.Parser.Term.do">
              <AtomNode start="(782, 75)" end="(782, 77)" leading="" trailing="&#10;    /-&#10;    We want to create the syntax&#10;    ```&#10;    focus&#10;      refine no_implicit_lambda% (have $id:haveId $bs* : $type := ?body; ?_)&#10;      case body =&amp;gt; $tacs*&#10;    ```&#10;    However, we need to be very careful with the syntax infos involved:&#10;    * We want most infos up to `tacs` to be independent of changes inside it so that incrementality&#10;      is not prematurely disabled; we use the `have` and then the `by` token as the reference for&#10;      this. Note that if we did nothing, the reference would be the entire `have` input and so any&#10;      change to `tacs` would change every token synthesized below.&#10;    * For the single node of the `case` body, we *should not* change the ref as this makes sure the&#10;      entire tactic block is included in any &amp;quot;unsaved goals&amp;quot; message (which is emitted after&#10;      execution of all nested tactics so it is indeed safe for `evalCase` to ignore it for&#10;      incrementality).&#10;    * Even after setting the ref, we still need a `with_annotate_state` to show the correct tactic&#10;      state on `by` as the synthetic info derived from the ref is ignored for this purpose.&#10;    -/&#10;    " val="do"/>
              <OtherNode start="(802, 5)" end="(807, 12)" kind="Lean.Parser.Term.doSeqIndent">
                <NullNode start="(802, 5)" end="(807, 12)">
                  <OtherNode start="(802, 5)" end="(802, 78)" kind="Lean.Parser.Term.doSeqItem">
                    <OtherNode start="(802, 5)" end="(802, 78)" kind="Lean.Parser.Term.doLetArrow">
                      <AtomNode start="(802, 5)" end="(802, 8)" leading="" trailing=" " val="let"/>
                      <NullNode/>
                      <OtherNode start="(802, 9)" end="(802, 78)" kind="Lean.Parser.Term.doIdDecl">
                        <IdentNode start="(802, 9)" end="(802, 12)" leading="" trailing=" " raw_val="tac" val="tac"/>
                        <NullNode/>
                        <AtomNode start="(802, 13)" end="(802, 14)" leading="" trailing=" " val="←"/>
                        <OtherNode start="(802, 15)" end="(802, 78)" kind="Lean.Parser.Term.doExpr">
                          <OtherNode start="(802, 15)" end="(802, 78)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(802, 15)" end="(802, 27)" leading="" trailing=" " raw_val="Lean.withRef" val="Lean.withRef" full_name="Lean.withRef" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            <NullNode start="(802, 28)" end="(802, 78)">
                              <IdentNode start="(802, 28)" end="(802, 32)" leading="" trailing=" " raw_val="byTk" val="byTk"/>
                              <OtherNode start="(802, 33)" end="(802, 78)" kind="Lean.Parser.Tactic.quot">
                                <AtomNode start="(802, 33)" end="(802, 42)" leading="" trailing=" " val="`(tactic|"/>
                                <OtherNode start="(802, 43)" end="(802, 77)" kind="Lean.Parser.Tactic.withAnnotateState">
                                  <AtomNode start="(802, 43)" end="(802, 62)" leading="" trailing=" " val="with_annotate_state"/>
                                  <OtherNode start="(802, 63)" end="(802, 68)" kind="rawStx.pseudo.antiquot">
                                    <AtomNode start="(802, 63)" end="(802, 64)" leading="" trailing="" val="$"/>
                                    <NullNode/>
                                    <IdentNode start="(802, 64)" end="(802, 68)" leading="" trailing=" " raw_val="byTk" val="byTk"/>
                                    <NullNode/>
                                  </OtherNode>
                                  <OtherNode start="(802, 69)" end="(802, 77)" kind="Lean.Parser.Tactic.paren">
                                    <AtomNode start="(802, 69)" end="(802, 70)" leading="" trailing="" val="("/>
                                    <TacticTacticseqNode start="(802, 70)" end="(802, 76)">
                                      <TacticTacticseq1IndentedNode start="(802, 70)" end="(802, 76)">
                                        <NullNode start="(802, 70)" end="(802, 76)">
                                          <OtherNode start="(802, 70)" end="(802, 76)" kind="sepBy.antiquot_suffix_splice">
                                            <OtherNode start="(802, 70)" end="(802, 75)" kind="tactic.pseudo.antiquot">
                                              <AtomNode start="(802, 70)" end="(802, 71)" leading="" trailing="" val="$"/>
                                              <NullNode/>
                                              <IdentNode start="(802, 71)" end="(802, 75)" leading="" trailing="" raw_val="tacs" val="tacs"/>
                                              <NullNode/>
                                            </OtherNode>
                                            <AtomNode start="(802, 75)" end="(802, 76)" leading="" trailing="" val="*"/>
                                          </OtherNode>
                                        </NullNode>
                                      </TacticTacticseq1IndentedNode>
                                    </TacticTacticseqNode>
                                    <AtomNode start="(802, 76)" end="(802, 77)" leading="" trailing="" val=")"/>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(802, 77)" end="(802, 78)" leading="" trailing="&#10;    " val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <OtherNode start="(803, 5)" end="(803, 40)" kind="Lean.Parser.Term.doSeqItem">
                    <OtherNode start="(803, 5)" end="(803, 40)" kind="Lean.Parser.Term.doLetArrow">
                      <AtomNode start="(803, 5)" end="(803, 8)" leading="" trailing=" " val="let"/>
                      <NullNode/>
                      <OtherNode start="(803, 9)" end="(803, 40)" kind="Lean.Parser.Term.doIdDecl">
                        <IdentNode start="(803, 9)" end="(803, 12)" leading="" trailing=" " raw_val="tac" val="tac"/>
                        <NullNode/>
                        <AtomNode start="(803, 13)" end="(803, 14)" leading="" trailing=" " val="←"/>
                        <OtherNode start="(803, 15)" end="(803, 40)" kind="Lean.Parser.Term.doExpr">
                          <OtherNode start="(803, 15)" end="(803, 40)" kind="Lean.Parser.Term.dynamicQuot">
                            <AtomNode start="(803, 15)" end="(803, 17)" leading="" trailing="" val="`("/>
                            <IdentNode start="(803, 17)" end="(803, 26)" leading="" trailing="" raw_val="tacticSeq" val="tacticSeq"/>
                            <AtomNode start="(803, 26)" end="(803, 27)" leading="" trailing=" " val="|"/>
                            <TacticTacticseqNode start="(803, 28)" end="(803, 39)">
                              <TacticTacticseq1IndentedNode start="(803, 28)" end="(803, 39)">
                                <NullNode start="(803, 28)" end="(803, 39)">
                                  <OtherNode start="(803, 28)" end="(803, 39)" kind="tactic.pseudo.antiquot">
                                    <AtomNode start="(803, 28)" end="(803, 29)" leading="" trailing="" val="$"/>
                                    <NullNode/>
                                    <IdentNode start="(803, 29)" end="(803, 32)" leading="" trailing="" raw_val="tac" val="tac"/>
                                    <OtherNode start="(803, 32)" end="(803, 39)" kind="antiquotName">
                                      <AtomNode start="(803, 32)" end="(803, 33)" leading="" trailing="" val=":"/>
                                      <AtomNode start="(803, 33)" end="(803, 39)" leading="" trailing="" val="tactic"/>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </TacticTacticseq1IndentedNode>
                            </TacticTacticseqNode>
                            <AtomNode start="(803, 39)" end="(803, 40)" leading="" trailing="&#10;    " val=")"/>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <OtherNode start="(804, 5)" end="(804, 77)" kind="Lean.Parser.Term.doSeqItem">
                    <OtherNode start="(804, 5)" end="(804, 77)" kind="Lean.Parser.Term.doLetArrow">
                      <AtomNode start="(804, 5)" end="(804, 8)" leading="" trailing=" " val="let"/>
                      <NullNode/>
                      <OtherNode start="(804, 9)" end="(804, 77)" kind="Lean.Parser.Term.doIdDecl">
                        <IdentNode start="(804, 9)" end="(804, 12)" leading="" trailing=" " raw_val="tac" val="tac"/>
                        <NullNode/>
                        <AtomNode start="(804, 13)" end="(804, 14)" leading="" trailing=" " val="←"/>
                        <OtherNode start="(804, 15)" end="(804, 77)" kind="Lean.Parser.Term.doExpr">
                          <OtherNode start="(804, 15)" end="(804, 77)" kind="Lean.Parser.Term.app">
                            <IdentNode start="(804, 15)" end="(804, 27)" leading="" trailing=" " raw_val="Lean.withRef" val="Lean.withRef" full_name="Lean.withRef" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                            <NullNode start="(804, 28)" end="(804, 77)">
                              <IdentNode start="(804, 28)" end="(804, 32)" leading="" trailing=" " raw_val="byTk" val="byTk"/>
                              <OtherNode start="(804, 33)" end="(804, 77)" kind="Lean.Parser.Tactic.quot">
                                <AtomNode start="(804, 33)" end="(804, 42)" leading="" trailing=" " val="`(tactic|"/>
                                <OtherNode start="(804, 43)" end="(804, 76)" kind="Lean.Parser.Tactic.case">
                                  <AtomNode start="(804, 43)" end="(804, 47)" leading="" trailing=" " val="case"/>
                                  <NullNode start="(804, 48)" end="(804, 52)">
                                    <OtherNode start="(804, 48)" end="(804, 52)" kind="Lean.Parser.Tactic.caseArg">
                                      <LeanBinderidentNode start="(804, 48)" end="(804, 52)">
                                        <IdentNode start="(804, 48)" end="(804, 52)" leading="" trailing=" " raw_val="body" val="body"/>
                                      </LeanBinderidentNode>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(804, 53)" end="(804, 55)" leading="" trailing=" " val="=&amp;gt;"/>
                                  <OtherNode start="(804, 56)" end="(804, 76)" kind="Lean.Parser.Tactic.tacticSeq.antiquot">
                                    <AtomNode start="(804, 56)" end="(804, 57)" leading="" trailing="" val="$"/>
                                    <NullNode/>
                                    <OtherNode start="(804, 57)" end="(804, 66)" kind="antiquotNestedExpr">
                                      <AtomNode start="(804, 57)" end="(804, 58)" leading="" trailing="" val="("/>
                                      <OtherNode start="(804, 58)" end="(804, 65)" kind="Lean.Parser.Term.app">
                                        <OtherNode start="(804, 58)" end="(804, 61)" kind="Lean.Parser.Term.dotIdent">
                                          <AtomNode start="(804, 58)" end="(804, 59)" leading="" trailing="" val="."/>
                                          <IdentNode start="(804, 59)" end="(804, 61)" leading="" trailing=" " raw_val="mk" val="mk"/>
                                        </OtherNode>
                                        <NullNode start="(804, 62)" end="(804, 65)">
                                          <IdentNode start="(804, 62)" end="(804, 65)" leading="" trailing="" raw_val="tac" val="tac"/>
                                        </NullNode>
                                      </OtherNode>
                                      <AtomNode start="(804, 65)" end="(804, 66)" leading="" trailing="" val=")"/>
                                    </OtherNode>
                                    <OtherNode start="(804, 66)" end="(804, 76)" kind="antiquotName">
                                      <AtomNode start="(804, 66)" end="(804, 67)" leading="" trailing="" val=":"/>
                                      <AtomNode start="(804, 67)" end="(804, 76)" leading="" trailing="" val="tacticSeq"/>
                                    </OtherNode>
                                  </OtherNode>
                                </OtherNode>
                                <AtomNode start="(804, 76)" end="(804, 77)" leading="" trailing="&#10;    " val=")"/>
                              </OtherNode>
                            </NullNode>
                          </OtherNode>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                  <OtherNode start="(805, 5)" end="(807, 12)" kind="Lean.Parser.Term.doSeqItem">
                    <OtherNode start="(805, 5)" end="(807, 12)" kind="Lean.Parser.Term.doExpr">
                      <OtherNode start="(805, 5)" end="(807, 12)" kind="Lean.Parser.Term.app">
                        <IdentNode start="(805, 5)" end="(805, 17)" leading="" trailing=" " raw_val="Lean.withRef" val="Lean.withRef" full_name="Lean.withRef" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode start="(805, 18)" end="(807, 12)">
                          <IdentNode start="(805, 18)" end="(805, 24)" leading="" trailing=" " raw_val="haveTk" val="haveTk"/>
                          <OtherNode start="(805, 25)" end="(807, 12)" kind="Lean.Parser.Tactic.quot">
                            <AtomNode start="(805, 25)" end="(805, 34)" leading="" trailing=" " val="`(tactic|"/>
                            <OtherNode start="(805, 35)" end="(807, 11)" kind="Lean.Parser.Tactic.focus">
                              <AtomNode start="(805, 35)" end="(805, 40)" leading="" trailing="&#10;      " val="focus"/>
                              <TacticTacticseqNode start="(806, 7)" end="(807, 11)">
                                <TacticTacticseq1IndentedNode start="(806, 7)" end="(807, 11)">
                                  <NullNode start="(806, 7)" end="(807, 11)">
                                    <OtherNode start="(806, 7)" end="(806, 77)" kind="Lean.Parser.Tactic.refine">
                                      <AtomNode start="(806, 7)" end="(806, 13)" leading="" trailing=" " val="refine"/>
                                      <OtherNode start="(806, 14)" end="(806, 77)" kind="Lean.Parser.Term.noImplicitLambda">
                                        <AtomNode start="(806, 14)" end="(806, 33)" leading="" trailing=" " val="no_implicit_lambda%"/>
                                        <OtherNode start="(806, 34)" end="(806, 77)" kind="Lean.Parser.Term.paren">
                                          <AtomNode start="(806, 34)" end="(806, 35)" leading="" trailing="" val="("/>
                                          <OtherNode start="(806, 35)" end="(806, 76)" kind="Lean.Parser.Term.have">
                                            <AtomNode start="(806, 35)" end="(806, 39)" leading="" trailing=" " val="have"/>
                                            <OtherNode start="(806, 40)" end="(806, 72)" kind="Lean.Parser.Term.haveDecl">
                                              <OtherNode start="(806, 40)" end="(806, 72)" kind="Lean.Parser.Term.haveIdDecl">
                                                <OtherNode start="(806, 40)" end="(806, 50)" kind="Lean.Parser.Term.haveId.antiquot">
                                                  <AtomNode start="(806, 40)" end="(806, 41)" leading="" trailing="" val="$"/>
                                                  <NullNode/>
                                                  <IdentNode start="(806, 41)" end="(806, 43)" leading="" trailing="" raw_val="id" val="id"/>
                                                  <OtherNode start="(806, 43)" end="(806, 50)" kind="antiquotName">
                                                    <AtomNode start="(806, 43)" end="(806, 44)" leading="" trailing="" val=":"/>
                                                    <AtomNode start="(806, 44)" end="(806, 50)" leading="" trailing=" " val="haveId"/>
                                                  </OtherNode>
                                                </OtherNode>
                                                <NullNode start="(806, 51)" end="(806, 55)">
                                                  <OtherNode start="(806, 51)" end="(806, 55)" kind="many.antiquot_suffix_splice">
                                                    <OtherNode start="(806, 51)" end="(806, 54)" kind="Lean.Parser.Term.letIdBinder.pseudo.antiquot">
                                                      <AtomNode start="(806, 51)" end="(806, 52)" leading="" trailing="" val="$"/>
                                                      <NullNode/>
                                                      <IdentNode start="(806, 52)" end="(806, 54)" leading="" trailing="" raw_val="bs" val="bs"/>
                                                      <NullNode/>
                                                    </OtherNode>
                                                    <AtomNode start="(806, 54)" end="(806, 55)" leading="" trailing=" " val="*"/>
                                                  </OtherNode>
                                                </NullNode>
                                                <NullNode start="(806, 56)" end="(806, 63)">
                                                  <TermTypespecNode start="(806, 56)" end="(806, 63)">
                                                    <AtomNode start="(806, 56)" end="(806, 57)" leading="" trailing=" " val=":"/>
                                                    <OtherNode start="(806, 58)" end="(806, 63)" kind="term.pseudo.antiquot">
                                                      <AtomNode start="(806, 58)" end="(806, 59)" leading="" trailing="" val="$"/>
                                                      <NullNode/>
                                                      <IdentNode start="(806, 59)" end="(806, 63)" leading="" trailing=" " raw_val="type" val="type"/>
                                                      <NullNode/>
                                                    </OtherNode>
                                                  </TermTypespecNode>
                                                </NullNode>
                                                <AtomNode start="(806, 64)" end="(806, 66)" leading="" trailing=" " val=":="/>
                                                <OtherNode start="(806, 67)" end="(806, 72)" kind="Lean.Parser.Term.syntheticHole">
                                                  <AtomNode start="(806, 67)" end="(806, 68)" leading="" trailing="" val="?"/>
                                                  <IdentNode start="(806, 68)" end="(806, 72)" leading="" trailing="" raw_val="body" val="body"/>
                                                </OtherNode>
                                              </OtherNode>
                                            </OtherNode>
                                            <AtomNode start="(806, 72)" end="(806, 73)" leading="" trailing=" " val=";"/>
                                            <OtherNode start="(806, 74)" end="(806, 76)" kind="Lean.Parser.Term.syntheticHole">
                                              <AtomNode start="(806, 74)" end="(806, 75)" leading="" trailing="" val="?"/>
                                              <AtomNode start="(806, 75)" end="(806, 76)" leading="" trailing="" val="_"/>
                                            </OtherNode>
                                          </OtherNode>
                                          <AtomNode start="(806, 76)" end="(806, 77)" leading="" trailing="&#10;      " val=")"/>
                                        </OtherNode>
                                      </OtherNode>
                                    </OtherNode>
                                    <NullNode/>
                                    <OtherNode start="(807, 7)" end="(807, 11)" kind="tactic.pseudo.antiquot">
                                      <AtomNode start="(807, 7)" end="(807, 8)" leading="" trailing="" val="$"/>
                                      <NullNode/>
                                      <IdentNode start="(807, 8)" end="(807, 11)" leading="" trailing="" raw_val="tac" val="tac"/>
                                      <NullNode/>
                                    </OtherNode>
                                  </NullNode>
                                </TacticTacticseq1IndentedNode>
                              </TacticTacticseqNode>
                            </OtherNode>
                            <AtomNode start="(807, 11)" end="(807, 12)" leading="" trailing="&#10;  " val=")"/>
                          </OtherNode>
                        </NullNode>
                      </OtherNode>
                    </OtherNode>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
          </OtherNode>
          <OtherNode start="(808, 3)" end="(808, 79)" kind="Lean.Parser.Term.matchAlt">
            <AtomNode start="(808, 3)" end="(808, 4)" leading="" trailing=" " val="|"/>
            <NullNode start="(808, 5)" end="(808, 32)">
              <NullNode start="(808, 5)" end="(808, 32)">
                <OtherNode start="(808, 5)" end="(808, 32)" kind="Lean.Parser.Tactic.quot">
                  <AtomNode start="(808, 5)" end="(808, 14)" leading="" trailing=" " val="`(tactic|"/>
                  <OtherNode start="(808, 15)" end="(808, 31)" kind="Lean.Parser.Tactic.tacticHave_">
                    <AtomNode start="(808, 15)" end="(808, 19)" leading="" trailing=" " val="have"/>
                    <OtherNode start="(808, 20)" end="(808, 31)" kind="Lean.Parser.Term.haveDecl.antiquot">
                      <AtomNode start="(808, 20)" end="(808, 21)" leading="" trailing="" val="$"/>
                      <NullNode/>
                      <IdentNode start="(808, 21)" end="(808, 22)" leading="" trailing="" raw_val="d" val="d"/>
                      <OtherNode start="(808, 22)" end="(808, 31)" kind="antiquotName">
                        <AtomNode start="(808, 22)" end="(808, 23)" leading="" trailing="" val=":"/>
                        <AtomNode start="(808, 23)" end="(808, 31)" leading="" trailing="" val="haveDecl"/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(808, 31)" end="(808, 32)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </NullNode>
            </NullNode>
            <AtomNode start="(808, 33)" end="(808, 35)" leading="" trailing=" " val="=&amp;gt;"/>
            <OtherNode start="(808, 36)" end="(808, 79)" kind="Lean.Parser.Tactic.quot">
              <AtomNode start="(808, 36)" end="(808, 45)" leading="" trailing=" " val="`(tactic|"/>
              <OtherNode start="(808, 46)" end="(808, 78)" kind="Lean.Parser.Tactic.tacticRefine_lift_">
                <AtomNode start="(808, 46)" end="(808, 57)" leading="" trailing=" " val="refine_lift"/>
                <OtherNode start="(808, 58)" end="(808, 78)" kind="Lean.Parser.Term.have">
                  <AtomNode start="(808, 58)" end="(808, 62)" leading="" trailing=" " val="have"/>
                  <OtherNode start="(808, 63)" end="(808, 74)" kind="Lean.Parser.Term.haveDecl.antiquot">
                    <AtomNode start="(808, 63)" end="(808, 64)" leading="" trailing="" val="$"/>
                    <NullNode/>
                    <IdentNode start="(808, 64)" end="(808, 65)" leading="" trailing="" raw_val="d" val="d"/>
                    <OtherNode start="(808, 65)" end="(808, 74)" kind="antiquotName">
                      <AtomNode start="(808, 65)" end="(808, 66)" leading="" trailing="" val=":"/>
                      <AtomNode start="(808, 66)" end="(808, 74)" leading="" trailing="" val="haveDecl"/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(808, 74)" end="(808, 75)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(808, 76)" end="(808, 78)" kind="Lean.Parser.Term.syntheticHole">
                    <AtomNode start="(808, 76)" end="(808, 77)" leading="" trailing="" val="?"/>
                    <AtomNode start="(808, 77)" end="(808, 78)" leading="" trailing="" val="_"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(808, 78)" end="(808, 79)" leading="" trailing="&#10;&#10;" val=")"/>
            </OtherNode>
          </OtherNode>
        </NullNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(810, 1)" end="(817, 84)" kind="Lean.Parser.Command.macro">
      <NullNode start="(810, 1)" end="(816, 4)">
        <CommandDoccommentNode start="(810, 1)" end="(816, 4)" comment="Given a main goal `ctx ⊢ t`, `suffices h : t' from e` replaces the main goal with `ctx ⊢ t'`,&#10;`e` must have type `t` in the context `ctx, h : t'`.&#10;&#10;The variant `suffices h : t' by tac` is a shorthand for `suffices h : t' from by tac`.&#10;If `h :` is omitted, the name `this` is used.&#10; -/">
          <AtomNode start="(810, 1)" end="(810, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(811, 1)" end="(816, 4)" leading="" trailing="&#10;" val="Given a main goal `ctx ⊢ t`, `suffices h : t' from e` replaces the main goal with `ctx ⊢ t'`,&#10;`e` must have type `t` in the context `ctx, h : t'`.&#10;&#10;The variant `suffices h : t' by tac` is a shorthand for `suffices h : t' from by tac`.&#10;If `h :` is omitted, the name `this` is used.&#10; -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(817, 1)" end="(817, 6)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(817, 7)" end="(817, 33)">
        <OtherNode start="(817, 7)" end="(817, 18)" kind="Lean.Parser.Command.macroArg">
          <NullNode/>
          <OtherNode start="(817, 7)" end="(817, 18)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(817, 7)" end="(817, 18)" kind="str">
              <AtomNode start="(817, 7)" end="(817, 18)" leading="" trailing=" " val="&amp;quot;suffices &amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(817, 19)" end="(817, 33)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(817, 19)" end="(817, 21)">
            <IdentNode start="(817, 19)" end="(817, 20)" leading="" trailing="" raw_val="d" val="d"/>
            <AtomNode start="(817, 20)" end="(817, 21)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(817, 21)" end="(817, 33)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(817, 21)" end="(817, 33)" leading="" trailing=" " raw_val="sufficesDecl" val="sufficesDecl" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(817, 34)" end="(817, 84)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(817, 34)" end="(817, 35)" leading="" trailing=" " val=":"/>
        <IdentNode start="(817, 36)" end="(817, 42)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(817, 43)" end="(817, 45)" leading="" trailing=" " val="=&amp;gt;"/>
        <OtherNode start="(817, 46)" end="(817, 84)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(817, 46)" end="(817, 84)" kind="Lean.Parser.Tactic.quot">
            <AtomNode start="(817, 46)" end="(817, 55)" leading="" trailing=" " val="`(tactic|"/>
            <OtherNode start="(817, 56)" end="(817, 83)" kind="Lean.Parser.Tactic.tacticRefine_lift_">
              <AtomNode start="(817, 56)" end="(817, 67)" leading="" trailing=" " val="refine_lift"/>
              <OtherNode start="(817, 68)" end="(817, 83)" kind="Lean.Parser.Term.suffices">
                <AtomNode start="(817, 68)" end="(817, 76)" leading="" trailing=" " val="suffices"/>
                <OtherNode start="(817, 77)" end="(817, 79)" kind="Lean.Parser.Term.sufficesDecl.antiquot">
                  <AtomNode start="(817, 77)" end="(817, 78)" leading="" trailing="" val="$"/>
                  <NullNode/>
                  <IdentNode start="(817, 78)" end="(817, 79)" leading="" trailing="" raw_val="d" val="d"/>
                  <NullNode/>
                </OtherNode>
                <AtomNode start="(817, 79)" end="(817, 80)" leading="" trailing=" " val=";"/>
                <OtherNode start="(817, 81)" end="(817, 83)" kind="Lean.Parser.Term.syntheticHole">
                  <AtomNode start="(817, 81)" end="(817, 82)" leading="" trailing="" val="?"/>
                  <AtomNode start="(817, 82)" end="(817, 83)" leading="" trailing="" val="_"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
            <AtomNode start="(817, 83)" end="(817, 84)" leading="" trailing="&#10;" val=")"/>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(818, 1)" end="(829, 77)" kind="Lean.Parser.Command.macro">
      <NullNode start="(818, 1)" end="(828, 3)">
        <CommandDoccommentNode start="(818, 1)" end="(828, 3)" comment="The `let` tactic is for adding definitions to the local context of the main goal.&#10;* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.&#10;* `let x := e` uses the type of `e` for `t`.&#10;* `let : t := e` and `let := e` use `this` for the name of the hypothesis.&#10;* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat =&amp;gt; _`,&#10;  where `_` stands for the tactics that follow this one.&#10;  It is convenient for types that let only one applicable constructor.&#10;  For example, given `p : α × β × γ`, `let ⟨x, y, z⟩ := p` produces the&#10;  local variables `x : α`, `y : β`, and `z : γ`.&#10;-/">
          <AtomNode start="(818, 1)" end="(818, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(819, 1)" end="(828, 3)" leading="" trailing="&#10;" val="The `let` tactic is for adding definitions to the local context of the main goal.&#10;* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.&#10;* `let x := e` uses the type of `e` for `t`.&#10;* `let : t := e` and `let := e` use `this` for the name of the hypothesis.&#10;* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat =&amp;gt; _`,&#10;  where `_` stands for the tactics that follow this one.&#10;  It is convenient for types that let only one applicable constructor.&#10;  For example, given `p : α × β × γ`, `let ⟨x, y, z⟩ := p` produces the&#10;  local variables `x : α`, `y : β`, and `z : γ`.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(829, 1)" end="(829, 6)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(829, 7)" end="(829, 23)">
        <OtherNode start="(829, 7)" end="(829, 13)" kind="Lean.Parser.Command.macroArg">
          <NullNode/>
          <OtherNode start="(829, 7)" end="(829, 13)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(829, 7)" end="(829, 13)" kind="str">
              <AtomNode start="(829, 7)" end="(829, 13)" leading="" trailing=" " val="&amp;quot;let &amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(829, 14)" end="(829, 23)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(829, 14)" end="(829, 16)">
            <IdentNode start="(829, 14)" end="(829, 15)" leading="" trailing="" raw_val="d" val="d"/>
            <AtomNode start="(829, 15)" end="(829, 16)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(829, 16)" end="(829, 23)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(829, 16)" end="(829, 23)" leading="" trailing=" " raw_val="letDecl" val="letDecl" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(829, 24)" end="(829, 77)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(829, 24)" end="(829, 25)" leading="" trailing=" " val=":"/>
        <IdentNode start="(829, 26)" end="(829, 32)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(829, 33)" end="(829, 35)" leading="" trailing=" " val="=&amp;gt;"/>
        <OtherNode start="(829, 36)" end="(829, 77)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(829, 36)" end="(829, 77)" kind="Lean.Parser.Tactic.quot">
            <AtomNode start="(829, 36)" end="(829, 45)" leading="" trailing=" " val="`(tactic|"/>
            <OtherNode start="(829, 46)" end="(829, 76)" kind="Lean.Parser.Tactic.tacticRefine_lift_">
              <AtomNode start="(829, 46)" end="(829, 57)" leading="" trailing=" " val="refine_lift"/>
              <OtherNode start="(829, 58)" end="(829, 76)" kind="Lean.Parser.Term.let">
                <AtomNode start="(829, 58)" end="(829, 61)" leading="" trailing=" " val="let"/>
                <OtherNode start="(829, 62)" end="(829, 72)" kind="Lean.Parser.Term.letDecl.antiquot">
                  <AtomNode start="(829, 62)" end="(829, 63)" leading="" trailing="" val="$"/>
                  <NullNode/>
                  <IdentNode start="(829, 63)" end="(829, 64)" leading="" trailing="" raw_val="d" val="d"/>
                  <OtherNode start="(829, 64)" end="(829, 72)" kind="antiquotName">
                    <AtomNode start="(829, 64)" end="(829, 65)" leading="" trailing="" val=":"/>
                    <AtomNode start="(829, 65)" end="(829, 72)" leading="" trailing="" val="letDecl"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(829, 72)" end="(829, 73)" leading="" trailing=" " val=";"/>
                <OtherNode start="(829, 74)" end="(829, 76)" kind="Lean.Parser.Term.syntheticHole">
                  <AtomNode start="(829, 74)" end="(829, 75)" leading="" trailing="" val="?"/>
                  <AtomNode start="(829, 75)" end="(829, 76)" leading="" trailing="" val="_"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
            <AtomNode start="(829, 76)" end="(829, 77)" leading="" trailing="&#10;" val=")"/>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(830, 1)" end="(834, 72)" kind="Lean.Parser.Command.macro">
      <NullNode start="(830, 1)" end="(833, 3)">
        <CommandDoccommentNode start="(830, 1)" end="(833, 3)" comment="`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,&#10; performs the unification, and replaces the target with the unified version of `t`.&#10;-/">
          <AtomNode start="(830, 1)" end="(830, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(831, 1)" end="(833, 3)" leading="" trailing="&#10;" val="`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,&#10; performs the unification, and replaces the target with the unified version of `t`.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(834, 1)" end="(834, 6)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(834, 7)" end="(834, 21)">
        <OtherNode start="(834, 7)" end="(834, 14)" kind="Lean.Parser.Command.macroArg">
          <NullNode/>
          <OtherNode start="(834, 7)" end="(834, 14)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(834, 7)" end="(834, 14)" kind="str">
              <AtomNode start="(834, 7)" end="(834, 14)" leading="" trailing=" " val="&amp;quot;show &amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(834, 15)" end="(834, 21)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(834, 15)" end="(834, 17)">
            <IdentNode start="(834, 15)" end="(834, 16)" leading="" trailing="" raw_val="e" val="e"/>
            <AtomNode start="(834, 16)" end="(834, 17)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(834, 17)" end="(834, 21)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(834, 17)" end="(834, 21)" leading="" trailing=" " raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(834, 22)" end="(834, 72)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(834, 22)" end="(834, 23)" leading="" trailing=" " val=":"/>
        <IdentNode start="(834, 24)" end="(834, 30)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(834, 31)" end="(834, 33)" leading="" trailing=" " val="=&amp;gt;"/>
        <OtherNode start="(834, 34)" end="(834, 72)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(834, 34)" end="(834, 72)" kind="Lean.Parser.Tactic.quot">
            <AtomNode start="(834, 34)" end="(834, 43)" leading="" trailing=" " val="`(tactic|"/>
            <OtherNode start="(834, 44)" end="(834, 71)" kind="Lean.Parser.Tactic.tacticRefine_lift_">
              <AtomNode start="(834, 44)" end="(834, 55)" leading="" trailing=" " val="refine_lift"/>
              <OtherNode start="(834, 56)" end="(834, 71)" kind="Lean.Parser.Term.show">
                <AtomNode start="(834, 56)" end="(834, 60)" leading="" trailing=" " val="show"/>
                <OtherNode start="(834, 61)" end="(834, 63)" kind="term.pseudo.antiquot">
                  <AtomNode start="(834, 61)" end="(834, 62)" leading="" trailing="" val="$"/>
                  <NullNode/>
                  <IdentNode start="(834, 62)" end="(834, 63)" leading="" trailing=" " raw_val="e" val="e"/>
                  <NullNode/>
                </OtherNode>
                <OtherNode start="(834, 64)" end="(834, 71)" kind="Lean.Parser.Term.fromTerm">
                  <AtomNode start="(834, 64)" end="(834, 68)" leading="" trailing=" " val="from"/>
                  <OtherNode start="(834, 69)" end="(834, 71)" kind="Lean.Parser.Term.syntheticHole">
                    <AtomNode start="(834, 69)" end="(834, 70)" leading="" trailing="" val="?"/>
                    <AtomNode start="(834, 70)" end="(834, 71)" leading="" trailing="" val="_"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </OtherNode>
            <AtomNode start="(834, 71)" end="(834, 72)" leading="" trailing=" -- TODO: fix, see comment&#10;" val=")"/>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(835, 1)" end="(837, 82)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(835, 1)" end="(836, 50)">
        <CommandDoccommentNode start="(835, 1)" end="(836, 50)" comment="`let rec f : t := e` adds a recursive definition `f` to the current goal.&#10;The syntax is the same as term-mode `let rec`. -/">
          <AtomNode start="(835, 1)" end="(835, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(835, 5)" end="(836, 50)" leading="" trailing="&#10;" val="`let rec f : t := e` adds a recursive definition `f` to the current goal.&#10;The syntax is the same as term-mode `let rec`. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(837, 1)" end="(837, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(837, 8)" end="(837, 24)">
        <OtherNode start="(837, 8)" end="(837, 24)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(837, 8)" end="(837, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(837, 9)" end="(837, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(837, 14)" end="(837, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(837, 17)" end="(837, 23)" leading="" trailing="" raw_val="letrec" val="letrec"/>
          <AtomNode start="(837, 23)" end="(837, 24)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(837, 25)" end="(837, 73)">
        <OtherNode start="(837, 25)" end="(837, 73)" kind="Lean.Parser.Syntax.unary">
          <IdentNode start="(837, 25)" end="(837, 37)" leading="" trailing="" raw_val="withPosition" val="withPosition"/>
          <AtomNode start="(837, 37)" end="(837, 38)" leading="" trailing="" val="("/>
          <NullNode start="(837, 38)" end="(837, 72)">
            <OtherNode start="(837, 38)" end="(837, 60)" kind="Lean.Parser.Syntax.unary">
              <IdentNode start="(837, 38)" end="(837, 44)" leading="" trailing="" raw_val="atomic" val="atomic"/>
              <AtomNode start="(837, 44)" end="(837, 45)" leading="" trailing="" val="("/>
              <NullNode start="(837, 45)" end="(837, 59)">
                <OtherNode start="(837, 45)" end="(837, 51)" kind="Lean.Parser.Syntax.atom">
                  <OtherNode start="(837, 45)" end="(837, 51)" kind="str">
                    <AtomNode start="(837, 45)" end="(837, 51)" leading="" trailing=" " val="&amp;quot;let &amp;quot;"/>
                  </OtherNode>
                </OtherNode>
                <OtherNode start="(837, 52)" end="(837, 59)" kind="Lean.Parser.Syntax.nonReserved">
                  <AtomNode start="(837, 52)" end="(837, 53)" leading="" trailing="" val="&amp;amp;"/>
                  <OtherNode start="(837, 53)" end="(837, 59)" kind="str">
                    <AtomNode start="(837, 53)" end="(837, 59)" leading="" trailing="" val="&amp;quot;rec &amp;quot;"/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(837, 59)" end="(837, 60)" leading="" trailing=" " val=")"/>
            </OtherNode>
            <OtherNode start="(837, 61)" end="(837, 72)" kind="Lean.Parser.Syntax.cat">
              <IdentNode start="(837, 61)" end="(837, 72)" leading="" trailing="" raw_val="letRecDecls" val="letRecDecls" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              <NullNode/>
            </OtherNode>
          </NullNode>
          <AtomNode start="(837, 72)" end="(837, 73)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(837, 74)" end="(837, 75)" leading="" trailing=" " val=":"/>
      <IdentNode start="(837, 76)" end="(837, 82)" leading="" trailing="&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(838, 1)" end="(839, 67)" kind="Lean.Parser.Command.macro_rules">
      <NullNode/>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(838, 1)" end="(838, 12)" leading="" trailing="&#10;  " val="macro_rules"/>
      <NullNode/>
      <OtherNode start="(839, 3)" end="(839, 67)" kind="Lean.Parser.Term.matchAlts">
        <NullNode start="(839, 3)" end="(839, 67)">
          <OtherNode start="(839, 3)" end="(839, 67)" kind="Lean.Parser.Term.matchAlt">
            <AtomNode start="(839, 3)" end="(839, 4)" leading="" trailing=" " val="|"/>
            <NullNode start="(839, 5)" end="(839, 26)">
              <NullNode start="(839, 5)" end="(839, 26)">
                <OtherNode start="(839, 5)" end="(839, 26)" kind="Lean.Parser.Tactic.quot">
                  <AtomNode start="(839, 5)" end="(839, 14)" leading="" trailing=" " val="`(tactic|"/>
                  <OtherNode start="(839, 15)" end="(839, 25)" kind="Lean.Parser.Tactic.letrec">
                    <AtomNode start="(839, 15)" end="(839, 18)" leading="" trailing=" " val="let"/>
                    <AtomNode start="(839, 19)" end="(839, 22)" leading="" trailing=" " val="rec"/>
                    <OtherNode start="(839, 23)" end="(839, 25)" kind="Lean.Parser.Term.letRecDecls.antiquot">
                      <AtomNode start="(839, 23)" end="(839, 24)" leading="" trailing="" val="$"/>
                      <NullNode/>
                      <IdentNode start="(839, 24)" end="(839, 25)" leading="" trailing="" raw_val="d" val="d"/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(839, 25)" end="(839, 26)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </NullNode>
            </NullNode>
            <AtomNode start="(839, 27)" end="(839, 29)" leading="" trailing=" " val="=&amp;gt;"/>
            <OtherNode start="(839, 30)" end="(839, 67)" kind="Lean.Parser.Tactic.quot">
              <AtomNode start="(839, 30)" end="(839, 39)" leading="" trailing=" " val="`(tactic|"/>
              <OtherNode start="(839, 40)" end="(839, 66)" kind="Lean.Parser.Tactic.tacticRefine_lift_">
                <AtomNode start="(839, 40)" end="(839, 51)" leading="" trailing=" " val="refine_lift"/>
                <OtherNode start="(839, 52)" end="(839, 66)" kind="Lean.Parser.Term.letrec">
                  <GroupNode start="(839, 52)" end="(839, 59)">
                    <AtomNode start="(839, 52)" end="(839, 55)" leading="" trailing=" " val="let"/>
                    <AtomNode start="(839, 56)" end="(839, 59)" leading="" trailing=" " val="rec"/>
                  </GroupNode>
                  <OtherNode start="(839, 60)" end="(839, 62)" kind="Lean.Parser.Term.letRecDecls.antiquot">
                    <AtomNode start="(839, 60)" end="(839, 61)" leading="" trailing="" val="$"/>
                    <NullNode/>
                    <IdentNode start="(839, 61)" end="(839, 62)" leading="" trailing="" raw_val="d" val="d"/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(839, 62)" end="(839, 63)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(839, 64)" end="(839, 66)" kind="Lean.Parser.Term.syntheticHole">
                    <AtomNode start="(839, 64)" end="(839, 65)" leading="" trailing="" val="?"/>
                    <AtomNode start="(839, 65)" end="(839, 66)" leading="" trailing="" val="_"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(839, 66)" end="(839, 67)" leading="" trailing="&#10;&#10;" val=")"/>
            </OtherNode>
          </OtherNode>
        </NullNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(841, 1)" end="(842, 105)" kind="Lean.Parser.Command.macro">
      <NullNode start="(841, 1)" end="(841, 53)">
        <CommandDoccommentNode start="(841, 1)" end="(841, 53)" comment="Similar to `refine_lift`, but using `refine'` -/">
          <AtomNode start="(841, 1)" end="(841, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(841, 5)" end="(841, 53)" leading="" trailing="&#10;" val="Similar to `refine_lift`, but using `refine'` -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(842, 1)" end="(842, 6)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(842, 7)" end="(842, 29)">
        <OtherNode start="(842, 7)" end="(842, 22)" kind="Lean.Parser.Command.macroArg">
          <NullNode/>
          <OtherNode start="(842, 7)" end="(842, 22)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(842, 7)" end="(842, 22)" kind="str">
              <AtomNode start="(842, 7)" end="(842, 22)" leading="" trailing=" " val="&amp;quot;refine_lift' &amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(842, 23)" end="(842, 29)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(842, 23)" end="(842, 25)">
            <IdentNode start="(842, 23)" end="(842, 24)" leading="" trailing="" raw_val="e" val="e"/>
            <AtomNode start="(842, 24)" end="(842, 25)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(842, 25)" end="(842, 29)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(842, 25)" end="(842, 29)" leading="" trailing=" " raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(842, 30)" end="(842, 105)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(842, 30)" end="(842, 31)" leading="" trailing=" " val=":"/>
        <IdentNode start="(842, 32)" end="(842, 38)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(842, 39)" end="(842, 41)" leading="" trailing=" " val="=&amp;gt;"/>
        <OtherNode start="(842, 42)" end="(842, 105)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(842, 42)" end="(842, 105)" kind="Lean.Parser.Tactic.quot">
            <AtomNode start="(842, 42)" end="(842, 51)" leading="" trailing=" " val="`(tactic|"/>
            <OtherNode start="(842, 52)" end="(842, 104)" kind="Lean.Parser.Tactic.focus">
              <AtomNode start="(842, 52)" end="(842, 57)" leading="" trailing=" " val="focus"/>
              <TacticTacticseqNode start="(842, 58)" end="(842, 104)">
                <TacticTacticseq1IndentedNode start="(842, 58)" end="(842, 104)">
                  <NullNode start="(842, 58)" end="(842, 104)">
                    <OtherNode start="(842, 58)" end="(842, 104)" kind="Lean.Parser.Tactic.paren">
                      <AtomNode start="(842, 58)" end="(842, 59)" leading="" trailing="" val="("/>
                      <TacticTacticseqNode start="(842, 59)" end="(842, 103)">
                        <TacticTacticseq1IndentedNode start="(842, 59)" end="(842, 103)">
                          <NullNode start="(842, 59)" end="(842, 103)">
                            <OtherNode start="(842, 59)" end="(842, 89)" kind="Lean.Parser.Tactic.refine'">
                              <AtomNode start="(842, 59)" end="(842, 66)" leading="" trailing=" " val="refine'"/>
                              <OtherNode start="(842, 67)" end="(842, 89)" kind="Lean.Parser.Term.noImplicitLambda">
                                <AtomNode start="(842, 67)" end="(842, 86)" leading="" trailing=" " val="no_implicit_lambda%"/>
                                <OtherNode start="(842, 87)" end="(842, 89)" kind="term.pseudo.antiquot">
                                  <AtomNode start="(842, 87)" end="(842, 88)" leading="" trailing="" val="$"/>
                                  <NullNode/>
                                  <IdentNode start="(842, 88)" end="(842, 89)" leading="" trailing="" raw_val="e" val="e"/>
                                  <NullNode/>
                                </OtherNode>
                              </OtherNode>
                            </OtherNode>
                            <AtomNode start="(842, 89)" end="(842, 90)" leading="" trailing=" " val=";"/>
                            <OtherNode start="(842, 91)" end="(842, 103)" kind="Lean.Parser.Tactic.rotateRight">
                              <AtomNode start="(842, 91)" end="(842, 103)" leading="" trailing="" val="rotate_right"/>
                              <NullNode/>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                      <AtomNode start="(842, 103)" end="(842, 104)" leading="" trailing="" val=")"/>
                    </OtherNode>
                  </NullNode>
                </TacticTacticseq1IndentedNode>
              </TacticTacticseqNode>
            </OtherNode>
            <AtomNode start="(842, 104)" end="(842, 105)" leading="" trailing="&#10;" val=")"/>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(843, 1)" end="(844, 83)" kind="Lean.Parser.Command.macro">
      <NullNode start="(843, 1)" end="(843, 46)">
        <CommandDoccommentNode start="(843, 1)" end="(843, 46)" comment="Similar to `have`, but using `refine'` -/">
          <AtomNode start="(843, 1)" end="(843, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(843, 5)" end="(843, 46)" leading="" trailing="&#10;" val="Similar to `have`, but using `refine'` -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(844, 1)" end="(844, 6)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(844, 7)" end="(844, 26)">
        <OtherNode start="(844, 7)" end="(844, 15)" kind="Lean.Parser.Command.macroArg">
          <NullNode/>
          <OtherNode start="(844, 7)" end="(844, 15)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(844, 7)" end="(844, 15)" kind="str">
              <AtomNode start="(844, 7)" end="(844, 15)" leading="" trailing=" " val="&amp;quot;have' &amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(844, 16)" end="(844, 26)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(844, 16)" end="(844, 18)">
            <IdentNode start="(844, 16)" end="(844, 17)" leading="" trailing="" raw_val="d" val="d"/>
            <AtomNode start="(844, 17)" end="(844, 18)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(844, 18)" end="(844, 26)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(844, 18)" end="(844, 26)" leading="" trailing=" " raw_val="haveDecl" val="haveDecl" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(844, 27)" end="(844, 83)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(844, 27)" end="(844, 28)" leading="" trailing=" " val=":"/>
        <IdentNode start="(844, 29)" end="(844, 35)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(844, 36)" end="(844, 38)" leading="" trailing=" " val="=&amp;gt;"/>
        <OtherNode start="(844, 39)" end="(844, 83)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(844, 39)" end="(844, 83)" kind="Lean.Parser.Tactic.quot">
            <AtomNode start="(844, 39)" end="(844, 48)" leading="" trailing=" " val="`(tactic|"/>
            <OtherNode start="(844, 49)" end="(844, 82)" kind="Lean.Parser.Tactic.tacticRefine_lift'_">
              <AtomNode start="(844, 49)" end="(844, 61)" leading="" trailing=" " val="refine_lift'"/>
              <OtherNode start="(844, 62)" end="(844, 82)" kind="Lean.Parser.Term.have">
                <AtomNode start="(844, 62)" end="(844, 66)" leading="" trailing=" " val="have"/>
                <OtherNode start="(844, 67)" end="(844, 78)" kind="Lean.Parser.Term.haveDecl.antiquot">
                  <AtomNode start="(844, 67)" end="(844, 68)" leading="" trailing="" val="$"/>
                  <NullNode/>
                  <IdentNode start="(844, 68)" end="(844, 69)" leading="" trailing="" raw_val="d" val="d"/>
                  <OtherNode start="(844, 69)" end="(844, 78)" kind="antiquotName">
                    <AtomNode start="(844, 69)" end="(844, 70)" leading="" trailing="" val=":"/>
                    <AtomNode start="(844, 70)" end="(844, 78)" leading="" trailing="" val="haveDecl"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(844, 78)" end="(844, 79)" leading="" trailing=" " val=";"/>
                <OtherNode start="(844, 80)" end="(844, 82)" kind="Lean.Parser.Term.syntheticHole">
                  <AtomNode start="(844, 80)" end="(844, 81)" leading="" trailing="" val="?"/>
                  <AtomNode start="(844, 81)" end="(844, 82)" leading="" trailing="" val="_"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
            <AtomNode start="(844, 82)" end="(844, 83)" leading="" trailing="&#10;" val=")"/>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(845, 1)" end="(846, 103)" kind="Lean.Parser.Command.in">
      <OtherNode start="(845, 1)" end="(845, 36)" kind="Lean.Parser.Command.set_option">
        <AtomNode start="(845, 1)" end="(845, 11)" leading="" trailing=" " val="set_option"/>
        <IdentNode start="(845, 12)" end="(845, 30)" leading="" trailing=" " raw_val="linter.missingDocs" val="linter.missingDocs"/>
        <NullNode/>
        <AtomNode start="(845, 31)" end="(845, 36)" leading="" trailing=" " val="false"/>
      </OtherNode>
      <AtomNode start="(845, 37)" end="(845, 39)" leading="" trailing=" -- OK, because `tactic_alt` causes inheritance of docs&#10;" val="in"/>
      <OtherNode start="(846, 1)" end="(846, 103)" kind="Lean.Parser.Command.macro">
        <NullNode/>
        <NullNode/>
        <TermAttrkindNode>
          <NullNode/>
        </TermAttrkindNode>
        <AtomNode start="(846, 1)" end="(846, 6)" leading="" trailing=" " val="macro"/>
        <NullNode/>
        <NullNode/>
        <NullNode start="(846, 7)" end="(846, 25)">
          <OtherNode start="(846, 7)" end="(846, 25)" kind="Lean.Parser.Command.namedPrio">
            <AtomNode start="(846, 7)" end="(846, 8)" leading="" trailing="" val="("/>
            <AtomNode start="(846, 8)" end="(846, 16)" leading="" trailing=" " val="priority"/>
            <AtomNode start="(846, 17)" end="(846, 19)" leading="" trailing=" " val=":="/>
            <OtherNode start="(846, 20)" end="(846, 24)" kind="prioHigh">
              <AtomNode start="(846, 20)" end="(846, 24)" leading="" trailing="" val="high"/>
            </OtherNode>
            <AtomNode start="(846, 24)" end="(846, 25)" leading="" trailing=" " val=")"/>
          </OtherNode>
        </NullNode>
        <NullNode start="(846, 26)" end="(846, 55)">
          <OtherNode start="(846, 26)" end="(846, 33)" kind="Lean.Parser.Command.macroArg">
            <NullNode/>
            <OtherNode start="(846, 26)" end="(846, 33)" kind="Lean.Parser.Syntax.atom">
              <OtherNode start="(846, 26)" end="(846, 33)" kind="str">
                <AtomNode start="(846, 26)" end="(846, 33)" leading="" trailing=" " val="&amp;quot;have'&amp;quot;"/>
              </OtherNode>
            </OtherNode>
          </OtherNode>
          <OtherNode start="(846, 34)" end="(846, 41)" kind="Lean.Parser.Command.macroArg">
            <NullNode start="(846, 34)" end="(846, 36)">
              <IdentNode start="(846, 34)" end="(846, 35)" leading="" trailing="" raw_val="x" val="x"/>
              <AtomNode start="(846, 35)" end="(846, 36)" leading="" trailing="" val=":"/>
            </NullNode>
            <OtherNode start="(846, 36)" end="(846, 41)" kind="Lean.Parser.Syntax.cat">
              <IdentNode start="(846, 36)" end="(846, 41)" leading="" trailing=" " raw_val="ident" val="ident" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              <NullNode/>
            </OtherNode>
          </OtherNode>
          <OtherNode start="(846, 42)" end="(846, 48)" kind="Lean.Parser.Command.macroArg">
            <NullNode/>
            <OtherNode start="(846, 42)" end="(846, 48)" kind="Lean.Parser.Syntax.atom">
              <OtherNode start="(846, 42)" end="(846, 48)" kind="str">
                <AtomNode start="(846, 42)" end="(846, 48)" leading="" trailing=" " val="&amp;quot; := &amp;quot;"/>
              </OtherNode>
            </OtherNode>
          </OtherNode>
          <OtherNode start="(846, 49)" end="(846, 55)" kind="Lean.Parser.Command.macroArg">
            <NullNode start="(846, 49)" end="(846, 51)">
              <IdentNode start="(846, 49)" end="(846, 50)" leading="" trailing="" raw_val="p" val="p"/>
              <AtomNode start="(846, 50)" end="(846, 51)" leading="" trailing="" val=":"/>
            </NullNode>
            <OtherNode start="(846, 51)" end="(846, 55)" kind="Lean.Parser.Syntax.cat">
              <IdentNode start="(846, 51)" end="(846, 55)" leading="" trailing=" " raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              <NullNode/>
            </OtherNode>
          </OtherNode>
        </NullNode>
        <OtherNode start="(846, 56)" end="(846, 103)" kind="Lean.Parser.Command.macroTail">
          <AtomNode start="(846, 56)" end="(846, 57)" leading="" trailing=" " val=":"/>
          <IdentNode start="(846, 58)" end="(846, 64)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
          <AtomNode start="(846, 65)" end="(846, 67)" leading="" trailing=" " val="=&amp;gt;"/>
          <OtherNode start="(846, 68)" end="(846, 103)" kind="Lean.Parser.Command.macroRhs">
            <OtherNode start="(846, 68)" end="(846, 103)" kind="Lean.Parser.Tactic.quot">
              <AtomNode start="(846, 68)" end="(846, 77)" leading="" trailing=" " val="`(tactic|"/>
              <OtherNode start="(846, 78)" end="(846, 102)" kind="Lean.Parser.Tactic.tacticHave'_">
                <AtomNode start="(846, 78)" end="(846, 83)" leading="" trailing=" " val="have'"/>
                <OtherNode start="(846, 84)" end="(846, 102)" kind="Lean.Parser.Term.haveDecl">
                  <OtherNode start="(846, 84)" end="(846, 102)" kind="Lean.Parser.Term.haveIdDecl">
                    <OtherNode start="(846, 84)" end="(846, 92)" kind="Lean.Parser.Term.haveId">
                      <IdentAntiquotNode start="(846, 84)" end="(846, 92)">
                        <AtomNode start="(846, 84)" end="(846, 85)" leading="" trailing="" val="$"/>
                        <NullNode/>
                        <IdentNode start="(846, 85)" end="(846, 86)" leading="" trailing="" raw_val="x" val="x"/>
                        <OtherNode start="(846, 86)" end="(846, 92)" kind="antiquotName">
                          <AtomNode start="(846, 86)" end="(846, 87)" leading="" trailing="" val=":"/>
                          <AtomNode start="(846, 87)" end="(846, 92)" leading="" trailing=" " val="ident"/>
                        </OtherNode>
                      </IdentAntiquotNode>
                    </OtherNode>
                    <NullNode/>
                    <NullNode start="(846, 93)" end="(846, 96)">
                      <TermTypespecNode start="(846, 93)" end="(846, 96)">
                        <AtomNode start="(846, 93)" end="(846, 94)" leading="" trailing=" " val=":"/>
                        <TermHoleNode start="(846, 95)" end="(846, 96)">
                          <AtomNode start="(846, 95)" end="(846, 96)" leading="" trailing=" " val="_"/>
                        </TermHoleNode>
                      </TermTypespecNode>
                    </NullNode>
                    <AtomNode start="(846, 97)" end="(846, 99)" leading="" trailing=" " val=":="/>
                    <OtherNode start="(846, 100)" end="(846, 102)" kind="term.pseudo.antiquot">
                      <AtomNode start="(846, 100)" end="(846, 101)" leading="" trailing="" val="$"/>
                      <NullNode/>
                      <IdentNode start="(846, 101)" end="(846, 102)" leading="" trailing="" raw_val="p" val="p"/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(846, 102)" end="(846, 103)" leading="" trailing="&#10;" val=")"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(847, 1)" end="(847, 54)" kind="Lean.Parser.Command.attribute">
      <AtomNode start="(847, 1)" end="(847, 10)" leading="" trailing=" " val="attribute"/>
      <AtomNode start="(847, 11)" end="(847, 12)" leading="" trailing="" val="["/>
      <NullNode start="(847, 12)" end="(847, 35)">
        <OtherNode start="(847, 12)" end="(847, 35)" kind="Lean.Parser.Term.attrInstance">
          <TermAttrkindNode>
            <NullNode/>
          </TermAttrkindNode>
          <OtherNode start="(847, 12)" end="(847, 35)" kind="Lean.Parser.Attr.tactic_alt">
            <AtomNode start="(847, 12)" end="(847, 22)" leading="" trailing=" " val="tactic_alt"/>
            <IdentNode start="(847, 23)" end="(847, 35)" leading="" trailing="" raw_val="tacticHave'_" val="tacticHave'_" full_name="Lean.Parser.Tactic.tacticHave'_" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(844, 1)" def_end="(844, 6)"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(847, 35)" end="(847, 36)" leading="" trailing=" " val="]"/>
      <NullNode start="(847, 37)" end="(847, 54)">
        <IdentNode start="(847, 37)" end="(847, 54)" leading="" trailing="&#10;" raw_val="«tacticHave'_:=_»" val="«tacticHave'_:=_»" full_name="Lean.Parser.Tactic.«tacticHave'_:=_»" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(846, 1)" def_end="(846, 6)"/>
      </NullNode>
    </OtherNode>
    <OtherNode start="(848, 1)" end="(849, 79)" kind="Lean.Parser.Command.macro">
      <NullNode start="(848, 1)" end="(848, 45)">
        <CommandDoccommentNode start="(848, 1)" end="(848, 45)" comment="Similar to `let`, but using `refine'` -/">
          <AtomNode start="(848, 1)" end="(848, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(848, 5)" end="(848, 45)" leading="" trailing="&#10;" val="Similar to `let`, but using `refine'` -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(849, 1)" end="(849, 6)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(849, 7)" end="(849, 24)">
        <OtherNode start="(849, 7)" end="(849, 14)" kind="Lean.Parser.Command.macroArg">
          <NullNode/>
          <OtherNode start="(849, 7)" end="(849, 14)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(849, 7)" end="(849, 14)" kind="str">
              <AtomNode start="(849, 7)" end="(849, 14)" leading="" trailing=" " val="&amp;quot;let' &amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(849, 15)" end="(849, 24)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(849, 15)" end="(849, 17)">
            <IdentNode start="(849, 15)" end="(849, 16)" leading="" trailing="" raw_val="d" val="d"/>
            <AtomNode start="(849, 16)" end="(849, 17)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(849, 17)" end="(849, 24)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(849, 17)" end="(849, 24)" leading="" trailing=" " raw_val="letDecl" val="letDecl" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(849, 25)" end="(849, 79)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(849, 25)" end="(849, 26)" leading="" trailing=" " val=":"/>
        <IdentNode start="(849, 27)" end="(849, 33)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(849, 34)" end="(849, 36)" leading="" trailing=" " val="=&amp;gt;"/>
        <OtherNode start="(849, 37)" end="(849, 79)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(849, 37)" end="(849, 79)" kind="Lean.Parser.Tactic.quot">
            <AtomNode start="(849, 37)" end="(849, 46)" leading="" trailing=" " val="`(tactic|"/>
            <OtherNode start="(849, 47)" end="(849, 78)" kind="Lean.Parser.Tactic.tacticRefine_lift'_">
              <AtomNode start="(849, 47)" end="(849, 59)" leading="" trailing=" " val="refine_lift'"/>
              <OtherNode start="(849, 60)" end="(849, 78)" kind="Lean.Parser.Term.let">
                <AtomNode start="(849, 60)" end="(849, 63)" leading="" trailing=" " val="let"/>
                <OtherNode start="(849, 64)" end="(849, 74)" kind="Lean.Parser.Term.letDecl.antiquot">
                  <AtomNode start="(849, 64)" end="(849, 65)" leading="" trailing="" val="$"/>
                  <NullNode/>
                  <IdentNode start="(849, 65)" end="(849, 66)" leading="" trailing="" raw_val="d" val="d"/>
                  <OtherNode start="(849, 66)" end="(849, 74)" kind="antiquotName">
                    <AtomNode start="(849, 66)" end="(849, 67)" leading="" trailing="" val=":"/>
                    <AtomNode start="(849, 67)" end="(849, 74)" leading="" trailing="" val="letDecl"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(849, 74)" end="(849, 75)" leading="" trailing=" " val=";"/>
                <OtherNode start="(849, 76)" end="(849, 78)" kind="Lean.Parser.Term.syntheticHole">
                  <AtomNode start="(849, 76)" end="(849, 77)" leading="" trailing="" val="?"/>
                  <AtomNode start="(849, 77)" end="(849, 78)" leading="" trailing="" val="_"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
            <AtomNode start="(849, 78)" end="(849, 79)" leading="" trailing="&#10;&#10;" val=")"/>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(851, 1)" end="(856, 95)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(851, 1)" end="(855, 3)">
        <CommandDoccommentNode start="(851, 1)" end="(855, 3)" comment="The left hand side of an induction arm, `| foo a b c` or `| @foo a b c`&#10;where `foo` is a constructor of the inductive type and `a b c` are the arguments&#10;to the constructor.&#10;-/">
          <AtomNode start="(851, 1)" end="(851, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(852, 1)" end="(855, 3)" leading="" trailing="&#10;" val="The left hand side of an induction arm, `| foo a b c` or `| @foo a b c`&#10;where `foo` is a constructor of the inductive type and `a b c` are the arguments&#10;to the constructor.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(856, 1)" end="(856, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(856, 8)" end="(856, 23)" leading="" trailing=" " raw_val="inductionAltLHS" val="inductionAltLHS"/>
      <AtomNode start="(856, 24)" end="(856, 26)" leading="" trailing=" " val=":="/>
      <NullNode start="(856, 27)" end="(856, 95)">
        <OtherNode start="(856, 27)" end="(856, 95)" kind="Lean.Parser.Syntax.unary">
          <IdentNode start="(856, 27)" end="(856, 39)" leading="" trailing="" raw_val="withPosition" val="withPosition"/>
          <AtomNode start="(856, 39)" end="(856, 40)" leading="" trailing="" val="("/>
          <NullNode start="(856, 40)" end="(856, 94)">
            <OtherNode start="(856, 40)" end="(856, 44)" kind="Lean.Parser.Syntax.atom">
              <OtherNode start="(856, 40)" end="(856, 44)" kind="str">
                <AtomNode start="(856, 40)" end="(856, 44)" leading="" trailing=" " val="&amp;quot;| &amp;quot;"/>
              </OtherNode>
            </OtherNode>
            <OtherNode start="(856, 45)" end="(856, 68)" kind="Lean.Parser.Syntax.paren">
              <AtomNode start="(856, 45)" end="(856, 46)" leading="" trailing="" val="("/>
              <NullNode start="(856, 46)" end="(856, 67)">
                <OtherNode start="(856, 46)" end="(856, 67)" kind="«stx_&amp;lt;|&amp;gt;_»">
                  <OtherNode start="(856, 46)" end="(856, 58)" kind="Lean.Parser.Syntax.paren">
                    <AtomNode start="(856, 46)" end="(856, 47)" leading="" trailing="" val="("/>
                    <NullNode start="(856, 47)" end="(856, 57)">
                      <OtherNode start="(856, 47)" end="(856, 51)" kind="stx_?">
                        <OtherNode start="(856, 47)" end="(856, 50)" kind="Lean.Parser.Syntax.atom">
                          <OtherNode start="(856, 47)" end="(856, 50)" kind="str">
                            <AtomNode start="(856, 47)" end="(856, 50)" leading="" trailing="" val="&amp;quot;@&amp;quot;"/>
                          </OtherNode>
                        </OtherNode>
                        <AtomNode start="(856, 50)" end="(856, 51)" leading="" trailing=" " val="?"/>
                      </OtherNode>
                      <OtherNode start="(856, 52)" end="(856, 57)" kind="Lean.Parser.Syntax.cat">
                        <IdentNode start="(856, 52)" end="(856, 57)" leading="" trailing="" raw_val="ident" val="ident" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(856, 57)" end="(856, 58)" leading="" trailing=" " val=")"/>
                  </OtherNode>
                  <AtomNode start="(856, 59)" end="(856, 62)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
                  <OtherNode start="(856, 63)" end="(856, 67)" kind="Lean.Parser.Syntax.cat">
                    <IdentNode start="(856, 63)" end="(856, 67)" leading="" trailing="" raw_val="hole" val="hole" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
              </NullNode>
              <AtomNode start="(856, 67)" end="(856, 68)" leading="" trailing=" " val=")"/>
            </OtherNode>
            <OtherNode start="(856, 69)" end="(856, 94)" kind="«stx_*»">
              <OtherNode start="(856, 69)" end="(856, 93)" kind="Lean.Parser.Syntax.paren">
                <AtomNode start="(856, 69)" end="(856, 70)" leading="" trailing="" val="("/>
                <NullNode start="(856, 70)" end="(856, 92)">
                  <OtherNode start="(856, 70)" end="(856, 75)" kind="Lean.Parser.Syntax.cat">
                    <IdentNode start="(856, 70)" end="(856, 75)" leading="" trailing=" " raw_val="colGt" val="colGt" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode/>
                  </OtherNode>
                  <OtherNode start="(856, 76)" end="(856, 92)" kind="Lean.Parser.Syntax.paren">
                    <AtomNode start="(856, 76)" end="(856, 77)" leading="" trailing="" val="("/>
                    <NullNode start="(856, 77)" end="(856, 91)">
                      <OtherNode start="(856, 77)" end="(856, 91)" kind="«stx_&amp;lt;|&amp;gt;_»">
                        <OtherNode start="(856, 77)" end="(856, 82)" kind="Lean.Parser.Syntax.cat">
                          <IdentNode start="(856, 77)" end="(856, 82)" leading="" trailing=" " raw_val="ident" val="ident" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode/>
                        </OtherNode>
                        <AtomNode start="(856, 83)" end="(856, 86)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
                        <OtherNode start="(856, 87)" end="(856, 91)" kind="Lean.Parser.Syntax.cat">
                          <IdentNode start="(856, 87)" end="(856, 91)" leading="" trailing="" raw_val="hole" val="hole" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                          <NullNode/>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(856, 91)" end="(856, 92)" leading="" trailing="" val=")"/>
                  </OtherNode>
                </NullNode>
                <AtomNode start="(856, 92)" end="(856, 93)" leading="" trailing="" val=")"/>
              </OtherNode>
              <AtomNode start="(856, 93)" end="(856, 94)" leading="" trailing="" val="*"/>
            </OtherNode>
          </NullNode>
          <AtomNode start="(856, 94)" end="(856, 95)" leading="" trailing="&#10;" val=")"/>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(857, 1)" end="(861, 107)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(857, 1)" end="(860, 3)">
        <CommandDoccommentNode start="(857, 1)" end="(860, 3)" comment="In induction alternative, which can have 1 or more cases on the left&#10;and `_`, `?_`, or a tactic sequence after the `=&amp;gt;`.&#10;-/">
          <AtomNode start="(857, 1)" end="(857, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(858, 1)" end="(860, 3)" leading="" trailing="&#10;" val="In induction alternative, which can have 1 or more cases on the left&#10;and `_`, `?_`, or a tactic sequence after the `=&amp;gt;`.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(861, 1)" end="(861, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(861, 8)" end="(861, 20)" leading="" trailing="  " raw_val="inductionAlt" val="inductionAlt"/>
      <AtomNode start="(861, 22)" end="(861, 24)" leading="" trailing=" " val=":="/>
      <NullNode start="(861, 25)" end="(861, 107)">
        <OtherNode start="(861, 25)" end="(861, 41)" kind="Lean.Parser.Syntax.unary">
          <IdentNode start="(861, 25)" end="(861, 33)" leading="" trailing="" raw_val="ppDedent" val="ppDedent"/>
          <AtomNode start="(861, 33)" end="(861, 34)" leading="" trailing="" val="("/>
          <NullNode start="(861, 34)" end="(861, 40)">
            <OtherNode start="(861, 34)" end="(861, 40)" kind="Lean.Parser.Syntax.cat">
              <IdentNode start="(861, 34)" end="(861, 40)" leading="" trailing="" raw_val="ppLine" val="ppLine" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              <NullNode/>
            </OtherNode>
          </NullNode>
          <AtomNode start="(861, 40)" end="(861, 41)" leading="" trailing=" " val=")"/>
        </OtherNode>
        <OtherNode start="(861, 42)" end="(861, 58)" kind="«stx_+»">
          <OtherNode start="(861, 42)" end="(861, 57)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(861, 42)" end="(861, 57)" leading="" trailing="" raw_val="inductionAltLHS" val="inductionAltLHS" full_name="Lean.Parser.Tactic.inductionAltLHS" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(856, 8)" def_end="(856, 23)"/>
            <NullNode/>
          </OtherNode>
          <AtomNode start="(861, 57)" end="(861, 58)" leading="" trailing=" " val="+"/>
        </OtherNode>
        <OtherNode start="(861, 59)" end="(861, 107)" kind="stx_?">
          <OtherNode start="(861, 59)" end="(861, 106)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(861, 59)" end="(861, 60)" leading="" trailing="" val="("/>
            <NullNode start="(861, 60)" end="(861, 105)">
              <OtherNode start="(861, 60)" end="(861, 66)" kind="Lean.Parser.Syntax.atom">
                <OtherNode start="(861, 60)" end="(861, 66)" kind="str">
                  <AtomNode start="(861, 60)" end="(861, 66)" leading="" trailing=" " val="&amp;quot; =&amp;gt; &amp;quot;"/>
                </OtherNode>
              </OtherNode>
              <OtherNode start="(861, 67)" end="(861, 105)" kind="Lean.Parser.Syntax.paren">
                <AtomNode start="(861, 67)" end="(861, 68)" leading="" trailing="" val="("/>
                <NullNode start="(861, 68)" end="(861, 104)">
                  <OtherNode start="(861, 68)" end="(861, 104)" kind="«stx_&amp;lt;|&amp;gt;_»">
                    <OtherNode start="(861, 68)" end="(861, 72)" kind="Lean.Parser.Syntax.cat">
                      <IdentNode start="(861, 68)" end="(861, 72)" leading="" trailing=" " raw_val="hole" val="hole" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(861, 73)" end="(861, 76)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
                    <OtherNode start="(861, 77)" end="(861, 104)" kind="«stx_&amp;lt;|&amp;gt;_»">
                      <OtherNode start="(861, 77)" end="(861, 90)" kind="Lean.Parser.Syntax.cat">
                        <IdentNode start="(861, 77)" end="(861, 90)" leading="" trailing=" " raw_val="syntheticHole" val="syntheticHole" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode/>
                      </OtherNode>
                      <AtomNode start="(861, 91)" end="(861, 94)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
                      <OtherNode start="(861, 95)" end="(861, 104)" kind="Lean.Parser.Syntax.cat">
                        <IdentNode start="(861, 95)" end="(861, 104)" leading="" trailing="" raw_val="tacticSeq" val="tacticSeq" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                        <NullNode/>
                      </OtherNode>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
                <AtomNode start="(861, 104)" end="(861, 105)" leading="" trailing="" val=")"/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(861, 105)" end="(861, 106)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(861, 106)" end="(861, 107)" leading="" trailing="&#10;" val="?"/>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(862, 1)" end="(866, 92)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(862, 1)" end="(865, 3)">
        <CommandDoccommentNode start="(862, 1)" end="(865, 3)" comment="After `with`, there is an optional tactic that runs on all branches, and&#10;then a list of alternatives.&#10;-/">
          <AtomNode start="(862, 1)" end="(862, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(863, 1)" end="(865, 3)" leading="" trailing="&#10;" val="After `with`, there is an optional tactic that runs on all branches, and&#10;then a list of alternatives.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(866, 1)" end="(866, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(866, 8)" end="(866, 21)" leading="" trailing=" " raw_val="inductionAlts" val="inductionAlts"/>
      <AtomNode start="(866, 22)" end="(866, 24)" leading="" trailing=" " val=":="/>
      <NullNode start="(866, 25)" end="(866, 92)">
        <OtherNode start="(866, 25)" end="(866, 32)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(866, 25)" end="(866, 32)" kind="str">
            <AtomNode start="(866, 25)" end="(866, 32)" leading="" trailing=" " val="&amp;quot; with&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(866, 33)" end="(866, 56)" kind="stx_?">
          <OtherNode start="(866, 33)" end="(866, 55)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(866, 33)" end="(866, 34)" leading="" trailing="" val="("/>
            <NullNode start="(866, 34)" end="(866, 54)">
              <OtherNode start="(866, 34)" end="(866, 41)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(866, 34)" end="(866, 41)" leading="" trailing=" " raw_val="ppSpace" val="ppSpace" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(866, 42)" end="(866, 47)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(866, 42)" end="(866, 47)" leading="" trailing=" " raw_val="colGt" val="colGt" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(866, 48)" end="(866, 54)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(866, 48)" end="(866, 54)" leading="" trailing="" raw_val="tactic" val="tactic" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(866, 54)" end="(866, 55)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(866, 55)" end="(866, 56)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(866, 57)" end="(866, 92)" kind="Lean.Parser.Syntax.unary">
          <IdentNode start="(866, 57)" end="(866, 69)" leading="" trailing="" raw_val="withPosition" val="withPosition"/>
          <AtomNode start="(866, 69)" end="(866, 70)" leading="" trailing="" val="("/>
          <NullNode start="(866, 70)" end="(866, 91)">
            <OtherNode start="(866, 70)" end="(866, 91)" kind="«stx_*»">
              <OtherNode start="(866, 70)" end="(866, 90)" kind="Lean.Parser.Syntax.paren">
                <AtomNode start="(866, 70)" end="(866, 71)" leading="" trailing="" val="("/>
                <NullNode start="(866, 71)" end="(866, 89)">
                  <OtherNode start="(866, 71)" end="(866, 76)" kind="Lean.Parser.Syntax.cat">
                    <IdentNode start="(866, 71)" end="(866, 76)" leading="" trailing=" " raw_val="colGe" val="colGe" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode/>
                  </OtherNode>
                  <OtherNode start="(866, 77)" end="(866, 89)" kind="Lean.Parser.Syntax.cat">
                    <IdentNode start="(866, 77)" end="(866, 89)" leading="" trailing="" raw_val="inductionAlt" val="inductionAlt" full_name="Lean.Parser.Tactic.inductionAlt" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(861, 8)" def_end="(861, 20)"/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
                <AtomNode start="(866, 89)" end="(866, 90)" leading="" trailing="" val=")"/>
              </OtherNode>
              <AtomNode start="(866, 90)" end="(866, 91)" leading="" trailing="" val="*"/>
            </OtherNode>
          </NullNode>
          <AtomNode start="(866, 91)" end="(866, 92)" leading="" trailing="&#10;&#10;" val=")"/>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(868, 1)" end="(875, 53)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(868, 1)" end="(874, 3)">
        <CommandDoccommentNode start="(868, 1)" end="(874, 3)" comment="A target for the `induction` or `cases` tactic, of the form `e` or `h : e`.&#10;&#10;The `h : e` syntax introduces a hypotheses of the form `h : e = _` in each goal,&#10;with `_` replaced by the corresponding value of the target.&#10;It is useful when `e` is not a free variable.&#10;-/">
          <AtomNode start="(868, 1)" end="(868, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(869, 1)" end="(874, 3)" leading="" trailing="&#10;" val="A target for the `induction` or `cases` tactic, of the form `e` or `h : e`.&#10;&#10;The `h : e` syntax introduces a hypotheses of the form `h : e = _` in each goal,&#10;with `_` replaced by the corresponding value of the target.&#10;It is useful when `e` is not a free variable.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(875, 1)" end="(875, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(875, 8)" end="(875, 18)" leading="" trailing=" " raw_val="elimTarget" val="elimTarget"/>
      <AtomNode start="(875, 19)" end="(875, 21)" leading="" trailing=" " val=":="/>
      <NullNode start="(875, 22)" end="(875, 53)">
        <OtherNode start="(875, 22)" end="(875, 48)" kind="stx_?">
          <OtherNode start="(875, 22)" end="(875, 47)" kind="Lean.Parser.Syntax.unary">
            <IdentNode start="(875, 22)" end="(875, 28)" leading="" trailing="" raw_val="atomic" val="atomic"/>
            <AtomNode start="(875, 28)" end="(875, 29)" leading="" trailing="" val="("/>
            <NullNode start="(875, 29)" end="(875, 46)">
              <OtherNode start="(875, 29)" end="(875, 40)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(875, 29)" end="(875, 40)" leading="" trailing=" " raw_val="binderIdent" val="binderIdent" full_name="Lean.binderIdent" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(875, 41)" end="(875, 46)" kind="Lean.Parser.Syntax.atom">
                <OtherNode start="(875, 41)" end="(875, 46)" kind="str">
                  <AtomNode start="(875, 41)" end="(875, 46)" leading="" trailing="" val="&amp;quot; : &amp;quot;"/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(875, 46)" end="(875, 47)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(875, 47)" end="(875, 48)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(875, 49)" end="(875, 53)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(875, 49)" end="(875, 53)" leading="" trailing="&#10;" raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(876, 1)" end="(903, 73)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(876, 1)" end="(901, 3)">
        <CommandDoccommentNode start="(876, 1)" end="(901, 3)" comment="Assuming `x` is a variable in the local context with an inductive type,&#10;`induction x` applies induction on `x` to the main goal,&#10;producing one goal for each constructor of the inductive type,&#10;in which the target is replaced by a general instance of that constructor&#10;and an inductive hypothesis is added for each recursive argument to the constructor.&#10;If the type of an element in the local context depends on `x`,&#10;that element is reverted and reintroduced afterward,&#10;so that the inductive hypothesis incorporates that hypothesis as well.&#10;&#10;For example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,&#10;`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,&#10;and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.&#10;Here the names `a` and `ih₁` are chosen automatically and are not accessible.&#10;You can use `with` to provide the variables names for each constructor.&#10;- `induction e`, where `e` is an expression instead of a variable,&#10;  generalizes `e` in the goal, and then performs induction on the resulting variable.&#10;- `induction e using r` allows the user to specify the principle of induction that should be used.&#10;  Here `r` should be a term whose result type must be of the form `C t`,&#10;  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables&#10;- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,&#10;  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.&#10;  In other words, the net effect is that each inductive hypothesis is generalized.&#10;- Given `x : Nat`, `induction x with | zero =&amp;gt; tac₁ | succ x' ih =&amp;gt; tac₂`&#10;  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.&#10;-/">
          <AtomNode start="(876, 1)" end="(876, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(877, 1)" end="(901, 3)" leading="" trailing="&#10;" val="Assuming `x` is a variable in the local context with an inductive type,&#10;`induction x` applies induction on `x` to the main goal,&#10;producing one goal for each constructor of the inductive type,&#10;in which the target is replaced by a general instance of that constructor&#10;and an inductive hypothesis is added for each recursive argument to the constructor.&#10;If the type of an element in the local context depends on `x`,&#10;that element is reverted and reintroduced afterward,&#10;so that the inductive hypothesis incorporates that hypothesis as well.&#10;&#10;For example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,&#10;`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,&#10;and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.&#10;Here the names `a` and `ih₁` are chosen automatically and are not accessible.&#10;You can use `with` to provide the variables names for each constructor.&#10;- `induction e`, where `e` is an expression instead of a variable,&#10;  generalizes `e` in the goal, and then performs induction on the resulting variable.&#10;- `induction e using r` allows the user to specify the principle of induction that should be used.&#10;  Here `r` should be a term whose result type must be of the form `C t`,&#10;  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables&#10;- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,&#10;  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.&#10;  In other words, the net effect is that each inductive hypothesis is generalized.&#10;- Given `x : Nat`, `induction x with | zero =&amp;gt; tac₁ | succ x' ih =&amp;gt; tac₂`&#10;  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(902, 1)" end="(902, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(902, 8)" end="(902, 27)">
        <OtherNode start="(902, 8)" end="(902, 27)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(902, 8)" end="(902, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(902, 9)" end="(902, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(902, 14)" end="(902, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(902, 17)" end="(902, 26)" leading="" trailing="" raw_val="induction" val="induction"/>
          <AtomNode start="(902, 26)" end="(902, 27)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(902, 28)" end="(903, 64)">
        <OtherNode start="(902, 28)" end="(902, 40)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(902, 28)" end="(902, 40)" kind="str">
            <AtomNode start="(902, 28)" end="(902, 40)" leading="" trailing=" " val="&amp;quot;induction &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(902, 41)" end="(902, 53)" kind="«stx_,+»">
          <OtherNode start="(902, 41)" end="(902, 51)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(902, 41)" end="(902, 51)" leading="" trailing="" raw_val="elimTarget" val="elimTarget" full_name="Lean.Parser.Tactic.elimTarget" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(875, 8)" def_end="(875, 18)"/>
            <NullNode/>
          </OtherNode>
          <AtomNode start="(902, 51)" end="(902, 53)" leading="" trailing=" " val=",+"/>
        </OtherNode>
        <OtherNode start="(902, 54)" end="(902, 71)" kind="stx_?">
          <OtherNode start="(902, 54)" end="(902, 70)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(902, 54)" end="(902, 55)" leading="" trailing="" val="("/>
            <NullNode start="(902, 55)" end="(902, 69)">
              <OtherNode start="(902, 55)" end="(902, 64)" kind="Lean.Parser.Syntax.atom">
                <OtherNode start="(902, 55)" end="(902, 64)" kind="str">
                  <AtomNode start="(902, 55)" end="(902, 64)" leading="" trailing=" " val="&amp;quot; using &amp;quot;"/>
                </OtherNode>
              </OtherNode>
              <OtherNode start="(902, 65)" end="(902, 69)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(902, 65)" end="(902, 69)" leading="" trailing="" raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(902, 69)" end="(902, 70)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(902, 70)" end="(902, 71)" leading="" trailing="&#10;  " val="?"/>
        </OtherNode>
        <OtherNode start="(903, 3)" end="(903, 47)" kind="stx_?">
          <OtherNode start="(903, 3)" end="(903, 46)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(903, 3)" end="(903, 4)" leading="" trailing="" val="("/>
            <NullNode start="(903, 4)" end="(903, 45)">
              <OtherNode start="(903, 4)" end="(903, 19)" kind="Lean.Parser.Syntax.atom">
                <OtherNode start="(903, 4)" end="(903, 19)" kind="str">
                  <AtomNode start="(903, 4)" end="(903, 19)" leading="" trailing=" " val="&amp;quot; generalizing&amp;quot;"/>
                </OtherNode>
              </OtherNode>
              <OtherNode start="(903, 20)" end="(903, 45)" kind="«stx_+»">
                <OtherNode start="(903, 20)" end="(903, 44)" kind="Lean.Parser.Syntax.paren">
                  <AtomNode start="(903, 20)" end="(903, 21)" leading="" trailing="" val="("/>
                  <NullNode start="(903, 21)" end="(903, 43)">
                    <OtherNode start="(903, 21)" end="(903, 28)" kind="Lean.Parser.Syntax.cat">
                      <IdentNode start="(903, 21)" end="(903, 28)" leading="" trailing=" " raw_val="ppSpace" val="ppSpace" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(903, 29)" end="(903, 34)" kind="Lean.Parser.Syntax.cat">
                      <IdentNode start="(903, 29)" end="(903, 34)" leading="" trailing=" " raw_val="colGt" val="colGt" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(903, 35)" end="(903, 43)" kind="Lean.Parser.Syntax.cat">
                      <IdentNode start="(903, 35)" end="(903, 39)" leading="" trailing="" raw_val="term" val="term" full_name="Lean.Parser.Category.term" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
                      <NullNode start="(903, 39)" end="(903, 43)">
                        <OtherNode start="(903, 39)" end="(903, 43)" kind="Lean.Parser.precedence">
                          <AtomNode start="(903, 39)" end="(903, 40)" leading="" trailing="" val=":"/>
                          <OtherNode start="(903, 40)" end="(903, 43)" kind="precMax">
                            <AtomNode start="(903, 40)" end="(903, 43)" leading="" trailing="" val="max"/>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(903, 43)" end="(903, 44)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(903, 44)" end="(903, 45)" leading="" trailing="" val="+"/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(903, 45)" end="(903, 46)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(903, 46)" end="(903, 47)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(903, 48)" end="(903, 64)" kind="stx_?">
          <OtherNode start="(903, 48)" end="(903, 63)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(903, 48)" end="(903, 49)" leading="" trailing="" val="("/>
            <NullNode start="(903, 49)" end="(903, 62)">
              <OtherNode start="(903, 49)" end="(903, 62)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(903, 49)" end="(903, 62)" leading="" trailing="" raw_val="inductionAlts" val="inductionAlts" full_name="Lean.Parser.Tactic.inductionAlts" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(866, 8)" def_end="(866, 21)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(903, 62)" end="(903, 63)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(903, 63)" end="(903, 64)" leading="" trailing=" " val="?"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(903, 65)" end="(903, 66)" leading="" trailing=" " val=":"/>
      <IdentNode start="(903, 67)" end="(903, 73)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(905, 1)" end="(906, 65)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(905, 1)" end="(905, 74)">
        <CommandDoccommentNode start="(905, 1)" end="(905, 74)" comment="A `generalize` argument, of the form `term = x` or `h : term = x`. -/">
          <AtomNode start="(905, 1)" end="(905, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(905, 5)" end="(905, 74)" leading="" trailing="&#10;" val="A `generalize` argument, of the form `term = x` or `h : term = x`. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(906, 1)" end="(906, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(906, 8)" end="(906, 21)" leading="" trailing=" " raw_val="generalizeArg" val="generalizeArg"/>
      <AtomNode start="(906, 22)" end="(906, 24)" leading="" trailing=" " val=":="/>
      <NullNode start="(906, 25)" end="(906, 65)">
        <OtherNode start="(906, 25)" end="(906, 45)" kind="stx_?">
          <OtherNode start="(906, 25)" end="(906, 44)" kind="Lean.Parser.Syntax.unary">
            <IdentNode start="(906, 25)" end="(906, 31)" leading="" trailing="" raw_val="atomic" val="atomic"/>
            <AtomNode start="(906, 31)" end="(906, 32)" leading="" trailing="" val="("/>
            <NullNode start="(906, 32)" end="(906, 43)">
              <OtherNode start="(906, 32)" end="(906, 37)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(906, 32)" end="(906, 37)" leading="" trailing=" " raw_val="ident" val="ident" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(906, 38)" end="(906, 43)" kind="Lean.Parser.Syntax.atom">
                <OtherNode start="(906, 38)" end="(906, 43)" kind="str">
                  <AtomNode start="(906, 38)" end="(906, 43)" leading="" trailing="" val="&amp;quot; : &amp;quot;"/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(906, 43)" end="(906, 44)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(906, 44)" end="(906, 45)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(906, 46)" end="(906, 53)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(906, 46)" end="(906, 50)" leading="" trailing="" raw_val="term" val="term" full_name="Lean.Parser.Category.term" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
          <NullNode start="(906, 50)" end="(906, 53)">
            <OtherNode start="(906, 50)" end="(906, 53)" kind="Lean.Parser.precedence">
              <AtomNode start="(906, 50)" end="(906, 51)" leading="" trailing="" val=":"/>
              <OtherNode start="(906, 51)" end="(906, 53)" kind="num">
                <AtomNode start="(906, 51)" end="(906, 53)" leading="" trailing=" " val="51"/>
              </OtherNode>
            </OtherNode>
          </NullNode>
        </OtherNode>
        <OtherNode start="(906, 54)" end="(906, 59)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(906, 54)" end="(906, 59)" kind="str">
            <AtomNode start="(906, 54)" end="(906, 59)" leading="" trailing=" " val="&amp;quot; = &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(906, 60)" end="(906, 65)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(906, 60)" end="(906, 65)" leading="" trailing="&#10;&#10;" raw_val="ident" val="ident" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(908, 1)" end="(915, 79)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(908, 1)" end="(914, 3)">
        <CommandDoccommentNode start="(908, 1)" end="(914, 3)" comment="* `generalize ([h :] e = x),+` replaces all occurrences `e`s in the main goal&#10;  with a fresh hypothesis `x`s. If `h` is given, `h : e = x` is introduced as well.&#10;* `generalize e = x at h₁ ... hₙ` also generalizes occurrences of `e`&#10;  inside `h₁`, ..., `hₙ`.&#10;* `generalize e = x at *` will generalize occurrences of `e` everywhere.&#10;-/">
          <AtomNode start="(908, 1)" end="(908, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(909, 1)" end="(914, 3)" leading="" trailing="&#10;" val="* `generalize ([h :] e = x),+` replaces all occurrences `e`s in the main goal&#10;  with a fresh hypothesis `x`s. If `h` is given, `h : e = x` is introduced as well.&#10;* `generalize e = x at h₁ ... hₙ` also generalizes occurrences of `e`&#10;  inside `h₁`, ..., `hₙ`.&#10;* `generalize e = x at *` will generalize occurrences of `e` everywhere.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(915, 1)" end="(915, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(915, 8)" end="(915, 28)">
        <OtherNode start="(915, 8)" end="(915, 28)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(915, 8)" end="(915, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(915, 9)" end="(915, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(915, 14)" end="(915, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(915, 17)" end="(915, 27)" leading="" trailing="" raw_val="generalize" val="generalize"/>
          <AtomNode start="(915, 27)" end="(915, 28)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(915, 29)" end="(915, 70)">
        <OtherNode start="(915, 29)" end="(915, 42)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(915, 29)" end="(915, 42)" kind="str">
            <AtomNode start="(915, 29)" end="(915, 42)" leading="" trailing=" " val="&amp;quot;generalize &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(915, 43)" end="(915, 58)" kind="«stx_,+»">
          <OtherNode start="(915, 43)" end="(915, 56)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(915, 43)" end="(915, 56)" leading="" trailing="" raw_val="generalizeArg" val="generalizeArg" full_name="Lean.Parser.Tactic.generalizeArg" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(906, 8)" def_end="(906, 21)"/>
            <NullNode/>
          </OtherNode>
          <AtomNode start="(915, 56)" end="(915, 58)" leading="" trailing=" " val=",+"/>
        </OtherNode>
        <OtherNode start="(915, 59)" end="(915, 70)" kind="stx_?">
          <OtherNode start="(915, 59)" end="(915, 69)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(915, 59)" end="(915, 60)" leading="" trailing="" val="("/>
            <NullNode start="(915, 60)" end="(915, 68)">
              <OtherNode start="(915, 60)" end="(915, 68)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(915, 60)" end="(915, 68)" leading="" trailing="" raw_val="location" val="location" full_name="Lean.Parser.Tactic.location" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(484, 8)" def_end="(484, 16)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(915, 68)" end="(915, 69)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(915, 69)" end="(915, 70)" leading="" trailing=" " val="?"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(915, 71)" end="(915, 72)" leading="" trailing=" " val=":"/>
      <IdentNode start="(915, 73)" end="(915, 79)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(917, 1)" end="(940, 89)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(917, 1)" end="(939, 3)">
        <CommandDoccommentNode start="(917, 1)" end="(939, 3)" comment="Assuming `x` is a variable in the local context with an inductive type,&#10;`cases x` splits the main goal, producing one goal for each constructor of the&#10;inductive type, in which the target is replaced by a general instance of that constructor.&#10;If the type of an element in the local context depends on `x`,&#10;that element is reverted and reintroduced afterward,&#10;so that the case split affects that hypothesis as well.&#10;`cases` detects unreachable cases and closes them automatically.&#10;&#10;For example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,&#10;`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,&#10;and one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.&#10;Here the name `a` is chosen automatically and is not accessible.&#10;You can use `with` to provide the variables names for each constructor.&#10;- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,&#10;  and then cases on the resulting variable.&#10;- Given `as : List α`, `cases as with | nil =&amp;gt; tac₁ | cons a as' =&amp;gt; tac₂`,&#10;  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,&#10;  and `a` and `as'` are used as names for the new variables introduced.&#10;- `cases h : e`, where `e` is a variable or an expression,&#10;  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,&#10;  where `...` is the constructor instance for that particular case.&#10;-/">
          <AtomNode start="(917, 1)" end="(917, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(918, 1)" end="(939, 3)" leading="" trailing="&#10;" val="Assuming `x` is a variable in the local context with an inductive type,&#10;`cases x` splits the main goal, producing one goal for each constructor of the&#10;inductive type, in which the target is replaced by a general instance of that constructor.&#10;If the type of an element in the local context depends on `x`,&#10;that element is reverted and reintroduced afterward,&#10;so that the case split affects that hypothesis as well.&#10;`cases` detects unreachable cases and closes them automatically.&#10;&#10;For example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,&#10;`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,&#10;and one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.&#10;Here the name `a` is chosen automatically and is not accessible.&#10;You can use `with` to provide the variables names for each constructor.&#10;- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,&#10;  and then cases on the resulting variable.&#10;- Given `as : List α`, `cases as with | nil =&amp;gt; tac₁ | cons a as' =&amp;gt; tac₂`,&#10;  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,&#10;  and `a` and `as'` are used as names for the new variables introduced.&#10;- `cases h : e`, where `e` is a variable or an expression,&#10;  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,&#10;  where `...` is the constructor instance for that particular case.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(940, 1)" end="(940, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(940, 8)" end="(940, 23)">
        <OtherNode start="(940, 8)" end="(940, 23)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(940, 8)" end="(940, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(940, 9)" end="(940, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(940, 14)" end="(940, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(940, 17)" end="(940, 22)" leading="" trailing="" raw_val="cases" val="cases"/>
          <AtomNode start="(940, 22)" end="(940, 23)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(940, 24)" end="(940, 80)">
        <OtherNode start="(940, 24)" end="(940, 32)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(940, 24)" end="(940, 32)" kind="str">
            <AtomNode start="(940, 24)" end="(940, 32)" leading="" trailing=" " val="&amp;quot;cases &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(940, 33)" end="(940, 45)" kind="«stx_,+»">
          <OtherNode start="(940, 33)" end="(940, 43)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(940, 33)" end="(940, 43)" leading="" trailing="" raw_val="elimTarget" val="elimTarget" full_name="Lean.Parser.Tactic.elimTarget" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(875, 8)" def_end="(875, 18)"/>
            <NullNode/>
          </OtherNode>
          <AtomNode start="(940, 43)" end="(940, 45)" leading="" trailing=" " val=",+"/>
        </OtherNode>
        <OtherNode start="(940, 46)" end="(940, 63)" kind="stx_?">
          <OtherNode start="(940, 46)" end="(940, 62)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(940, 46)" end="(940, 47)" leading="" trailing="" val="("/>
            <NullNode start="(940, 47)" end="(940, 61)">
              <OtherNode start="(940, 47)" end="(940, 56)" kind="Lean.Parser.Syntax.atom">
                <OtherNode start="(940, 47)" end="(940, 56)" kind="str">
                  <AtomNode start="(940, 47)" end="(940, 56)" leading="" trailing=" " val="&amp;quot; using &amp;quot;"/>
                </OtherNode>
              </OtherNode>
              <OtherNode start="(940, 57)" end="(940, 61)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(940, 57)" end="(940, 61)" leading="" trailing="" raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(940, 61)" end="(940, 62)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(940, 62)" end="(940, 63)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(940, 64)" end="(940, 80)" kind="stx_?">
          <OtherNode start="(940, 64)" end="(940, 79)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(940, 64)" end="(940, 65)" leading="" trailing="" val="("/>
            <NullNode start="(940, 65)" end="(940, 78)">
              <OtherNode start="(940, 65)" end="(940, 78)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(940, 65)" end="(940, 78)" leading="" trailing="" raw_val="inductionAlts" val="inductionAlts" full_name="Lean.Parser.Tactic.inductionAlts" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(866, 8)" def_end="(866, 21)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(940, 78)" end="(940, 79)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(940, 79)" end="(940, 80)" leading="" trailing=" " val="?"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(940, 81)" end="(940, 82)" leading="" trailing=" " val=":"/>
      <IdentNode start="(940, 83)" end="(940, 89)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(942, 1)" end="(969, 73)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(942, 1)" end="(967, 3)">
        <CommandDoccommentNode start="(942, 1)" end="(967, 3)" comment="The `fun_induction` tactic is a convenience wrapper of the `induction` tactic when using a functional&#10;induction principle.&#10;&#10;The tactic invocation&#10;```&#10;fun_induction f x₁ ... xₙ y₁ ... yₘ&#10;```&#10;where `f` is a function defined by non-mutual structural or well-founded recursion, is equivalent to&#10;```&#10;induction y₁, ... yₘ using f.induct x₁ ... xₙ&#10;```&#10;where the arguments of `f` are used as arguments to `f.induct` or targets of the induction, as&#10;appropriate.&#10;&#10;The form&#10;```&#10;fun_induction f&#10;```&#10;(with no arguments to `f`) searches the goal for an unique eligible application of `f`, and uses&#10;these arguments. An application of `f` is eligible if it is saturated and the arguments that will&#10;become targets are free variables.&#10;&#10;The forms `fun_induction f x y generalizing z₁ ... zₙ` and&#10;`fun_induction f x y with | case1 =&amp;gt; tac₁ | case2 x' ih =&amp;gt; tac₂` work like with `induction.`&#10;-/">
          <AtomNode start="(942, 1)" end="(942, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(943, 1)" end="(967, 3)" leading="" trailing="&#10;" val="The `fun_induction` tactic is a convenience wrapper of the `induction` tactic when using a functional&#10;induction principle.&#10;&#10;The tactic invocation&#10;```&#10;fun_induction f x₁ ... xₙ y₁ ... yₘ&#10;```&#10;where `f` is a function defined by non-mutual structural or well-founded recursion, is equivalent to&#10;```&#10;induction y₁, ... yₘ using f.induct x₁ ... xₙ&#10;```&#10;where the arguments of `f` are used as arguments to `f.induct` or targets of the induction, as&#10;appropriate.&#10;&#10;The form&#10;```&#10;fun_induction f&#10;```&#10;(with no arguments to `f`) searches the goal for an unique eligible application of `f`, and uses&#10;these arguments. An application of `f` is eligible if it is saturated and the arguments that will&#10;become targets are free variables.&#10;&#10;The forms `fun_induction f x y generalizing z₁ ... zₙ` and&#10;`fun_induction f x y with | case1 =&amp;gt; tac₁ | case2 x' ih =&amp;gt; tac₂` work like with `induction.`&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(968, 1)" end="(968, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(968, 8)" end="(968, 30)">
        <OtherNode start="(968, 8)" end="(968, 30)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(968, 8)" end="(968, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(968, 9)" end="(968, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(968, 14)" end="(968, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(968, 17)" end="(968, 29)" leading="" trailing="" raw_val="funInduction" val="funInduction"/>
          <AtomNode start="(968, 29)" end="(968, 30)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(968, 31)" end="(969, 64)">
        <OtherNode start="(968, 31)" end="(968, 47)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(968, 31)" end="(968, 47)" kind="str">
            <AtomNode start="(968, 31)" end="(968, 47)" leading="" trailing=" " val="&amp;quot;fun_induction &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(968, 48)" end="(968, 52)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(968, 48)" end="(968, 52)" leading="" trailing="&#10;  " raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
        <OtherNode start="(969, 3)" end="(969, 47)" kind="stx_?">
          <OtherNode start="(969, 3)" end="(969, 46)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(969, 3)" end="(969, 4)" leading="" trailing="" val="("/>
            <NullNode start="(969, 4)" end="(969, 45)">
              <OtherNode start="(969, 4)" end="(969, 19)" kind="Lean.Parser.Syntax.atom">
                <OtherNode start="(969, 4)" end="(969, 19)" kind="str">
                  <AtomNode start="(969, 4)" end="(969, 19)" leading="" trailing=" " val="&amp;quot; generalizing&amp;quot;"/>
                </OtherNode>
              </OtherNode>
              <OtherNode start="(969, 20)" end="(969, 45)" kind="«stx_+»">
                <OtherNode start="(969, 20)" end="(969, 44)" kind="Lean.Parser.Syntax.paren">
                  <AtomNode start="(969, 20)" end="(969, 21)" leading="" trailing="" val="("/>
                  <NullNode start="(969, 21)" end="(969, 43)">
                    <OtherNode start="(969, 21)" end="(969, 28)" kind="Lean.Parser.Syntax.cat">
                      <IdentNode start="(969, 21)" end="(969, 28)" leading="" trailing=" " raw_val="ppSpace" val="ppSpace" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(969, 29)" end="(969, 34)" kind="Lean.Parser.Syntax.cat">
                      <IdentNode start="(969, 29)" end="(969, 34)" leading="" trailing=" " raw_val="colGt" val="colGt" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(969, 35)" end="(969, 43)" kind="Lean.Parser.Syntax.cat">
                      <IdentNode start="(969, 35)" end="(969, 39)" leading="" trailing="" raw_val="term" val="term" full_name="Lean.Parser.Category.term" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
                      <NullNode start="(969, 39)" end="(969, 43)">
                        <OtherNode start="(969, 39)" end="(969, 43)" kind="Lean.Parser.precedence">
                          <AtomNode start="(969, 39)" end="(969, 40)" leading="" trailing="" val=":"/>
                          <OtherNode start="(969, 40)" end="(969, 43)" kind="precMax">
                            <AtomNode start="(969, 40)" end="(969, 43)" leading="" trailing="" val="max"/>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(969, 43)" end="(969, 44)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(969, 44)" end="(969, 45)" leading="" trailing="" val="+"/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(969, 45)" end="(969, 46)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(969, 46)" end="(969, 47)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(969, 48)" end="(969, 64)" kind="stx_?">
          <OtherNode start="(969, 48)" end="(969, 63)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(969, 48)" end="(969, 49)" leading="" trailing="" val="("/>
            <NullNode start="(969, 49)" end="(969, 62)">
              <OtherNode start="(969, 49)" end="(969, 62)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(969, 49)" end="(969, 62)" leading="" trailing="" raw_val="inductionAlts" val="inductionAlts" full_name="Lean.Parser.Tactic.inductionAlts" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(866, 8)" def_end="(866, 21)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(969, 62)" end="(969, 63)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(969, 63)" end="(969, 64)" leading="" trailing=" " val="?"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(969, 65)" end="(969, 66)" leading="" trailing=" " val=":"/>
      <IdentNode start="(969, 67)" end="(969, 73)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(971, 1)" end="(996, 70)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(971, 1)" end="(995, 3)">
        <CommandDoccommentNode start="(971, 1)" end="(995, 3)" comment="The `fun_cases` tactic is a convenience wrapper of the `cases` tactic when using a functional&#10;cases principle.&#10;&#10;The tactic invocation&#10;```&#10;fun_cases f x ... y ...`&#10;```&#10;is equivalent to&#10;```&#10;cases y, ... using f.fun_cases x ...&#10;```&#10;where the arguments of `f` are used as arguments to `f.fun_cases` or targets of the case analysis, as&#10;appropriate.&#10;&#10;The form&#10;```&#10;fun_cases f&#10;```&#10;(with no arguments to `f`) searches the goal for an unique eligible application of `f`, and uses&#10;these arguments. An application of `f` is eligible if it is saturated and the arguments that will&#10;become targets are free variables.&#10;&#10;The form `fun_cases f x y with | case1 =&amp;gt; tac₁ | case2 x' ih =&amp;gt; tac₂` works like with `cases`.&#10;-/">
          <AtomNode start="(971, 1)" end="(971, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(972, 1)" end="(995, 3)" leading="" trailing="&#10;" val="The `fun_cases` tactic is a convenience wrapper of the `cases` tactic when using a functional&#10;cases principle.&#10;&#10;The tactic invocation&#10;```&#10;fun_cases f x ... y ...`&#10;```&#10;is equivalent to&#10;```&#10;cases y, ... using f.fun_cases x ...&#10;```&#10;where the arguments of `f` are used as arguments to `f.fun_cases` or targets of the case analysis, as&#10;appropriate.&#10;&#10;The form&#10;```&#10;fun_cases f&#10;```&#10;(with no arguments to `f`) searches the goal for an unique eligible application of `f`, and uses&#10;these arguments. An application of `f` is eligible if it is saturated and the arguments that will&#10;become targets are free variables.&#10;&#10;The form `fun_cases f x y with | case1 =&amp;gt; tac₁ | case2 x' ih =&amp;gt; tac₂` works like with `cases`.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(996, 1)" end="(996, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(996, 8)" end="(996, 26)">
        <OtherNode start="(996, 8)" end="(996, 26)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(996, 8)" end="(996, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(996, 9)" end="(996, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(996, 14)" end="(996, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(996, 17)" end="(996, 25)" leading="" trailing="" raw_val="funCases" val="funCases"/>
          <AtomNode start="(996, 25)" end="(996, 26)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(996, 27)" end="(996, 61)">
        <OtherNode start="(996, 27)" end="(996, 39)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(996, 27)" end="(996, 39)" kind="str">
            <AtomNode start="(996, 27)" end="(996, 39)" leading="" trailing=" " val="&amp;quot;fun_cases &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(996, 40)" end="(996, 44)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(996, 40)" end="(996, 44)" leading="" trailing=" " raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
        <OtherNode start="(996, 45)" end="(996, 61)" kind="stx_?">
          <OtherNode start="(996, 45)" end="(996, 60)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(996, 45)" end="(996, 46)" leading="" trailing="" val="("/>
            <NullNode start="(996, 46)" end="(996, 59)">
              <OtherNode start="(996, 46)" end="(996, 59)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(996, 46)" end="(996, 59)" leading="" trailing="" raw_val="inductionAlts" val="inductionAlts" full_name="Lean.Parser.Tactic.inductionAlts" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(866, 8)" def_end="(866, 21)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(996, 59)" end="(996, 60)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(996, 60)" end="(996, 61)" leading="" trailing=" " val="?"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(996, 62)" end="(996, 63)" leading="" trailing=" " val=":"/>
      <IdentNode start="(996, 64)" end="(996, 70)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(998, 1)" end="(999, 74)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(998, 1)" end="(998, 93)">
        <CommandDoccommentNode start="(998, 1)" end="(998, 93)" comment="`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. -/">
          <AtomNode start="(998, 1)" end="(998, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(998, 5)" end="(998, 93)" leading="" trailing="&#10;" val="`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(999, 1)" end="(999, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(999, 8)" end="(999, 25)">
        <OtherNode start="(999, 8)" end="(999, 25)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(999, 8)" end="(999, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(999, 9)" end="(999, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(999, 14)" end="(999, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(999, 17)" end="(999, 24)" leading="" trailing="" raw_val="renameI" val="renameI"/>
          <AtomNode start="(999, 24)" end="(999, 25)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(999, 26)" end="(999, 65)">
        <OtherNode start="(999, 26)" end="(999, 36)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(999, 26)" end="(999, 36)" kind="str">
            <AtomNode start="(999, 26)" end="(999, 36)" leading="" trailing=" " val="&amp;quot;rename_i&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(999, 37)" end="(999, 65)" kind="«stx_+»">
          <OtherNode start="(999, 37)" end="(999, 64)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(999, 37)" end="(999, 38)" leading="" trailing="" val="("/>
            <NullNode start="(999, 38)" end="(999, 63)">
              <OtherNode start="(999, 38)" end="(999, 45)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(999, 38)" end="(999, 45)" leading="" trailing=" " raw_val="ppSpace" val="ppSpace" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(999, 46)" end="(999, 51)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(999, 46)" end="(999, 51)" leading="" trailing=" " raw_val="colGt" val="colGt" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(999, 52)" end="(999, 63)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(999, 52)" end="(999, 63)" leading="" trailing="" raw_val="binderIdent" val="binderIdent" full_name="Lean.binderIdent" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(999, 63)" end="(999, 64)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(999, 64)" end="(999, 65)" leading="" trailing=" " val="+"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(999, 66)" end="(999, 67)" leading="" trailing=" " val=":"/>
      <IdentNode start="(999, 68)" end="(999, 74)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(1001, 1)" end="(1013, 36)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1001, 1)" end="(1012, 3)">
        <CommandDoccommentNode start="(1001, 1)" end="(1012, 3)" comment="`repeat tac` repeatedly applies `tac` so long as it succeeds.&#10;The tactic `tac` may be a tactic sequence, and if `tac` fails at any point in its execution,&#10;`repeat` will revert any partial changes that `tac` made to the tactic state.&#10;&#10;The tactic `tac` should eventually fail, otherwise `repeat tac` will run indefinitely.&#10;&#10;See also:&#10;* `try tac` is like `repeat tac` but will apply `tac` at most once.&#10;* `repeat' tac` recursively applies `tac` to each goal.&#10;* `first | tac1 | tac2` implements the backtracking used by `repeat`&#10;-/">
          <AtomNode start="(1001, 1)" end="(1001, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1002, 1)" end="(1012, 3)" leading="" trailing="&#10;" val="`repeat tac` repeatedly applies `tac` so long as it succeeds.&#10;The tactic `tac` may be a tactic sequence, and if `tac` fails at any point in its execution,&#10;`repeat` will revert any partial changes that `tac` made to the tactic state.&#10;&#10;The tactic `tac` should eventually fail, otherwise `repeat tac` will run indefinitely.&#10;&#10;See also:&#10;* `try tac` is like `repeat tac` but will apply `tac` at most once.&#10;* `repeat' tac` recursively applies `tac` to each goal.&#10;* `first | tac1 | tac2` implements the backtracking used by `repeat`&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1013, 1)" end="(1013, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(1013, 8)" end="(1013, 27)">
        <OtherNode start="(1013, 8)" end="(1013, 17)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1013, 8)" end="(1013, 17)" kind="str">
            <AtomNode start="(1013, 8)" end="(1013, 17)" leading="" trailing=" " val="&amp;quot;repeat &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1013, 18)" end="(1013, 27)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(1013, 18)" end="(1013, 27)" leading="" trailing=" " raw_val="tacticSeq" val="tacticSeq" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1013, 28)" end="(1013, 29)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1013, 30)" end="(1013, 36)" leading="" trailing="&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(1014, 1)" end="(1015, 76)" kind="Lean.Parser.Command.macro_rules">
      <NullNode/>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1014, 1)" end="(1014, 12)" leading="" trailing="&#10;  " val="macro_rules"/>
      <NullNode/>
      <OtherNode start="(1015, 3)" end="(1015, 76)" kind="Lean.Parser.Term.matchAlts">
        <NullNode start="(1015, 3)" end="(1015, 76)">
          <OtherNode start="(1015, 3)" end="(1015, 76)" kind="Lean.Parser.Term.matchAlt">
            <AtomNode start="(1015, 3)" end="(1015, 4)" leading="" trailing=" " val="|"/>
            <NullNode start="(1015, 5)" end="(1015, 27)">
              <NullNode start="(1015, 5)" end="(1015, 27)">
                <OtherNode start="(1015, 5)" end="(1015, 27)" kind="Lean.Parser.Tactic.quot">
                  <AtomNode start="(1015, 5)" end="(1015, 14)" leading="" trailing=" " val="`(tactic|"/>
                  <OtherNode start="(1015, 15)" end="(1015, 26)" kind="Lean.Parser.Tactic.tacticRepeat_">
                    <AtomNode start="(1015, 15)" end="(1015, 21)" leading="" trailing=" " val="repeat"/>
                    <OtherNode start="(1015, 22)" end="(1015, 26)" kind="Lean.Parser.Tactic.tacticSeq.antiquot">
                      <AtomNode start="(1015, 22)" end="(1015, 23)" leading="" trailing="" val="$"/>
                      <NullNode/>
                      <IdentNode start="(1015, 23)" end="(1015, 26)" leading="" trailing="" raw_val="seq" val="seq"/>
                      <NullNode/>
                    </OtherNode>
                  </OtherNode>
                  <AtomNode start="(1015, 26)" end="(1015, 27)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </NullNode>
            </NullNode>
            <AtomNode start="(1015, 28)" end="(1015, 30)" leading="" trailing=" " val="=&amp;gt;"/>
            <OtherNode start="(1015, 31)" end="(1015, 76)" kind="Lean.Parser.Tactic.quot">
              <AtomNode start="(1015, 31)" end="(1015, 40)" leading="" trailing=" " val="`(tactic|"/>
              <OtherNode start="(1015, 41)" end="(1015, 75)" kind="Lean.Parser.Tactic.first">
                <AtomNode start="(1015, 41)" end="(1015, 46)" leading="" trailing=" " val="first"/>
                <NullNode start="(1015, 47)" end="(1015, 75)">
                  <GroupNode start="(1015, 47)" end="(1015, 68)">
                    <AtomNode start="(1015, 47)" end="(1015, 48)" leading="" trailing=" " val="|"/>
                    <TacticTacticseqNode start="(1015, 49)" end="(1015, 68)">
                      <TacticTacticseq1IndentedNode start="(1015, 49)" end="(1015, 68)">
                        <NullNode start="(1015, 49)" end="(1015, 68)">
                          <OtherNode start="(1015, 49)" end="(1015, 55)" kind="Lean.Parser.Tactic.paren">
                            <AtomNode start="(1015, 49)" end="(1015, 50)" leading="" trailing="" val="("/>
                            <OtherNode start="(1015, 50)" end="(1015, 54)" kind="Lean.Parser.Tactic.tacticSeq.antiquot">
                              <AtomNode start="(1015, 50)" end="(1015, 51)" leading="" trailing="" val="$"/>
                              <NullNode/>
                              <IdentNode start="(1015, 51)" end="(1015, 54)" leading="" trailing="" raw_val="seq" val="seq"/>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(1015, 54)" end="(1015, 55)" leading="" trailing="" val=")"/>
                          </OtherNode>
                          <AtomNode start="(1015, 55)" end="(1015, 56)" leading="" trailing=" " val=";"/>
                          <OtherNode start="(1015, 57)" end="(1015, 68)" kind="Lean.Parser.Tactic.tacticRepeat_">
                            <AtomNode start="(1015, 57)" end="(1015, 63)" leading="" trailing=" " val="repeat"/>
                            <OtherNode start="(1015, 64)" end="(1015, 68)" kind="Lean.Parser.Tactic.tacticSeq.antiquot">
                              <AtomNode start="(1015, 64)" end="(1015, 65)" leading="" trailing="" val="$"/>
                              <NullNode/>
                              <IdentNode start="(1015, 65)" end="(1015, 68)" leading="" trailing=" " raw_val="seq" val="seq"/>
                              <NullNode/>
                            </OtherNode>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </GroupNode>
                  <GroupNode start="(1015, 69)" end="(1015, 75)">
                    <AtomNode start="(1015, 69)" end="(1015, 70)" leading="" trailing=" " val="|"/>
                    <TacticTacticseqNode start="(1015, 71)" end="(1015, 75)">
                      <TacticTacticseq1IndentedNode start="(1015, 71)" end="(1015, 75)">
                        <NullNode start="(1015, 71)" end="(1015, 75)">
                          <OtherNode start="(1015, 71)" end="(1015, 75)" kind="Lean.Parser.Tactic.skip">
                            <AtomNode start="(1015, 71)" end="(1015, 75)" leading="" trailing="" val="skip"/>
                          </OtherNode>
                        </NullNode>
                      </TacticTacticseq1IndentedNode>
                    </TacticTacticseqNode>
                  </GroupNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1015, 75)" end="(1015, 76)" leading="" trailing="&#10;&#10;" val=")"/>
            </OtherNode>
          </OtherNode>
        </NullNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(1017, 1)" end="(1025, 55)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1017, 1)" end="(1024, 3)">
        <CommandDoccommentNode start="(1017, 1)" end="(1024, 3)" comment="`repeat' tac` recursively applies `tac` on all of the goals so long as it succeeds.&#10;That is to say, if `tac` produces multiple subgoals, then `repeat' tac` is applied to each of them.&#10;&#10;See also:&#10;* `repeat tac` simply repeatedly applies `tac`.&#10;* `repeat1' tac` is `repeat' tac` but requires that `tac` succeed for some goal at least once.&#10;-/">
          <AtomNode start="(1017, 1)" end="(1017, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1018, 1)" end="(1024, 3)" leading="" trailing="&#10;" val="`repeat' tac` recursively applies `tac` on all of the goals so long as it succeeds.&#10;That is to say, if `tac` produces multiple subgoals, then `repeat' tac` is applied to each of them.&#10;&#10;See also:&#10;* `repeat tac` simply repeatedly applies `tac`.&#10;* `repeat1' tac` is `repeat' tac` but requires that `tac` succeed for some goal at least once.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1025, 1)" end="(1025, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(1025, 8)" end="(1025, 25)">
        <OtherNode start="(1025, 8)" end="(1025, 25)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1025, 8)" end="(1025, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(1025, 9)" end="(1025, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1025, 14)" end="(1025, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1025, 17)" end="(1025, 24)" leading="" trailing="" raw_val="repeat'" val="repeat'"/>
          <AtomNode start="(1025, 24)" end="(1025, 25)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(1025, 26)" end="(1025, 46)">
        <OtherNode start="(1025, 26)" end="(1025, 36)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1025, 26)" end="(1025, 36)" kind="str">
            <AtomNode start="(1025, 26)" end="(1025, 36)" leading="" trailing=" " val="&amp;quot;repeat' &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1025, 37)" end="(1025, 46)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(1025, 37)" end="(1025, 46)" leading="" trailing=" " raw_val="tacticSeq" val="tacticSeq" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1025, 47)" end="(1025, 48)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1025, 49)" end="(1025, 55)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(1027, 1)" end="(1035, 57)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1027, 1)" end="(1034, 3)">
        <CommandDoccommentNode start="(1027, 1)" end="(1034, 3)" comment="`repeat1' tac` recursively applies to `tac` on all of the goals so long as it succeeds,&#10;but `repeat1' tac` fails if `tac` succeeds on none of the initial goals.&#10;&#10;See also:&#10;* `repeat tac` simply applies `tac` repeatedly.&#10;* `repeat' tac` is like `repeat1' tac` but it does not require that `tac` succeed at least once.&#10;-/">
          <AtomNode start="(1027, 1)" end="(1027, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1028, 1)" end="(1034, 3)" leading="" trailing="&#10;" val="`repeat1' tac` recursively applies to `tac` on all of the goals so long as it succeeds,&#10;but `repeat1' tac` fails if `tac` succeeds on none of the initial goals.&#10;&#10;See also:&#10;* `repeat tac` simply applies `tac` repeatedly.&#10;* `repeat' tac` is like `repeat1' tac` but it does not require that `tac` succeed at least once.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1035, 1)" end="(1035, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(1035, 8)" end="(1035, 26)">
        <OtherNode start="(1035, 8)" end="(1035, 26)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1035, 8)" end="(1035, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(1035, 9)" end="(1035, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1035, 14)" end="(1035, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1035, 17)" end="(1035, 25)" leading="" trailing="" raw_val="repeat1'" val="repeat1'"/>
          <AtomNode start="(1035, 25)" end="(1035, 26)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(1035, 27)" end="(1035, 48)">
        <OtherNode start="(1035, 27)" end="(1035, 38)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1035, 27)" end="(1035, 38)" kind="str">
            <AtomNode start="(1035, 27)" end="(1035, 38)" leading="" trailing=" " val="&amp;quot;repeat1' &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1035, 39)" end="(1035, 48)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(1035, 39)" end="(1035, 48)" leading="" trailing=" " raw_val="tacticSeq" val="tacticSeq" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1035, 49)" end="(1035, 50)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1035, 51)" end="(1035, 57)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(1037, 1)" end="(1045, 26)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1037, 1)" end="(1044, 3)">
        <CommandDoccommentNode start="(1037, 1)" end="(1044, 3)" comment="`trivial` tries different simple tactics (e.g., `rfl`, `contradiction`, ...)&#10;to close the current goal.&#10;You can use the command `macro_rules` to extend the set of tactics used. Example:&#10;```&#10;macro_rules | `(tactic| trivial) =&amp;gt; `(tactic| simp)&#10;```&#10;-/">
          <AtomNode start="(1037, 1)" end="(1037, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1038, 1)" end="(1044, 3)" leading="" trailing="&#10;" val="`trivial` tries different simple tactics (e.g., `rfl`, `contradiction`, ...)&#10;to close the current goal.&#10;You can use the command `macro_rules` to extend the set of tactics used. Example:&#10;```&#10;macro_rules | `(tactic| trivial) =&amp;gt; `(tactic| simp)&#10;```&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1045, 1)" end="(1045, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(1045, 8)" end="(1045, 17)">
        <OtherNode start="(1045, 8)" end="(1045, 17)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1045, 8)" end="(1045, 17)" kind="str">
            <AtomNode start="(1045, 8)" end="(1045, 17)" leading="" trailing=" " val="&amp;quot;trivial&amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1045, 18)" end="(1045, 19)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1045, 20)" end="(1045, 26)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(1047, 1)" end="(1054, 68)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1047, 1)" end="(1053, 3)">
        <CommandDoccommentNode start="(1047, 1)" end="(1053, 3)" comment="`classical tacs` runs `tacs` in a scope where `Classical.propDecidable` is a low priority&#10;local instance.&#10;&#10;Note that `classical` is a scoping tactic: it adds the instance only within the&#10;scope of the tactic.&#10;-/">
          <AtomNode start="(1047, 1)" end="(1047, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1048, 1)" end="(1053, 3)" leading="" trailing="&#10;" val="`classical tacs` runs `tacs` in a scope where `Classical.propDecidable` is a low priority&#10;local instance.&#10;&#10;Note that `classical` is a scoping tactic: it adds the instance only within the&#10;scope of the tactic.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1054, 1)" end="(1054, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(1054, 8)" end="(1054, 27)">
        <OtherNode start="(1054, 8)" end="(1054, 27)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1054, 8)" end="(1054, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(1054, 9)" end="(1054, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1054, 14)" end="(1054, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1054, 17)" end="(1054, 26)" leading="" trailing="" raw_val="classical" val="classical"/>
          <AtomNode start="(1054, 26)" end="(1054, 27)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(1054, 28)" end="(1054, 59)">
        <OtherNode start="(1054, 28)" end="(1054, 39)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1054, 28)" end="(1054, 39)" kind="str">
            <AtomNode start="(1054, 28)" end="(1054, 39)" leading="" trailing=" " val="&amp;quot;classical&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1054, 40)" end="(1054, 59)" kind="Lean.Parser.Syntax.unary">
          <IdentNode start="(1054, 40)" end="(1054, 48)" leading="" trailing="" raw_val="ppDedent" val="ppDedent"/>
          <AtomNode start="(1054, 48)" end="(1054, 49)" leading="" trailing="" val="("/>
          <NullNode start="(1054, 49)" end="(1054, 58)">
            <OtherNode start="(1054, 49)" end="(1054, 58)" kind="Lean.Parser.Syntax.cat">
              <IdentNode start="(1054, 49)" end="(1054, 58)" leading="" trailing="" raw_val="tacticSeq" val="tacticSeq" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              <NullNode/>
            </OtherNode>
          </NullNode>
          <AtomNode start="(1054, 58)" end="(1054, 59)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1054, 60)" end="(1054, 61)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1054, 62)" end="(1054, 68)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(1056, 1)" end="(1068, 74)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1056, 1)" end="(1067, 3)">
        <CommandDoccommentNode start="(1056, 1)" end="(1067, 3)" comment="The `split` tactic is useful for breaking nested if-then-else and `match` expressions into separate cases.&#10;For a `match` expression with `n` cases, the `split` tactic generates at most `n` subgoals.&#10;&#10;For example, given `n : Nat`, and a target `if n = 0 then Q else R`, `split` will generate&#10;one goal with hypothesis `n = 0` and target `Q`, and a second goal with hypothesis&#10;`¬n = 0` and target `R`.  Note that the introduced hypothesis is unnamed, and is commonly&#10;renamed used the `case` or `next` tactics.&#10;&#10;- `split` will split the goal (target).&#10;- `split at h` will split the hypothesis `h`.&#10;-/">
          <AtomNode start="(1056, 1)" end="(1056, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1057, 1)" end="(1067, 3)" leading="" trailing="&#10;" val="The `split` tactic is useful for breaking nested if-then-else and `match` expressions into separate cases.&#10;For a `match` expression with `n` cases, the `split` tactic generates at most `n` subgoals.&#10;&#10;For example, given `n : Nat`, and a target `if n = 0 then Q else R`, `split` will generate&#10;one goal with hypothesis `n = 0` and target `Q`, and a second goal with hypothesis&#10;`¬n = 0` and target `R`.  Note that the introduced hypothesis is unnamed, and is commonly&#10;renamed used the `case` or `next` tactics.&#10;&#10;- `split` will split the goal (target).&#10;- `split at h` will split the hypothesis `h`.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1068, 1)" end="(1068, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(1068, 8)" end="(1068, 23)">
        <OtherNode start="(1068, 8)" end="(1068, 23)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1068, 8)" end="(1068, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(1068, 9)" end="(1068, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1068, 14)" end="(1068, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1068, 17)" end="(1068, 22)" leading="" trailing="" raw_val="split" val="split"/>
          <AtomNode start="(1068, 22)" end="(1068, 23)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(1068, 24)" end="(1068, 65)">
        <OtherNode start="(1068, 24)" end="(1068, 31)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1068, 24)" end="(1068, 31)" kind="str">
            <AtomNode start="(1068, 24)" end="(1068, 31)" leading="" trailing=" " val="&amp;quot;split&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1068, 32)" end="(1068, 53)" kind="stx_?">
          <OtherNode start="(1068, 32)" end="(1068, 52)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(1068, 32)" end="(1068, 33)" leading="" trailing="" val="("/>
            <NullNode start="(1068, 33)" end="(1068, 51)">
              <OtherNode start="(1068, 33)" end="(1068, 40)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(1068, 33)" end="(1068, 40)" leading="" trailing=" " raw_val="ppSpace" val="ppSpace" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(1068, 41)" end="(1068, 46)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(1068, 41)" end="(1068, 46)" leading="" trailing=" " raw_val="colGt" val="colGt" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(1068, 47)" end="(1068, 51)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(1068, 47)" end="(1068, 51)" leading="" trailing="" raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1068, 51)" end="(1068, 52)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(1068, 52)" end="(1068, 53)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(1068, 54)" end="(1068, 65)" kind="stx_?">
          <OtherNode start="(1068, 54)" end="(1068, 64)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(1068, 54)" end="(1068, 55)" leading="" trailing="" val="("/>
            <NullNode start="(1068, 55)" end="(1068, 63)">
              <OtherNode start="(1068, 55)" end="(1068, 63)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(1068, 55)" end="(1068, 63)" leading="" trailing="" raw_val="location" val="location" full_name="Lean.Parser.Tactic.location" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(484, 8)" def_end="(484, 16)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1068, 63)" end="(1068, 64)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(1068, 64)" end="(1068, 65)" leading="" trailing=" " val="?"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1068, 66)" end="(1068, 67)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1068, 68)" end="(1068, 74)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(1070, 1)" end="(1079, 52)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1070, 1)" end="(1078, 3)">
        <CommandDoccommentNode start="(1070, 1)" end="(1078, 3)" comment="`dbg_trace &amp;quot;foo&amp;quot;` prints `foo` when elaborated.&#10;Useful for debugging tactic control flow:&#10;```&#10;example : False ∨ True := by&#10;  first&#10;  | apply Or.inl; trivial; dbg_trace &amp;quot;left&amp;quot;&#10;  | apply Or.inr; trivial; dbg_trace &amp;quot;right&amp;quot;&#10;```&#10;-/">
          <AtomNode start="(1070, 1)" end="(1070, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(1070, 5)" end="(1078, 3)" leading="" trailing="&#10;" val="`dbg_trace &amp;quot;foo&amp;quot;` prints `foo` when elaborated.&#10;Useful for debugging tactic control flow:&#10;```&#10;example : False ∨ True := by&#10;  first&#10;  | apply Or.inl; trivial; dbg_trace &amp;quot;left&amp;quot;&#10;  | apply Or.inr; trivial; dbg_trace &amp;quot;right&amp;quot;&#10;```&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1079, 1)" end="(1079, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(1079, 8)" end="(1079, 26)">
        <OtherNode start="(1079, 8)" end="(1079, 26)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1079, 8)" end="(1079, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(1079, 9)" end="(1079, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1079, 14)" end="(1079, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1079, 17)" end="(1079, 25)" leading="" trailing="" raw_val="dbgTrace" val="dbgTrace"/>
          <AtomNode start="(1079, 25)" end="(1079, 26)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(1079, 27)" end="(1079, 43)">
        <OtherNode start="(1079, 27)" end="(1079, 39)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1079, 27)" end="(1079, 39)" kind="str">
            <AtomNode start="(1079, 27)" end="(1079, 39)" leading="" trailing=" " val="&amp;quot;dbg_trace &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1079, 40)" end="(1079, 43)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(1079, 40)" end="(1079, 43)" leading="" trailing=" " raw_val="str" val="str" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1079, 44)" end="(1079, 45)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1079, 46)" end="(1079, 52)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(1081, 1)" end="(1087, 59)" kind="Lean.Parser.Command.macro">
      <NullNode start="(1081, 1)" end="(1086, 3)">
        <CommandDoccommentNode start="(1081, 1)" end="(1086, 3)" comment="`stop` is a helper tactic for &amp;quot;discarding&amp;quot; the rest of a proof:&#10;it is defined as `repeat sorry`.&#10;It is useful when working on the middle of a complex proofs,&#10;and less messy than commenting the remainder of the proof.&#10;-/">
          <AtomNode start="(1081, 1)" end="(1081, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1082, 1)" end="(1086, 3)" leading="" trailing="&#10;" val="`stop` is a helper tactic for &amp;quot;discarding&amp;quot; the rest of a proof:&#10;it is defined as `repeat sorry`.&#10;It is useful when working on the middle of a complex proofs,&#10;and less messy than commenting the remainder of the proof.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1087, 1)" end="(1087, 6)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(1087, 7)" end="(1087, 23)">
        <OtherNode start="(1087, 7)" end="(1087, 13)" kind="Lean.Parser.Command.macroArg">
          <NullNode/>
          <OtherNode start="(1087, 7)" end="(1087, 13)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(1087, 7)" end="(1087, 13)" kind="str">
              <AtomNode start="(1087, 7)" end="(1087, 13)" leading="" trailing=" " val="&amp;quot;stop&amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1087, 14)" end="(1087, 23)" kind="Lean.Parser.Command.macroArg">
          <NullNode/>
          <OtherNode start="(1087, 14)" end="(1087, 23)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(1087, 14)" end="(1087, 23)" leading="" trailing=" " raw_val="tacticSeq" val="tacticSeq" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(1087, 24)" end="(1087, 59)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(1087, 24)" end="(1087, 25)" leading="" trailing=" " val=":"/>
        <IdentNode start="(1087, 26)" end="(1087, 32)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(1087, 33)" end="(1087, 35)" leading="" trailing=" " val="=&amp;gt;"/>
        <OtherNode start="(1087, 36)" end="(1087, 59)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(1087, 36)" end="(1087, 59)" kind="Lean.Parser.Tactic.quot">
            <AtomNode start="(1087, 36)" end="(1087, 45)" leading="" trailing=" " val="`(tactic|"/>
            <OtherNode start="(1087, 46)" end="(1087, 58)" kind="Lean.Parser.Tactic.tacticRepeat_">
              <AtomNode start="(1087, 46)" end="(1087, 52)" leading="" trailing=" " val="repeat"/>
              <TacticTacticseqNode start="(1087, 53)" end="(1087, 58)">
                <TacticTacticseq1IndentedNode start="(1087, 53)" end="(1087, 58)">
                  <NullNode start="(1087, 53)" end="(1087, 58)">
                    <OtherNode start="(1087, 53)" end="(1087, 58)" kind="Lean.Parser.Tactic.tacticSorry">
                      <AtomNode start="(1087, 53)" end="(1087, 58)" leading="" trailing="" val="sorry"/>
                    </OtherNode>
                  </NullNode>
                </TacticTacticseq1IndentedNode>
              </TacticTacticseqNode>
            </OtherNode>
            <AtomNode start="(1087, 58)" end="(1087, 59)" leading="" trailing="&#10;&#10;" val=")"/>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(1089, 1)" end="(1097, 56)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1089, 1)" end="(1096, 3)">
        <CommandDoccommentNode start="(1089, 1)" end="(1096, 3)" comment="The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`.&#10;The premises of this hypothesis, either universal quantifications or&#10;non-dependent implications, are instantiated by concrete terms coming&#10;from arguments `a₁` ... `aₙ`.&#10;The tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ`&#10;and tries to clear the previous one.&#10;-/">
          <AtomNode start="(1089, 1)" end="(1089, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1090, 1)" end="(1096, 3)" leading="" trailing="&#10;" val="The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`.&#10;The premises of this hypothesis, either universal quantifications or&#10;non-dependent implications, are instantiated by concrete terms coming&#10;from arguments `a₁` ... `aₙ`.&#10;The tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ`&#10;and tries to clear the previous one.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1097, 1)" end="(1097, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(1097, 8)" end="(1097, 28)">
        <OtherNode start="(1097, 8)" end="(1097, 28)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1097, 8)" end="(1097, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(1097, 9)" end="(1097, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1097, 14)" end="(1097, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1097, 17)" end="(1097, 27)" leading="" trailing="" raw_val="specialize" val="specialize"/>
          <AtomNode start="(1097, 27)" end="(1097, 28)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(1097, 29)" end="(1097, 47)">
        <OtherNode start="(1097, 29)" end="(1097, 42)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1097, 29)" end="(1097, 42)" kind="str">
            <AtomNode start="(1097, 29)" end="(1097, 42)" leading="" trailing=" " val="&amp;quot;specialize &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1097, 43)" end="(1097, 47)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(1097, 43)" end="(1097, 47)" leading="" trailing=" " raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1097, 48)" end="(1097, 49)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1097, 50)" end="(1097, 56)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(1099, 1)" end="(1111, 94)" kind="Lean.Parser.Command.macro">
      <NullNode start="(1099, 1)" end="(1110, 3)">
        <CommandDoccommentNode start="(1099, 1)" end="(1110, 3)" comment="`unhygienic tacs` runs `tacs` with name hygiene disabled.&#10;This means that tactics that would normally create inaccessible names will instead&#10;make regular variables. **Warning**: Tactics may change their variable naming&#10;strategies at any time, so code that depends on autogenerated names is brittle.&#10;Users should try not to use `unhygienic` if possible.&#10;```&#10;example : ∀ x : Nat, x = x := by unhygienic&#10;  intro            -- x would normally be intro'd as inaccessible&#10;  exact Eq.refl x  -- refer to x&#10;```&#10;-/">
          <AtomNode start="(1099, 1)" end="(1099, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1100, 1)" end="(1110, 3)" leading="" trailing="&#10;" val="`unhygienic tacs` runs `tacs` with name hygiene disabled.&#10;This means that tactics that would normally create inaccessible names will instead&#10;make regular variables. **Warning**: Tactics may change their variable naming&#10;strategies at any time, so code that depends on autogenerated names is brittle.&#10;Users should try not to use `unhygienic` if possible.&#10;```&#10;example : ∀ x : Nat, x = x := by unhygienic&#10;  intro            -- x would normally be intro'd as inaccessible&#10;  exact Eq.refl x  -- refer to x&#10;```&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1111, 1)" end="(1111, 6)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(1111, 7)" end="(1111, 32)">
        <OtherNode start="(1111, 7)" end="(1111, 20)" kind="Lean.Parser.Command.macroArg">
          <NullNode/>
          <OtherNode start="(1111, 7)" end="(1111, 20)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(1111, 7)" end="(1111, 20)" kind="str">
              <AtomNode start="(1111, 7)" end="(1111, 20)" leading="" trailing=" " val="&amp;quot;unhygienic &amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1111, 21)" end="(1111, 32)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(1111, 21)" end="(1111, 23)">
            <IdentNode start="(1111, 21)" end="(1111, 22)" leading="" trailing="" raw_val="t" val="t"/>
            <AtomNode start="(1111, 22)" end="(1111, 23)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(1111, 23)" end="(1111, 32)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(1111, 23)" end="(1111, 32)" leading="" trailing=" " raw_val="tacticSeq" val="tacticSeq" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(1111, 33)" end="(1111, 94)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(1111, 33)" end="(1111, 34)" leading="" trailing=" " val=":"/>
        <IdentNode start="(1111, 35)" end="(1111, 41)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(1111, 42)" end="(1111, 44)" leading="" trailing=" " val="=&amp;gt;"/>
        <OtherNode start="(1111, 45)" end="(1111, 94)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(1111, 45)" end="(1111, 94)" kind="Lean.Parser.Tactic.quot">
            <AtomNode start="(1111, 45)" end="(1111, 54)" leading="" trailing=" " val="`(tactic|"/>
            <OtherNode start="(1111, 55)" end="(1111, 93)" kind="Lean.Parser.Tactic.set_option">
              <AtomNode start="(1111, 55)" end="(1111, 65)" leading="" trailing=" " val="set_option"/>
              <IdentNode start="(1111, 66)" end="(1111, 81)" leading="" trailing=" " raw_val="tactic.hygienic" val="tactic.hygienic"/>
              <NullNode/>
              <AtomNode start="(1111, 82)" end="(1111, 87)" leading="" trailing=" " val="false"/>
              <AtomNode start="(1111, 88)" end="(1111, 90)" leading="" trailing=" " val="in"/>
              <OtherNode start="(1111, 91)" end="(1111, 93)" kind="Lean.Parser.Tactic.tacticSeq.antiquot">
                <AtomNode start="(1111, 91)" end="(1111, 92)" leading="" trailing="" val="$"/>
                <NullNode/>
                <IdentNode start="(1111, 92)" end="(1111, 93)" leading="" trailing="" raw_val="t" val="t"/>
                <NullNode/>
              </OtherNode>
            </OtherNode>
            <AtomNode start="(1111, 93)" end="(1111, 94)" leading="" trailing="&#10;&#10;" val=")"/>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(1113, 1)" end="(1117, 45)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1113, 1)" end="(1116, 3)">
        <CommandDoccommentNode start="(1113, 1)" end="(1116, 3)" comment="The tactic `sleep ms` sleeps for `ms` milliseconds and does nothing.&#10;It is used for debugging purposes only.&#10;-/">
          <AtomNode start="(1113, 1)" end="(1113, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1114, 1)" end="(1116, 3)" leading="" trailing="&#10;" val="The tactic `sleep ms` sleeps for `ms` milliseconds and does nothing.&#10;It is used for debugging purposes only.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1117, 1)" end="(1117, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(1117, 8)" end="(1117, 23)">
        <OtherNode start="(1117, 8)" end="(1117, 23)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1117, 8)" end="(1117, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(1117, 9)" end="(1117, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1117, 14)" end="(1117, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1117, 17)" end="(1117, 22)" leading="" trailing="" raw_val="sleep" val="sleep"/>
          <AtomNode start="(1117, 22)" end="(1117, 23)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(1117, 24)" end="(1117, 36)">
        <OtherNode start="(1117, 24)" end="(1117, 32)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1117, 24)" end="(1117, 32)" kind="str">
            <AtomNode start="(1117, 24)" end="(1117, 32)" leading="" trailing=" " val="&amp;quot;sleep &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1117, 33)" end="(1117, 36)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(1117, 33)" end="(1117, 36)" leading="" trailing=" " raw_val="num" val="num" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1117, 37)" end="(1117, 38)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1117, 39)" end="(1117, 45)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(1119, 1)" end="(1124, 47)" kind="Lean.Parser.Command.macro">
      <NullNode start="(1119, 1)" end="(1122, 3)">
        <CommandDoccommentNode start="(1119, 1)" end="(1122, 3)" comment="`exists e₁, e₂, ...` is shorthand for `refine ⟨e₁, e₂, ...⟩; try trivial`.&#10;It is useful for existential goals.&#10;-/">
          <AtomNode start="(1119, 1)" end="(1119, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1120, 1)" end="(1122, 3)" leading="" trailing="&#10;" val="`exists e₁, e₂, ...` is shorthand for `refine ⟨e₁, e₂, ...⟩; try trivial`.&#10;It is useful for existential goals.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1123, 1)" end="(1123, 6)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(1123, 7)" end="(1123, 26)">
        <OtherNode start="(1123, 7)" end="(1123, 16)" kind="Lean.Parser.Command.macroArg">
          <NullNode/>
          <OtherNode start="(1123, 7)" end="(1123, 16)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(1123, 7)" end="(1123, 16)" kind="str">
              <AtomNode start="(1123, 7)" end="(1123, 16)" leading="" trailing=" " val="&amp;quot;exists &amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1123, 17)" end="(1123, 26)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(1123, 17)" end="(1123, 20)">
            <IdentNode start="(1123, 17)" end="(1123, 19)" leading="" trailing="" raw_val="es" val="es"/>
            <AtomNode start="(1123, 19)" end="(1123, 20)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(1123, 20)" end="(1123, 26)" kind="«stx_,+»">
            <OtherNode start="(1123, 20)" end="(1123, 24)" kind="Lean.Parser.Syntax.cat">
              <IdentNode start="(1123, 20)" end="(1123, 24)" leading="" trailing="" raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              <NullNode/>
            </OtherNode>
            <AtomNode start="(1123, 24)" end="(1123, 26)" leading="" trailing=" " val=",+"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(1123, 27)" end="(1124, 47)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(1123, 27)" end="(1123, 28)" leading="" trailing=" " val=":"/>
        <IdentNode start="(1123, 29)" end="(1123, 35)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(1123, 36)" end="(1123, 38)" leading="" trailing="&#10;  " val="=&amp;gt;"/>
        <OtherNode start="(1124, 3)" end="(1124, 47)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(1124, 3)" end="(1124, 47)" kind="Lean.Parser.Tactic.quot">
            <AtomNode start="(1124, 3)" end="(1124, 12)" leading="" trailing=" " val="`(tactic|"/>
            <OtherNode start="(1124, 13)" end="(1124, 46)" kind="Lean.Parser.Tactic.paren">
              <AtomNode start="(1124, 13)" end="(1124, 14)" leading="" trailing="" val="("/>
              <TacticTacticseqNode start="(1124, 14)" end="(1124, 45)">
                <TacticTacticseq1IndentedNode start="(1124, 14)" end="(1124, 45)">
                  <NullNode start="(1124, 14)" end="(1124, 45)">
                    <OtherNode start="(1124, 14)" end="(1124, 32)" kind="Lean.Parser.Tactic.refine">
                      <AtomNode start="(1124, 14)" end="(1124, 20)" leading="" trailing=" " val="refine"/>
                      <OtherNode start="(1124, 21)" end="(1124, 32)" kind="Lean.Parser.Term.anonymousCtor">
                        <AtomNode start="(1124, 21)" end="(1124, 22)" leading="" trailing="" val="⟨"/>
                        <NullNode start="(1124, 22)" end="(1124, 31)">
                          <OtherNode start="(1124, 22)" end="(1124, 27)" kind="sepBy.antiquot_suffix_splice">
                            <OtherNode start="(1124, 22)" end="(1124, 25)" kind="term.pseudo.antiquot">
                              <AtomNode start="(1124, 22)" end="(1124, 23)" leading="" trailing="" val="$"/>
                              <NullNode/>
                              <IdentNode start="(1124, 23)" end="(1124, 25)" leading="" trailing="" raw_val="es" val="es"/>
                              <NullNode/>
                            </OtherNode>
                            <AtomNode start="(1124, 25)" end="(1124, 27)" leading="" trailing="" val=",*"/>
                          </OtherNode>
                          <AtomNode start="(1124, 27)" end="(1124, 28)" leading="" trailing=" " val=","/>
                          <OtherNode start="(1124, 29)" end="(1124, 31)" kind="Lean.Parser.Term.syntheticHole">
                            <AtomNode start="(1124, 29)" end="(1124, 30)" leading="" trailing="" val="?"/>
                            <AtomNode start="(1124, 30)" end="(1124, 31)" leading="" trailing="" val="_"/>
                          </OtherNode>
                        </NullNode>
                        <AtomNode start="(1124, 31)" end="(1124, 32)" leading="" trailing="" val="⟩"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(1124, 32)" end="(1124, 33)" leading="" trailing=" " val=";"/>
                    <OtherNode start="(1124, 34)" end="(1124, 45)" kind="Lean.Parser.Tactic.tacticTry_">
                      <AtomNode start="(1124, 34)" end="(1124, 37)" leading="" trailing=" " val="try"/>
                      <TacticTacticseqNode start="(1124, 38)" end="(1124, 45)">
                        <TacticTacticseq1IndentedNode start="(1124, 38)" end="(1124, 45)">
                          <NullNode start="(1124, 38)" end="(1124, 45)">
                            <OtherNode start="(1124, 38)" end="(1124, 45)" kind="Lean.Parser.Tactic.tacticTrivial">
                              <AtomNode start="(1124, 38)" end="(1124, 45)" leading="" trailing="" val="trivial"/>
                            </OtherNode>
                          </NullNode>
                        </TacticTacticseq1IndentedNode>
                      </TacticTacticseqNode>
                    </OtherNode>
                  </NullNode>
                </TacticTacticseq1IndentedNode>
              </TacticTacticseqNode>
              <AtomNode start="(1124, 45)" end="(1124, 46)" leading="" trailing="" val=")"/>
            </OtherNode>
            <AtomNode start="(1124, 46)" end="(1124, 47)" leading="" trailing="&#10;&#10;" val=")"/>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(1126, 1)" end="(1134, 55)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1126, 1)" end="(1133, 3)">
        <CommandDoccommentNode start="(1126, 1)" end="(1133, 3)" comment="Apply congruence (recursively) to goals of the form `⊢ f as = f bs` and `⊢ HEq (f as) (f bs)`.&#10;The optional parameter is the depth of the recursive applications.&#10;This is useful when `congr` is too aggressive in breaking down the goal.&#10;For example, given `⊢ f (g (x + y)) = f (g (y + x))`,&#10;`congr` produces the goals `⊢ x = y` and `⊢ y = x`,&#10;while `congr 2` produces the intended `⊢ x + y = y + x`.&#10;-/">
          <AtomNode start="(1126, 1)" end="(1126, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1127, 1)" end="(1133, 3)" leading="" trailing="&#10;" val="Apply congruence (recursively) to goals of the form `⊢ f as = f bs` and `⊢ HEq (f as) (f bs)`.&#10;The optional parameter is the depth of the recursive applications.&#10;This is useful when `congr` is too aggressive in breaking down the goal.&#10;For example, given `⊢ f (g (x + y)) = f (g (y + x))`,&#10;`congr` produces the goals `⊢ x = y` and `⊢ y = x`,&#10;while `congr 2` produces the intended `⊢ x + y = y + x`.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1134, 1)" end="(1134, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(1134, 8)" end="(1134, 23)">
        <OtherNode start="(1134, 8)" end="(1134, 23)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1134, 8)" end="(1134, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(1134, 9)" end="(1134, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1134, 14)" end="(1134, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1134, 17)" end="(1134, 22)" leading="" trailing="" raw_val="congr" val="congr"/>
          <AtomNode start="(1134, 22)" end="(1134, 23)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(1134, 24)" end="(1134, 46)">
        <OtherNode start="(1134, 24)" end="(1134, 31)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1134, 24)" end="(1134, 31)" kind="str">
            <AtomNode start="(1134, 24)" end="(1134, 31)" leading="" trailing=" " val="&amp;quot;congr&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1134, 32)" end="(1134, 46)" kind="stx_?">
          <OtherNode start="(1134, 32)" end="(1134, 45)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(1134, 32)" end="(1134, 33)" leading="" trailing="" val="("/>
            <NullNode start="(1134, 33)" end="(1134, 44)">
              <OtherNode start="(1134, 33)" end="(1134, 40)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(1134, 33)" end="(1134, 40)" leading="" trailing=" " raw_val="ppSpace" val="ppSpace" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(1134, 41)" end="(1134, 44)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(1134, 41)" end="(1134, 44)" leading="" trailing="" raw_val="num" val="num" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1134, 44)" end="(1134, 45)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(1134, 45)" end="(1134, 46)" leading="" trailing=" " val="?"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1134, 47)" end="(1134, 48)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1134, 49)" end="(1134, 55)" leading="" trailing="&#10;&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(1137, 1)" end="(1152, 70)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1137, 1)" end="(1149, 3)">
        <CommandDoccommentNode start="(1137, 1)" end="(1149, 3)" comment="In tactic mode, `if h : t then tac1 else tac2` can be used as alternative syntax for:&#10;```&#10;by_cases h : t&#10;· tac1&#10;· tac2&#10;```&#10;It performs case distinction on `h : t` or `h : ¬t` and `tac1` and `tac2` are the subproofs.&#10;&#10;You can use `?_` or `_` for either subproof to delay the goal to after the tactic, but&#10;if a tactic sequence is provided for `tac1` or `tac2` then it will require the goal to be closed&#10;by the end of the block.&#10;-/">
          <AtomNode start="(1137, 1)" end="(1137, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1138, 1)" end="(1149, 3)" leading="" trailing="&#10;" val="In tactic mode, `if h : t then tac1 else tac2` can be used as alternative syntax for:&#10;```&#10;by_cases h : t&#10;· tac1&#10;· tac2&#10;```&#10;It performs case distinction on `h : t` or `h : ¬t` and `tac1` and `tac2` are the subproofs.&#10;&#10;You can use `?_` or `_` for either subproof to delay the goal to after the tactic, but&#10;if a tactic sequence is provided for `tac1` or `tac2` then it will require the goal to be closed&#10;by the end of the block.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1150, 1)" end="(1150, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(1150, 8)" end="(1150, 34)">
        <OtherNode start="(1150, 8)" end="(1150, 34)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1150, 8)" end="(1150, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(1150, 9)" end="(1150, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1150, 14)" end="(1150, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1150, 17)" end="(1150, 33)" leading="" trailing="" raw_val="tacDepIfThenElse" val="tacDepIfThenElse"/>
          <AtomNode start="(1150, 33)" end="(1150, 34)" leading="" trailing="&#10;  " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(1151, 3)" end="(1152, 61)">
        <OtherNode start="(1151, 3)" end="(1152, 61)" kind="Lean.Parser.Syntax.unary">
          <IdentNode start="(1151, 3)" end="(1151, 14)" leading="" trailing="" raw_val="ppRealGroup" val="ppRealGroup"/>
          <AtomNode start="(1151, 14)" end="(1151, 15)" leading="" trailing="" val="("/>
          <NullNode start="(1151, 15)" end="(1152, 60)">
            <OtherNode start="(1151, 15)" end="(1151, 99)" kind="Lean.Parser.Syntax.unary">
              <IdentNode start="(1151, 15)" end="(1151, 25)" leading="" trailing="" raw_val="ppRealFill" val="ppRealFill"/>
              <AtomNode start="(1151, 25)" end="(1151, 26)" leading="" trailing="" val="("/>
              <NullNode start="(1151, 26)" end="(1151, 98)">
                <OtherNode start="(1151, 26)" end="(1151, 72)" kind="Lean.Parser.Syntax.unary">
                  <IdentNode start="(1151, 26)" end="(1151, 34)" leading="" trailing="" raw_val="ppIndent" val="ppIndent"/>
                  <AtomNode start="(1151, 34)" end="(1151, 35)" leading="" trailing="" val="("/>
                  <NullNode start="(1151, 35)" end="(1151, 71)">
                    <OtherNode start="(1151, 35)" end="(1151, 40)" kind="Lean.Parser.Syntax.atom">
                      <OtherNode start="(1151, 35)" end="(1151, 40)" kind="str">
                        <AtomNode start="(1151, 35)" end="(1151, 40)" leading="" trailing=" " val="&amp;quot;if &amp;quot;"/>
                      </OtherNode>
                    </OtherNode>
                    <OtherNode start="(1151, 41)" end="(1151, 52)" kind="Lean.Parser.Syntax.cat">
                      <IdentNode start="(1151, 41)" end="(1151, 52)" leading="" trailing=" " raw_val="binderIdent" val="binderIdent" full_name="Lean.binderIdent" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(1151, 53)" end="(1151, 58)" kind="Lean.Parser.Syntax.atom">
                      <OtherNode start="(1151, 53)" end="(1151, 58)" kind="str">
                        <AtomNode start="(1151, 53)" end="(1151, 58)" leading="" trailing=" " val="&amp;quot; : &amp;quot;"/>
                      </OtherNode>
                    </OtherNode>
                    <OtherNode start="(1151, 59)" end="(1151, 63)" kind="Lean.Parser.Syntax.cat">
                      <IdentNode start="(1151, 59)" end="(1151, 63)" leading="" trailing=" " raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(1151, 64)" end="(1151, 71)" kind="Lean.Parser.Syntax.atom">
                      <OtherNode start="(1151, 64)" end="(1151, 71)" kind="str">
                        <AtomNode start="(1151, 64)" end="(1151, 71)" leading="" trailing="" val="&amp;quot; then&amp;quot;"/>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(1151, 71)" end="(1151, 72)" leading="" trailing=" " val=")"/>
                </OtherNode>
                <OtherNode start="(1151, 73)" end="(1151, 80)" kind="Lean.Parser.Syntax.cat">
                  <IdentNode start="(1151, 73)" end="(1151, 80)" leading="" trailing=" " raw_val="ppSpace" val="ppSpace" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode/>
                </OtherNode>
                <OtherNode start="(1151, 81)" end="(1151, 98)" kind="Lean.Parser.Syntax.cat">
                  <IdentNode start="(1151, 81)" end="(1151, 98)" leading="" trailing="" raw_val="matchRhsTacticSeq" val="matchRhsTacticSeq" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1151, 98)" end="(1151, 99)" leading="" trailing="&#10;    " val=")"/>
            </OtherNode>
            <OtherNode start="(1152, 5)" end="(1152, 22)" kind="Lean.Parser.Syntax.unary">
              <IdentNode start="(1152, 5)" end="(1152, 13)" leading="" trailing="" raw_val="ppDedent" val="ppDedent"/>
              <AtomNode start="(1152, 13)" end="(1152, 14)" leading="" trailing="" val="("/>
              <NullNode start="(1152, 14)" end="(1152, 21)">
                <OtherNode start="(1152, 14)" end="(1152, 21)" kind="Lean.Parser.Syntax.cat">
                  <IdentNode start="(1152, 14)" end="(1152, 21)" leading="" trailing="" raw_val="ppSpace" val="ppSpace" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1152, 21)" end="(1152, 22)" leading="" trailing=" " val=")"/>
            </OtherNode>
            <OtherNode start="(1152, 23)" end="(1152, 60)" kind="Lean.Parser.Syntax.unary">
              <IdentNode start="(1152, 23)" end="(1152, 33)" leading="" trailing="" raw_val="ppRealFill" val="ppRealFill"/>
              <AtomNode start="(1152, 33)" end="(1152, 34)" leading="" trailing="" val="("/>
              <NullNode start="(1152, 34)" end="(1152, 59)">
                <OtherNode start="(1152, 34)" end="(1152, 41)" kind="Lean.Parser.Syntax.atom">
                  <OtherNode start="(1152, 34)" end="(1152, 41)" kind="str">
                    <AtomNode start="(1152, 34)" end="(1152, 41)" leading="" trailing=" " val="&amp;quot;else &amp;quot;"/>
                  </OtherNode>
                </OtherNode>
                <OtherNode start="(1152, 42)" end="(1152, 59)" kind="Lean.Parser.Syntax.cat">
                  <IdentNode start="(1152, 42)" end="(1152, 59)" leading="" trailing="" raw_val="matchRhsTacticSeq" val="matchRhsTacticSeq" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1152, 59)" end="(1152, 60)" leading="" trailing="" val=")"/>
            </OtherNode>
          </NullNode>
          <AtomNode start="(1152, 60)" end="(1152, 61)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1152, 62)" end="(1152, 63)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1152, 64)" end="(1152, 70)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(1154, 1)" end="(1169, 70)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1154, 1)" end="(1166, 3)">
        <CommandDoccommentNode start="(1154, 1)" end="(1166, 3)" comment="In tactic mode, `if t then tac1 else tac2` is alternative syntax for:&#10;```&#10;by_cases t&#10;· tac1&#10;· tac2&#10;```&#10;It performs case distinction on `h† : t` or `h† : ¬t`, where `h†` is an anonymous&#10;hypothesis, and `tac1` and `tac2` are the subproofs. (It doesn't actually use&#10;nondependent `if`, since this wouldn't add anything to the context and hence would be&#10;useless for proving theorems. To actually insert an `ite` application use&#10;`refine if t then ?_ else ?_`.)&#10;-/">
          <AtomNode start="(1154, 1)" end="(1154, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1155, 1)" end="(1166, 3)" leading="" trailing="&#10;" val="In tactic mode, `if t then tac1 else tac2` is alternative syntax for:&#10;```&#10;by_cases t&#10;· tac1&#10;· tac2&#10;```&#10;It performs case distinction on `h† : t` or `h† : ¬t`, where `h†` is an anonymous&#10;hypothesis, and `tac1` and `tac2` are the subproofs. (It doesn't actually use&#10;nondependent `if`, since this wouldn't add anything to the context and hence would be&#10;useless for proving theorems. To actually insert an `ite` application use&#10;`refine if t then ?_ else ?_`.)&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1167, 1)" end="(1167, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(1167, 8)" end="(1167, 31)">
        <OtherNode start="(1167, 8)" end="(1167, 31)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1167, 8)" end="(1167, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(1167, 9)" end="(1167, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1167, 14)" end="(1167, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1167, 17)" end="(1167, 30)" leading="" trailing="" raw_val="tacIfThenElse" val="tacIfThenElse"/>
          <AtomNode start="(1167, 30)" end="(1167, 31)" leading="" trailing="&#10;  " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(1168, 3)" end="(1169, 61)">
        <OtherNode start="(1168, 3)" end="(1169, 61)" kind="Lean.Parser.Syntax.unary">
          <IdentNode start="(1168, 3)" end="(1168, 14)" leading="" trailing="" raw_val="ppRealGroup" val="ppRealGroup"/>
          <AtomNode start="(1168, 14)" end="(1168, 15)" leading="" trailing="" val="("/>
          <NullNode start="(1168, 15)" end="(1169, 60)">
            <OtherNode start="(1168, 15)" end="(1168, 81)" kind="Lean.Parser.Syntax.unary">
              <IdentNode start="(1168, 15)" end="(1168, 25)" leading="" trailing="" raw_val="ppRealFill" val="ppRealFill"/>
              <AtomNode start="(1168, 25)" end="(1168, 26)" leading="" trailing="" val="("/>
              <NullNode start="(1168, 26)" end="(1168, 80)">
                <OtherNode start="(1168, 26)" end="(1168, 54)" kind="Lean.Parser.Syntax.unary">
                  <IdentNode start="(1168, 26)" end="(1168, 34)" leading="" trailing="" raw_val="ppIndent" val="ppIndent"/>
                  <AtomNode start="(1168, 34)" end="(1168, 35)" leading="" trailing="" val="("/>
                  <NullNode start="(1168, 35)" end="(1168, 53)">
                    <OtherNode start="(1168, 35)" end="(1168, 40)" kind="Lean.Parser.Syntax.atom">
                      <OtherNode start="(1168, 35)" end="(1168, 40)" kind="str">
                        <AtomNode start="(1168, 35)" end="(1168, 40)" leading="" trailing=" " val="&amp;quot;if &amp;quot;"/>
                      </OtherNode>
                    </OtherNode>
                    <OtherNode start="(1168, 41)" end="(1168, 45)" kind="Lean.Parser.Syntax.cat">
                      <IdentNode start="(1168, 41)" end="(1168, 45)" leading="" trailing=" " raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(1168, 46)" end="(1168, 53)" kind="Lean.Parser.Syntax.atom">
                      <OtherNode start="(1168, 46)" end="(1168, 53)" kind="str">
                        <AtomNode start="(1168, 46)" end="(1168, 53)" leading="" trailing="" val="&amp;quot; then&amp;quot;"/>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(1168, 53)" end="(1168, 54)" leading="" trailing=" " val=")"/>
                </OtherNode>
                <OtherNode start="(1168, 55)" end="(1168, 62)" kind="Lean.Parser.Syntax.cat">
                  <IdentNode start="(1168, 55)" end="(1168, 62)" leading="" trailing=" " raw_val="ppSpace" val="ppSpace" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode/>
                </OtherNode>
                <OtherNode start="(1168, 63)" end="(1168, 80)" kind="Lean.Parser.Syntax.cat">
                  <IdentNode start="(1168, 63)" end="(1168, 80)" leading="" trailing="" raw_val="matchRhsTacticSeq" val="matchRhsTacticSeq" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1168, 80)" end="(1168, 81)" leading="" trailing="&#10;    " val=")"/>
            </OtherNode>
            <OtherNode start="(1169, 5)" end="(1169, 22)" kind="Lean.Parser.Syntax.unary">
              <IdentNode start="(1169, 5)" end="(1169, 13)" leading="" trailing="" raw_val="ppDedent" val="ppDedent"/>
              <AtomNode start="(1169, 13)" end="(1169, 14)" leading="" trailing="" val="("/>
              <NullNode start="(1169, 14)" end="(1169, 21)">
                <OtherNode start="(1169, 14)" end="(1169, 21)" kind="Lean.Parser.Syntax.cat">
                  <IdentNode start="(1169, 14)" end="(1169, 21)" leading="" trailing="" raw_val="ppSpace" val="ppSpace" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1169, 21)" end="(1169, 22)" leading="" trailing=" " val=")"/>
            </OtherNode>
            <OtherNode start="(1169, 23)" end="(1169, 60)" kind="Lean.Parser.Syntax.unary">
              <IdentNode start="(1169, 23)" end="(1169, 33)" leading="" trailing="" raw_val="ppRealFill" val="ppRealFill"/>
              <AtomNode start="(1169, 33)" end="(1169, 34)" leading="" trailing="" val="("/>
              <NullNode start="(1169, 34)" end="(1169, 59)">
                <OtherNode start="(1169, 34)" end="(1169, 41)" kind="Lean.Parser.Syntax.atom">
                  <OtherNode start="(1169, 34)" end="(1169, 41)" kind="str">
                    <AtomNode start="(1169, 34)" end="(1169, 41)" leading="" trailing=" " val="&amp;quot;else &amp;quot;"/>
                  </OtherNode>
                </OtherNode>
                <OtherNode start="(1169, 42)" end="(1169, 59)" kind="Lean.Parser.Syntax.cat">
                  <IdentNode start="(1169, 42)" end="(1169, 59)" leading="" trailing="" raw_val="matchRhsTacticSeq" val="matchRhsTacticSeq" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  <NullNode/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1169, 59)" end="(1169, 60)" leading="" trailing="" val=")"/>
            </OtherNode>
          </NullNode>
          <AtomNode start="(1169, 60)" end="(1169, 61)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1169, 62)" end="(1169, 63)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1169, 64)" end="(1169, 70)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(1171, 1)" end="(1175, 49)" kind="Lean.Parser.Command.macro">
      <NullNode start="(1171, 1)" end="(1174, 3)">
        <CommandDoccommentNode start="(1171, 1)" end="(1174, 3)" comment="The tactic `nofun` is shorthand for `exact nofun`: it introduces the assumptions, then performs an&#10;empty pattern match, closing the goal if the introduced pattern is impossible.&#10;-/">
          <AtomNode start="(1171, 1)" end="(1171, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1172, 1)" end="(1174, 3)" leading="" trailing="&#10;" val="The tactic `nofun` is shorthand for `exact nofun`: it introduces the assumptions, then performs an&#10;empty pattern match, closing the goal if the introduced pattern is impossible.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1175, 1)" end="(1175, 6)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(1175, 7)" end="(1175, 14)">
        <OtherNode start="(1175, 7)" end="(1175, 14)" kind="Lean.Parser.Command.macroArg">
          <NullNode/>
          <OtherNode start="(1175, 7)" end="(1175, 14)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(1175, 7)" end="(1175, 14)" kind="str">
              <AtomNode start="(1175, 7)" end="(1175, 14)" leading="" trailing=" " val="&amp;quot;nofun&amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(1175, 15)" end="(1175, 49)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(1175, 15)" end="(1175, 16)" leading="" trailing=" " val=":"/>
        <IdentNode start="(1175, 17)" end="(1175, 23)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(1175, 24)" end="(1175, 26)" leading="" trailing=" " val="=&amp;gt;"/>
        <OtherNode start="(1175, 27)" end="(1175, 49)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(1175, 27)" end="(1175, 49)" kind="Lean.Parser.Tactic.quot">
            <AtomNode start="(1175, 27)" end="(1175, 36)" leading="" trailing=" " val="`(tactic|"/>
            <OtherNode start="(1175, 37)" end="(1175, 48)" kind="Lean.Parser.Tactic.exact">
              <AtomNode start="(1175, 37)" end="(1175, 42)" leading="" trailing=" " val="exact"/>
              <OtherNode start="(1175, 43)" end="(1175, 48)" kind="Lean.Parser.Term.nofun">
                <AtomNode start="(1175, 43)" end="(1175, 48)" leading="" trailing="" val="nofun"/>
              </OtherNode>
            </OtherNode>
            <AtomNode start="(1175, 48)" end="(1175, 49)" leading="" trailing="&#10;&#10;" val=")"/>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(1177, 1)" end="(1181, 38)" kind="Lean.Parser.Command.macro">
      <NullNode start="(1177, 1)" end="(1179, 3)">
        <CommandDoccommentNode start="(1177, 1)" end="(1179, 3)" comment="The tactic `nomatch h` is shorthand for `exact nomatch h`.&#10;-/">
          <AtomNode start="(1177, 1)" end="(1177, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1178, 1)" end="(1179, 3)" leading="" trailing="&#10;" val="The tactic `nomatch h` is shorthand for `exact nomatch h`.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1180, 1)" end="(1180, 6)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(1180, 7)" end="(1180, 27)">
        <OtherNode start="(1180, 7)" end="(1180, 17)" kind="Lean.Parser.Command.macroArg">
          <NullNode/>
          <OtherNode start="(1180, 7)" end="(1180, 17)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(1180, 7)" end="(1180, 17)" kind="str">
              <AtomNode start="(1180, 7)" end="(1180, 17)" leading="" trailing=" " val="&amp;quot;nomatch &amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1180, 18)" end="(1180, 27)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(1180, 18)" end="(1180, 21)">
            <IdentNode start="(1180, 18)" end="(1180, 20)" leading="" trailing="" raw_val="es" val="es"/>
            <AtomNode start="(1180, 20)" end="(1180, 21)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(1180, 21)" end="(1180, 27)" kind="«stx_,+»">
            <OtherNode start="(1180, 21)" end="(1180, 25)" kind="Lean.Parser.Syntax.cat">
              <IdentNode start="(1180, 21)" end="(1180, 25)" leading="" trailing="" raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              <NullNode/>
            </OtherNode>
            <AtomNode start="(1180, 25)" end="(1180, 27)" leading="" trailing=" " val=",+"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(1180, 28)" end="(1181, 38)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(1180, 28)" end="(1180, 29)" leading="" trailing=" " val=":"/>
        <IdentNode start="(1180, 30)" end="(1180, 36)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(1180, 37)" end="(1180, 39)" leading="" trailing="&#10;  " val="=&amp;gt;"/>
        <OtherNode start="(1181, 3)" end="(1181, 38)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(1181, 3)" end="(1181, 38)" kind="Lean.Parser.Tactic.quot">
            <AtomNode start="(1181, 3)" end="(1181, 12)" leading="" trailing=" " val="`(tactic|"/>
            <OtherNode start="(1181, 13)" end="(1181, 37)" kind="Lean.Parser.Tactic.exact">
              <AtomNode start="(1181, 13)" end="(1181, 18)" leading="" trailing=" " val="exact"/>
              <OtherNode start="(1181, 19)" end="(1181, 37)" kind="Lean.Parser.Term.nomatch">
                <AtomNode start="(1181, 19)" end="(1181, 26)" leading="" trailing=" " val="nomatch"/>
                <NullNode start="(1181, 27)" end="(1181, 37)">
                  <OtherNode start="(1181, 27)" end="(1181, 37)" kind="sepBy.antiquot_suffix_splice">
                    <OtherNode start="(1181, 27)" end="(1181, 35)" kind="term.pseudo.antiquot">
                      <AtomNode start="(1181, 27)" end="(1181, 28)" leading="" trailing="" val="$"/>
                      <NullNode/>
                      <IdentNode start="(1181, 28)" end="(1181, 30)" leading="" trailing="" raw_val="es" val="es"/>
                      <OtherNode start="(1181, 30)" end="(1181, 35)" kind="antiquotName">
                        <AtomNode start="(1181, 30)" end="(1181, 31)" leading="" trailing="" val=":"/>
                        <AtomNode start="(1181, 31)" end="(1181, 35)" leading="" trailing="" val="term"/>
                      </OtherNode>
                    </OtherNode>
                    <AtomNode start="(1181, 35)" end="(1181, 37)" leading="" trailing="" val=",*"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </OtherNode>
            <AtomNode start="(1181, 37)" end="(1181, 38)" leading="" trailing="&#10;&#10;" val=")"/>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(1183, 1)" end="(1212, 53)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1183, 1)" end="(1211, 3)">
        <CommandDoccommentNode start="(1183, 1)" end="(1211, 3)" comment="Acts like `have`, but removes a hypothesis with the same name as&#10;this one if possible. For example, if the state is:&#10;&#10;```lean&#10;f : α → β&#10;h : α&#10;⊢ goal&#10;```&#10;&#10;Then after `replace h := f h` the state will be:&#10;&#10;```lean&#10;f : α → β&#10;h : β&#10;⊢ goal&#10;```&#10;&#10;whereas `have h := f h` would result in:&#10;&#10;```lean&#10;f : α → β&#10;h† : α&#10;h : β&#10;⊢ goal&#10;```&#10;&#10;This can be used to simulate the `specialize` and `apply at` tactics of Coq.&#10;-/">
          <AtomNode start="(1183, 1)" end="(1183, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1184, 1)" end="(1211, 3)" leading="" trailing="&#10;" val="Acts like `have`, but removes a hypothesis with the same name as&#10;this one if possible. For example, if the state is:&#10;&#10;```lean&#10;f : α → β&#10;h : α&#10;⊢ goal&#10;```&#10;&#10;Then after `replace h := f h` the state will be:&#10;&#10;```lean&#10;f : α → β&#10;h : β&#10;⊢ goal&#10;```&#10;&#10;whereas `have h := f h` would result in:&#10;&#10;```lean&#10;f : α → β&#10;h† : α&#10;h : β&#10;⊢ goal&#10;```&#10;&#10;This can be used to simulate the `specialize` and `apply at` tactics of Coq.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1212, 1)" end="(1212, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(1212, 8)" end="(1212, 25)">
        <OtherNode start="(1212, 8)" end="(1212, 25)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1212, 8)" end="(1212, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(1212, 9)" end="(1212, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1212, 14)" end="(1212, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1212, 17)" end="(1212, 24)" leading="" trailing="" raw_val="replace" val="replace"/>
          <AtomNode start="(1212, 24)" end="(1212, 25)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(1212, 26)" end="(1212, 44)">
        <OtherNode start="(1212, 26)" end="(1212, 35)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1212, 26)" end="(1212, 35)" kind="str">
            <AtomNode start="(1212, 26)" end="(1212, 35)" leading="" trailing=" " val="&amp;quot;replace&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1212, 36)" end="(1212, 44)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(1212, 36)" end="(1212, 44)" leading="" trailing=" " raw_val="haveDecl" val="haveDecl" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1212, 45)" end="(1212, 46)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1212, 47)" end="(1212, 53)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(1214, 1)" end="(1215, 29)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1214, 1)" end="(1214, 73)">
        <CommandDoccommentNode start="(1214, 1)" end="(1214, 73)" comment="`and_intros` applies `And.intro` until it does not make progress. -/">
          <AtomNode start="(1214, 1)" end="(1214, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(1214, 5)" end="(1214, 73)" leading="" trailing="&#10;" val="`and_intros` applies `And.intro` until it does not make progress. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1215, 1)" end="(1215, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(1215, 8)" end="(1215, 20)">
        <OtherNode start="(1215, 8)" end="(1215, 20)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1215, 8)" end="(1215, 20)" kind="str">
            <AtomNode start="(1215, 8)" end="(1215, 20)" leading="" trailing=" " val="&amp;quot;and_intros&amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1215, 21)" end="(1215, 22)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1215, 23)" end="(1215, 29)" leading="" trailing="&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(1216, 1)" end="(1216, 81)" kind="Lean.Parser.Command.macro_rules">
      <NullNode/>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1216, 1)" end="(1216, 12)" leading="" trailing=" " val="macro_rules"/>
      <NullNode/>
      <OtherNode start="(1216, 13)" end="(1216, 81)" kind="Lean.Parser.Term.matchAlts">
        <NullNode start="(1216, 13)" end="(1216, 81)">
          <OtherNode start="(1216, 13)" end="(1216, 81)" kind="Lean.Parser.Term.matchAlt">
            <AtomNode start="(1216, 13)" end="(1216, 14)" leading="" trailing=" " val="|"/>
            <NullNode start="(1216, 15)" end="(1216, 36)">
              <NullNode start="(1216, 15)" end="(1216, 36)">
                <OtherNode start="(1216, 15)" end="(1216, 36)" kind="Lean.Parser.Tactic.quot">
                  <AtomNode start="(1216, 15)" end="(1216, 24)" leading="" trailing=" " val="`(tactic|"/>
                  <OtherNode start="(1216, 25)" end="(1216, 35)" kind="Lean.Parser.Tactic.tacticAnd_intros">
                    <AtomNode start="(1216, 25)" end="(1216, 35)" leading="" trailing="" val="and_intros"/>
                  </OtherNode>
                  <AtomNode start="(1216, 35)" end="(1216, 36)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </NullNode>
            </NullNode>
            <AtomNode start="(1216, 37)" end="(1216, 39)" leading="" trailing=" " val="=&amp;gt;"/>
            <OtherNode start="(1216, 40)" end="(1216, 81)" kind="Lean.Parser.Tactic.quot">
              <AtomNode start="(1216, 40)" end="(1216, 49)" leading="" trailing=" " val="`(tactic|"/>
              <OtherNode start="(1216, 50)" end="(1216, 80)" kind="Lean.Parser.Tactic.repeat'">
                <AtomNode start="(1216, 50)" end="(1216, 57)" leading="" trailing=" " val="repeat'"/>
                <TacticTacticseqNode start="(1216, 58)" end="(1216, 80)">
                  <TacticTacticseq1IndentedNode start="(1216, 58)" end="(1216, 80)">
                    <NullNode start="(1216, 58)" end="(1216, 80)">
                      <OtherNode start="(1216, 58)" end="(1216, 80)" kind="Lean.Parser.Tactic.refine">
                        <AtomNode start="(1216, 58)" end="(1216, 64)" leading="" trailing=" " val="refine"/>
                        <OtherNode start="(1216, 65)" end="(1216, 80)" kind="Lean.Parser.Term.app">
                          <IdentNode start="(1216, 65)" end="(1216, 74)" leading="" trailing=" " raw_val="And.intro" val="And.intro"/>
                          <NullNode start="(1216, 75)" end="(1216, 80)">
                            <OtherNode start="(1216, 75)" end="(1216, 77)" kind="Lean.Parser.Term.syntheticHole">
                              <AtomNode start="(1216, 75)" end="(1216, 76)" leading="" trailing="" val="?"/>
                              <AtomNode start="(1216, 76)" end="(1216, 77)" leading="" trailing=" " val="_"/>
                            </OtherNode>
                            <OtherNode start="(1216, 78)" end="(1216, 80)" kind="Lean.Parser.Term.syntheticHole">
                              <AtomNode start="(1216, 78)" end="(1216, 79)" leading="" trailing="" val="?"/>
                              <AtomNode start="(1216, 79)" end="(1216, 80)" leading="" trailing="" val="_"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </OtherNode>
                    </NullNode>
                  </TacticTacticseq1IndentedNode>
                </TacticTacticseqNode>
              </OtherNode>
              <AtomNode start="(1216, 80)" end="(1216, 81)" leading="" trailing="&#10;&#10;" val=")"/>
            </OtherNode>
          </OtherNode>
        </NullNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(1218, 1)" end="(1222, 47)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1218, 1)" end="(1221, 3)">
        <CommandDoccommentNode start="(1218, 1)" end="(1221, 3)" comment="`subst_eq` repeatedly substitutes according to the equality proof hypotheses in the context,&#10;replacing the left side of the equality with the right, until no more progress can be made.&#10;-/">
          <AtomNode start="(1218, 1)" end="(1218, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1219, 1)" end="(1221, 3)" leading="" trailing="&#10;" val="`subst_eq` repeatedly substitutes according to the equality proof hypotheses in the context,&#10;replacing the left side of the equality with the right, until no more progress can be made.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1222, 1)" end="(1222, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(1222, 8)" end="(1222, 26)">
        <OtherNode start="(1222, 8)" end="(1222, 26)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1222, 8)" end="(1222, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(1222, 9)" end="(1222, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1222, 14)" end="(1222, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1222, 17)" end="(1222, 25)" leading="" trailing="" raw_val="substEqs" val="substEqs"/>
          <AtomNode start="(1222, 25)" end="(1222, 26)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(1222, 27)" end="(1222, 38)">
        <OtherNode start="(1222, 27)" end="(1222, 38)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1222, 27)" end="(1222, 38)" kind="str">
            <AtomNode start="(1222, 27)" end="(1222, 38)" leading="" trailing=" " val="&amp;quot;subst_eqs&amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1222, 39)" end="(1222, 40)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1222, 41)" end="(1222, 47)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(1224, 1)" end="(1225, 50)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1224, 1)" end="(1224, 67)">
        <CommandDoccommentNode start="(1224, 1)" end="(1224, 67)" comment="The `run_tac doSeq` tactic executes code in `TacticM Unit`. -/">
          <AtomNode start="(1224, 1)" end="(1224, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(1224, 5)" end="(1224, 67)" leading="" trailing="&#10;" val="The `run_tac doSeq` tactic executes code in `TacticM Unit`. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1225, 1)" end="(1225, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(1225, 8)" end="(1225, 24)">
        <OtherNode start="(1225, 8)" end="(1225, 24)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1225, 8)" end="(1225, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(1225, 9)" end="(1225, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1225, 14)" end="(1225, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1225, 17)" end="(1225, 23)" leading="" trailing="" raw_val="runTac" val="runTac"/>
          <AtomNode start="(1225, 23)" end="(1225, 24)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(1225, 25)" end="(1225, 41)">
        <OtherNode start="(1225, 25)" end="(1225, 35)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1225, 25)" end="(1225, 35)" kind="str">
            <AtomNode start="(1225, 25)" end="(1225, 35)" leading="" trailing=" " val="&amp;quot;run_tac &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1225, 36)" end="(1225, 41)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(1225, 36)" end="(1225, 41)" leading="" trailing=" " raw_val="doSeq" val="doSeq" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1225, 42)" end="(1225, 43)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1225, 44)" end="(1225, 50)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(1227, 1)" end="(1228, 82)" kind="Lean.Parser.Command.macro">
      <NullNode start="(1227, 1)" end="(1227, 97)">
        <CommandDoccommentNode start="(1227, 1)" end="(1227, 97)" comment="`haveI` behaves like `have`, but inlines the value instead of producing a `let_fun` term. -/">
          <AtomNode start="(1227, 1)" end="(1227, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(1227, 5)" end="(1227, 97)" leading="" trailing="&#10;" val="`haveI` behaves like `have`, but inlines the value instead of producing a `let_fun` term. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1228, 1)" end="(1228, 6)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(1228, 7)" end="(1228, 25)">
        <OtherNode start="(1228, 7)" end="(1228, 14)" kind="Lean.Parser.Command.macroArg">
          <NullNode/>
          <OtherNode start="(1228, 7)" end="(1228, 14)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(1228, 7)" end="(1228, 14)" kind="str">
              <AtomNode start="(1228, 7)" end="(1228, 14)" leading="" trailing=" " val="&amp;quot;haveI&amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1228, 15)" end="(1228, 25)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(1228, 15)" end="(1228, 17)">
            <IdentNode start="(1228, 15)" end="(1228, 16)" leading="" trailing="" raw_val="d" val="d"/>
            <AtomNode start="(1228, 16)" end="(1228, 17)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(1228, 17)" end="(1228, 25)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(1228, 17)" end="(1228, 25)" leading="" trailing=" " raw_val="haveDecl" val="haveDecl" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(1228, 26)" end="(1228, 82)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(1228, 26)" end="(1228, 27)" leading="" trailing=" " val=":"/>
        <IdentNode start="(1228, 28)" end="(1228, 34)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(1228, 35)" end="(1228, 37)" leading="" trailing=" " val="=&amp;gt;"/>
        <OtherNode start="(1228, 38)" end="(1228, 82)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(1228, 38)" end="(1228, 82)" kind="Lean.Parser.Tactic.quot">
            <AtomNode start="(1228, 38)" end="(1228, 47)" leading="" trailing=" " val="`(tactic|"/>
            <OtherNode start="(1228, 48)" end="(1228, 81)" kind="Lean.Parser.Tactic.tacticRefine_lift_">
              <AtomNode start="(1228, 48)" end="(1228, 59)" leading="" trailing=" " val="refine_lift"/>
              <OtherNode start="(1228, 60)" end="(1228, 81)" kind="Lean.Parser.Term.haveI">
                <AtomNode start="(1228, 60)" end="(1228, 65)" leading="" trailing=" " val="haveI"/>
                <OtherNode start="(1228, 66)" end="(1228, 77)" kind="Lean.Parser.Term.haveDecl.antiquot">
                  <AtomNode start="(1228, 66)" end="(1228, 67)" leading="" trailing="" val="$"/>
                  <NullNode/>
                  <IdentNode start="(1228, 67)" end="(1228, 68)" leading="" trailing="" raw_val="d" val="d"/>
                  <OtherNode start="(1228, 68)" end="(1228, 77)" kind="antiquotName">
                    <AtomNode start="(1228, 68)" end="(1228, 69)" leading="" trailing="" val=":"/>
                    <AtomNode start="(1228, 69)" end="(1228, 77)" leading="" trailing="" val="haveDecl"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(1228, 77)" end="(1228, 78)" leading="" trailing=" " val=";"/>
                <OtherNode start="(1228, 79)" end="(1228, 81)" kind="Lean.Parser.Term.syntheticHole">
                  <AtomNode start="(1228, 79)" end="(1228, 80)" leading="" trailing="" val="?"/>
                  <AtomNode start="(1228, 80)" end="(1228, 81)" leading="" trailing="" val="_"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
            <AtomNode start="(1228, 81)" end="(1228, 82)" leading="" trailing="&#10;&#10;" val=")"/>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(1230, 1)" end="(1231, 80)" kind="Lean.Parser.Command.macro">
      <NullNode start="(1230, 1)" end="(1230, 95)">
        <CommandDoccommentNode start="(1230, 1)" end="(1230, 95)" comment="`letI` behaves like `let`, but inlines the value instead of producing a `let_fun` term. -/">
          <AtomNode start="(1230, 1)" end="(1230, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(1230, 5)" end="(1230, 95)" leading="" trailing="&#10;" val="`letI` behaves like `let`, but inlines the value instead of producing a `let_fun` term. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1231, 1)" end="(1231, 6)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(1231, 7)" end="(1231, 24)">
        <OtherNode start="(1231, 7)" end="(1231, 13)" kind="Lean.Parser.Command.macroArg">
          <NullNode/>
          <OtherNode start="(1231, 7)" end="(1231, 13)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(1231, 7)" end="(1231, 13)" kind="str">
              <AtomNode start="(1231, 7)" end="(1231, 13)" leading="" trailing=" " val="&amp;quot;letI&amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1231, 14)" end="(1231, 24)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(1231, 14)" end="(1231, 16)">
            <IdentNode start="(1231, 14)" end="(1231, 15)" leading="" trailing="" raw_val="d" val="d"/>
            <AtomNode start="(1231, 15)" end="(1231, 16)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(1231, 16)" end="(1231, 24)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(1231, 16)" end="(1231, 24)" leading="" trailing=" " raw_val="haveDecl" val="haveDecl" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(1231, 25)" end="(1231, 80)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(1231, 25)" end="(1231, 26)" leading="" trailing=" " val=":"/>
        <IdentNode start="(1231, 27)" end="(1231, 33)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(1231, 34)" end="(1231, 36)" leading="" trailing=" " val="=&amp;gt;"/>
        <OtherNode start="(1231, 37)" end="(1231, 80)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(1231, 37)" end="(1231, 80)" kind="Lean.Parser.Tactic.quot">
            <AtomNode start="(1231, 37)" end="(1231, 46)" leading="" trailing=" " val="`(tactic|"/>
            <OtherNode start="(1231, 47)" end="(1231, 79)" kind="Lean.Parser.Tactic.tacticRefine_lift_">
              <AtomNode start="(1231, 47)" end="(1231, 58)" leading="" trailing=" " val="refine_lift"/>
              <OtherNode start="(1231, 59)" end="(1231, 79)" kind="Lean.Parser.Term.letI">
                <AtomNode start="(1231, 59)" end="(1231, 63)" leading="" trailing=" " val="letI"/>
                <OtherNode start="(1231, 64)" end="(1231, 75)" kind="Lean.Parser.Term.haveDecl.antiquot">
                  <AtomNode start="(1231, 64)" end="(1231, 65)" leading="" trailing="" val="$"/>
                  <NullNode/>
                  <IdentNode start="(1231, 65)" end="(1231, 66)" leading="" trailing="" raw_val="d" val="d"/>
                  <OtherNode start="(1231, 66)" end="(1231, 75)" kind="antiquotName">
                    <AtomNode start="(1231, 66)" end="(1231, 67)" leading="" trailing="" val=":"/>
                    <AtomNode start="(1231, 67)" end="(1231, 75)" leading="" trailing="" val="haveDecl"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(1231, 75)" end="(1231, 76)" leading="" trailing=" " val=";"/>
                <OtherNode start="(1231, 77)" end="(1231, 79)" kind="Lean.Parser.Term.syntheticHole">
                  <AtomNode start="(1231, 77)" end="(1231, 78)" leading="" trailing="" val="?"/>
                  <AtomNode start="(1231, 78)" end="(1231, 79)" leading="" trailing="" val="_"/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
            <AtomNode start="(1231, 79)" end="(1231, 80)" leading="" trailing="&#10;&#10;" val=")"/>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <CommandDeclarationNode start="(1233, 1)" end="(1252, 25)" name="DecideConfig" full_name="Lean.Parser.Tactic.DecideConfig">
      <CommandDeclmodifiersNode start="(1233, 1)" end="(1235, 3)">
        <NullNode start="(1233, 1)" end="(1235, 3)">
          <CommandDoccommentNode start="(1233, 1)" end="(1235, 3)" comment="Configuration for the `decide` tactic family.&#10;-/">
            <AtomNode start="(1233, 1)" end="(1233, 4)" leading="" trailing="&#10;" val="/--"/>
            <AtomNode start="(1234, 1)" end="(1235, 3)" leading="" trailing="&#10;" val="Configuration for the `decide` tactic family.&#10;-/"/>
          </CommandDoccommentNode>
        </NullNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode/>
      </CommandDeclmodifiersNode>
      <CommandStructureNode start="(1236, 1)" end="(1252, 25)" name="DecideConfig">
        <CommandStructuretkNode start="(1236, 1)" end="(1236, 10)">
          <AtomNode start="(1236, 1)" end="(1236, 10)" leading="" trailing=" " val="structure"/>
        </CommandStructuretkNode>
        <CommandDeclidNode start="(1236, 11)" end="(1236, 23)">
          <IdentNode start="(1236, 11)" end="(1236, 23)" leading="" trailing=" " raw_val="DecideConfig" val="DecideConfig"/>
          <NullNode/>
        </CommandDeclidNode>
        <NullNode/>
        <NullNode/>
        <NullNode/>
        <NullNode start="(1236, 24)" end="(1252, 25)">
          <AtomNode start="(1236, 24)" end="(1236, 29)" leading="" trailing="&#10;  " val="where"/>
          <NullNode/>
          <OtherNode start="(1237, 3)" end="(1252, 25)" kind="Lean.Parser.Command.structFields">
            <NullNode start="(1237, 3)" end="(1252, 25)">
              <OtherNode start="(1237, 3)" end="(1240, 25)" kind="Lean.Parser.Command.structSimpleBinder">
                <CommandDeclmodifiersNode start="(1237, 3)" end="(1239, 61)">
                  <NullNode start="(1237, 3)" end="(1239, 61)">
                    <CommandDoccommentNode start="(1237, 3)" end="(1239, 61)" comment="If true (default: false), then use only kernel reduction when reducing the `Decidable` instance.&#10;  This is more efficient, since the default mode reduces twice (once in the elaborator and again in the kernel),&#10;  however kernel reduction ignores transparency settings. -/">
                      <AtomNode start="(1237, 3)" end="(1237, 6)" leading="" trailing=" " val="/--"/>
                      <AtomNode start="(1237, 7)" end="(1239, 61)" leading="" trailing="&#10;  " val="If true (default: false), then use only kernel reduction when reducing the `Decidable` instance.&#10;  This is more efficient, since the default mode reduces twice (once in the elaborator and again in the kernel),&#10;  however kernel reduction ignores transparency settings. -/"/>
                    </CommandDoccommentNode>
                  </NullNode>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </CommandDeclmodifiersNode>
                <IdentNode start="(1240, 3)" end="(1240, 9)" leading="" trailing=" " raw_val="kernel" val="kernel"/>
                <OtherNode start="(1240, 10)" end="(1240, 16)" kind="Lean.Parser.Command.optDeclSig">
                  <NullNode/>
                  <NullNode start="(1240, 10)" end="(1240, 16)">
                    <TermTypespecNode start="(1240, 10)" end="(1240, 16)">
                      <AtomNode start="(1240, 10)" end="(1240, 11)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(1240, 12)" end="(1240, 16)" leading="" trailing=" " raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </TermTypespecNode>
                  </NullNode>
                </OtherNode>
                <NullNode start="(1240, 17)" end="(1240, 25)">
                  <OtherNode start="(1240, 17)" end="(1240, 25)" kind="Lean.Parser.Term.binderDefault">
                    <AtomNode start="(1240, 17)" end="(1240, 19)" leading="" trailing=" " val=":="/>
                    <IdentNode start="(1240, 20)" end="(1240, 25)" leading="" trailing="&#10;  " raw_val="false" val="false" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <OtherNode start="(1241, 3)" end="(1246, 25)" kind="Lean.Parser.Command.structSimpleBinder">
                <CommandDeclmodifiersNode start="(1241, 3)" end="(1245, 104)">
                  <NullNode start="(1241, 3)" end="(1245, 104)">
                    <CommandDoccommentNode start="(1241, 3)" end="(1245, 104)" comment="If true (default: false), then uses the native code compiler to evaluate the `Decidable` instance,&#10;  admitting the result via the axiom `Lean.ofReduceBool`.  This can be significantly more efficient,&#10;  but it is at the cost of increasing the trusted code base, namely the Lean compiler&#10;  and all definitions with an `@[implemented_by]` attribute.&#10;  The instance is only evaluated once. The `native_decide` tactic is a synonym for `decide +native`. -/">
                      <AtomNode start="(1241, 3)" end="(1241, 6)" leading="" trailing=" " val="/--"/>
                      <AtomNode start="(1241, 7)" end="(1245, 104)" leading="" trailing="&#10;  " val="If true (default: false), then uses the native code compiler to evaluate the `Decidable` instance,&#10;  admitting the result via the axiom `Lean.ofReduceBool`.  This can be significantly more efficient,&#10;  but it is at the cost of increasing the trusted code base, namely the Lean compiler&#10;  and all definitions with an `@[implemented_by]` attribute.&#10;  The instance is only evaluated once. The `native_decide` tactic is a synonym for `decide +native`. -/"/>
                    </CommandDoccommentNode>
                  </NullNode>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </CommandDeclmodifiersNode>
                <IdentNode start="(1246, 3)" end="(1246, 9)" leading="" trailing=" " raw_val="native" val="native"/>
                <OtherNode start="(1246, 10)" end="(1246, 16)" kind="Lean.Parser.Command.optDeclSig">
                  <NullNode/>
                  <NullNode start="(1246, 10)" end="(1246, 16)">
                    <TermTypespecNode start="(1246, 10)" end="(1246, 16)">
                      <AtomNode start="(1246, 10)" end="(1246, 11)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(1246, 12)" end="(1246, 16)" leading="" trailing=" " raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </TermTypespecNode>
                  </NullNode>
                </OtherNode>
                <NullNode start="(1246, 17)" end="(1246, 25)">
                  <OtherNode start="(1246, 17)" end="(1246, 25)" kind="Lean.Parser.Term.binderDefault">
                    <AtomNode start="(1246, 17)" end="(1246, 19)" leading="" trailing=" " val=":="/>
                    <IdentNode start="(1246, 20)" end="(1246, 25)" leading="" trailing="&#10;  " raw_val="false" val="false" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <OtherNode start="(1247, 3)" end="(1248, 28)" kind="Lean.Parser.Command.structSimpleBinder">
                <CommandDeclmodifiersNode start="(1247, 3)" end="(1247, 126)">
                  <NullNode start="(1247, 3)" end="(1247, 126)">
                    <CommandDoccommentNode start="(1247, 3)" end="(1247, 126)" comment="If true (default: true), then when preprocessing the goal, do zeta reduction to attempt to eliminate free variables. -/">
                      <AtomNode start="(1247, 3)" end="(1247, 6)" leading="" trailing=" " val="/--"/>
                      <AtomNode start="(1247, 7)" end="(1247, 126)" leading="" trailing="&#10;  " val="If true (default: true), then when preprocessing the goal, do zeta reduction to attempt to eliminate free variables. -/"/>
                    </CommandDoccommentNode>
                  </NullNode>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </CommandDeclmodifiersNode>
                <IdentNode start="(1248, 3)" end="(1248, 13)" leading="" trailing=" " raw_val="zetaReduce" val="zetaReduce"/>
                <OtherNode start="(1248, 14)" end="(1248, 20)" kind="Lean.Parser.Command.optDeclSig">
                  <NullNode/>
                  <NullNode start="(1248, 14)" end="(1248, 20)">
                    <TermTypespecNode start="(1248, 14)" end="(1248, 20)">
                      <AtomNode start="(1248, 14)" end="(1248, 15)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(1248, 16)" end="(1248, 20)" leading="" trailing=" " raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </TermTypespecNode>
                  </NullNode>
                </OtherNode>
                <NullNode start="(1248, 21)" end="(1248, 28)">
                  <OtherNode start="(1248, 21)" end="(1248, 28)" kind="Lean.Parser.Term.binderDefault">
                    <AtomNode start="(1248, 21)" end="(1248, 23)" leading="" trailing=" " val=":="/>
                    <IdentNode start="(1248, 24)" end="(1248, 28)" leading="" trailing="&#10;  " raw_val="true" val="true" full_name="Bool.true" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <OtherNode start="(1249, 3)" end="(1252, 25)" kind="Lean.Parser.Command.structSimpleBinder">
                <CommandDeclmodifiersNode start="(1249, 3)" end="(1251, 67)">
                  <NullNode start="(1249, 3)" end="(1251, 67)">
                    <CommandDoccommentNode start="(1249, 3)" end="(1251, 67)" comment="If true (default: false), then when preprocessing, removes irrelevant variables and reverts the local context.&#10;  A variable is *relevant* if it appears in the target, if it appears in a relevant variable,&#10;  or if it is a proposition that refers to a relevant variable. -/">
                      <AtomNode start="(1249, 3)" end="(1249, 6)" leading="" trailing=" " val="/--"/>
                      <AtomNode start="(1249, 7)" end="(1251, 67)" leading="" trailing="&#10;  " val="If true (default: false), then when preprocessing, removes irrelevant variables and reverts the local context.&#10;  A variable is *relevant* if it appears in the target, if it appears in a relevant variable,&#10;  or if it is a proposition that refers to a relevant variable. -/"/>
                    </CommandDoccommentNode>
                  </NullNode>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                  <NullNode/>
                </CommandDeclmodifiersNode>
                <IdentNode start="(1252, 3)" end="(1252, 9)" leading="" trailing=" " raw_val="revert" val="revert"/>
                <OtherNode start="(1252, 10)" end="(1252, 16)" kind="Lean.Parser.Command.optDeclSig">
                  <NullNode/>
                  <NullNode start="(1252, 10)" end="(1252, 16)">
                    <TermTypespecNode start="(1252, 10)" end="(1252, 16)">
                      <AtomNode start="(1252, 10)" end="(1252, 11)" leading="" trailing=" " val=":"/>
                      <IdentNode start="(1252, 12)" end="(1252, 16)" leading="" trailing=" " raw_val="Bool" val="Bool" full_name="Bool" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    </TermTypespecNode>
                  </NullNode>
                </OtherNode>
                <NullNode start="(1252, 17)" end="(1252, 25)">
                  <OtherNode start="(1252, 17)" end="(1252, 25)" kind="Lean.Parser.Term.binderDefault">
                    <AtomNode start="(1252, 17)" end="(1252, 19)" leading="" trailing=" " val=":="/>
                    <IdentNode start="(1252, 20)" end="(1252, 25)" leading="" trailing="&#10;&#10;" raw_val="false" val="false" full_name="Bool.false" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
            </NullNode>
          </OtherNode>
        </NullNode>
        <OtherNode kind="Lean.Parser.Command.optDeriving">
          <NullNode/>
        </OtherNode>
      </CommandStructureNode>
    </CommandDeclarationNode>
    <OtherNode start="(1254, 1)" end="(1324, 52)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1254, 1)" end="(1323, 3)">
        <CommandDoccommentNode start="(1254, 1)" end="(1323, 3)" comment="`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`&#10;and then reducing that instance to evaluate the truth value of `p`.&#10;If it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.&#10;&#10;The target is not allowed to contain local variables or metavariables.&#10;If there are local variables, you can first try using the `revert` tactic with these local variables to move them into the target,&#10;or you can use the `+revert` option, described below.&#10;&#10;Options:&#10;- `decide +revert` begins by reverting local variables that the target depends on,&#10;  after cleaning up the local context of irrelevant variables.&#10;  A variable is *relevant* if it appears in the target, if it appears in a relevant variable,&#10;  or if it is a proposition that refers to a relevant variable.&#10;- `decide +kernel` uses kernel for reduction instead of the elaborator.&#10;  It has two key properties: (1) since it uses the kernel, it ignores transparency and can unfold everything,&#10;  and (2) it reduces the `Decidable` instance only once instead of twice.&#10;- `decide +native` uses the native code compiler (`#eval`) to evaluate the `Decidable` instance,&#10;  admitting the result via the `Lean.ofReduceBool` axiom.&#10;  This can be significantly more efficient than using reduction, but it is at the cost of increasing the size&#10;  of the trusted code base.&#10;  Namely, it depends on the correctness of the Lean compiler and all definitions with an `@[implemented_by]` attribute.&#10;  Like with `+kernel`, the `Decidable` instance is evaluated only once.&#10;&#10;Limitation: In the default mode or `+kernel` mode, since `decide` uses reduction to evaluate the term,&#10;`Decidable` instances defined by well-founded recursion might not work because evaluating them requires reducing proofs.&#10;Reduction can also get stuck on `Decidable` instances with `Eq.rec` terms.&#10;These can appear in instances defined using tactics (such as `rw` and `simp`).&#10;To avoid this, create such instances using definitions such as `decidable_of_iff` instead.&#10;&#10;## Examples&#10;&#10;Proving inequalities:&#10;```lean&#10;example : 2 + 2 ≠ 5 := by decide&#10;```&#10;&#10;Trying to prove a false proposition:&#10;```lean&#10;example : 1 ≠ 1 := by decide&#10;/-&#10;tactic 'decide' proved that the proposition&#10;  1 ≠ 1&#10;is false&#10;-/&#10;```&#10;&#10;Trying to prove a proposition whose `Decidable` instance fails to reduce&#10;```lean&#10;opaque unknownProp : Prop&#10;&#10;open scoped Classical in&#10;example : unknownProp := by decide&#10;/-&#10;tactic 'decide' failed for proposition&#10;  unknownProp&#10;since its 'Decidable' instance reduced to&#10;  Classical.choice ⋯&#10;rather than to the 'isTrue' constructor.&#10;-/&#10;```&#10;&#10;## Properties and relations&#10;&#10;For equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.&#10;```lean&#10;example : 1 + 1 = 2 := by decide&#10;example : 1 + 1 = 2 := by rfl&#10;```&#10;-/">
          <AtomNode start="(1254, 1)" end="(1254, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1255, 1)" end="(1323, 3)" leading="" trailing="&#10;" val="`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`&#10;and then reducing that instance to evaluate the truth value of `p`.&#10;If it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.&#10;&#10;The target is not allowed to contain local variables or metavariables.&#10;If there are local variables, you can first try using the `revert` tactic with these local variables to move them into the target,&#10;or you can use the `+revert` option, described below.&#10;&#10;Options:&#10;- `decide +revert` begins by reverting local variables that the target depends on,&#10;  after cleaning up the local context of irrelevant variables.&#10;  A variable is *relevant* if it appears in the target, if it appears in a relevant variable,&#10;  or if it is a proposition that refers to a relevant variable.&#10;- `decide +kernel` uses kernel for reduction instead of the elaborator.&#10;  It has two key properties: (1) since it uses the kernel, it ignores transparency and can unfold everything,&#10;  and (2) it reduces the `Decidable` instance only once instead of twice.&#10;- `decide +native` uses the native code compiler (`#eval`) to evaluate the `Decidable` instance,&#10;  admitting the result via the `Lean.ofReduceBool` axiom.&#10;  This can be significantly more efficient than using reduction, but it is at the cost of increasing the size&#10;  of the trusted code base.&#10;  Namely, it depends on the correctness of the Lean compiler and all definitions with an `@[implemented_by]` attribute.&#10;  Like with `+kernel`, the `Decidable` instance is evaluated only once.&#10;&#10;Limitation: In the default mode or `+kernel` mode, since `decide` uses reduction to evaluate the term,&#10;`Decidable` instances defined by well-founded recursion might not work because evaluating them requires reducing proofs.&#10;Reduction can also get stuck on `Decidable` instances with `Eq.rec` terms.&#10;These can appear in instances defined using tactics (such as `rw` and `simp`).&#10;To avoid this, create such instances using definitions such as `decidable_of_iff` instead.&#10;&#10;## Examples&#10;&#10;Proving inequalities:&#10;```lean&#10;example : 2 + 2 ≠ 5 := by decide&#10;```&#10;&#10;Trying to prove a false proposition:&#10;```lean&#10;example : 1 ≠ 1 := by decide&#10;/-&#10;tactic 'decide' proved that the proposition&#10;  1 ≠ 1&#10;is false&#10;-/&#10;```&#10;&#10;Trying to prove a proposition whose `Decidable` instance fails to reduce&#10;```lean&#10;opaque unknownProp : Prop&#10;&#10;open scoped Classical in&#10;example : unknownProp := by decide&#10;/-&#10;tactic 'decide' failed for proposition&#10;  unknownProp&#10;since its 'Decidable' instance reduced to&#10;  Classical.choice ⋯&#10;rather than to the 'isTrue' constructor.&#10;-/&#10;```&#10;&#10;## Properties and relations&#10;&#10;For equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.&#10;```lean&#10;example : 1 + 1 = 2 := by decide&#10;example : 1 + 1 = 2 := by rfl&#10;```&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1324, 1)" end="(1324, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(1324, 8)" end="(1324, 24)">
        <OtherNode start="(1324, 8)" end="(1324, 24)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1324, 8)" end="(1324, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(1324, 9)" end="(1324, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1324, 14)" end="(1324, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1324, 17)" end="(1324, 23)" leading="" trailing="" raw_val="decide" val="decide"/>
          <AtomNode start="(1324, 23)" end="(1324, 24)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(1324, 25)" end="(1324, 43)">
        <OtherNode start="(1324, 25)" end="(1324, 33)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1324, 25)" end="(1324, 33)" kind="str">
            <AtomNode start="(1324, 25)" end="(1324, 33)" leading="" trailing=" " val="&amp;quot;decide&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1324, 34)" end="(1324, 43)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(1324, 34)" end="(1324, 43)" leading="" trailing=" " raw_val="optConfig" val="optConfig" full_name="Lean.Parser.Tactic.optConfig" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(458, 8)" def_end="(458, 17)"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1324, 44)" end="(1324, 45)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1324, 46)" end="(1324, 52)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(1326, 1)" end="(1341, 65)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1326, 1)" end="(1340, 3)">
        <CommandDoccommentNode start="(1326, 1)" end="(1340, 3)" comment="`native_decide` is a synonym for `decide +native`.&#10;It will attempt to prove a goal of type `p` by synthesizing an instance&#10;of `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this&#10;uses `#eval` to evaluate the decidability instance.&#10;&#10;This should be used with care because it adds the entire lean compiler to the trusted&#10;part, and the axiom `Lean.ofReduceBool` will show up in `#print axioms` for theorems using&#10;this method or anything that transitively depends on them. Nevertheless, because it is&#10;compiled, this can be significantly more efficient than using `decide`, and for very&#10;large computations this is one way to run external programs and trust the result.&#10;```lean&#10;example : (List.range 1000).length = 1000 := by native_decide&#10;```&#10;-/">
          <AtomNode start="(1326, 1)" end="(1326, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1327, 1)" end="(1340, 3)" leading="" trailing="&#10;" val="`native_decide` is a synonym for `decide +native`.&#10;It will attempt to prove a goal of type `p` by synthesizing an instance&#10;of `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this&#10;uses `#eval` to evaluate the decidability instance.&#10;&#10;This should be used with care because it adds the entire lean compiler to the trusted&#10;part, and the axiom `Lean.ofReduceBool` will show up in `#print axioms` for theorems using&#10;this method or anything that transitively depends on them. Nevertheless, because it is&#10;compiled, this can be significantly more efficient than using `decide`, and for very&#10;large computations this is one way to run external programs and trust the result.&#10;```lean&#10;example : (List.range 1000).length = 1000 := by native_decide&#10;```&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1341, 1)" end="(1341, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(1341, 8)" end="(1341, 30)">
        <OtherNode start="(1341, 8)" end="(1341, 30)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1341, 8)" end="(1341, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(1341, 9)" end="(1341, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1341, 14)" end="(1341, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1341, 17)" end="(1341, 29)" leading="" trailing="" raw_val="nativeDecide" val="nativeDecide"/>
          <AtomNode start="(1341, 29)" end="(1341, 30)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(1341, 31)" end="(1341, 56)">
        <OtherNode start="(1341, 31)" end="(1341, 46)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1341, 31)" end="(1341, 46)" kind="str">
            <AtomNode start="(1341, 31)" end="(1341, 46)" leading="" trailing=" " val="&amp;quot;native_decide&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1341, 47)" end="(1341, 56)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(1341, 47)" end="(1341, 56)" leading="" trailing=" " raw_val="optConfig" val="optConfig" full_name="Lean.Parser.Tactic.optConfig" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(458, 8)" def_end="(458, 17)"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1341, 57)" end="(1341, 58)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1341, 59)" end="(1341, 65)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(1343, 1)" end="(1343, 58)" kind="Lean.Parser.Command.macro_rules">
      <NullNode/>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1343, 1)" end="(1343, 12)" leading="" trailing=" " val="macro_rules"/>
      <NullNode/>
      <OtherNode start="(1343, 13)" end="(1343, 58)" kind="Lean.Parser.Term.matchAlts">
        <NullNode start="(1343, 13)" end="(1343, 58)">
          <OtherNode start="(1343, 13)" end="(1343, 58)" kind="Lean.Parser.Term.matchAlt">
            <AtomNode start="(1343, 13)" end="(1343, 14)" leading="" trailing=" " val="|"/>
            <NullNode start="(1343, 15)" end="(1343, 33)">
              <NullNode start="(1343, 15)" end="(1343, 33)">
                <OtherNode start="(1343, 15)" end="(1343, 33)" kind="Lean.Parser.Tactic.quot">
                  <AtomNode start="(1343, 15)" end="(1343, 24)" leading="" trailing=" " val="`(tactic|"/>
                  <OtherNode start="(1343, 25)" end="(1343, 32)" kind="Lean.Parser.Tactic.tacticTrivial">
                    <AtomNode start="(1343, 25)" end="(1343, 32)" leading="" trailing="" val="trivial"/>
                  </OtherNode>
                  <AtomNode start="(1343, 32)" end="(1343, 33)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </NullNode>
            </NullNode>
            <AtomNode start="(1343, 34)" end="(1343, 36)" leading="" trailing=" " val="=&amp;gt;"/>
            <OtherNode start="(1343, 37)" end="(1343, 58)" kind="Lean.Parser.Tactic.quot">
              <AtomNode start="(1343, 37)" end="(1343, 46)" leading="" trailing=" " val="`(tactic|"/>
              <OtherNode start="(1343, 47)" end="(1343, 57)" kind="Lean.Parser.Tactic.assumption">
                <AtomNode start="(1343, 47)" end="(1343, 57)" leading="" trailing="" val="assumption"/>
              </OtherNode>
              <AtomNode start="(1343, 57)" end="(1343, 58)" leading="" trailing="&#10;" val=")"/>
            </OtherNode>
          </OtherNode>
        </NullNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(1344, 1)" end="(1344, 51)" kind="Lean.Parser.Command.macro_rules">
      <NullNode/>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1344, 1)" end="(1344, 12)" leading="" trailing=" " val="macro_rules"/>
      <NullNode/>
      <OtherNode start="(1344, 13)" end="(1344, 51)" kind="Lean.Parser.Term.matchAlts">
        <NullNode start="(1344, 13)" end="(1344, 51)">
          <OtherNode start="(1344, 13)" end="(1344, 51)" kind="Lean.Parser.Term.matchAlt">
            <AtomNode start="(1344, 13)" end="(1344, 14)" leading="" trailing=" " val="|"/>
            <NullNode start="(1344, 15)" end="(1344, 33)">
              <NullNode start="(1344, 15)" end="(1344, 33)">
                <OtherNode start="(1344, 15)" end="(1344, 33)" kind="Lean.Parser.Tactic.quot">
                  <AtomNode start="(1344, 15)" end="(1344, 24)" leading="" trailing=" " val="`(tactic|"/>
                  <OtherNode start="(1344, 25)" end="(1344, 32)" kind="Lean.Parser.Tactic.tacticTrivial">
                    <AtomNode start="(1344, 25)" end="(1344, 32)" leading="" trailing="" val="trivial"/>
                  </OtherNode>
                  <AtomNode start="(1344, 32)" end="(1344, 33)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </NullNode>
            </NullNode>
            <AtomNode start="(1344, 34)" end="(1344, 36)" leading="" trailing=" " val="=&amp;gt;"/>
            <OtherNode start="(1344, 37)" end="(1344, 51)" kind="Lean.Parser.Tactic.quot">
              <AtomNode start="(1344, 37)" end="(1344, 46)" leading="" trailing=" " val="`(tactic|"/>
              <OtherNode start="(1344, 47)" end="(1344, 50)" kind="Lean.Parser.Tactic.tacticRfl">
                <AtomNode start="(1344, 47)" end="(1344, 50)" leading="" trailing="" val="rfl"/>
              </OtherNode>
              <AtomNode start="(1344, 50)" end="(1344, 51)" leading="" trailing="&#10;" val=")"/>
            </OtherNode>
          </OtherNode>
        </NullNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(1345, 1)" end="(1345, 61)" kind="Lean.Parser.Command.macro_rules">
      <NullNode/>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1345, 1)" end="(1345, 12)" leading="" trailing=" " val="macro_rules"/>
      <NullNode/>
      <OtherNode start="(1345, 13)" end="(1345, 61)" kind="Lean.Parser.Term.matchAlts">
        <NullNode start="(1345, 13)" end="(1345, 61)">
          <OtherNode start="(1345, 13)" end="(1345, 61)" kind="Lean.Parser.Term.matchAlt">
            <AtomNode start="(1345, 13)" end="(1345, 14)" leading="" trailing=" " val="|"/>
            <NullNode start="(1345, 15)" end="(1345, 33)">
              <NullNode start="(1345, 15)" end="(1345, 33)">
                <OtherNode start="(1345, 15)" end="(1345, 33)" kind="Lean.Parser.Tactic.quot">
                  <AtomNode start="(1345, 15)" end="(1345, 24)" leading="" trailing=" " val="`(tactic|"/>
                  <OtherNode start="(1345, 25)" end="(1345, 32)" kind="Lean.Parser.Tactic.tacticTrivial">
                    <AtomNode start="(1345, 25)" end="(1345, 32)" leading="" trailing="" val="trivial"/>
                  </OtherNode>
                  <AtomNode start="(1345, 32)" end="(1345, 33)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </NullNode>
            </NullNode>
            <AtomNode start="(1345, 34)" end="(1345, 36)" leading="" trailing=" " val="=&amp;gt;"/>
            <OtherNode start="(1345, 37)" end="(1345, 61)" kind="Lean.Parser.Tactic.quot">
              <AtomNode start="(1345, 37)" end="(1345, 46)" leading="" trailing=" " val="`(tactic|"/>
              <OtherNode start="(1345, 47)" end="(1345, 60)" kind="Lean.Parser.Tactic.contradiction">
                <AtomNode start="(1345, 47)" end="(1345, 60)" leading="" trailing="" val="contradiction"/>
              </OtherNode>
              <AtomNode start="(1345, 60)" end="(1345, 61)" leading="" trailing="&#10;" val=")"/>
            </OtherNode>
          </OtherNode>
        </NullNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(1346, 1)" end="(1346, 54)" kind="Lean.Parser.Command.macro_rules">
      <NullNode/>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1346, 1)" end="(1346, 12)" leading="" trailing=" " val="macro_rules"/>
      <NullNode/>
      <OtherNode start="(1346, 13)" end="(1346, 54)" kind="Lean.Parser.Term.matchAlts">
        <NullNode start="(1346, 13)" end="(1346, 54)">
          <OtherNode start="(1346, 13)" end="(1346, 54)" kind="Lean.Parser.Term.matchAlt">
            <AtomNode start="(1346, 13)" end="(1346, 14)" leading="" trailing=" " val="|"/>
            <NullNode start="(1346, 15)" end="(1346, 33)">
              <NullNode start="(1346, 15)" end="(1346, 33)">
                <OtherNode start="(1346, 15)" end="(1346, 33)" kind="Lean.Parser.Tactic.quot">
                  <AtomNode start="(1346, 15)" end="(1346, 24)" leading="" trailing=" " val="`(tactic|"/>
                  <OtherNode start="(1346, 25)" end="(1346, 32)" kind="Lean.Parser.Tactic.tacticTrivial">
                    <AtomNode start="(1346, 25)" end="(1346, 32)" leading="" trailing="" val="trivial"/>
                  </OtherNode>
                  <AtomNode start="(1346, 32)" end="(1346, 33)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </NullNode>
            </NullNode>
            <AtomNode start="(1346, 34)" end="(1346, 36)" leading="" trailing=" " val="=&amp;gt;"/>
            <OtherNode start="(1346, 37)" end="(1346, 54)" kind="Lean.Parser.Tactic.quot">
              <AtomNode start="(1346, 37)" end="(1346, 46)" leading="" trailing=" " val="`(tactic|"/>
              <OtherNode start="(1346, 47)" end="(1346, 53)" kind="Lean.Parser.Tactic.decide">
                <AtomNode start="(1346, 47)" end="(1346, 53)" leading="" trailing="" val="decide"/>
                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                  <NullNode/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(1346, 53)" end="(1346, 54)" leading="" trailing="&#10;" val=")"/>
            </OtherNode>
          </OtherNode>
        </NullNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(1347, 1)" end="(1347, 64)" kind="Lean.Parser.Command.macro_rules">
      <NullNode/>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1347, 1)" end="(1347, 12)" leading="" trailing=" " val="macro_rules"/>
      <NullNode/>
      <OtherNode start="(1347, 13)" end="(1347, 64)" kind="Lean.Parser.Term.matchAlts">
        <NullNode start="(1347, 13)" end="(1347, 64)">
          <OtherNode start="(1347, 13)" end="(1347, 64)" kind="Lean.Parser.Term.matchAlt">
            <AtomNode start="(1347, 13)" end="(1347, 14)" leading="" trailing=" " val="|"/>
            <NullNode start="(1347, 15)" end="(1347, 33)">
              <NullNode start="(1347, 15)" end="(1347, 33)">
                <OtherNode start="(1347, 15)" end="(1347, 33)" kind="Lean.Parser.Tactic.quot">
                  <AtomNode start="(1347, 15)" end="(1347, 24)" leading="" trailing=" " val="`(tactic|"/>
                  <OtherNode start="(1347, 25)" end="(1347, 32)" kind="Lean.Parser.Tactic.tacticTrivial">
                    <AtomNode start="(1347, 25)" end="(1347, 32)" leading="" trailing="" val="trivial"/>
                  </OtherNode>
                  <AtomNode start="(1347, 32)" end="(1347, 33)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </NullNode>
            </NullNode>
            <AtomNode start="(1347, 34)" end="(1347, 36)" leading="" trailing=" " val="=&amp;gt;"/>
            <OtherNode start="(1347, 37)" end="(1347, 64)" kind="Lean.Parser.Tactic.quot">
              <AtomNode start="(1347, 37)" end="(1347, 46)" leading="" trailing=" " val="`(tactic|"/>
              <OtherNode start="(1347, 47)" end="(1347, 63)" kind="Lean.Parser.Tactic.apply">
                <AtomNode start="(1347, 47)" end="(1347, 52)" leading="" trailing=" " val="apply"/>
                <IdentNode start="(1347, 53)" end="(1347, 63)" leading="" trailing="" raw_val="True.intro" val="True.intro"/>
              </OtherNode>
              <AtomNode start="(1347, 63)" end="(1347, 64)" leading="" trailing="&#10;" val=")"/>
            </OtherNode>
          </OtherNode>
        </NullNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(1348, 1)" end="(1348, 75)" kind="Lean.Parser.Command.macro_rules">
      <NullNode/>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1348, 1)" end="(1348, 12)" leading="" trailing=" " val="macro_rules"/>
      <NullNode/>
      <OtherNode start="(1348, 13)" end="(1348, 75)" kind="Lean.Parser.Term.matchAlts">
        <NullNode start="(1348, 13)" end="(1348, 75)">
          <OtherNode start="(1348, 13)" end="(1348, 75)" kind="Lean.Parser.Term.matchAlt">
            <AtomNode start="(1348, 13)" end="(1348, 14)" leading="" trailing=" " val="|"/>
            <NullNode start="(1348, 15)" end="(1348, 33)">
              <NullNode start="(1348, 15)" end="(1348, 33)">
                <OtherNode start="(1348, 15)" end="(1348, 33)" kind="Lean.Parser.Tactic.quot">
                  <AtomNode start="(1348, 15)" end="(1348, 24)" leading="" trailing=" " val="`(tactic|"/>
                  <OtherNode start="(1348, 25)" end="(1348, 32)" kind="Lean.Parser.Tactic.tacticTrivial">
                    <AtomNode start="(1348, 25)" end="(1348, 32)" leading="" trailing="" val="trivial"/>
                  </OtherNode>
                  <AtomNode start="(1348, 32)" end="(1348, 33)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </NullNode>
            </NullNode>
            <AtomNode start="(1348, 34)" end="(1348, 36)" leading="" trailing=" " val="=&amp;gt;"/>
            <OtherNode start="(1348, 37)" end="(1348, 75)" kind="Lean.Parser.Tactic.quot">
              <AtomNode start="(1348, 37)" end="(1348, 46)" leading="" trailing=" " val="`(tactic|"/>
              <OtherNode start="(1348, 47)" end="(1348, 74)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»">
                <OtherNode start="(1348, 47)" end="(1348, 62)" kind="Lean.Parser.Tactic.apply">
                  <AtomNode start="(1348, 47)" end="(1348, 52)" leading="" trailing=" " val="apply"/>
                  <IdentNode start="(1348, 53)" end="(1348, 62)" leading="" trailing=" " raw_val="And.intro" val="And.intro"/>
                </OtherNode>
                <AtomNode start="(1348, 63)" end="(1348, 66)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
                <OtherNode start="(1348, 67)" end="(1348, 74)" kind="Lean.Parser.Tactic.tacticTrivial">
                  <AtomNode start="(1348, 67)" end="(1348, 74)" leading="" trailing="" val="trivial"/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(1348, 74)" end="(1348, 75)" leading="" trailing="&#10;&#10;" val=")"/>
            </OtherNode>
          </OtherNode>
        </NullNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(1350, 1)" end="(1380, 50)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1350, 1)" end="(1379, 3)">
        <CommandDoccommentNode start="(1350, 1)" end="(1379, 3)" comment="The `omega` tactic, for resolving integer and natural linear arithmetic problems.&#10;&#10;It is not yet a full decision procedure (no &amp;quot;dark&amp;quot; or &amp;quot;grey&amp;quot; shadows),&#10;but should be effective on many problems.&#10;&#10;We handle hypotheses of the form `x = y`, `x &amp;lt; y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`&#10;(and `k` a literal), along with negations of these statements.&#10;&#10;We decompose the sides of the inequalities as linear combinations of atoms.&#10;&#10;If we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables&#10;and the relevant inequalities.&#10;&#10;On the first pass, we do not perform case splits on natural subtraction.&#10;If `omega` fails, we recursively perform a case split on&#10;a natural subtraction appearing in a hypothesis, and try again.&#10;&#10;The options&#10;```&#10;omega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax&#10;```&#10;can be used to:&#10;* `splitDisjunctions`: split any disjunctions found in the context,&#10;  if the problem is not otherwise solvable.&#10;* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.&#10;* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.&#10;* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`&#10;Currently, all of these are on by default.&#10;-/">
          <AtomNode start="(1350, 1)" end="(1350, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1351, 1)" end="(1379, 3)" leading="" trailing="&#10;" val="The `omega` tactic, for resolving integer and natural linear arithmetic problems.&#10;&#10;It is not yet a full decision procedure (no &amp;quot;dark&amp;quot; or &amp;quot;grey&amp;quot; shadows),&#10;but should be effective on many problems.&#10;&#10;We handle hypotheses of the form `x = y`, `x &amp;lt; y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`&#10;(and `k` a literal), along with negations of these statements.&#10;&#10;We decompose the sides of the inequalities as linear combinations of atoms.&#10;&#10;If we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables&#10;and the relevant inequalities.&#10;&#10;On the first pass, we do not perform case splits on natural subtraction.&#10;If `omega` fails, we recursively perform a case split on&#10;a natural subtraction appearing in a hypothesis, and try again.&#10;&#10;The options&#10;```&#10;omega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax&#10;```&#10;can be used to:&#10;* `splitDisjunctions`: split any disjunctions found in the context,&#10;  if the problem is not otherwise solvable.&#10;* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.&#10;* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.&#10;* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`&#10;Currently, all of these are on by default.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1380, 1)" end="(1380, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(1380, 8)" end="(1380, 23)">
        <OtherNode start="(1380, 8)" end="(1380, 23)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1380, 8)" end="(1380, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(1380, 9)" end="(1380, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1380, 14)" end="(1380, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1380, 17)" end="(1380, 22)" leading="" trailing="" raw_val="omega" val="omega"/>
          <AtomNode start="(1380, 22)" end="(1380, 23)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(1380, 24)" end="(1380, 41)">
        <OtherNode start="(1380, 24)" end="(1380, 31)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1380, 24)" end="(1380, 31)" kind="str">
            <AtomNode start="(1380, 24)" end="(1380, 31)" leading="" trailing=" " val="&amp;quot;omega&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1380, 32)" end="(1380, 41)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(1380, 32)" end="(1380, 41)" leading="" trailing=" " raw_val="optConfig" val="optConfig" full_name="Lean.Parser.Tactic.optConfig" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(458, 8)" def_end="(458, 17)"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1380, 42)" end="(1380, 43)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1380, 44)" end="(1380, 50)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(1382, 1)" end="(1387, 108)" kind="Lean.Parser.Command.macro">
      <NullNode start="(1382, 1)" end="(1386, 3)">
        <CommandDoccommentNode start="(1382, 1)" end="(1386, 3)" comment="`bv_omega` is `omega` with an additional preprocessor that turns statements about `BitVec` into statements about `Nat`.&#10;Currently the preprocessor is implemented as `try simp only [bitvec_to_nat] at *`.&#10;`bitvec_to_nat` is a `@[simp]` attribute that you can (cautiously) add to more theorems.&#10;-/">
          <AtomNode start="(1382, 1)" end="(1382, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1383, 1)" end="(1386, 3)" leading="" trailing="&#10;" val="`bv_omega` is `omega` with an additional preprocessor that turns statements about `BitVec` into statements about `Nat`.&#10;Currently the preprocessor is implemented as `try simp only [bitvec_to_nat] at *`.&#10;`bitvec_to_nat` is a `@[simp]` attribute that you can (cautiously) add to more theorems.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1387, 1)" end="(1387, 6)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(1387, 7)" end="(1387, 17)">
        <OtherNode start="(1387, 7)" end="(1387, 17)" kind="Lean.Parser.Command.macroArg">
          <NullNode/>
          <OtherNode start="(1387, 7)" end="(1387, 17)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(1387, 7)" end="(1387, 17)" kind="str">
              <AtomNode start="(1387, 7)" end="(1387, 17)" leading="" trailing=" " val="&amp;quot;bv_omega&amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(1387, 18)" end="(1387, 108)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(1387, 18)" end="(1387, 19)" leading="" trailing=" " val=":"/>
        <IdentNode start="(1387, 20)" end="(1387, 26)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(1387, 27)" end="(1387, 29)" leading="" trailing=" " val="=&amp;gt;"/>
        <OtherNode start="(1387, 30)" end="(1387, 108)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(1387, 30)" end="(1387, 108)" kind="Lean.Parser.Tactic.quot">
            <AtomNode start="(1387, 30)" end="(1387, 39)" leading="" trailing=" " val="`(tactic|"/>
            <OtherNode start="(1387, 40)" end="(1387, 107)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»">
              <OtherNode start="(1387, 40)" end="(1387, 97)" kind="Lean.Parser.Tactic.paren">
                <AtomNode start="(1387, 40)" end="(1387, 41)" leading="" trailing="" val="("/>
                <TacticTacticseqNode start="(1387, 41)" end="(1387, 96)">
                  <TacticTacticseq1IndentedNode start="(1387, 41)" end="(1387, 96)">
                    <NullNode start="(1387, 41)" end="(1387, 96)">
                      <OtherNode start="(1387, 41)" end="(1387, 96)" kind="Lean.Parser.Tactic.tacticTry_">
                        <AtomNode start="(1387, 41)" end="(1387, 44)" leading="" trailing=" " val="try"/>
                        <TacticTacticseqNode start="(1387, 45)" end="(1387, 96)">
                          <TacticTacticseq1IndentedNode start="(1387, 45)" end="(1387, 96)">
                            <NullNode start="(1387, 45)" end="(1387, 96)">
                              <OtherNode start="(1387, 45)" end="(1387, 96)" kind="Lean.Parser.Tactic.simp">
                                <AtomNode start="(1387, 45)" end="(1387, 49)" leading="" trailing=" " val="simp"/>
                                <OtherNode start="(1387, 50)" end="(1387, 70)" kind="Lean.Parser.Tactic.optConfig">
                                  <NullNode start="(1387, 50)" end="(1387, 70)">
                                    <OtherNode start="(1387, 50)" end="(1387, 70)" kind="Lean.Parser.Tactic.configItem">
                                      <OtherNode start="(1387, 50)" end="(1387, 70)" kind="Lean.Parser.Tactic.negConfigItem">
                                        <AtomNode start="(1387, 50)" end="(1387, 51)" leading="" trailing="" val="-"/>
                                        <IdentNode start="(1387, 51)" end="(1387, 70)" leading="" trailing=" " raw_val="implicitDefEqProofs" val="implicitDefEqProofs"/>
                                      </OtherNode>
                                    </OtherNode>
                                  </NullNode>
                                </OtherNode>
                                <NullNode/>
                                <NullNode start="(1387, 71)" end="(1387, 75)">
                                  <AtomNode start="(1387, 71)" end="(1387, 75)" leading="" trailing=" " val="only"/>
                                </NullNode>
                                <NullNode start="(1387, 76)" end="(1387, 91)">
                                  <AtomNode start="(1387, 76)" end="(1387, 77)" leading="" trailing="" val="["/>
                                  <NullNode start="(1387, 77)" end="(1387, 90)">
                                    <OtherNode start="(1387, 77)" end="(1387, 90)" kind="Lean.Parser.Tactic.simpLemma">
                                      <NullNode/>
                                      <NullNode/>
                                      <IdentNode start="(1387, 77)" end="(1387, 90)" leading="" trailing="" raw_val="bitvec_to_nat" val="bitvec_to_nat"/>
                                    </OtherNode>
                                  </NullNode>
                                  <AtomNode start="(1387, 90)" end="(1387, 91)" leading="" trailing=" " val="]"/>
                                </NullNode>
                                <NullNode start="(1387, 92)" end="(1387, 96)">
                                  <OtherNode start="(1387, 92)" end="(1387, 96)" kind="Lean.Parser.Tactic.location">
                                    <AtomNode start="(1387, 92)" end="(1387, 94)" leading="" trailing=" " val="at"/>
                                    <OtherNode start="(1387, 95)" end="(1387, 96)" kind="Lean.Parser.Tactic.locationWildcard">
                                      <AtomNode start="(1387, 95)" end="(1387, 96)" leading="" trailing="" val="*"/>
                                    </OtherNode>
                                  </OtherNode>
                                </NullNode>
                              </OtherNode>
                            </NullNode>
                          </TacticTacticseq1IndentedNode>
                        </TacticTacticseqNode>
                      </OtherNode>
                    </NullNode>
                  </TacticTacticseq1IndentedNode>
                </TacticTacticseqNode>
                <AtomNode start="(1387, 96)" end="(1387, 97)" leading="" trailing=" " val=")"/>
              </OtherNode>
              <AtomNode start="(1387, 98)" end="(1387, 101)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
              <OtherNode start="(1387, 102)" end="(1387, 107)" kind="Lean.Parser.Tactic.omega">
                <AtomNode start="(1387, 102)" end="(1387, 107)" leading="" trailing="" val="omega"/>
                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </OtherNode>
            <AtomNode start="(1387, 107)" end="(1387, 108)" leading="" trailing="&#10;&#10;" val=")"/>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(1389, 1)" end="(1390, 53)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1389, 1)" end="(1389, 80)">
        <CommandDoccommentNode start="(1389, 1)" end="(1389, 80)" comment="Implementation of `ac_nf` (the full `ac_nf` calls `trivial` afterwards). -/">
          <AtomNode start="(1389, 1)" end="(1389, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(1389, 5)" end="(1389, 80)" leading="" trailing="&#10;" val="Implementation of `ac_nf` (the full `ac_nf` calls `trivial` afterwards). -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1390, 1)" end="(1390, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(1390, 8)" end="(1390, 23)">
        <OtherNode start="(1390, 8)" end="(1390, 23)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1390, 8)" end="(1390, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(1390, 9)" end="(1390, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1390, 14)" end="(1390, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1390, 17)" end="(1390, 22)" leading="" trailing="" raw_val="acNf0" val="acNf0"/>
          <AtomNode start="(1390, 22)" end="(1390, 23)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(1390, 24)" end="(1390, 44)">
        <OtherNode start="(1390, 24)" end="(1390, 32)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1390, 24)" end="(1390, 32)" kind="str">
            <AtomNode start="(1390, 24)" end="(1390, 32)" leading="" trailing=" " val="&amp;quot;ac_nf0&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1390, 33)" end="(1390, 44)" kind="stx_?">
          <OtherNode start="(1390, 33)" end="(1390, 43)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(1390, 33)" end="(1390, 34)" leading="" trailing="" val="("/>
            <NullNode start="(1390, 34)" end="(1390, 42)">
              <OtherNode start="(1390, 34)" end="(1390, 42)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(1390, 34)" end="(1390, 42)" leading="" trailing="" raw_val="location" val="location" full_name="Lean.Parser.Tactic.location" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(484, 8)" def_end="(484, 16)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1390, 42)" end="(1390, 43)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(1390, 43)" end="(1390, 44)" leading="" trailing=" " val="?"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1390, 45)" end="(1390, 46)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1390, 47)" end="(1390, 53)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(1392, 1)" end="(1393, 71)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1392, 1)" end="(1392, 88)">
        <CommandDoccommentNode start="(1392, 1)" end="(1392, 88)" comment="Implementation of `norm_cast` (the full `norm_cast` calls `trivial` afterwards). -/">
          <AtomNode start="(1392, 1)" end="(1392, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(1392, 5)" end="(1392, 88)" leading="" trailing="&#10;" val="Implementation of `norm_cast` (the full `norm_cast` calls `trivial` afterwards). -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1393, 1)" end="(1393, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(1393, 8)" end="(1393, 27)">
        <OtherNode start="(1393, 8)" end="(1393, 27)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1393, 8)" end="(1393, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(1393, 9)" end="(1393, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1393, 14)" end="(1393, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1393, 17)" end="(1393, 26)" leading="" trailing="" raw_val="normCast0" val="normCast0"/>
          <AtomNode start="(1393, 26)" end="(1393, 27)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(1393, 28)" end="(1393, 62)">
        <OtherNode start="(1393, 28)" end="(1393, 40)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1393, 28)" end="(1393, 40)" kind="str">
            <AtomNode start="(1393, 28)" end="(1393, 40)" leading="" trailing=" " val="&amp;quot;norm_cast0&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1393, 41)" end="(1393, 50)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(1393, 41)" end="(1393, 50)" leading="" trailing=" " raw_val="optConfig" val="optConfig" full_name="Lean.Parser.Tactic.optConfig" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(458, 8)" def_end="(458, 17)"/>
          <NullNode/>
        </OtherNode>
        <OtherNode start="(1393, 51)" end="(1393, 62)" kind="stx_?">
          <OtherNode start="(1393, 51)" end="(1393, 61)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(1393, 51)" end="(1393, 52)" leading="" trailing="" val="("/>
            <NullNode start="(1393, 52)" end="(1393, 60)">
              <OtherNode start="(1393, 52)" end="(1393, 60)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(1393, 52)" end="(1393, 60)" leading="" trailing="" raw_val="location" val="location" full_name="Lean.Parser.Tactic.location" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(484, 8)" def_end="(484, 16)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1393, 60)" end="(1393, 61)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(1393, 61)" end="(1393, 62)" leading="" trailing=" " val="?"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1393, 63)" end="(1393, 64)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1393, 65)" end="(1393, 71)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(1395, 1)" end="(1402, 101)" kind="Lean.Parser.Command.macro">
      <NullNode start="(1395, 1)" end="(1401, 76)">
        <CommandDoccommentNode start="(1395, 1)" end="(1401, 76)" comment="`assumption_mod_cast` is a variant of `assumption` that solves the goal&#10;using a hypothesis. Unlike `assumption`, it first pre-processes the goal and&#10;each hypothesis to move casts as far outwards as possible, so it can be used&#10;in more situations.&#10;&#10;Concretely, it runs `norm_cast` on the goal. For each local hypothesis `h`, it also&#10;normalizes `h` with `norm_cast` and tries to use that to close the goal. -/">
          <AtomNode start="(1395, 1)" end="(1395, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(1395, 5)" end="(1401, 76)" leading="" trailing="&#10;" val="`assumption_mod_cast` is a variant of `assumption` that solves the goal&#10;using a hypothesis. Unlike `assumption`, it first pre-processes the goal and&#10;each hypothesis to move casts as far outwards as possible, so it can be used&#10;in more situations.&#10;&#10;Concretely, it runs `norm_cast` on the goal. For each local hypothesis `h`, it also&#10;normalizes `h` with `norm_cast` and tries to use that to close the goal. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1402, 1)" end="(1402, 6)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(1402, 7)" end="(1402, 42)">
        <OtherNode start="(1402, 7)" end="(1402, 28)" kind="Lean.Parser.Command.macroArg">
          <NullNode/>
          <OtherNode start="(1402, 7)" end="(1402, 28)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(1402, 7)" end="(1402, 28)" kind="str">
              <AtomNode start="(1402, 7)" end="(1402, 28)" leading="" trailing=" " val="&amp;quot;assumption_mod_cast&amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1402, 29)" end="(1402, 42)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(1402, 29)" end="(1402, 33)">
            <IdentNode start="(1402, 29)" end="(1402, 32)" leading="" trailing="" raw_val="cfg" val="cfg"/>
            <AtomNode start="(1402, 32)" end="(1402, 33)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(1402, 33)" end="(1402, 42)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(1402, 33)" end="(1402, 42)" leading="" trailing=" " raw_val="optConfig" val="optConfig" full_name="Lean.Parser.Tactic.optConfig" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(458, 8)" def_end="(458, 17)"/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(1402, 43)" end="(1402, 101)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(1402, 43)" end="(1402, 44)" leading="" trailing=" " val=":"/>
        <IdentNode start="(1402, 45)" end="(1402, 51)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(1402, 52)" end="(1402, 54)" leading="" trailing=" " val="=&amp;gt;"/>
        <OtherNode start="(1402, 55)" end="(1402, 101)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(1402, 55)" end="(1402, 101)" kind="Lean.Parser.Tactic.quot">
            <AtomNode start="(1402, 55)" end="(1402, 64)" leading="" trailing=" " val="`(tactic|"/>
            <OtherNode start="(1402, 65)" end="(1402, 100)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»">
              <OtherNode start="(1402, 65)" end="(1402, 85)" kind="Lean.Parser.Tactic.normCast0">
                <AtomNode start="(1402, 65)" end="(1402, 75)" leading="" trailing=" " val="norm_cast0"/>
                <OtherNode start="(1402, 76)" end="(1402, 80)" kind="Lean.Parser.Tactic.optConfig.antiquot">
                  <AtomNode start="(1402, 76)" end="(1402, 77)" leading="" trailing="" val="$"/>
                  <NullNode/>
                  <IdentNode start="(1402, 77)" end="(1402, 80)" leading="" trailing=" " raw_val="cfg" val="cfg"/>
                  <NullNode/>
                </OtherNode>
                <NullNode start="(1402, 81)" end="(1402, 85)">
                  <OtherNode start="(1402, 81)" end="(1402, 85)" kind="Lean.Parser.Tactic.location">
                    <AtomNode start="(1402, 81)" end="(1402, 83)" leading="" trailing=" " val="at"/>
                    <OtherNode start="(1402, 84)" end="(1402, 85)" kind="Lean.Parser.Tactic.locationWildcard">
                      <AtomNode start="(1402, 84)" end="(1402, 85)" leading="" trailing=" " val="*"/>
                    </OtherNode>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1402, 86)" end="(1402, 89)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
              <OtherNode start="(1402, 90)" end="(1402, 100)" kind="Lean.Parser.Tactic.assumption">
                <AtomNode start="(1402, 90)" end="(1402, 100)" leading="" trailing="" val="assumption"/>
              </OtherNode>
            </OtherNode>
            <AtomNode start="(1402, 100)" end="(1402, 101)" leading="" trailing="&#10;&#10;" val=")"/>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(1404, 1)" end="(1440, 54)" kind="Lean.Parser.Command.macro">
      <NullNode start="(1404, 1)" end="(1438, 3)">
        <CommandDoccommentNode start="(1404, 1)" end="(1438, 3)" comment="The `norm_cast` family of tactics is used to normalize certain coercions (*casts*) in expressions.&#10;- `norm_cast` normalizes casts in the target.&#10;- `norm_cast at h` normalizes casts in hypothesis `h`.&#10;&#10;The tactic is basically a version of `simp` with a specific set of lemmas to move casts&#10;upwards in the expression.&#10;Therefore even in situations where non-terminal `simp` calls are discouraged (because of fragility),&#10;`norm_cast` is considered to be safe.&#10;It also has special handling of numerals.&#10;&#10;For instance, given an assumption&#10;```lean&#10;a b : ℤ&#10;h : ↑a + ↑b &amp;lt; (10 : ℚ)&#10;```&#10;writing `norm_cast at h` will turn `h` into&#10;```lean&#10;h : a + b &amp;lt; 10&#10;```&#10;&#10;There are also variants of basic tactics that use `norm_cast` to normalize expressions during&#10;their operation, to make them more flexible about the expressions they accept&#10;(we say that it is a tactic *modulo* the effects of `norm_cast`):&#10;- `exact_mod_cast` for `exact` and `apply_mod_cast` for `apply`.&#10;  Writing `exact_mod_cast h` and `apply_mod_cast h` will normalize casts&#10;  in the goal and `h` before using `exact h` or `apply h`.&#10;- `rw_mod_cast` for `rw`. It applies `norm_cast` between rewrites.&#10;- `assumption_mod_cast` for `assumption`.&#10;  This is effectively `norm_cast at *; assumption`, but more efficient.&#10;  It normalizes casts in the goal and, for every hypothesis `h` in the context,&#10;  it will try to normalize casts in `h` and use `exact h`.&#10;&#10;See also `push_cast`, which moves casts inwards rather than lifting them outwards.&#10;-/">
          <AtomNode start="(1404, 1)" end="(1404, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1405, 1)" end="(1438, 3)" leading="" trailing="&#10;" val="The `norm_cast` family of tactics is used to normalize certain coercions (*casts*) in expressions.&#10;- `norm_cast` normalizes casts in the target.&#10;- `norm_cast at h` normalizes casts in hypothesis `h`.&#10;&#10;The tactic is basically a version of `simp` with a specific set of lemmas to move casts&#10;upwards in the expression.&#10;Therefore even in situations where non-terminal `simp` calls are discouraged (because of fragility),&#10;`norm_cast` is considered to be safe.&#10;It also has special handling of numerals.&#10;&#10;For instance, given an assumption&#10;```lean&#10;a b : ℤ&#10;h : ↑a + ↑b &amp;lt; (10 : ℚ)&#10;```&#10;writing `norm_cast at h` will turn `h` into&#10;```lean&#10;h : a + b &amp;lt; 10&#10;```&#10;&#10;There are also variants of basic tactics that use `norm_cast` to normalize expressions during&#10;their operation, to make them more flexible about the expressions they accept&#10;(we say that it is a tactic *modulo* the effects of `norm_cast`):&#10;- `exact_mod_cast` for `exact` and `apply_mod_cast` for `apply`.&#10;  Writing `exact_mod_cast h` and `apply_mod_cast h` will normalize casts&#10;  in the goal and `h` before using `exact h` or `apply h`.&#10;- `rw_mod_cast` for `rw`. It applies `norm_cast` between rewrites.&#10;- `assumption_mod_cast` for `assumption`.&#10;  This is effectively `norm_cast at *; assumption`, but more efficient.&#10;  It normalizes casts in the goal and, for every hypothesis `h` in the context,&#10;  it will try to normalize casts in `h` and use `exact h`.&#10;&#10;See also `push_cast`, which moves casts inwards rather than lifting them outwards.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1439, 1)" end="(1439, 6)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(1439, 7)" end="(1439, 48)">
        <OtherNode start="(1439, 7)" end="(1439, 18)" kind="Lean.Parser.Command.macroArg">
          <NullNode/>
          <OtherNode start="(1439, 7)" end="(1439, 18)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(1439, 7)" end="(1439, 18)" kind="str">
              <AtomNode start="(1439, 7)" end="(1439, 18)" leading="" trailing=" " val="&amp;quot;norm_cast&amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1439, 19)" end="(1439, 32)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(1439, 19)" end="(1439, 23)">
            <IdentNode start="(1439, 19)" end="(1439, 22)" leading="" trailing="" raw_val="cfg" val="cfg"/>
            <AtomNode start="(1439, 22)" end="(1439, 23)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(1439, 23)" end="(1439, 32)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(1439, 23)" end="(1439, 32)" leading="" trailing=" " raw_val="optConfig" val="optConfig" full_name="Lean.Parser.Tactic.optConfig" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(458, 8)" def_end="(458, 17)"/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1439, 33)" end="(1439, 48)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(1439, 33)" end="(1439, 37)">
            <IdentNode start="(1439, 33)" end="(1439, 36)" leading="" trailing="" raw_val="loc" val="loc"/>
            <AtomNode start="(1439, 36)" end="(1439, 37)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(1439, 37)" end="(1439, 48)" kind="stx_?">
            <OtherNode start="(1439, 37)" end="(1439, 47)" kind="Lean.Parser.Syntax.paren">
              <AtomNode start="(1439, 37)" end="(1439, 38)" leading="" trailing="" val="("/>
              <NullNode start="(1439, 38)" end="(1439, 46)">
                <OtherNode start="(1439, 38)" end="(1439, 46)" kind="Lean.Parser.Syntax.cat">
                  <IdentNode start="(1439, 38)" end="(1439, 46)" leading="" trailing="" raw_val="location" val="location" full_name="Lean.Parser.Tactic.location" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(484, 8)" def_end="(484, 16)"/>
                  <NullNode/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1439, 46)" end="(1439, 47)" leading="" trailing="" val=")"/>
            </OtherNode>
            <AtomNode start="(1439, 47)" end="(1439, 48)" leading="" trailing=" " val="?"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(1439, 49)" end="(1440, 54)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(1439, 49)" end="(1439, 50)" leading="" trailing=" " val=":"/>
        <IdentNode start="(1439, 51)" end="(1439, 57)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(1439, 58)" end="(1439, 60)" leading="" trailing="&#10;  " val="=&amp;gt;"/>
        <OtherNode start="(1440, 3)" end="(1440, 54)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(1440, 3)" end="(1440, 54)" kind="Lean.Parser.Tactic.quot">
            <AtomNode start="(1440, 3)" end="(1440, 12)" leading="" trailing=" " val="`(tactic|"/>
            <OtherNode start="(1440, 13)" end="(1440, 53)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»">
              <OtherNode start="(1440, 13)" end="(1440, 37)" kind="Lean.Parser.Tactic.normCast0">
                <AtomNode start="(1440, 13)" end="(1440, 23)" leading="" trailing=" " val="norm_cast0"/>
                <OtherNode start="(1440, 24)" end="(1440, 28)" kind="Lean.Parser.Tactic.optConfig.antiquot">
                  <AtomNode start="(1440, 24)" end="(1440, 25)" leading="" trailing="" val="$"/>
                  <NullNode/>
                  <IdentNode start="(1440, 25)" end="(1440, 28)" leading="" trailing=" " raw_val="cfg" val="cfg"/>
                  <NullNode/>
                </OtherNode>
                <NullNode start="(1440, 29)" end="(1440, 37)">
                  <OtherNode start="(1440, 29)" end="(1440, 37)" kind="optional.antiquot_scope">
                    <AtomNode start="(1440, 29)" end="(1440, 30)" leading="" trailing="" val="$"/>
                    <NullNode/>
                    <AtomNode start="(1440, 30)" end="(1440, 31)" leading="" trailing="" val="["/>
                    <NullNode start="(1440, 31)" end="(1440, 35)">
                      <OtherNode start="(1440, 31)" end="(1440, 35)" kind="Lean.Parser.Tactic.location.antiquot">
                        <AtomNode start="(1440, 31)" end="(1440, 32)" leading="" trailing="" val="$"/>
                        <NullNode/>
                        <IdentNode start="(1440, 32)" end="(1440, 35)" leading="" trailing="" raw_val="loc" val="loc"/>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(1440, 35)" end="(1440, 36)" leading="" trailing="" val="]"/>
                    <AtomNode start="(1440, 36)" end="(1440, 37)" leading="" trailing=" " val="?"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1440, 38)" end="(1440, 41)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
              <OtherNode start="(1440, 42)" end="(1440, 53)" kind="Lean.Parser.Tactic.tacticTry_">
                <AtomNode start="(1440, 42)" end="(1440, 45)" leading="" trailing=" " val="try"/>
                <TacticTacticseqNode start="(1440, 46)" end="(1440, 53)">
                  <TacticTacticseq1IndentedNode start="(1440, 46)" end="(1440, 53)">
                    <NullNode start="(1440, 46)" end="(1440, 53)">
                      <OtherNode start="(1440, 46)" end="(1440, 53)" kind="Lean.Parser.Tactic.tacticTrivial">
                        <AtomNode start="(1440, 46)" end="(1440, 53)" leading="" trailing="" val="trivial"/>
                      </OtherNode>
                    </NullNode>
                  </TacticTacticseq1IndentedNode>
                </TacticTacticseqNode>
              </OtherNode>
            </OtherNode>
            <AtomNode start="(1440, 53)" end="(1440, 54)" leading="" trailing="&#10;&#10;&#10;" val=")"/>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(1443, 1)" end="(1477, 76)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1443, 1)" end="(1475, 3)">
        <CommandDoccommentNode start="(1443, 1)" end="(1475, 3)" comment="`push_cast` rewrites the goal to move certain coercions (*casts*) inward, toward the leaf nodes.&#10;This uses `norm_cast` lemmas in the forward direction.&#10;For example, `↑(a + b)` will be written to `↑a + ↑b`.&#10;- `push_cast` moves casts inward in the goal.&#10;- `push_cast at h` moves casts inward in the hypothesis `h`.&#10;It can be used with extra simp lemmas with, for example, `push_cast [Int.add_zero]`.&#10;&#10;Example:&#10;```lean&#10;example (a b : Nat)&#10;    (h1 : ((a + b : Nat) : Int) = 10)&#10;    (h2 : ((a + b + 0 : Nat) : Int) = 10) :&#10;    ((a + b : Nat) : Int) = 10 := by&#10;  /-&#10;  h1 : ↑(a + b) = 10&#10;  h2 : ↑(a + b + 0) = 10&#10;  ⊢ ↑(a + b) = 10&#10;  -/&#10;  push_cast&#10;  /- Now&#10;  ⊢ ↑a + ↑b = 10&#10;  -/&#10;  push_cast at h1&#10;  push_cast [Int.add_zero] at h2&#10;  /- Now&#10;  h1 h2 : ↑a + ↑b = 10&#10;  -/&#10;  exact h1&#10;```&#10;&#10;See also `norm_cast`.&#10;-/">
          <AtomNode start="(1443, 1)" end="(1443, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1444, 1)" end="(1475, 3)" leading="" trailing="&#10;" val="`push_cast` rewrites the goal to move certain coercions (*casts*) inward, toward the leaf nodes.&#10;This uses `norm_cast` lemmas in the forward direction.&#10;For example, `↑(a + b)` will be written to `↑a + ↑b`.&#10;- `push_cast` moves casts inward in the goal.&#10;- `push_cast at h` moves casts inward in the hypothesis `h`.&#10;It can be used with extra simp lemmas with, for example, `push_cast [Int.add_zero]`.&#10;&#10;Example:&#10;```lean&#10;example (a b : Nat)&#10;    (h1 : ((a + b : Nat) : Int) = 10)&#10;    (h2 : ((a + b + 0 : Nat) : Int) = 10) :&#10;    ((a + b : Nat) : Int) = 10 := by&#10;  /-&#10;  h1 : ↑(a + b) = 10&#10;  h2 : ↑(a + b + 0) = 10&#10;  ⊢ ↑(a + b) = 10&#10;  -/&#10;  push_cast&#10;  /- Now&#10;  ⊢ ↑a + ↑b = 10&#10;  -/&#10;  push_cast at h1&#10;  push_cast [Int.add_zero] at h2&#10;  /- Now&#10;  h1 h2 : ↑a + ↑b = 10&#10;  -/&#10;  exact h1&#10;```&#10;&#10;See also `norm_cast`.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1476, 1)" end="(1476, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(1476, 8)" end="(1476, 26)">
        <OtherNode start="(1476, 8)" end="(1476, 26)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1476, 8)" end="(1476, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(1476, 9)" end="(1476, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1476, 14)" end="(1476, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1476, 17)" end="(1476, 25)" leading="" trailing="" raw_val="pushCast" val="pushCast"/>
          <AtomNode start="(1476, 25)" end="(1476, 26)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(1476, 27)" end="(1477, 67)">
        <OtherNode start="(1476, 27)" end="(1476, 38)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1476, 27)" end="(1476, 38)" kind="str">
            <AtomNode start="(1476, 27)" end="(1476, 38)" leading="" trailing=" " val="&amp;quot;push_cast&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1476, 39)" end="(1476, 48)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(1476, 39)" end="(1476, 48)" leading="" trailing=" " raw_val="optConfig" val="optConfig" full_name="Lean.Parser.Tactic.optConfig" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(458, 8)" def_end="(458, 17)"/>
          <NullNode/>
        </OtherNode>
        <OtherNode start="(1476, 49)" end="(1476, 62)" kind="stx_?">
          <OtherNode start="(1476, 49)" end="(1476, 61)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(1476, 49)" end="(1476, 50)" leading="" trailing="" val="("/>
            <NullNode start="(1476, 50)" end="(1476, 60)">
              <OtherNode start="(1476, 50)" end="(1476, 60)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(1476, 50)" end="(1476, 60)" leading="" trailing="" raw_val="discharger" val="discharger" full_name="Lean.Parser.Tactic.discharger" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(602, 8)" def_end="(602, 18)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1476, 60)" end="(1476, 61)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(1476, 61)" end="(1476, 62)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(1476, 63)" end="(1476, 74)" kind="stx_?">
          <OtherNode start="(1476, 63)" end="(1476, 73)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(1476, 63)" end="(1476, 64)" leading="" trailing="" val="("/>
            <NullNode start="(1476, 64)" end="(1476, 72)">
              <OtherNode start="(1476, 64)" end="(1476, 72)" kind="Lean.Parser.Syntax.nonReserved">
                <AtomNode start="(1476, 64)" end="(1476, 65)" leading="" trailing="" val="&amp;amp;"/>
                <OtherNode start="(1476, 65)" end="(1476, 72)" kind="str">
                  <AtomNode start="(1476, 65)" end="(1476, 72)" leading="" trailing="" val="&amp;quot; only&amp;quot;"/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1476, 72)" end="(1476, 73)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(1476, 73)" end="(1476, 74)" leading="" trailing="&#10;  " val="?"/>
        </OtherNode>
        <OtherNode start="(1477, 3)" end="(1477, 55)" kind="stx_?">
          <OtherNode start="(1477, 3)" end="(1477, 54)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(1477, 3)" end="(1477, 4)" leading="" trailing="" val="("/>
            <NullNode start="(1477, 4)" end="(1477, 53)">
              <OtherNode start="(1477, 4)" end="(1477, 8)" kind="Lean.Parser.Syntax.atom">
                <OtherNode start="(1477, 4)" end="(1477, 8)" kind="str">
                  <AtomNode start="(1477, 4)" end="(1477, 8)" leading="" trailing=" " val="&amp;quot; [&amp;quot;"/>
                </OtherNode>
              </OtherNode>
              <OtherNode start="(1477, 9)" end="(1477, 49)" kind="«stx_,*»">
                <OtherNode start="(1477, 9)" end="(1477, 47)" kind="Lean.Parser.Syntax.paren">
                  <AtomNode start="(1477, 9)" end="(1477, 10)" leading="" trailing="" val="("/>
                  <NullNode start="(1477, 10)" end="(1477, 46)">
                    <OtherNode start="(1477, 10)" end="(1477, 46)" kind="«stx_&amp;lt;|&amp;gt;_»">
                      <OtherNode start="(1477, 10)" end="(1477, 18)" kind="Lean.Parser.Syntax.cat">
                        <IdentNode start="(1477, 10)" end="(1477, 18)" leading="" trailing=" " raw_val="simpStar" val="simpStar" full_name="Lean.Parser.Tactic.simpStar" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(618, 8)" def_end="(618, 16)"/>
                        <NullNode/>
                      </OtherNode>
                      <AtomNode start="(1477, 19)" end="(1477, 22)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
                      <OtherNode start="(1477, 23)" end="(1477, 46)" kind="«stx_&amp;lt;|&amp;gt;_»">
                        <OtherNode start="(1477, 23)" end="(1477, 32)" kind="Lean.Parser.Syntax.cat">
                          <IdentNode start="(1477, 23)" end="(1477, 32)" leading="" trailing=" " raw_val="simpErase" val="simpErase" full_name="Lean.Parser.Tactic.simpErase" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(616, 8)" def_end="(616, 17)"/>
                          <NullNode/>
                        </OtherNode>
                        <AtomNode start="(1477, 33)" end="(1477, 36)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
                        <OtherNode start="(1477, 37)" end="(1477, 46)" kind="Lean.Parser.Syntax.cat">
                          <IdentNode start="(1477, 37)" end="(1477, 46)" leading="" trailing="" raw_val="simpLemma" val="simpLemma" full_name="Lean.Parser.Tactic.simpLemma" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(614, 8)" def_end="(614, 17)"/>
                          <NullNode/>
                        </OtherNode>
                      </OtherNode>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(1477, 46)" end="(1477, 47)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(1477, 47)" end="(1477, 49)" leading="" trailing=" " val=",*"/>
              </OtherNode>
              <OtherNode start="(1477, 50)" end="(1477, 53)" kind="Lean.Parser.Syntax.atom">
                <OtherNode start="(1477, 50)" end="(1477, 53)" kind="str">
                  <AtomNode start="(1477, 50)" end="(1477, 53)" leading="" trailing="" val="&amp;quot;]&amp;quot;"/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1477, 53)" end="(1477, 54)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(1477, 54)" end="(1477, 55)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(1477, 56)" end="(1477, 67)" kind="stx_?">
          <OtherNode start="(1477, 56)" end="(1477, 66)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(1477, 56)" end="(1477, 57)" leading="" trailing="" val="("/>
            <NullNode start="(1477, 57)" end="(1477, 65)">
              <OtherNode start="(1477, 57)" end="(1477, 65)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(1477, 57)" end="(1477, 65)" leading="" trailing="" raw_val="location" val="location" full_name="Lean.Parser.Tactic.location" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(484, 8)" def_end="(484, 16)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1477, 65)" end="(1477, 66)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(1477, 66)" end="(1477, 67)" leading="" trailing=" " val="?"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1477, 68)" end="(1477, 69)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1477, 70)" end="(1477, 76)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(1479, 1)" end="(1482, 70)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1479, 1)" end="(1481, 3)">
        <CommandDoccommentNode start="(1479, 1)" end="(1481, 3)" comment="`norm_cast_add_elim foo` registers `foo` as an elim-lemma in `norm_cast`.&#10;-/">
          <AtomNode start="(1479, 1)" end="(1479, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1480, 1)" end="(1481, 3)" leading="" trailing="&#10;" val="`norm_cast_add_elim foo` registers `foo` as an elim-lemma in `norm_cast`.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1482, 1)" end="(1482, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(1482, 8)" end="(1482, 33)">
        <OtherNode start="(1482, 8)" end="(1482, 33)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1482, 8)" end="(1482, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(1482, 9)" end="(1482, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1482, 14)" end="(1482, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1482, 17)" end="(1482, 32)" leading="" trailing="" raw_val="normCastAddElim" val="normCastAddElim"/>
          <AtomNode start="(1482, 32)" end="(1482, 33)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(1482, 34)" end="(1482, 60)">
        <OtherNode start="(1482, 34)" end="(1482, 54)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1482, 34)" end="(1482, 54)" kind="str">
            <AtomNode start="(1482, 34)" end="(1482, 54)" leading="" trailing=" " val="&amp;quot;norm_cast_add_elim&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1482, 55)" end="(1482, 60)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(1482, 55)" end="(1482, 60)" leading="" trailing=" " raw_val="ident" val="ident" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1482, 61)" end="(1482, 62)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1482, 63)" end="(1482, 70)" leading="" trailing="&#10;&#10;" raw_val="command" val="command" full_name="Lean.Parser.Category.command" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(1484, 1)" end="(1500, 45)" kind="Lean.Parser.Command.macro">
      <NullNode start="(1484, 1)" end="(1498, 3)">
        <CommandDoccommentNode start="(1484, 1)" end="(1498, 3)" comment="`ac_nf` normalizes equalities up to application of an associative and commutative operator.&#10;- `ac_nf` normalizes all hypotheses and the goal target of the goal.&#10;- `ac_nf at l` normalizes at location(s) `l`, where `l` is either `*` or a&#10;  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`&#10;  can also be used, to signify the target of the goal.&#10;```&#10;instance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩&#10;instance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩&#10;&#10;example (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by&#10; ac_nf&#10; -- goal: a + (b + (c + d)) = a + (b + (c + d))&#10;```&#10;-/">
          <AtomNode start="(1484, 1)" end="(1484, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1485, 1)" end="(1498, 3)" leading="" trailing="&#10;" val="`ac_nf` normalizes equalities up to application of an associative and commutative operator.&#10;- `ac_nf` normalizes all hypotheses and the goal target of the goal.&#10;- `ac_nf at l` normalizes at location(s) `l`, where `l` is either `*` or a&#10;  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`&#10;  can also be used, to signify the target of the goal.&#10;```&#10;instance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩&#10;instance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩&#10;&#10;example (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by&#10; ac_nf&#10; -- goal: a + (b + (c + d)) = a + (b + (c + d))&#10;```&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1499, 1)" end="(1499, 6)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(1499, 7)" end="(1499, 30)">
        <OtherNode start="(1499, 7)" end="(1499, 14)" kind="Lean.Parser.Command.macroArg">
          <NullNode/>
          <OtherNode start="(1499, 7)" end="(1499, 14)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(1499, 7)" end="(1499, 14)" kind="str">
              <AtomNode start="(1499, 7)" end="(1499, 14)" leading="" trailing=" " val="&amp;quot;ac_nf&amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1499, 15)" end="(1499, 30)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(1499, 15)" end="(1499, 19)">
            <IdentNode start="(1499, 15)" end="(1499, 18)" leading="" trailing="" raw_val="loc" val="loc"/>
            <AtomNode start="(1499, 18)" end="(1499, 19)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(1499, 19)" end="(1499, 30)" kind="stx_?">
            <OtherNode start="(1499, 19)" end="(1499, 29)" kind="Lean.Parser.Syntax.paren">
              <AtomNode start="(1499, 19)" end="(1499, 20)" leading="" trailing="" val="("/>
              <NullNode start="(1499, 20)" end="(1499, 28)">
                <OtherNode start="(1499, 20)" end="(1499, 28)" kind="Lean.Parser.Syntax.cat">
                  <IdentNode start="(1499, 20)" end="(1499, 28)" leading="" trailing="" raw_val="location" val="location" full_name="Lean.Parser.Tactic.location" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(484, 8)" def_end="(484, 16)"/>
                  <NullNode/>
                </OtherNode>
              </NullNode>
              <AtomNode start="(1499, 28)" end="(1499, 29)" leading="" trailing="" val=")"/>
            </OtherNode>
            <AtomNode start="(1499, 29)" end="(1499, 30)" leading="" trailing=" " val="?"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(1499, 31)" end="(1500, 45)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(1499, 31)" end="(1499, 32)" leading="" trailing=" " val=":"/>
        <IdentNode start="(1499, 33)" end="(1499, 39)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(1499, 40)" end="(1499, 42)" leading="" trailing="&#10;  " val="=&amp;gt;"/>
        <OtherNode start="(1500, 3)" end="(1500, 45)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(1500, 3)" end="(1500, 45)" kind="Lean.Parser.Tactic.quot">
            <AtomNode start="(1500, 3)" end="(1500, 12)" leading="" trailing=" " val="`(tactic|"/>
            <OtherNode start="(1500, 13)" end="(1500, 44)" kind="Lean.Parser.Tactic.«tactic_&amp;lt;;&amp;gt;_»">
              <OtherNode start="(1500, 13)" end="(1500, 28)" kind="Lean.Parser.Tactic.acNf0">
                <AtomNode start="(1500, 13)" end="(1500, 19)" leading="" trailing=" " val="ac_nf0"/>
                <NullNode start="(1500, 20)" end="(1500, 28)">
                  <OtherNode start="(1500, 20)" end="(1500, 28)" kind="optional.antiquot_scope">
                    <AtomNode start="(1500, 20)" end="(1500, 21)" leading="" trailing="" val="$"/>
                    <NullNode/>
                    <AtomNode start="(1500, 21)" end="(1500, 22)" leading="" trailing="" val="["/>
                    <NullNode start="(1500, 22)" end="(1500, 26)">
                      <OtherNode start="(1500, 22)" end="(1500, 26)" kind="Lean.Parser.Tactic.location.antiquot">
                        <AtomNode start="(1500, 22)" end="(1500, 23)" leading="" trailing="" val="$"/>
                        <NullNode/>
                        <IdentNode start="(1500, 23)" end="(1500, 26)" leading="" trailing="" raw_val="loc" val="loc"/>
                        <NullNode/>
                      </OtherNode>
                    </NullNode>
                    <AtomNode start="(1500, 26)" end="(1500, 27)" leading="" trailing="" val="]"/>
                    <AtomNode start="(1500, 27)" end="(1500, 28)" leading="" trailing=" " val="?"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1500, 29)" end="(1500, 32)" leading="" trailing=" " val="&amp;lt;;&amp;gt;"/>
              <OtherNode start="(1500, 33)" end="(1500, 44)" kind="Lean.Parser.Tactic.tacticTry_">
                <AtomNode start="(1500, 33)" end="(1500, 36)" leading="" trailing=" " val="try"/>
                <TacticTacticseqNode start="(1500, 37)" end="(1500, 44)">
                  <TacticTacticseq1IndentedNode start="(1500, 37)" end="(1500, 44)">
                    <NullNode start="(1500, 37)" end="(1500, 44)">
                      <OtherNode start="(1500, 37)" end="(1500, 44)" kind="Lean.Parser.Tactic.tacticTrivial">
                        <AtomNode start="(1500, 37)" end="(1500, 44)" leading="" trailing="" val="trivial"/>
                      </OtherNode>
                    </NullNode>
                  </TacticTacticseq1IndentedNode>
                </TacticTacticseqNode>
              </OtherNode>
            </OtherNode>
            <AtomNode start="(1500, 44)" end="(1500, 45)" leading="" trailing="&#10;&#10;" val=")"/>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(1502, 1)" end="(1508, 50)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1502, 1)" end="(1507, 3)">
        <CommandDoccommentNode start="(1502, 1)" end="(1507, 3)" comment="* `symm` applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation,&#10;  that is, a relation which has a symmetry lemma tagged with the attribute [symm].&#10;  It replaces the target with `u ~ t`.&#10;* `symm at h` will rewrite a hypothesis `h : t ~ u` to `h : u ~ t`.&#10;-/">
          <AtomNode start="(1502, 1)" end="(1502, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1503, 1)" end="(1507, 3)" leading="" trailing="&#10;" val="* `symm` applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation,&#10;  that is, a relation which has a symmetry lemma tagged with the attribute [symm].&#10;  It replaces the target with `u ~ t`.&#10;* `symm at h` will rewrite a hypothesis `h : t ~ u` to `h : u ~ t`.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1508, 1)" end="(1508, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(1508, 8)" end="(1508, 22)">
        <OtherNode start="(1508, 8)" end="(1508, 22)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1508, 8)" end="(1508, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(1508, 9)" end="(1508, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1508, 14)" end="(1508, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1508, 17)" end="(1508, 21)" leading="" trailing="" raw_val="symm" val="symm"/>
          <AtomNode start="(1508, 21)" end="(1508, 22)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(1508, 23)" end="(1508, 41)">
        <OtherNode start="(1508, 23)" end="(1508, 29)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1508, 23)" end="(1508, 29)" kind="str">
            <AtomNode start="(1508, 23)" end="(1508, 29)" leading="" trailing=" " val="&amp;quot;symm&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1508, 30)" end="(1508, 41)" kind="stx_?">
          <OtherNode start="(1508, 30)" end="(1508, 40)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(1508, 30)" end="(1508, 31)" leading="" trailing="" val="("/>
            <NullNode start="(1508, 31)" end="(1508, 39)">
              <OtherNode start="(1508, 31)" end="(1508, 39)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(1508, 31)" end="(1508, 39)" leading="" trailing="" raw_val="location" val="location" full_name="Lean.Parser.Tactic.location" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(484, 8)" def_end="(484, 16)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1508, 39)" end="(1508, 40)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(1508, 40)" end="(1508, 41)" leading="" trailing=" " val="?"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1508, 42)" end="(1508, 43)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1508, 44)" end="(1508, 50)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(1510, 1)" end="(1512, 55)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1510, 1)" end="(1511, 38)">
        <CommandDoccommentNode start="(1510, 1)" end="(1511, 38)" comment="For every hypothesis `h : a ~ b` where a `@[symm]` lemma is available,&#10;add a hypothesis `h_symm : b ~ a`. -/">
          <AtomNode start="(1510, 1)" end="(1510, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(1510, 5)" end="(1511, 38)" leading="" trailing="&#10;" val="For every hypothesis `h : a ~ b` where a `@[symm]` lemma is available,&#10;add a hypothesis `h_symm : b ~ a`. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1512, 1)" end="(1512, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(1512, 8)" end="(1512, 30)">
        <OtherNode start="(1512, 8)" end="(1512, 30)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1512, 8)" end="(1512, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(1512, 9)" end="(1512, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1512, 14)" end="(1512, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1512, 17)" end="(1512, 29)" leading="" trailing="" raw_val="symmSaturate" val="symmSaturate"/>
          <AtomNode start="(1512, 29)" end="(1512, 30)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(1512, 31)" end="(1512, 46)">
        <OtherNode start="(1512, 31)" end="(1512, 46)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1512, 31)" end="(1512, 46)" kind="str">
            <AtomNode start="(1512, 31)" end="(1512, 46)" leading="" trailing=" " val="&amp;quot;symm_saturate&amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1512, 47)" end="(1512, 48)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1512, 49)" end="(1512, 55)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <CommandNamespaceNode start="(1514, 1)" end="(1514, 22)" name="SolveByElim">
      <AtomNode start="(1514, 1)" end="(1514, 10)" leading="" trailing=" " val="namespace"/>
      <IdentNode start="(1514, 11)" end="(1514, 22)" leading="" trailing="&#10;&#10;" raw_val="SolveByElim" val="SolveByElim"/>
    </CommandNamespaceNode>
    <OtherNode start="(1516, 1)" end="(1517, 29)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(1516, 1)" end="(1516, 66)">
        <CommandDoccommentNode start="(1516, 1)" end="(1516, 66)" comment="Syntax for omitting a local hypothesis in `solve_by_elim`. -/">
          <AtomNode start="(1516, 1)" end="(1516, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(1516, 5)" end="(1516, 66)" leading="" trailing="&#10;" val="Syntax for omitting a local hypothesis in `solve_by_elim`. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(1517, 1)" end="(1517, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(1517, 8)" end="(1517, 13)" leading="" trailing=" " raw_val="erase" val="erase"/>
      <AtomNode start="(1517, 14)" end="(1517, 16)" leading="" trailing=" " val=":="/>
      <NullNode start="(1517, 17)" end="(1517, 29)">
        <OtherNode start="(1517, 17)" end="(1517, 20)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1517, 17)" end="(1517, 20)" kind="str">
            <AtomNode start="(1517, 17)" end="(1517, 20)" leading="" trailing=" " val="&amp;quot;-&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1517, 21)" end="(1517, 29)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(1517, 21)" end="(1517, 25)" leading="" trailing="" raw_val="term" val="term" full_name="Lean.Parser.Category.term" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
          <NullNode start="(1517, 25)" end="(1517, 29)">
            <OtherNode start="(1517, 25)" end="(1517, 29)" kind="Lean.Parser.precedence">
              <AtomNode start="(1517, 25)" end="(1517, 26)" leading="" trailing="" val=":"/>
              <OtherNode start="(1517, 26)" end="(1517, 29)" kind="precMax">
                <AtomNode start="(1517, 26)" end="(1517, 29)" leading="" trailing="&#10;" val="max"/>
              </OtherNode>
            </OtherNode>
          </NullNode>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(1518, 1)" end="(1519, 19)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(1518, 1)" end="(1518, 69)">
        <CommandDoccommentNode start="(1518, 1)" end="(1518, 69)" comment="Syntax for including all local hypotheses in `solve_by_elim`. -/">
          <AtomNode start="(1518, 1)" end="(1518, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(1518, 5)" end="(1518, 69)" leading="" trailing="&#10;" val="Syntax for including all local hypotheses in `solve_by_elim`. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(1519, 1)" end="(1519, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(1519, 8)" end="(1519, 12)" leading="" trailing=" " raw_val="star" val="star"/>
      <AtomNode start="(1519, 13)" end="(1519, 15)" leading="" trailing=" " val=":="/>
      <NullNode start="(1519, 16)" end="(1519, 19)">
        <OtherNode start="(1519, 16)" end="(1519, 19)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1519, 16)" end="(1519, 19)" kind="str">
            <AtomNode start="(1519, 16)" end="(1519, 19)" leading="" trailing="&#10;" val="&amp;quot;*&amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(1520, 1)" end="(1521, 38)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(1520, 1)" end="(1520, 73)">
        <CommandDoccommentNode start="(1520, 1)" end="(1520, 73)" comment="Syntax for adding or removing a term, or `*`, in `solve_by_elim`. -/">
          <AtomNode start="(1520, 1)" end="(1520, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(1520, 5)" end="(1520, 73)" leading="" trailing="&#10;" val="Syntax for adding or removing a term, or `*`, in `solve_by_elim`. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(1521, 1)" end="(1521, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(1521, 8)" end="(1521, 11)" leading="" trailing=" " raw_val="arg" val="arg"/>
      <AtomNode start="(1521, 12)" end="(1521, 14)" leading="" trailing=" " val=":="/>
      <NullNode start="(1521, 15)" end="(1521, 38)">
        <OtherNode start="(1521, 15)" end="(1521, 38)" kind="«stx_&amp;lt;|&amp;gt;_»">
          <OtherNode start="(1521, 15)" end="(1521, 19)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(1521, 15)" end="(1521, 19)" leading="" trailing=" " raw_val="star" val="star" full_name="Lean.Parser.Tactic.SolveByElim.star" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(1519, 8)" def_end="(1519, 12)"/>
            <NullNode/>
          </OtherNode>
          <AtomNode start="(1521, 20)" end="(1521, 23)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
          <OtherNode start="(1521, 24)" end="(1521, 38)" kind="«stx_&amp;lt;|&amp;gt;_»">
            <OtherNode start="(1521, 24)" end="(1521, 29)" kind="Lean.Parser.Syntax.cat">
              <IdentNode start="(1521, 24)" end="(1521, 29)" leading="" trailing=" " raw_val="erase" val="erase" full_name="Lean.Parser.Tactic.SolveByElim.erase" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(1517, 8)" def_end="(1517, 13)"/>
              <NullNode/>
            </OtherNode>
            <AtomNode start="(1521, 30)" end="(1521, 33)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
            <OtherNode start="(1521, 34)" end="(1521, 38)" kind="Lean.Parser.Syntax.cat">
              <IdentNode start="(1521, 34)" end="(1521, 38)" leading="" trailing="&#10;" raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              <NullNode/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(1522, 1)" end="(1523, 42)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(1522, 1)" end="(1522, 64)">
        <CommandDoccommentNode start="(1522, 1)" end="(1522, 64)" comment="Syntax for adding and removing terms in `solve_by_elim`. -/">
          <AtomNode start="(1522, 1)" end="(1522, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(1522, 5)" end="(1522, 64)" leading="" trailing="&#10;" val="Syntax for adding and removing terms in `solve_by_elim`. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(1523, 1)" end="(1523, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(1523, 8)" end="(1523, 12)" leading="" trailing=" " raw_val="args" val="args"/>
      <AtomNode start="(1523, 13)" end="(1523, 15)" leading="" trailing=" " val=":="/>
      <NullNode start="(1523, 16)" end="(1523, 42)">
        <OtherNode start="(1523, 16)" end="(1523, 20)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1523, 16)" end="(1523, 20)" kind="str">
            <AtomNode start="(1523, 16)" end="(1523, 20)" leading="" trailing=" " val="&amp;quot; [&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1523, 21)" end="(1523, 38)" kind="«stx_,*»">
          <OtherNode start="(1523, 21)" end="(1523, 36)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(1523, 21)" end="(1523, 36)" leading="" trailing="" raw_val="SolveByElim.arg" val="SolveByElim.arg" full_name="Lean.Parser.Tactic.SolveByElim.arg" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(1521, 8)" def_end="(1521, 11)"/>
            <NullNode/>
          </OtherNode>
          <AtomNode start="(1523, 36)" end="(1523, 38)" leading="" trailing=" " val=",*"/>
        </OtherNode>
        <OtherNode start="(1523, 39)" end="(1523, 42)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1523, 39)" end="(1523, 42)" kind="str">
            <AtomNode start="(1523, 39)" end="(1523, 42)" leading="" trailing="&#10;" val="&amp;quot;]&amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(1524, 1)" end="(1525, 35)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(1524, 1)" end="(1524, 82)">
        <CommandDoccommentNode start="(1524, 1)" end="(1524, 82)" comment="Syntax for using all lemmas labelled with an attribute in `solve_by_elim`. -/">
          <AtomNode start="(1524, 1)" end="(1524, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(1524, 5)" end="(1524, 82)" leading="" trailing="&#10;" val="Syntax for using all lemmas labelled with an attribute in `solve_by_elim`. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(1525, 1)" end="(1525, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(1525, 8)" end="(1525, 14)" leading="" trailing=" " raw_val="using_" val="using_"/>
      <AtomNode start="(1525, 15)" end="(1525, 17)" leading="" trailing=" " val=":="/>
      <NullNode start="(1525, 18)" end="(1525, 35)">
        <OtherNode start="(1525, 18)" end="(1525, 27)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1525, 18)" end="(1525, 27)" kind="str">
            <AtomNode start="(1525, 18)" end="(1525, 27)" leading="" trailing=" " val="&amp;quot; using &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1525, 28)" end="(1525, 35)" kind="«stx_,*»">
          <OtherNode start="(1525, 28)" end="(1525, 33)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(1525, 28)" end="(1525, 33)" leading="" trailing="" raw_val="ident" val="ident" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            <NullNode/>
          </OtherNode>
          <AtomNode start="(1525, 33)" end="(1525, 35)" leading="" trailing="&#10;&#10;" val=",*"/>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <CommandEndNode start="(1527, 1)" end="(1527, 16)" name="SolveByElim">
      <AtomNode start="(1527, 1)" end="(1527, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(1527, 5)" end="(1527, 16)">
        <IdentNode start="(1527, 5)" end="(1527, 16)" leading="" trailing="&#10;&#10;" raw_val="SolveByElim" val="SolveByElim"/>
      </NullNode>
    </CommandEndNode>
    <CommandSectionNode start="(1529, 1)" end="(1529, 20)" name="SolveByElim">
      <AtomNode start="(1529, 1)" end="(1529, 8)" leading="" trailing=" " val="section"/>
      <NullNode start="(1529, 9)" end="(1529, 20)">
        <IdentNode start="(1529, 9)" end="(1529, 20)" leading="" trailing="&#10;" raw_val="SolveByElim" val="SolveByElim"/>
      </NullNode>
    </CommandSectionNode>
    <CommandOpenNode start="(1530, 1)" end="(1530, 31)">
      <AtomNode start="(1530, 1)" end="(1530, 5)" leading="" trailing=" " val="open"/>
      <CommandOpenonlyNode start="(1530, 6)" end="(1530, 31)">
        <IdentNode start="(1530, 6)" end="(1530, 17)" leading="" trailing=" " raw_val="SolveByElim" val="SolveByElim"/>
        <AtomNode start="(1530, 18)" end="(1530, 19)" leading="" trailing="" val="("/>
        <NullNode start="(1530, 19)" end="(1530, 30)">
          <IdentNode start="(1530, 19)" end="(1530, 23)" leading="" trailing=" " raw_val="args" val="args" full_name="Lean.Parser.Tactic.SolveByElim.args" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(1523, 8)" def_end="(1523, 12)"/>
          <IdentNode start="(1530, 24)" end="(1530, 30)" leading="" trailing="" raw_val="using_" val="using_" full_name="Lean.Parser.Tactic.SolveByElim.using_" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(1525, 8)" def_end="(1525, 14)"/>
        </NullNode>
        <AtomNode start="(1530, 30)" end="(1530, 31)" leading="" trailing="&#10;&#10;" val=")"/>
      </CommandOpenonlyNode>
    </CommandOpenNode>
    <OtherNode start="(1532, 1)" end="(1570, 72)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1532, 1)" end="(1568, 3)">
        <CommandDoccommentNode start="(1532, 1)" end="(1568, 3)" comment="`solve_by_elim` calls `apply` on the main goal to find an assumption whose head matches&#10;and then repeatedly calls `apply` on the generated subgoals until no subgoals remain,&#10;performing at most `maxDepth` (defaults to 6) recursive steps.&#10;&#10;`solve_by_elim` discharges the current goal or fails.&#10;&#10;`solve_by_elim` performs backtracking if subgoals can not be solved.&#10;&#10;By default, the assumptions passed to `apply` are the local context, `rfl`, `trivial`,&#10;`congrFun` and `congrArg`.&#10;&#10;The assumptions can be modified with similar syntax as for `simp`:&#10;* `solve_by_elim [h₁, h₂, ..., hᵣ]` also applies the given expressions.&#10;* `solve_by_elim only [h₁, h₂, ..., hᵣ]` does not include the local context,&#10;  `rfl`, `trivial`, `congrFun`, or `congrArg` unless they are explicitly included.&#10;* `solve_by_elim [-h₁, ... -hₙ]` removes the given local hypotheses.&#10;* `solve_by_elim using [a₁, ...]` uses all lemmas which have been labelled&#10;  with the attributes `aᵢ` (these attributes must be created using `register_label_attr`).&#10;&#10;`solve_by_elim*` tries to solve all goals together, using backtracking if a solution for one goal&#10;makes other goals impossible.&#10;(Adding or removing local hypotheses may not be well-behaved when starting with multiple goals.)&#10;&#10;Optional arguments passed via a configuration argument as `solve_by_elim (config := { ... })`&#10;- `maxDepth`: number of attempts at discharging generated subgoals&#10;- `symm`: adds all hypotheses derived by `symm` (defaults to `true`).&#10;- `exfalso`: allow calling `exfalso` and trying again if `solve_by_elim` fails&#10;  (defaults to `true`).&#10;- `transparency`: change the transparency mode when calling `apply`. Defaults to `.default`,&#10;  but it is often useful to change to `.reducible`,&#10;  so semireducible definitions will not be unfolded when trying to apply a lemma.&#10;&#10;See also the doc-comment for `Lean.Meta.Tactic.Backtrack.BacktrackConfig` for the options&#10;`proc`, `suspend`, and `discharge` which allow further customization of `solve_by_elim`.&#10;Both `apply_assumption` and `apply_rules` are implemented via these hooks.&#10;-/">
          <AtomNode start="(1532, 1)" end="(1532, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1533, 1)" end="(1568, 3)" leading="" trailing="&#10;" val="`solve_by_elim` calls `apply` on the main goal to find an assumption whose head matches&#10;and then repeatedly calls `apply` on the generated subgoals until no subgoals remain,&#10;performing at most `maxDepth` (defaults to 6) recursive steps.&#10;&#10;`solve_by_elim` discharges the current goal or fails.&#10;&#10;`solve_by_elim` performs backtracking if subgoals can not be solved.&#10;&#10;By default, the assumptions passed to `apply` are the local context, `rfl`, `trivial`,&#10;`congrFun` and `congrArg`.&#10;&#10;The assumptions can be modified with similar syntax as for `simp`:&#10;* `solve_by_elim [h₁, h₂, ..., hᵣ]` also applies the given expressions.&#10;* `solve_by_elim only [h₁, h₂, ..., hᵣ]` does not include the local context,&#10;  `rfl`, `trivial`, `congrFun`, or `congrArg` unless they are explicitly included.&#10;* `solve_by_elim [-h₁, ... -hₙ]` removes the given local hypotheses.&#10;* `solve_by_elim using [a₁, ...]` uses all lemmas which have been labelled&#10;  with the attributes `aᵢ` (these attributes must be created using `register_label_attr`).&#10;&#10;`solve_by_elim*` tries to solve all goals together, using backtracking if a solution for one goal&#10;makes other goals impossible.&#10;(Adding or removing local hypotheses may not be well-behaved when starting with multiple goals.)&#10;&#10;Optional arguments passed via a configuration argument as `solve_by_elim (config := { ... })`&#10;- `maxDepth`: number of attempts at discharging generated subgoals&#10;- `symm`: adds all hypotheses derived by `symm` (defaults to `true`).&#10;- `exfalso`: allow calling `exfalso` and trying again if `solve_by_elim` fails&#10;  (defaults to `true`).&#10;- `transparency`: change the transparency mode when calling `apply`. Defaults to `.default`,&#10;  but it is often useful to change to `.reducible`,&#10;  so semireducible definitions will not be unfolded when trying to apply a lemma.&#10;&#10;See also the doc-comment for `Lean.Meta.Tactic.Backtrack.BacktrackConfig` for the options&#10;`proc`, `suspend`, and `discharge` which allow further customization of `solve_by_elim`.&#10;Both `apply_assumption` and `apply_rules` are implemented via these hooks.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1569, 1)" end="(1569, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(1569, 8)" end="(1569, 29)">
        <OtherNode start="(1569, 8)" end="(1569, 29)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1569, 8)" end="(1569, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(1569, 9)" end="(1569, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1569, 14)" end="(1569, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1569, 17)" end="(1569, 28)" leading="" trailing="" raw_val="solveByElim" val="solveByElim"/>
          <AtomNode start="(1569, 28)" end="(1569, 29)" leading="" trailing="&#10;  " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(1570, 3)" end="(1570, 63)">
        <OtherNode start="(1570, 3)" end="(1570, 18)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1570, 3)" end="(1570, 18)" kind="str">
            <AtomNode start="(1570, 3)" end="(1570, 18)" leading="" trailing=" " val="&amp;quot;solve_by_elim&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1570, 19)" end="(1570, 23)" kind="stx_?">
          <OtherNode start="(1570, 19)" end="(1570, 22)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(1570, 19)" end="(1570, 22)" kind="str">
              <AtomNode start="(1570, 19)" end="(1570, 22)" leading="" trailing="" val="&amp;quot;*&amp;quot;"/>
            </OtherNode>
          </OtherNode>
          <AtomNode start="(1570, 22)" end="(1570, 23)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(1570, 24)" end="(1570, 33)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(1570, 24)" end="(1570, 33)" leading="" trailing=" " raw_val="optConfig" val="optConfig" full_name="Lean.Parser.Tactic.optConfig" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(458, 8)" def_end="(458, 17)"/>
          <NullNode/>
        </OtherNode>
        <OtherNode start="(1570, 34)" end="(1570, 45)" kind="stx_?">
          <OtherNode start="(1570, 34)" end="(1570, 44)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(1570, 34)" end="(1570, 35)" leading="" trailing="" val="("/>
            <NullNode start="(1570, 35)" end="(1570, 43)">
              <OtherNode start="(1570, 35)" end="(1570, 43)" kind="Lean.Parser.Syntax.nonReserved">
                <AtomNode start="(1570, 35)" end="(1570, 36)" leading="" trailing="" val="&amp;amp;"/>
                <OtherNode start="(1570, 36)" end="(1570, 43)" kind="str">
                  <AtomNode start="(1570, 36)" end="(1570, 43)" leading="" trailing="" val="&amp;quot; only&amp;quot;"/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1570, 43)" end="(1570, 44)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(1570, 44)" end="(1570, 45)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(1570, 46)" end="(1570, 53)" kind="stx_?">
          <OtherNode start="(1570, 46)" end="(1570, 52)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(1570, 46)" end="(1570, 47)" leading="" trailing="" val="("/>
            <NullNode start="(1570, 47)" end="(1570, 51)">
              <OtherNode start="(1570, 47)" end="(1570, 51)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(1570, 47)" end="(1570, 51)" leading="" trailing="" raw_val="args" val="args" full_name="Lean.Parser.Tactic.SolveByElim.args" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(1523, 8)" def_end="(1523, 12)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1570, 51)" end="(1570, 52)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(1570, 52)" end="(1570, 53)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(1570, 54)" end="(1570, 63)" kind="stx_?">
          <OtherNode start="(1570, 54)" end="(1570, 62)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(1570, 54)" end="(1570, 55)" leading="" trailing="" val="("/>
            <NullNode start="(1570, 55)" end="(1570, 61)">
              <OtherNode start="(1570, 55)" end="(1570, 61)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(1570, 55)" end="(1570, 61)" leading="" trailing="" raw_val="using_" val="using_" full_name="Lean.Parser.Tactic.SolveByElim.using_" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(1525, 8)" def_end="(1525, 14)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1570, 61)" end="(1570, 62)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(1570, 62)" end="(1570, 63)" leading="" trailing=" " val="?"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1570, 64)" end="(1570, 65)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1570, 66)" end="(1570, 72)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(1572, 1)" end="(1593, 70)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1572, 1)" end="(1591, 3)">
        <CommandDoccommentNode start="(1572, 1)" end="(1591, 3)" comment="`apply_assumption` looks for an assumption of the form `... → ∀ _, ... → head`&#10;where `head` matches the current goal.&#10;&#10;You can specify additional rules to apply using `apply_assumption [...]`.&#10;By default `apply_assumption` will also try `rfl`, `trivial`, `congrFun`, and `congrArg`.&#10;If you don't want these, or don't want to use all hypotheses, use `apply_assumption only [...]`.&#10;You can use `apply_assumption [-h]` to omit a local hypothesis.&#10;You can use `apply_assumption using [a₁, ...]` to use all lemmas which have been labelled&#10;with the attributes `aᵢ` (these attributes must be created using `register_label_attr`).&#10;&#10;`apply_assumption` will use consequences of local hypotheses obtained via `symm`.&#10;&#10;If `apply_assumption` fails, it will call `exfalso` and try again.&#10;Thus if there is an assumption of the form `P → ¬ Q`, the new tactic state&#10;will have two goals, `P` and `Q`.&#10;&#10;You can pass a further configuration via the syntax `apply_rules (config := {...}) lemmas`.&#10;The options supported are the same as for `solve_by_elim` (and include all the options for `apply`).&#10;-/">
          <AtomNode start="(1572, 1)" end="(1572, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1573, 1)" end="(1591, 3)" leading="" trailing="&#10;" val="`apply_assumption` looks for an assumption of the form `... → ∀ _, ... → head`&#10;where `head` matches the current goal.&#10;&#10;You can specify additional rules to apply using `apply_assumption [...]`.&#10;By default `apply_assumption` will also try `rfl`, `trivial`, `congrFun`, and `congrArg`.&#10;If you don't want these, or don't want to use all hypotheses, use `apply_assumption only [...]`.&#10;You can use `apply_assumption [-h]` to omit a local hypothesis.&#10;You can use `apply_assumption using [a₁, ...]` to use all lemmas which have been labelled&#10;with the attributes `aᵢ` (these attributes must be created using `register_label_attr`).&#10;&#10;`apply_assumption` will use consequences of local hypotheses obtained via `symm`.&#10;&#10;If `apply_assumption` fails, it will call `exfalso` and try again.&#10;Thus if there is an assumption of the form `P → ¬ Q`, the new tactic state&#10;will have two goals, `P` and `Q`.&#10;&#10;You can pass a further configuration via the syntax `apply_rules (config := {...}) lemmas`.&#10;The options supported are the same as for `solve_by_elim` (and include all the options for `apply`).&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1592, 1)" end="(1592, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(1592, 8)" end="(1592, 33)">
        <OtherNode start="(1592, 8)" end="(1592, 33)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1592, 8)" end="(1592, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(1592, 9)" end="(1592, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1592, 14)" end="(1592, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1592, 17)" end="(1592, 32)" leading="" trailing="" raw_val="applyAssumption" val="applyAssumption"/>
          <AtomNode start="(1592, 32)" end="(1592, 33)" leading="" trailing="&#10;  " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(1593, 3)" end="(1593, 61)">
        <OtherNode start="(1593, 3)" end="(1593, 21)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1593, 3)" end="(1593, 21)" kind="str">
            <AtomNode start="(1593, 3)" end="(1593, 21)" leading="" trailing=" " val="&amp;quot;apply_assumption&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1593, 22)" end="(1593, 31)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(1593, 22)" end="(1593, 31)" leading="" trailing=" " raw_val="optConfig" val="optConfig" full_name="Lean.Parser.Tactic.optConfig" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(458, 8)" def_end="(458, 17)"/>
          <NullNode/>
        </OtherNode>
        <OtherNode start="(1593, 32)" end="(1593, 43)" kind="stx_?">
          <OtherNode start="(1593, 32)" end="(1593, 42)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(1593, 32)" end="(1593, 33)" leading="" trailing="" val="("/>
            <NullNode start="(1593, 33)" end="(1593, 41)">
              <OtherNode start="(1593, 33)" end="(1593, 41)" kind="Lean.Parser.Syntax.nonReserved">
                <AtomNode start="(1593, 33)" end="(1593, 34)" leading="" trailing="" val="&amp;amp;"/>
                <OtherNode start="(1593, 34)" end="(1593, 41)" kind="str">
                  <AtomNode start="(1593, 34)" end="(1593, 41)" leading="" trailing="" val="&amp;quot; only&amp;quot;"/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1593, 41)" end="(1593, 42)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(1593, 42)" end="(1593, 43)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(1593, 44)" end="(1593, 51)" kind="stx_?">
          <OtherNode start="(1593, 44)" end="(1593, 50)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(1593, 44)" end="(1593, 45)" leading="" trailing="" val="("/>
            <NullNode start="(1593, 45)" end="(1593, 49)">
              <OtherNode start="(1593, 45)" end="(1593, 49)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(1593, 45)" end="(1593, 49)" leading="" trailing="" raw_val="args" val="args" full_name="Lean.Parser.Tactic.SolveByElim.args" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(1523, 8)" def_end="(1523, 12)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1593, 49)" end="(1593, 50)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(1593, 50)" end="(1593, 51)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(1593, 52)" end="(1593, 61)" kind="stx_?">
          <OtherNode start="(1593, 52)" end="(1593, 60)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(1593, 52)" end="(1593, 53)" leading="" trailing="" val="("/>
            <NullNode start="(1593, 53)" end="(1593, 59)">
              <OtherNode start="(1593, 53)" end="(1593, 59)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(1593, 53)" end="(1593, 59)" leading="" trailing="" raw_val="using_" val="using_" full_name="Lean.Parser.Tactic.SolveByElim.using_" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(1525, 8)" def_end="(1525, 14)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1593, 59)" end="(1593, 60)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(1593, 60)" end="(1593, 61)" leading="" trailing=" " val="?"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1593, 62)" end="(1593, 63)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1593, 64)" end="(1593, 70)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(1595, 1)" end="(1618, 91)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1595, 1)" end="(1617, 3)">
        <CommandDoccommentNode start="(1595, 1)" end="(1617, 3)" comment="`apply_rules [l₁, l₂, ...]` tries to solve the main goal by iteratively&#10;applying the list of lemmas `[l₁, l₂, ...]` or by applying a local hypothesis.&#10;If `apply` generates new goals, `apply_rules` iteratively tries to solve those goals.&#10;You can use `apply_rules [-h]` to omit a local hypothesis.&#10;&#10;`apply_rules` will also use `rfl`, `trivial`, `congrFun` and `congrArg`.&#10;These can be disabled, as can local hypotheses, by using `apply_rules only [...]`.&#10;&#10;You can use `apply_rules using [a₁, ...]` to use all lemmas which have been labelled&#10;with the attributes `aᵢ` (these attributes must be created using `register_label_attr`).&#10;&#10;You can pass a further configuration via the syntax `apply_rules (config := {...})`.&#10;The options supported are the same as for `solve_by_elim` (and include all the options for `apply`).&#10;&#10;`apply_rules` will try calling `symm` on hypotheses and `exfalso` on the goal as needed.&#10;This can be disabled with `apply_rules (config := {symm := false, exfalso := false})`.&#10;&#10;You can bound the iteration depth using the syntax `apply_rules (config := {maxDepth := n})`.&#10;&#10;Unlike `solve_by_elim`, `apply_rules` does not perform backtracking, and greedily applies&#10;a lemma from the list until it gets stuck.&#10;-/">
          <AtomNode start="(1595, 1)" end="(1595, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1596, 1)" end="(1617, 3)" leading="" trailing="&#10;" val="`apply_rules [l₁, l₂, ...]` tries to solve the main goal by iteratively&#10;applying the list of lemmas `[l₁, l₂, ...]` or by applying a local hypothesis.&#10;If `apply` generates new goals, `apply_rules` iteratively tries to solve those goals.&#10;You can use `apply_rules [-h]` to omit a local hypothesis.&#10;&#10;`apply_rules` will also use `rfl`, `trivial`, `congrFun` and `congrArg`.&#10;These can be disabled, as can local hypotheses, by using `apply_rules only [...]`.&#10;&#10;You can use `apply_rules using [a₁, ...]` to use all lemmas which have been labelled&#10;with the attributes `aᵢ` (these attributes must be created using `register_label_attr`).&#10;&#10;You can pass a further configuration via the syntax `apply_rules (config := {...})`.&#10;The options supported are the same as for `solve_by_elim` (and include all the options for `apply`).&#10;&#10;`apply_rules` will try calling `symm` on hypotheses and `exfalso` on the goal as needed.&#10;This can be disabled with `apply_rules (config := {symm := false, exfalso := false})`.&#10;&#10;You can bound the iteration depth using the syntax `apply_rules (config := {maxDepth := n})`.&#10;&#10;Unlike `solve_by_elim`, `apply_rules` does not perform backtracking, and greedily applies&#10;a lemma from the list until it gets stuck.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1618, 1)" end="(1618, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(1618, 8)" end="(1618, 28)">
        <OtherNode start="(1618, 8)" end="(1618, 28)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1618, 8)" end="(1618, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(1618, 9)" end="(1618, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1618, 14)" end="(1618, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1618, 17)" end="(1618, 27)" leading="" trailing="" raw_val="applyRules" val="applyRules"/>
          <AtomNode start="(1618, 27)" end="(1618, 28)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(1618, 29)" end="(1618, 82)">
        <OtherNode start="(1618, 29)" end="(1618, 42)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1618, 29)" end="(1618, 42)" kind="str">
            <AtomNode start="(1618, 29)" end="(1618, 42)" leading="" trailing=" " val="&amp;quot;apply_rules&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1618, 43)" end="(1618, 52)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(1618, 43)" end="(1618, 52)" leading="" trailing=" " raw_val="optConfig" val="optConfig" full_name="Lean.Parser.Tactic.optConfig" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(458, 8)" def_end="(458, 17)"/>
          <NullNode/>
        </OtherNode>
        <OtherNode start="(1618, 53)" end="(1618, 64)" kind="stx_?">
          <OtherNode start="(1618, 53)" end="(1618, 63)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(1618, 53)" end="(1618, 54)" leading="" trailing="" val="("/>
            <NullNode start="(1618, 54)" end="(1618, 62)">
              <OtherNode start="(1618, 54)" end="(1618, 62)" kind="Lean.Parser.Syntax.nonReserved">
                <AtomNode start="(1618, 54)" end="(1618, 55)" leading="" trailing="" val="&amp;amp;"/>
                <OtherNode start="(1618, 55)" end="(1618, 62)" kind="str">
                  <AtomNode start="(1618, 55)" end="(1618, 62)" leading="" trailing="" val="&amp;quot; only&amp;quot;"/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1618, 62)" end="(1618, 63)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(1618, 63)" end="(1618, 64)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(1618, 65)" end="(1618, 72)" kind="stx_?">
          <OtherNode start="(1618, 65)" end="(1618, 71)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(1618, 65)" end="(1618, 66)" leading="" trailing="" val="("/>
            <NullNode start="(1618, 66)" end="(1618, 70)">
              <OtherNode start="(1618, 66)" end="(1618, 70)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(1618, 66)" end="(1618, 70)" leading="" trailing="" raw_val="args" val="args" full_name="Lean.Parser.Tactic.SolveByElim.args" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(1523, 8)" def_end="(1523, 12)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1618, 70)" end="(1618, 71)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(1618, 71)" end="(1618, 72)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(1618, 73)" end="(1618, 82)" kind="stx_?">
          <OtherNode start="(1618, 73)" end="(1618, 81)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(1618, 73)" end="(1618, 74)" leading="" trailing="" val="("/>
            <NullNode start="(1618, 74)" end="(1618, 80)">
              <OtherNode start="(1618, 74)" end="(1618, 80)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(1618, 74)" end="(1618, 80)" leading="" trailing="" raw_val="using_" val="using_" full_name="Lean.Parser.Tactic.SolveByElim.using_" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(1525, 8)" def_end="(1525, 14)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1618, 80)" end="(1618, 81)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(1618, 81)" end="(1618, 82)" leading="" trailing=" " val="?"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1618, 83)" end="(1618, 84)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1618, 85)" end="(1618, 91)" leading="" trailing="&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <CommandEndNode start="(1619, 1)" end="(1619, 16)" name="SolveByElim">
      <AtomNode start="(1619, 1)" end="(1619, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(1619, 5)" end="(1619, 16)">
        <IdentNode start="(1619, 5)" end="(1619, 16)" leading="" trailing="&#10;&#10;" raw_val="SolveByElim" val="SolveByElim"/>
      </NullNode>
    </CommandEndNode>
    <OtherNode start="(1621, 1)" end="(1629, 71)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1621, 1)" end="(1628, 3)">
        <CommandDoccommentNode start="(1621, 1)" end="(1628, 3)" comment="Searches environment for definitions or theorems that can solve the goal using `exact`&#10;with conditions resolved by `solve_by_elim`.&#10;&#10;The optional `using` clause provides identifiers in the local context that must be&#10;used by `exact?` when closing the goal.  This is most useful if there are multiple&#10;ways to resolve the goal, and one wants to guide which lemma is used.&#10;-/">
          <AtomNode start="(1621, 1)" end="(1621, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1622, 1)" end="(1628, 3)" leading="" trailing="&#10;" val="Searches environment for definitions or theorems that can solve the goal using `exact`&#10;with conditions resolved by `solve_by_elim`.&#10;&#10;The optional `using` clause provides identifiers in the local context that must be&#10;used by `exact?` when closing the goal.  This is most useful if there are multiple&#10;ways to resolve the goal, and one wants to guide which lemma is used.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1629, 1)" end="(1629, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(1629, 8)" end="(1629, 24)">
        <OtherNode start="(1629, 8)" end="(1629, 24)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1629, 8)" end="(1629, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(1629, 9)" end="(1629, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1629, 14)" end="(1629, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1629, 17)" end="(1629, 23)" leading="" trailing="" raw_val="exact?" val="exact?"/>
          <AtomNode start="(1629, 23)" end="(1629, 24)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(1629, 25)" end="(1629, 62)">
        <OtherNode start="(1629, 25)" end="(1629, 33)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1629, 25)" end="(1629, 33)" kind="str">
            <AtomNode start="(1629, 25)" end="(1629, 33)" leading="" trailing=" " val="&amp;quot;exact?&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1629, 34)" end="(1629, 62)" kind="stx_?">
          <OtherNode start="(1629, 34)" end="(1629, 61)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(1629, 34)" end="(1629, 35)" leading="" trailing="" val="("/>
            <NullNode start="(1629, 35)" end="(1629, 60)">
              <OtherNode start="(1629, 35)" end="(1629, 44)" kind="Lean.Parser.Syntax.atom">
                <OtherNode start="(1629, 35)" end="(1629, 44)" kind="str">
                  <AtomNode start="(1629, 35)" end="(1629, 44)" leading="" trailing=" " val="&amp;quot; using &amp;quot;"/>
                </OtherNode>
              </OtherNode>
              <OtherNode start="(1629, 45)" end="(1629, 60)" kind="«stx_,+»">
                <OtherNode start="(1629, 45)" end="(1629, 58)" kind="Lean.Parser.Syntax.paren">
                  <AtomNode start="(1629, 45)" end="(1629, 46)" leading="" trailing="" val="("/>
                  <NullNode start="(1629, 46)" end="(1629, 57)">
                    <OtherNode start="(1629, 46)" end="(1629, 51)" kind="Lean.Parser.Syntax.cat">
                      <IdentNode start="(1629, 46)" end="(1629, 51)" leading="" trailing=" " raw_val="colGt" val="colGt" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(1629, 52)" end="(1629, 57)" kind="Lean.Parser.Syntax.cat">
                      <IdentNode start="(1629, 52)" end="(1629, 57)" leading="" trailing="" raw_val="ident" val="ident" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode/>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(1629, 57)" end="(1629, 58)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(1629, 58)" end="(1629, 60)" leading="" trailing="" val=",+"/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1629, 60)" end="(1629, 61)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(1629, 61)" end="(1629, 62)" leading="" trailing=" " val="?"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1629, 63)" end="(1629, 64)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1629, 65)" end="(1629, 71)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(1631, 1)" end="(1638, 70)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1631, 1)" end="(1637, 3)">
        <CommandDoccommentNode start="(1631, 1)" end="(1637, 3)" comment="Searches environment for definitions or theorems that can refine the goal using `apply`&#10;with conditions resolved when possible with `solve_by_elim`.&#10;&#10;The optional `using` clause provides identifiers in the local context that must be&#10;used when closing the goal.&#10;-/">
          <AtomNode start="(1631, 1)" end="(1631, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1632, 1)" end="(1637, 3)" leading="" trailing="&#10;" val="Searches environment for definitions or theorems that can refine the goal using `apply`&#10;with conditions resolved when possible with `solve_by_elim`.&#10;&#10;The optional `using` clause provides identifiers in the local context that must be&#10;used when closing the goal.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1638, 1)" end="(1638, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(1638, 8)" end="(1638, 24)">
        <OtherNode start="(1638, 8)" end="(1638, 24)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1638, 8)" end="(1638, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(1638, 9)" end="(1638, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1638, 14)" end="(1638, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1638, 17)" end="(1638, 23)" leading="" trailing="" raw_val="apply?" val="apply?"/>
          <AtomNode start="(1638, 23)" end="(1638, 24)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(1638, 25)" end="(1638, 61)">
        <OtherNode start="(1638, 25)" end="(1638, 33)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1638, 25)" end="(1638, 33)" kind="str">
            <AtomNode start="(1638, 25)" end="(1638, 33)" leading="" trailing=" " val="&amp;quot;apply?&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1638, 34)" end="(1638, 61)" kind="stx_?">
          <OtherNode start="(1638, 34)" end="(1638, 60)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(1638, 34)" end="(1638, 35)" leading="" trailing="" val="("/>
            <NullNode start="(1638, 35)" end="(1638, 59)">
              <OtherNode start="(1638, 35)" end="(1638, 44)" kind="Lean.Parser.Syntax.atom">
                <OtherNode start="(1638, 35)" end="(1638, 44)" kind="str">
                  <AtomNode start="(1638, 35)" end="(1638, 44)" leading="" trailing=" " val="&amp;quot; using &amp;quot;"/>
                </OtherNode>
              </OtherNode>
              <OtherNode start="(1638, 45)" end="(1638, 59)" kind="«stx_,+»">
                <OtherNode start="(1638, 45)" end="(1638, 57)" kind="Lean.Parser.Syntax.paren">
                  <AtomNode start="(1638, 45)" end="(1638, 46)" leading="" trailing="" val="("/>
                  <NullNode start="(1638, 46)" end="(1638, 56)">
                    <OtherNode start="(1638, 46)" end="(1638, 51)" kind="Lean.Parser.Syntax.cat">
                      <IdentNode start="(1638, 46)" end="(1638, 51)" leading="" trailing=" " raw_val="colGt" val="colGt" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode/>
                    </OtherNode>
                    <OtherNode start="(1638, 52)" end="(1638, 56)" kind="Lean.Parser.Syntax.cat">
                      <IdentNode start="(1638, 52)" end="(1638, 56)" leading="" trailing="" raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                      <NullNode/>
                    </OtherNode>
                  </NullNode>
                  <AtomNode start="(1638, 56)" end="(1638, 57)" leading="" trailing="" val=")"/>
                </OtherNode>
                <AtomNode start="(1638, 57)" end="(1638, 59)" leading="" trailing="" val=",+"/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1638, 59)" end="(1638, 60)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(1638, 60)" end="(1638, 61)" leading="" trailing=" " val="?"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1638, 62)" end="(1638, 63)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1638, 64)" end="(1638, 70)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(1640, 1)" end="(1643, 56)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(1640, 1)" end="(1642, 3)">
        <CommandDoccommentNode start="(1640, 1)" end="(1642, 3)" comment="Syntax for excluding some names, e.g. `[-my_lemma, -my_theorem]`.&#10;-/">
          <AtomNode start="(1640, 1)" end="(1640, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1641, 1)" end="(1642, 3)" leading="" trailing="&#10;" val="Syntax for excluding some names, e.g. `[-my_lemma, -my_theorem]`.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(1643, 1)" end="(1643, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(1643, 8)" end="(1643, 26)" leading="" trailing=" " raw_val="rewrites_forbidden" val="rewrites_forbidden"/>
      <AtomNode start="(1643, 27)" end="(1643, 29)" leading="" trailing=" " val=":="/>
      <NullNode start="(1643, 30)" end="(1643, 56)">
        <OtherNode start="(1643, 30)" end="(1643, 34)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1643, 30)" end="(1643, 34)" kind="str">
            <AtomNode start="(1643, 30)" end="(1643, 34)" leading="" trailing=" " val="&amp;quot; [&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1643, 35)" end="(1643, 52)" kind="Lean.Parser.Syntax.paren">
          <AtomNode start="(1643, 35)" end="(1643, 36)" leading="" trailing="" val="("/>
          <NullNode start="(1643, 36)" end="(1643, 51)">
            <OtherNode start="(1643, 36)" end="(1643, 51)" kind="«stx_,*,?»">
              <OtherNode start="(1643, 36)" end="(1643, 47)" kind="Lean.Parser.Syntax.paren">
                <AtomNode start="(1643, 36)" end="(1643, 37)" leading="" trailing="" val="("/>
                <NullNode start="(1643, 37)" end="(1643, 46)">
                  <OtherNode start="(1643, 37)" end="(1643, 40)" kind="Lean.Parser.Syntax.atom">
                    <OtherNode start="(1643, 37)" end="(1643, 40)" kind="str">
                      <AtomNode start="(1643, 37)" end="(1643, 40)" leading="" trailing=" " val="&amp;quot;-&amp;quot;"/>
                    </OtherNode>
                  </OtherNode>
                  <OtherNode start="(1643, 41)" end="(1643, 46)" kind="Lean.Parser.Syntax.cat">
                    <IdentNode start="(1643, 41)" end="(1643, 46)" leading="" trailing="" raw_val="ident" val="ident" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
                <AtomNode start="(1643, 46)" end="(1643, 47)" leading="" trailing="" val=")"/>
              </OtherNode>
              <AtomNode start="(1643, 47)" end="(1643, 51)" leading="" trailing="" val=",*,?"/>
            </OtherNode>
          </NullNode>
          <AtomNode start="(1643, 51)" end="(1643, 52)" leading="" trailing=" " val=")"/>
        </OtherNode>
        <OtherNode start="(1643, 53)" end="(1643, 56)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1643, 53)" end="(1643, 56)" kind="str">
            <AtomNode start="(1643, 53)" end="(1643, 56)" leading="" trailing="&#10;&#10;" val="&amp;quot;]&amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(1645, 1)" end="(1654, 84)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1645, 1)" end="(1653, 3)">
        <CommandDoccommentNode start="(1645, 1)" end="(1653, 3)" comment="`rw?` tries to find a lemma which can rewrite the goal.&#10;&#10;`rw?` should not be left in proofs; it is a search tool, like `apply?`.&#10;&#10;Suggestions are printed as `rw [h]` or `rw [← h]`.&#10;&#10;You can use `rw? [-my_lemma, -my_theorem]` to prevent `rw?` using the named lemmas.&#10;-/">
          <AtomNode start="(1645, 1)" end="(1645, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1646, 1)" end="(1653, 3)" leading="" trailing="&#10;" val="`rw?` tries to find a lemma which can rewrite the goal.&#10;&#10;`rw?` should not be left in proofs; it is a search tool, like `apply?`.&#10;&#10;Suggestions are printed as `rw [h]` or `rw [← h]`.&#10;&#10;You can use `rw? [-my_lemma, -my_theorem]` to prevent `rw?` using the named lemmas.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1654, 1)" end="(1654, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(1654, 8)" end="(1654, 27)">
        <OtherNode start="(1654, 8)" end="(1654, 27)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1654, 8)" end="(1654, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(1654, 9)" end="(1654, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1654, 14)" end="(1654, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1654, 17)" end="(1654, 26)" leading="" trailing="" raw_val="rewrites?" val="rewrites?"/>
          <AtomNode start="(1654, 26)" end="(1654, 27)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(1654, 28)" end="(1654, 75)">
        <OtherNode start="(1654, 28)" end="(1654, 33)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1654, 28)" end="(1654, 33)" kind="str">
            <AtomNode start="(1654, 28)" end="(1654, 33)" leading="" trailing=" " val="&amp;quot;rw?&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1654, 34)" end="(1654, 53)" kind="stx_?">
          <OtherNode start="(1654, 34)" end="(1654, 52)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(1654, 34)" end="(1654, 35)" leading="" trailing="" val="("/>
            <NullNode start="(1654, 35)" end="(1654, 51)">
              <OtherNode start="(1654, 35)" end="(1654, 42)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(1654, 35)" end="(1654, 42)" leading="" trailing=" " raw_val="ppSpace" val="ppSpace" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(1654, 43)" end="(1654, 51)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(1654, 43)" end="(1654, 51)" leading="" trailing="" raw_val="location" val="location" full_name="Lean.Parser.Tactic.location" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(484, 8)" def_end="(484, 16)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1654, 51)" end="(1654, 52)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(1654, 52)" end="(1654, 53)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(1654, 54)" end="(1654, 75)" kind="stx_?">
          <OtherNode start="(1654, 54)" end="(1654, 74)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(1654, 54)" end="(1654, 55)" leading="" trailing="" val="("/>
            <NullNode start="(1654, 55)" end="(1654, 73)">
              <OtherNode start="(1654, 55)" end="(1654, 73)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(1654, 55)" end="(1654, 73)" leading="" trailing="" raw_val="rewrites_forbidden" val="rewrites_forbidden" full_name="Lean.Parser.Tactic.rewrites_forbidden" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(1643, 8)" def_end="(1643, 26)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1654, 73)" end="(1654, 74)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(1654, 74)" end="(1654, 75)" leading="" trailing=" " val="?"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1654, 76)" end="(1654, 77)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1654, 78)" end="(1654, 84)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(1656, 1)" end="(1663, 58)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1656, 1)" end="(1662, 3)">
        <CommandDoccommentNode start="(1656, 1)" end="(1662, 3)" comment="`show_term tac` runs `tac`, then prints the generated term in the form&#10;&amp;quot;exact X Y Z&amp;quot; or &amp;quot;refine X ?_ Z&amp;quot; (prefixed by `expose_names` if necessary)&#10;if there are remaining subgoals.&#10;&#10;(For some tactics, the printed term will not be human readable.)&#10;-/">
          <AtomNode start="(1656, 1)" end="(1656, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1657, 1)" end="(1662, 3)" leading="" trailing="&#10;" val="`show_term tac` runs `tac`, then prints the generated term in the form&#10;&amp;quot;exact X Y Z&amp;quot; or &amp;quot;refine X ?_ Z&amp;quot; (prefixed by `expose_names` if necessary)&#10;if there are remaining subgoals.&#10;&#10;(For some tactics, the printed term will not be human readable.)&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1663, 1)" end="(1663, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(1663, 8)" end="(1663, 26)">
        <OtherNode start="(1663, 8)" end="(1663, 26)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1663, 8)" end="(1663, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(1663, 9)" end="(1663, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1663, 14)" end="(1663, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1663, 17)" end="(1663, 25)" leading="" trailing="" raw_val="showTerm" val="showTerm"/>
          <AtomNode start="(1663, 25)" end="(1663, 26)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(1663, 27)" end="(1663, 49)">
        <OtherNode start="(1663, 27)" end="(1663, 39)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1663, 27)" end="(1663, 39)" kind="str">
            <AtomNode start="(1663, 27)" end="(1663, 39)" leading="" trailing=" " val="&amp;quot;show_term &amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1663, 40)" end="(1663, 49)" kind="Lean.Parser.Syntax.cat">
          <IdentNode start="(1663, 40)" end="(1663, 49)" leading="" trailing=" " raw_val="tacticSeq" val="tacticSeq" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
          <NullNode/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1663, 50)" end="(1663, 51)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1663, 52)" end="(1663, 58)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(1665, 1)" end="(1669, 55)" kind="Lean.Parser.Command.macro">
      <NullNode start="(1665, 1)" end="(1667, 3)">
        <CommandDoccommentNode start="(1665, 1)" end="(1667, 3)" comment="`show_term e` elaborates `e`, then prints the generated term.&#10;-/">
          <AtomNode start="(1665, 1)" end="(1665, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1666, 1)" end="(1667, 3)" leading="" trailing="&#10;" val="`show_term e` elaborates `e`, then prints the generated term.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1668, 1)" end="(1668, 6)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode start="(1668, 7)" end="(1668, 29)">
        <OtherNode start="(1668, 7)" end="(1668, 29)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1668, 7)" end="(1668, 8)" leading="" trailing="" val="("/>
          <AtomNode start="(1668, 8)" end="(1668, 12)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1668, 13)" end="(1668, 15)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1668, 16)" end="(1668, 28)" leading="" trailing="" raw_val="showTermElab" val="showTermElab"/>
          <AtomNode start="(1668, 28)" end="(1668, 29)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(1668, 30)" end="(1668, 52)">
        <OtherNode start="(1668, 30)" end="(1668, 45)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(1668, 30)" end="(1668, 33)">
            <IdentNode start="(1668, 30)" end="(1668, 32)" leading="" trailing="" raw_val="tk" val="tk"/>
            <AtomNode start="(1668, 32)" end="(1668, 33)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(1668, 33)" end="(1668, 45)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(1668, 33)" end="(1668, 45)" kind="str">
              <AtomNode start="(1668, 33)" end="(1668, 45)" leading="" trailing=" " val="&amp;quot;show_term &amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1668, 46)" end="(1668, 52)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(1668, 46)" end="(1668, 48)">
            <IdentNode start="(1668, 46)" end="(1668, 47)" leading="" trailing="" raw_val="t" val="t"/>
            <AtomNode start="(1668, 47)" end="(1668, 48)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(1668, 48)" end="(1668, 52)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(1668, 48)" end="(1668, 52)" leading="" trailing=" " raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(1668, 53)" end="(1669, 55)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(1668, 53)" end="(1668, 54)" leading="" trailing=" " val=":"/>
        <IdentNode start="(1668, 55)" end="(1668, 59)" leading="" trailing=" " raw_val="term" val="term" full_name="Lean.Parser.Category.term" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(1668, 60)" end="(1668, 62)" leading="" trailing="&#10;  " val="=&amp;gt;"/>
        <OtherNode start="(1669, 3)" end="(1669, 55)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(1669, 3)" end="(1669, 55)" kind="Lean.Parser.Term.dynamicQuot">
            <AtomNode start="(1669, 3)" end="(1669, 5)" leading="" trailing="" val="`("/>
            <IdentNode start="(1669, 5)" end="(1669, 9)" leading="" trailing="" raw_val="term" val="term" full_name="Lean.Parser.Category.term" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
            <AtomNode start="(1669, 9)" end="(1669, 10)" leading="" trailing=" " val="|"/>
            <OtherNode start="(1669, 11)" end="(1669, 54)" kind="Lean.Parser.Term.noImplicitLambda">
              <AtomNode start="(1669, 11)" end="(1669, 30)" leading="" trailing=" " val="no_implicit_lambda%"/>
              <OtherNode start="(1669, 31)" end="(1669, 54)" kind="Lean.Parser.Term.paren">
                <AtomNode start="(1669, 31)" end="(1669, 32)" leading="" trailing="" val="("/>
                <OtherNode start="(1669, 32)" end="(1669, 53)" kind="Lean.Parser.Term.showTermElabImpl">
                  <TokenAntiquotNode start="(1669, 32)" end="(1669, 50)">
                    <AtomNode start="(1669, 32)" end="(1669, 46)" leading="" trailing="" val="show_term_elab"/>
                    <AtomNode start="(1669, 46)" end="(1669, 47)" leading="" trailing="" val="%"/>
                    <AtomNode start="(1669, 47)" end="(1669, 48)" leading="" trailing="" val="$"/>
                    <IdentNode start="(1669, 48)" end="(1669, 50)" leading="" trailing=" " raw_val="tk" val="tk"/>
                  </TokenAntiquotNode>
                  <OtherNode start="(1669, 51)" end="(1669, 53)" kind="term.pseudo.antiquot">
                    <AtomNode start="(1669, 51)" end="(1669, 52)" leading="" trailing="" val="$"/>
                    <NullNode/>
                    <IdentNode start="(1669, 52)" end="(1669, 53)" leading="" trailing="" raw_val="t" val="t"/>
                    <NullNode/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(1669, 53)" end="(1669, 54)" leading="" trailing="" val=")"/>
              </OtherNode>
            </OtherNode>
            <AtomNode start="(1669, 54)" end="(1669, 55)" leading="" trailing="&#10;&#10;" val=")"/>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(1671, 1)" end="(1675, 78)" kind="Lean.Parser.Command.macro">
      <NullNode start="(1671, 1)" end="(1674, 3)">
        <CommandDoccommentNode start="(1671, 1)" end="(1674, 3)" comment="The command `by?` will print a suggestion for replacing the proof block with a proof term&#10;using `show_term`.&#10;-/">
          <AtomNode start="(1671, 1)" end="(1671, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1672, 1)" end="(1674, 3)" leading="" trailing="&#10;" val="The command `by?` will print a suggestion for replacing the proof block with a proof term&#10;using `show_term`.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1675, 1)" end="(1675, 6)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode start="(1675, 7)" end="(1675, 20)">
        <OtherNode start="(1675, 7)" end="(1675, 20)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1675, 7)" end="(1675, 8)" leading="" trailing="" val="("/>
          <AtomNode start="(1675, 8)" end="(1675, 12)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1675, 13)" end="(1675, 15)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1675, 16)" end="(1675, 19)" leading="" trailing="" raw_val="by?" val="by?"/>
          <AtomNode start="(1675, 19)" end="(1675, 20)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(1675, 21)" end="(1675, 41)">
        <OtherNode start="(1675, 21)" end="(1675, 29)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(1675, 21)" end="(1675, 24)">
            <IdentNode start="(1675, 21)" end="(1675, 23)" leading="" trailing="" raw_val="tk" val="tk"/>
            <AtomNode start="(1675, 23)" end="(1675, 24)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(1675, 24)" end="(1675, 29)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(1675, 24)" end="(1675, 29)" kind="str">
              <AtomNode start="(1675, 24)" end="(1675, 29)" leading="" trailing=" " val="&amp;quot;by?&amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1675, 30)" end="(1675, 41)" kind="Lean.Parser.Command.macroArg">
          <NullNode start="(1675, 30)" end="(1675, 32)">
            <IdentNode start="(1675, 30)" end="(1675, 31)" leading="" trailing="" raw_val="t" val="t"/>
            <AtomNode start="(1675, 31)" end="(1675, 32)" leading="" trailing="" val=":"/>
          </NullNode>
          <OtherNode start="(1675, 32)" end="(1675, 41)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(1675, 32)" end="(1675, 41)" leading="" trailing=" " raw_val="tacticSeq" val="tacticSeq" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(1675, 42)" end="(1675, 78)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(1675, 42)" end="(1675, 43)" leading="" trailing=" " val=":"/>
        <IdentNode start="(1675, 44)" end="(1675, 48)" leading="" trailing=" " raw_val="term" val="term" full_name="Lean.Parser.Category.term" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(1675, 49)" end="(1675, 51)" leading="" trailing=" " val="=&amp;gt;"/>
        <OtherNode start="(1675, 52)" end="(1675, 78)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(1675, 52)" end="(1675, 78)" kind="Lean.Parser.Term.quot">
            <AtomNode start="(1675, 52)" end="(1675, 54)" leading="" trailing="" val="`("/>
            <OtherNode start="(1675, 54)" end="(1675, 77)" kind="Lean.Parser.Tactic.showTermElab">
              <TokenAntiquotNode start="(1675, 54)" end="(1675, 67)">
                <AtomNode start="(1675, 54)" end="(1675, 63)" leading="" trailing="" val="show_term"/>
                <AtomNode start="(1675, 63)" end="(1675, 64)" leading="" trailing="" val="%"/>
                <AtomNode start="(1675, 64)" end="(1675, 65)" leading="" trailing="" val="$"/>
                <IdentNode start="(1675, 65)" end="(1675, 67)" leading="" trailing=" " raw_val="tk" val="tk"/>
              </TokenAntiquotNode>
              <TermBytacticNode start="(1675, 68)" end="(1675, 77)">
                <TokenAntiquotNode start="(1675, 68)" end="(1675, 74)">
                  <AtomNode start="(1675, 68)" end="(1675, 70)" leading="" trailing="" val="by"/>
                  <AtomNode start="(1675, 70)" end="(1675, 71)" leading="" trailing="" val="%"/>
                  <AtomNode start="(1675, 71)" end="(1675, 72)" leading="" trailing="" val="$"/>
                  <IdentNode start="(1675, 72)" end="(1675, 74)" leading="" trailing=" " raw_val="tk" val="tk"/>
                </TokenAntiquotNode>
                <OtherNode start="(1675, 75)" end="(1675, 77)" kind="Lean.Parser.Tactic.tacticSeq.antiquot">
                  <AtomNode start="(1675, 75)" end="(1675, 76)" leading="" trailing="" val="$"/>
                  <NullNode/>
                  <IdentNode start="(1675, 76)" end="(1675, 77)" leading="" trailing="" raw_val="t" val="t"/>
                  <NullNode/>
                </OtherNode>
              </TermBytacticNode>
            </OtherNode>
            <AtomNode start="(1675, 77)" end="(1675, 78)" leading="" trailing="&#10;&#10;" val=")"/>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(1677, 1)" end="(1687, 53)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1677, 1)" end="(1686, 3)">
        <CommandDoccommentNode start="(1677, 1)" end="(1686, 3)" comment="`expose_names` renames all inaccessible variables with accessible names, making them available&#10;for reference in generated tactics. However, this renaming introduces machine-generated names&#10;that are not fully under user control. `expose_names` is primarily intended as a preamble for&#10;auto-generated end-game tactic scripts. It is also useful as an alternative to&#10;`set_option tactic.hygienic false`. If explicit control over renaming is needed in the&#10;middle of a tactic script, consider using structured tactic scripts with&#10;`match .. with`, `induction .. with`, or `intro` with explicit user-defined names,&#10;as well as tactics such as `next`, `case`, and `rename_i`.&#10;-/">
          <AtomNode start="(1677, 1)" end="(1677, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1678, 1)" end="(1686, 3)" leading="" trailing="&#10;" val="`expose_names` renames all inaccessible variables with accessible names, making them available&#10;for reference in generated tactics. However, this renaming introduces machine-generated names&#10;that are not fully under user control. `expose_names` is primarily intended as a preamble for&#10;auto-generated end-game tactic scripts. It is also useful as an alternative to&#10;`set_option tactic.hygienic false`. If explicit control over renaming is needed in the&#10;middle of a tactic script, consider using structured tactic scripts with&#10;`match .. with`, `induction .. with`, or `intro` with explicit user-defined names,&#10;as well as tactics such as `next`, `case`, and `rename_i`.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1687, 1)" end="(1687, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(1687, 8)" end="(1687, 29)">
        <OtherNode start="(1687, 8)" end="(1687, 29)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1687, 8)" end="(1687, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(1687, 9)" end="(1687, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1687, 14)" end="(1687, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1687, 17)" end="(1687, 28)" leading="" trailing="" raw_val="exposeNames" val="exposeNames"/>
          <AtomNode start="(1687, 28)" end="(1687, 29)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(1687, 30)" end="(1687, 44)">
        <OtherNode start="(1687, 30)" end="(1687, 44)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1687, 30)" end="(1687, 44)" kind="str">
            <AtomNode start="(1687, 30)" end="(1687, 44)" leading="" trailing=" " val="&amp;quot;expose_names&amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1687, 45)" end="(1687, 46)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1687, 47)" end="(1687, 53)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(1689, 1)" end="(1694, 61)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1689, 1)" end="(1693, 3)">
        <CommandDoccommentNode start="(1689, 1)" end="(1693, 3)" comment="`#suggest_premises` will suggest premises for the current goal, using the currently registered premise selector.&#10;&#10;The suggestions are printed in the order of their confidence, from highest to lowest.&#10;-/">
          <AtomNode start="(1689, 1)" end="(1689, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1690, 1)" end="(1693, 3)" leading="" trailing="&#10;" val="`#suggest_premises` will suggest premises for the current goal, using the currently registered premise selector.&#10;&#10;The suggestions are printed in the order of their confidence, from highest to lowest.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1694, 1)" end="(1694, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(1694, 8)" end="(1694, 33)">
        <OtherNode start="(1694, 8)" end="(1694, 33)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1694, 8)" end="(1694, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(1694, 9)" end="(1694, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1694, 14)" end="(1694, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1694, 17)" end="(1694, 32)" leading="" trailing="" raw_val="suggestPremises" val="suggestPremises"/>
          <AtomNode start="(1694, 32)" end="(1694, 33)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(1694, 34)" end="(1694, 52)">
        <OtherNode start="(1694, 34)" end="(1694, 52)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1694, 34)" end="(1694, 52)" kind="str">
            <AtomNode start="(1694, 34)" end="(1694, 52)" leading="" trailing=" " val="&amp;quot;suggest_premises&amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1694, 53)" end="(1694, 54)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1694, 55)" end="(1694, 61)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(1696, 1)" end="(1725, 85)" kind="Lean.Parser.Command.macro">
      <NullNode start="(1696, 1)" end="(1723, 3)">
        <CommandDoccommentNode start="(1696, 1)" end="(1723, 3)" comment="Close fixed-width `BitVec` and `Bool` goals by obtaining a proof from an external SAT solver and&#10;verifying it inside Lean. The solvable goals are currently limited to&#10;- the Lean equivalent of [`QF_BV`](https://smt-lib.org/logics-all.shtml#QF_BV)&#10;- automatically splitting up `structure`s that contain information about `BitVec` or `Bool`&#10;```lean&#10;example : ∀ (a b : BitVec 64), (a &amp;amp;&amp;amp;&amp;amp; b) + (a ^^^ b) = a ||| b := by&#10;  intros&#10;  bv_decide&#10;```&#10;&#10;If `bv_decide` encounters an unknown definition it will be treated like an unconstrained `BitVec`&#10;variable. Sometimes this enables solving goals despite not understanding the definition because&#10;the precise properties of the definition do not matter in the specific proof.&#10;&#10;If `bv_decide` fails to close a goal it provides a counter-example, containing assignments for all&#10;terms that were considered as variables.&#10;&#10;In order to avoid calling a SAT solver every time, the proof can be cached with `bv_decide?`.&#10;&#10;If solving your problem relies inherently on using associativity or commutativity, consider enabling&#10;the `bv.ac_nf` option.&#10;&#10;&#10;Note: `bv_decide` uses `ofReduceBool` and thus trusts the correctness of the code generator.&#10;&#10;Note: include `import Std.Tactic.BVDecide`&#10;-/">
          <AtomNode start="(1696, 1)" end="(1696, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1697, 1)" end="(1723, 3)" leading="" trailing="&#10;" val="Close fixed-width `BitVec` and `Bool` goals by obtaining a proof from an external SAT solver and&#10;verifying it inside Lean. The solvable goals are currently limited to&#10;- the Lean equivalent of [`QF_BV`](https://smt-lib.org/logics-all.shtml#QF_BV)&#10;- automatically splitting up `structure`s that contain information about `BitVec` or `Bool`&#10;```lean&#10;example : ∀ (a b : BitVec 64), (a &amp;amp;&amp;amp;&amp;amp; b) + (a ^^^ b) = a ||| b := by&#10;  intros&#10;  bv_decide&#10;```&#10;&#10;If `bv_decide` encounters an unknown definition it will be treated like an unconstrained `BitVec`&#10;variable. Sometimes this enables solving goals despite not understanding the definition because&#10;the precise properties of the definition do not matter in the specific proof.&#10;&#10;If `bv_decide` fails to close a goal it provides a counter-example, containing assignments for all&#10;terms that were considered as variables.&#10;&#10;In order to avoid calling a SAT solver every time, the proof can be cached with `bv_decide?`.&#10;&#10;If solving your problem relies inherently on using associativity or commutativity, consider enabling&#10;the `bv.ac_nf` option.&#10;&#10;&#10;Note: `bv_decide` uses `ofReduceBool` and thus trusts the correctness of the code generator.&#10;&#10;Note: include `import Std.Tactic.BVDecide`&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1724, 1)" end="(1724, 6)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode start="(1724, 7)" end="(1724, 30)">
        <OtherNode start="(1724, 7)" end="(1724, 30)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1724, 7)" end="(1724, 8)" leading="" trailing="" val="("/>
          <AtomNode start="(1724, 8)" end="(1724, 12)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1724, 13)" end="(1724, 15)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1724, 16)" end="(1724, 29)" leading="" trailing="" raw_val="bvDecideMacro" val="bvDecideMacro"/>
          <AtomNode start="(1724, 29)" end="(1724, 30)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode start="(1724, 31)" end="(1724, 46)">
        <OtherNode start="(1724, 31)" end="(1724, 46)" kind="Lean.Parser.Command.namedPrio">
          <AtomNode start="(1724, 31)" end="(1724, 32)" leading="" trailing="" val="("/>
          <AtomNode start="(1724, 32)" end="(1724, 40)" leading="" trailing="" val="priority"/>
          <AtomNode start="(1724, 40)" end="(1724, 42)" leading="" trailing="" val=":="/>
          <OtherNode start="(1724, 42)" end="(1724, 45)" kind="prioLow">
            <AtomNode start="(1724, 42)" end="(1724, 45)" leading="" trailing="" val="low"/>
          </OtherNode>
          <AtomNode start="(1724, 45)" end="(1724, 46)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode start="(1724, 47)" end="(1724, 68)">
        <OtherNode start="(1724, 47)" end="(1724, 58)" kind="Lean.Parser.Command.macroArg">
          <NullNode/>
          <OtherNode start="(1724, 47)" end="(1724, 58)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(1724, 47)" end="(1724, 58)" kind="str">
              <AtomNode start="(1724, 47)" end="(1724, 58)" leading="" trailing=" " val="&amp;quot;bv_decide&amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1724, 59)" end="(1724, 68)" kind="Lean.Parser.Command.macroArg">
          <NullNode/>
          <OtherNode start="(1724, 59)" end="(1724, 68)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(1724, 59)" end="(1724, 68)" leading="" trailing=" " raw_val="optConfig" val="optConfig" full_name="Lean.Parser.Tactic.optConfig" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(458, 8)" def_end="(458, 17)"/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(1724, 69)" end="(1725, 85)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(1724, 69)" end="(1724, 70)" leading="" trailing=" " val=":"/>
        <IdentNode start="(1724, 71)" end="(1724, 77)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(1724, 78)" end="(1724, 80)" leading="" trailing="&#10;  " val="=&amp;gt;"/>
        <OtherNode start="(1725, 3)" end="(1725, 85)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(1725, 3)" end="(1725, 85)" kind="Lean.Parser.Term.app">
            <IdentNode start="(1725, 3)" end="(1725, 19)" leading="" trailing=" " raw_val="Macro.throwError" val="Macro.throwError" full_name="Lean.Macro.throwError" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            <NullNode start="(1725, 20)" end="(1725, 85)">
              <OtherNode start="(1725, 20)" end="(1725, 85)" kind="str">
                <AtomNode start="(1725, 20)" end="(1725, 85)" leading="" trailing="&#10;&#10;&#10;" val="&amp;quot;to use `bv_decide`, please include `import Std.Tactic.BVDecide`&amp;quot;"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(1728, 1)" end="(1734, 86)" kind="Lean.Parser.Command.macro">
      <NullNode start="(1728, 1)" end="(1732, 3)">
        <CommandDoccommentNode start="(1728, 1)" end="(1732, 3)" comment="Suggest a proof script for a `bv_decide` tactic call. Useful for caching LRAT proofs.&#10;&#10;Note: include `import Std.Tactic.BVDecide`&#10;-/">
          <AtomNode start="(1728, 1)" end="(1728, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1729, 1)" end="(1732, 3)" leading="" trailing="&#10;" val="Suggest a proof script for a `bv_decide` tactic call. Useful for caching LRAT proofs.&#10;&#10;Note: include `import Std.Tactic.BVDecide`&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1733, 1)" end="(1733, 6)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode start="(1733, 7)" end="(1733, 29)">
        <OtherNode start="(1733, 7)" end="(1733, 29)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1733, 7)" end="(1733, 8)" leading="" trailing="" val="("/>
          <AtomNode start="(1733, 8)" end="(1733, 12)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1733, 13)" end="(1733, 15)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1733, 16)" end="(1733, 28)" leading="" trailing="" raw_val="bvTraceMacro" val="bvTraceMacro"/>
          <AtomNode start="(1733, 28)" end="(1733, 29)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode start="(1733, 30)" end="(1733, 45)">
        <OtherNode start="(1733, 30)" end="(1733, 45)" kind="Lean.Parser.Command.namedPrio">
          <AtomNode start="(1733, 30)" end="(1733, 31)" leading="" trailing="" val="("/>
          <AtomNode start="(1733, 31)" end="(1733, 39)" leading="" trailing="" val="priority"/>
          <AtomNode start="(1733, 39)" end="(1733, 41)" leading="" trailing="" val=":="/>
          <OtherNode start="(1733, 41)" end="(1733, 44)" kind="prioLow">
            <AtomNode start="(1733, 41)" end="(1733, 44)" leading="" trailing="" val="low"/>
          </OtherNode>
          <AtomNode start="(1733, 44)" end="(1733, 45)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode start="(1733, 46)" end="(1733, 68)">
        <OtherNode start="(1733, 46)" end="(1733, 58)" kind="Lean.Parser.Command.macroArg">
          <NullNode/>
          <OtherNode start="(1733, 46)" end="(1733, 58)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(1733, 46)" end="(1733, 58)" kind="str">
              <AtomNode start="(1733, 46)" end="(1733, 58)" leading="" trailing=" " val="&amp;quot;bv_decide?&amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1733, 59)" end="(1733, 68)" kind="Lean.Parser.Command.macroArg">
          <NullNode/>
          <OtherNode start="(1733, 59)" end="(1733, 68)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(1733, 59)" end="(1733, 68)" leading="" trailing=" " raw_val="optConfig" val="optConfig" full_name="Lean.Parser.Tactic.optConfig" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(458, 8)" def_end="(458, 17)"/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(1733, 69)" end="(1734, 86)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(1733, 69)" end="(1733, 70)" leading="" trailing=" " val=":"/>
        <IdentNode start="(1733, 71)" end="(1733, 77)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(1733, 78)" end="(1733, 80)" leading="" trailing="&#10;  " val="=&amp;gt;"/>
        <OtherNode start="(1734, 3)" end="(1734, 86)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(1734, 3)" end="(1734, 86)" kind="Lean.Parser.Term.app">
            <IdentNode start="(1734, 3)" end="(1734, 19)" leading="" trailing=" " raw_val="Macro.throwError" val="Macro.throwError" full_name="Lean.Macro.throwError" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            <NullNode start="(1734, 20)" end="(1734, 86)">
              <OtherNode start="(1734, 20)" end="(1734, 86)" kind="str">
                <AtomNode start="(1734, 20)" end="(1734, 86)" leading="" trailing="&#10;&#10;&#10;" val="&amp;quot;to use `bv_decide?`, please include `import Std.Tactic.BVDecide`&amp;quot;"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(1737, 1)" end="(1744, 88)" kind="Lean.Parser.Command.macro">
      <NullNode start="(1737, 1)" end="(1742, 3)">
        <CommandDoccommentNode start="(1737, 1)" end="(1742, 3)" comment="Run the normalization procedure of `bv_decide` only. Sometimes this is enough to solve basic&#10;`BitVec` goals already.&#10;&#10;Note: include `import Std.Tactic.BVDecide`&#10;-/">
          <AtomNode start="(1737, 1)" end="(1737, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1738, 1)" end="(1742, 3)" leading="" trailing="&#10;" val="Run the normalization procedure of `bv_decide` only. Sometimes this is enough to solve basic&#10;`BitVec` goals already.&#10;&#10;Note: include `import Std.Tactic.BVDecide`&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1743, 1)" end="(1743, 6)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode start="(1743, 7)" end="(1743, 33)">
        <OtherNode start="(1743, 7)" end="(1743, 33)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1743, 7)" end="(1743, 8)" leading="" trailing="" val="("/>
          <AtomNode start="(1743, 8)" end="(1743, 12)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1743, 13)" end="(1743, 15)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1743, 16)" end="(1743, 32)" leading="" trailing="" raw_val="bvNormalizeMacro" val="bvNormalizeMacro"/>
          <AtomNode start="(1743, 32)" end="(1743, 33)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode start="(1743, 34)" end="(1743, 49)">
        <OtherNode start="(1743, 34)" end="(1743, 49)" kind="Lean.Parser.Command.namedPrio">
          <AtomNode start="(1743, 34)" end="(1743, 35)" leading="" trailing="" val="("/>
          <AtomNode start="(1743, 35)" end="(1743, 43)" leading="" trailing="" val="priority"/>
          <AtomNode start="(1743, 43)" end="(1743, 45)" leading="" trailing="" val=":="/>
          <OtherNode start="(1743, 45)" end="(1743, 48)" kind="prioLow">
            <AtomNode start="(1743, 45)" end="(1743, 48)" leading="" trailing="" val="low"/>
          </OtherNode>
          <AtomNode start="(1743, 48)" end="(1743, 49)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode start="(1743, 50)" end="(1743, 74)">
        <OtherNode start="(1743, 50)" end="(1743, 64)" kind="Lean.Parser.Command.macroArg">
          <NullNode/>
          <OtherNode start="(1743, 50)" end="(1743, 64)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(1743, 50)" end="(1743, 64)" kind="str">
              <AtomNode start="(1743, 50)" end="(1743, 64)" leading="" trailing=" " val="&amp;quot;bv_normalize&amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1743, 65)" end="(1743, 74)" kind="Lean.Parser.Command.macroArg">
          <NullNode/>
          <OtherNode start="(1743, 65)" end="(1743, 74)" kind="Lean.Parser.Syntax.cat">
            <IdentNode start="(1743, 65)" end="(1743, 74)" leading="" trailing=" " raw_val="optConfig" val="optConfig" full_name="Lean.Parser.Tactic.optConfig" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(458, 8)" def_end="(458, 17)"/>
            <NullNode/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(1743, 75)" end="(1744, 88)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(1743, 75)" end="(1743, 76)" leading="" trailing=" " val=":"/>
        <IdentNode start="(1743, 77)" end="(1743, 83)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(1743, 84)" end="(1743, 86)" leading="" trailing="&#10;  " val="=&amp;gt;"/>
        <OtherNode start="(1744, 3)" end="(1744, 88)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(1744, 3)" end="(1744, 88)" kind="Lean.Parser.Term.app">
            <IdentNode start="(1744, 3)" end="(1744, 19)" leading="" trailing=" " raw_val="Macro.throwError" val="Macro.throwError" full_name="Lean.Macro.throwError" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
            <NullNode start="(1744, 20)" end="(1744, 88)">
              <OtherNode start="(1744, 20)" end="(1744, 88)" kind="str">
                <AtomNode start="(1744, 20)" end="(1744, 88)" leading="" trailing="&#10;&#10;&#10;" val="&amp;quot;to use `bv_normalize`, please include `import Std.Tactic.BVDecide`&amp;quot;"/>
              </OtherNode>
            </NullNode>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <CommandEndNode start="(1747, 1)" end="(1747, 11)" name="Tactic">
      <AtomNode start="(1747, 1)" end="(1747, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(1747, 5)" end="(1747, 11)">
        <IdentNode start="(1747, 5)" end="(1747, 11)" leading="" trailing="&#10;&#10;" raw_val="Tactic" val="Tactic"/>
      </NullNode>
    </CommandEndNode>
    <CommandNamespaceNode start="(1749, 1)" end="(1749, 15)" name="Attr">
      <AtomNode start="(1749, 1)" end="(1749, 10)" leading="" trailing=" " val="namespace"/>
      <IdentNode start="(1749, 11)" end="(1749, 15)" leading="" trailing="&#10;" raw_val="Attr" val="Attr"/>
    </CommandNamespaceNode>
    <OtherNode start="(1750, 1)" end="(1799, 121)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1750, 1)" end="(1798, 3)">
        <CommandDoccommentNode start="(1750, 1)" end="(1798, 3)" comment="Theorems tagged with the `simp` attribute are used by the simplifier&#10;(i.e., the `simp` tactic, and its variants) to simplify expressions occurring in your goals.&#10;We call theorems tagged with the `simp` attribute &amp;quot;simp theorems&amp;quot; or &amp;quot;simp lemmas&amp;quot;.&#10;Lean maintains a database/index containing all active simp theorems.&#10;Here is an example of a simp theorem.&#10;```lean&#10;@[simp] theorem ne_eq (a b : α) : (a ≠ b) = Not (a = b) := rfl&#10;```&#10;This simp theorem instructs the simplifier to replace instances of the term&#10;`a ≠ b` (e.g. `x + 0 ≠ y`) with `Not (a = b)` (e.g., `Not (x + 0 = y)`).&#10;The simplifier applies simp theorems in one direction only:&#10;if `A = B` is a simp theorem, then `simp` replaces `A`s with `B`s,&#10;but it doesn't replace `B`s with `A`s. Hence a simp theorem should have the&#10;property that its right-hand side is &amp;quot;simpler&amp;quot; than its left-hand side.&#10;In particular, `=` and `↔` should not be viewed as symmetric operators in this situation.&#10;The following would be a terrible simp theorem (if it were even allowed):&#10;```lean&#10;@[simp] lemma mul_right_inv_bad (a : G) : 1 = a * a⁻¹ := ...&#10;```&#10;Replacing 1 with a * a⁻¹ is not a sensible default direction to travel.&#10;Even worse would be a theorem that causes expressions to grow without bound,&#10;causing simp to loop forever.&#10;&#10;By default the simplifier applies `simp` theorems to an expression `e`&#10;after its sub-expressions have been simplified.&#10;We say it performs a bottom-up simplification.&#10;You can instruct the simplifier to apply a theorem before its sub-expressions&#10;have been simplified by using the modifier `↓`. Here is an example&#10;```lean&#10;@[simp↓] theorem not_and_eq (p q : Prop) : (¬ (p ∧ q)) = (¬p ∨ ¬q) :=&#10;```&#10;&#10;You can instruct the simplifier to rewrite the lemma from right-to-left:&#10;```lean&#10;attribute @[simp ←] and_assoc&#10;```&#10;&#10;When multiple simp theorems are applicable, the simplifier uses the one with highest priority.&#10;The equational theorems of functions are applied at very low priority (100 and below).&#10;If there are several with the same priority, it is uses the &amp;quot;most recent one&amp;quot;. Example:&#10;```lean&#10;@[simp high] theorem cond_true (a b : α) : cond true a b = a := rfl&#10;@[simp low+1] theorem or_true (p : Prop) : (p ∨ True) = True :=&#10;  propext &amp;lt;| Iff.intro (fun _ =&amp;gt; trivial) (fun _ =&amp;gt; Or.inr trivial)&#10;@[simp 100] theorem ite_self {d : Decidable c} (a : α) : ite c a a = a := by&#10;  cases d &amp;lt;;&amp;gt; rfl&#10;```&#10;-/">
          <AtomNode start="(1750, 1)" end="(1750, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1751, 1)" end="(1798, 3)" leading="" trailing="&#10;" val="Theorems tagged with the `simp` attribute are used by the simplifier&#10;(i.e., the `simp` tactic, and its variants) to simplify expressions occurring in your goals.&#10;We call theorems tagged with the `simp` attribute &amp;quot;simp theorems&amp;quot; or &amp;quot;simp lemmas&amp;quot;.&#10;Lean maintains a database/index containing all active simp theorems.&#10;Here is an example of a simp theorem.&#10;```lean&#10;@[simp] theorem ne_eq (a b : α) : (a ≠ b) = Not (a = b) := rfl&#10;```&#10;This simp theorem instructs the simplifier to replace instances of the term&#10;`a ≠ b` (e.g. `x + 0 ≠ y`) with `Not (a = b)` (e.g., `Not (x + 0 = y)`).&#10;The simplifier applies simp theorems in one direction only:&#10;if `A = B` is a simp theorem, then `simp` replaces `A`s with `B`s,&#10;but it doesn't replace `B`s with `A`s. Hence a simp theorem should have the&#10;property that its right-hand side is &amp;quot;simpler&amp;quot; than its left-hand side.&#10;In particular, `=` and `↔` should not be viewed as symmetric operators in this situation.&#10;The following would be a terrible simp theorem (if it were even allowed):&#10;```lean&#10;@[simp] lemma mul_right_inv_bad (a : G) : 1 = a * a⁻¹ := ...&#10;```&#10;Replacing 1 with a * a⁻¹ is not a sensible default direction to travel.&#10;Even worse would be a theorem that causes expressions to grow without bound,&#10;causing simp to loop forever.&#10;&#10;By default the simplifier applies `simp` theorems to an expression `e`&#10;after its sub-expressions have been simplified.&#10;We say it performs a bottom-up simplification.&#10;You can instruct the simplifier to apply a theorem before its sub-expressions&#10;have been simplified by using the modifier `↓`. Here is an example&#10;```lean&#10;@[simp↓] theorem not_and_eq (p q : Prop) : (¬ (p ∧ q)) = (¬p ∨ ¬q) :=&#10;```&#10;&#10;You can instruct the simplifier to rewrite the lemma from right-to-left:&#10;```lean&#10;attribute @[simp ←] and_assoc&#10;```&#10;&#10;When multiple simp theorems are applicable, the simplifier uses the one with highest priority.&#10;The equational theorems of functions are applied at very low priority (100 and below).&#10;If there are several with the same priority, it is uses the &amp;quot;most recent one&amp;quot;. Example:&#10;```lean&#10;@[simp high] theorem cond_true (a b : α) : cond true a b = a := rfl&#10;@[simp low+1] theorem or_true (p : Prop) : (p ∨ True) = True :=&#10;  propext &amp;lt;| Iff.intro (fun _ =&amp;gt; trivial) (fun _ =&amp;gt; Or.inr trivial)&#10;@[simp 100] theorem ite_self {d : Decidable c} (a : α) : ite c a a = a := by&#10;  cases d &amp;lt;;&amp;gt; rfl&#10;```&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1799, 1)" end="(1799, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(1799, 8)" end="(1799, 22)">
        <OtherNode start="(1799, 8)" end="(1799, 22)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1799, 8)" end="(1799, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(1799, 9)" end="(1799, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1799, 14)" end="(1799, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1799, 17)" end="(1799, 21)" leading="" trailing="" raw_val="simp" val="simp"/>
          <AtomNode start="(1799, 21)" end="(1799, 22)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(1799, 23)" end="(1799, 114)">
        <OtherNode start="(1799, 23)" end="(1799, 29)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1799, 23)" end="(1799, 29)" kind="str">
            <AtomNode start="(1799, 23)" end="(1799, 29)" leading="" trailing=" " val="&amp;quot;simp&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1799, 30)" end="(1799, 67)" kind="stx_?">
          <OtherNode start="(1799, 30)" end="(1799, 66)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(1799, 30)" end="(1799, 31)" leading="" trailing="" val="("/>
            <NullNode start="(1799, 31)" end="(1799, 65)">
              <OtherNode start="(1799, 31)" end="(1799, 65)" kind="«stx_&amp;lt;|&amp;gt;_»">
                <OtherNode start="(1799, 31)" end="(1799, 45)" kind="Lean.Parser.Syntax.cat">
                  <IdentNode start="(1799, 31)" end="(1799, 45)" leading="" trailing=" " raw_val="Tactic.simpPre" val="Tactic.simpPre" full_name="Lean.Parser.Tactic.simpPre" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(605, 8)" def_end="(605, 15)"/>
                  <NullNode/>
                </OtherNode>
                <AtomNode start="(1799, 46)" end="(1799, 49)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
                <OtherNode start="(1799, 50)" end="(1799, 65)" kind="Lean.Parser.Syntax.cat">
                  <IdentNode start="(1799, 50)" end="(1799, 65)" leading="" trailing="" raw_val="Tactic.simpPost" val="Tactic.simpPost" full_name="Lean.Parser.Tactic.simpPost" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(607, 8)" def_end="(607, 16)"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1799, 65)" end="(1799, 66)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(1799, 66)" end="(1799, 67)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(1799, 68)" end="(1799, 98)" kind="stx_?">
          <OtherNode start="(1799, 68)" end="(1799, 97)" kind="Lean.Parser.Syntax.unary">
            <IdentNode start="(1799, 68)" end="(1799, 81)" leading="" trailing="" raw_val="patternIgnore" val="patternIgnore"/>
            <AtomNode start="(1799, 81)" end="(1799, 82)" leading="" trailing="" val="("/>
            <NullNode start="(1799, 82)" end="(1799, 96)">
              <OtherNode start="(1799, 82)" end="(1799, 96)" kind="«stx_&amp;lt;|&amp;gt;_»">
                <OtherNode start="(1799, 82)" end="(1799, 86)" kind="Lean.Parser.Syntax.atom">
                  <OtherNode start="(1799, 82)" end="(1799, 86)" kind="str">
                    <AtomNode start="(1799, 82)" end="(1799, 86)" leading="" trailing=" " val="&amp;quot;← &amp;quot;"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(1799, 87)" end="(1799, 90)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
                <OtherNode start="(1799, 91)" end="(1799, 96)" kind="Lean.Parser.Syntax.atom">
                  <OtherNode start="(1799, 91)" end="(1799, 96)" kind="str">
                    <AtomNode start="(1799, 91)" end="(1799, 96)" leading="" trailing="" val="&amp;quot;&amp;lt;- &amp;quot;"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1799, 96)" end="(1799, 97)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(1799, 97)" end="(1799, 98)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(1799, 99)" end="(1799, 114)" kind="stx_?">
          <OtherNode start="(1799, 99)" end="(1799, 113)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(1799, 99)" end="(1799, 100)" leading="" trailing="" val="("/>
            <NullNode start="(1799, 100)" end="(1799, 112)">
              <OtherNode start="(1799, 100)" end="(1799, 107)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(1799, 100)" end="(1799, 107)" leading="" trailing=" " raw_val="ppSpace" val="ppSpace" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(1799, 108)" end="(1799, 112)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(1799, 108)" end="(1799, 112)" leading="" trailing="" raw_val="prio" val="prio" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1799, 112)" end="(1799, 113)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(1799, 113)" end="(1799, 114)" leading="" trailing=" " val="?"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1799, 115)" end="(1799, 116)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1799, 117)" end="(1799, 121)" leading="" trailing="&#10;&#10;" raw_val="attr" val="attr" full_name="Lean.Parser.Category.attr" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(1801, 1)" end="(1807, 139)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1801, 1)" end="(1806, 3)">
        <CommandDoccommentNode start="(1801, 1)" end="(1806, 3)" comment="Theorems tagged with the `wf_preprocess` attribute are used during the processing of functions defined&#10;by well-founded recursion. They are applied to the function's body to add additional hypotheses,&#10;such as replacing `if c then _ else _` with `if h : c then _ else _` or `xs.map` with&#10;`xs.attach.map`. Also see `wfParam`.&#10;-/">
          <AtomNode start="(1801, 1)" end="(1801, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1802, 1)" end="(1806, 3)" leading="" trailing="&#10;" val="Theorems tagged with the `wf_preprocess` attribute are used during the processing of functions defined&#10;by well-founded recursion. They are applied to the function's body to add additional hypotheses,&#10;such as replacing `if c then _ else _` with `if h : c then _ else _` or `xs.map` with&#10;`xs.attach.map`. Also see `wfParam`.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1807, 1)" end="(1807, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(1807, 8)" end="(1807, 31)">
        <OtherNode start="(1807, 8)" end="(1807, 31)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1807, 8)" end="(1807, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(1807, 9)" end="(1807, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1807, 14)" end="(1807, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1807, 17)" end="(1807, 30)" leading="" trailing="" raw_val="wf_preprocess" val="wf_preprocess"/>
          <AtomNode start="(1807, 30)" end="(1807, 31)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(1807, 32)" end="(1807, 132)">
        <OtherNode start="(1807, 32)" end="(1807, 47)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1807, 32)" end="(1807, 47)" kind="str">
            <AtomNode start="(1807, 32)" end="(1807, 47)" leading="" trailing=" " val="&amp;quot;wf_preprocess&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1807, 48)" end="(1807, 85)" kind="stx_?">
          <OtherNode start="(1807, 48)" end="(1807, 84)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(1807, 48)" end="(1807, 49)" leading="" trailing="" val="("/>
            <NullNode start="(1807, 49)" end="(1807, 83)">
              <OtherNode start="(1807, 49)" end="(1807, 83)" kind="«stx_&amp;lt;|&amp;gt;_»">
                <OtherNode start="(1807, 49)" end="(1807, 63)" kind="Lean.Parser.Syntax.cat">
                  <IdentNode start="(1807, 49)" end="(1807, 63)" leading="" trailing=" " raw_val="Tactic.simpPre" val="Tactic.simpPre" full_name="Lean.Parser.Tactic.simpPre" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(605, 8)" def_end="(605, 15)"/>
                  <NullNode/>
                </OtherNode>
                <AtomNode start="(1807, 64)" end="(1807, 67)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
                <OtherNode start="(1807, 68)" end="(1807, 83)" kind="Lean.Parser.Syntax.cat">
                  <IdentNode start="(1807, 68)" end="(1807, 83)" leading="" trailing="" raw_val="Tactic.simpPost" val="Tactic.simpPost" full_name="Lean.Parser.Tactic.simpPost" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(607, 8)" def_end="(607, 16)"/>
                  <NullNode/>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1807, 83)" end="(1807, 84)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(1807, 84)" end="(1807, 85)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(1807, 86)" end="(1807, 116)" kind="stx_?">
          <OtherNode start="(1807, 86)" end="(1807, 115)" kind="Lean.Parser.Syntax.unary">
            <IdentNode start="(1807, 86)" end="(1807, 99)" leading="" trailing="" raw_val="patternIgnore" val="patternIgnore"/>
            <AtomNode start="(1807, 99)" end="(1807, 100)" leading="" trailing="" val="("/>
            <NullNode start="(1807, 100)" end="(1807, 114)">
              <OtherNode start="(1807, 100)" end="(1807, 114)" kind="«stx_&amp;lt;|&amp;gt;_»">
                <OtherNode start="(1807, 100)" end="(1807, 104)" kind="Lean.Parser.Syntax.atom">
                  <OtherNode start="(1807, 100)" end="(1807, 104)" kind="str">
                    <AtomNode start="(1807, 100)" end="(1807, 104)" leading="" trailing=" " val="&amp;quot;← &amp;quot;"/>
                  </OtherNode>
                </OtherNode>
                <AtomNode start="(1807, 105)" end="(1807, 108)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
                <OtherNode start="(1807, 109)" end="(1807, 114)" kind="Lean.Parser.Syntax.atom">
                  <OtherNode start="(1807, 109)" end="(1807, 114)" kind="str">
                    <AtomNode start="(1807, 109)" end="(1807, 114)" leading="" trailing="" val="&amp;quot;&amp;lt;- &amp;quot;"/>
                  </OtherNode>
                </OtherNode>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1807, 114)" end="(1807, 115)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(1807, 115)" end="(1807, 116)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(1807, 117)" end="(1807, 132)" kind="stx_?">
          <OtherNode start="(1807, 117)" end="(1807, 131)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(1807, 117)" end="(1807, 118)" leading="" trailing="" val="("/>
            <NullNode start="(1807, 118)" end="(1807, 130)">
              <OtherNode start="(1807, 118)" end="(1807, 125)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(1807, 118)" end="(1807, 125)" leading="" trailing=" " raw_val="ppSpace" val="ppSpace" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(1807, 126)" end="(1807, 130)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(1807, 126)" end="(1807, 130)" leading="" trailing="" raw_val="prio" val="prio" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1807, 130)" end="(1807, 131)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(1807, 131)" end="(1807, 132)" leading="" trailing=" " val="?"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1807, 133)" end="(1807, 134)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1807, 135)" end="(1807, 139)" leading="" trailing="&#10;&#10;" raw_val="attr" val="attr" full_name="Lean.Parser.Category.attr" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(1809, 1)" end="(1810, 58)" kind="Lean.Parser.Command.syntaxAbbrev">
      <NullNode start="(1809, 1)" end="(1809, 68)">
        <CommandDoccommentNode start="(1809, 1)" end="(1809, 68)" comment="The possible `norm_cast` kinds: `elim`, `move`, or `squash`. -/">
          <AtomNode start="(1809, 1)" end="(1809, 4)" leading="" trailing=" " val="/--"/>
          <AtomNode start="(1809, 5)" end="(1809, 68)" leading="" trailing="&#10;" val="The possible `norm_cast` kinds: `elim`, `move`, or `squash`. -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <AtomNode start="(1810, 1)" end="(1810, 7)" leading="" trailing=" " val="syntax"/>
      <IdentNode start="(1810, 8)" end="(1810, 21)" leading="" trailing=" " raw_val="normCastLabel" val="normCastLabel"/>
      <AtomNode start="(1810, 22)" end="(1810, 24)" leading="" trailing=" " val=":="/>
      <NullNode start="(1810, 25)" end="(1810, 58)">
        <OtherNode start="(1810, 25)" end="(1810, 58)" kind="«stx_&amp;lt;|&amp;gt;_»">
          <OtherNode start="(1810, 25)" end="(1810, 32)" kind="Lean.Parser.Syntax.nonReserved">
            <AtomNode start="(1810, 25)" end="(1810, 26)" leading="" trailing="" val="&amp;amp;"/>
            <OtherNode start="(1810, 26)" end="(1810, 32)" kind="str">
              <AtomNode start="(1810, 26)" end="(1810, 32)" leading="" trailing=" " val="&amp;quot;elim&amp;quot;"/>
            </OtherNode>
          </OtherNode>
          <AtomNode start="(1810, 33)" end="(1810, 36)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
          <OtherNode start="(1810, 37)" end="(1810, 58)" kind="«stx_&amp;lt;|&amp;gt;_»">
            <OtherNode start="(1810, 37)" end="(1810, 44)" kind="Lean.Parser.Syntax.nonReserved">
              <AtomNode start="(1810, 37)" end="(1810, 38)" leading="" trailing="" val="&amp;amp;"/>
              <OtherNode start="(1810, 38)" end="(1810, 44)" kind="str">
                <AtomNode start="(1810, 38)" end="(1810, 44)" leading="" trailing=" " val="&amp;quot;move&amp;quot;"/>
              </OtherNode>
            </OtherNode>
            <AtomNode start="(1810, 45)" end="(1810, 48)" leading="" trailing=" " val="&amp;lt;|&amp;gt;"/>
            <OtherNode start="(1810, 49)" end="(1810, 58)" kind="Lean.Parser.Syntax.nonReserved">
              <AtomNode start="(1810, 49)" end="(1810, 50)" leading="" trailing="" val="&amp;amp;"/>
              <OtherNode start="(1810, 50)" end="(1810, 58)" kind="str">
                <AtomNode start="(1810, 50)" end="(1810, 58)" leading="" trailing="&#10;&#10;" val="&amp;quot;squash&amp;quot;"/>
              </OtherNode>
            </OtherNode>
          </OtherNode>
        </OtherNode>
      </NullNode>
    </OtherNode>
    <OtherNode start="(1812, 1)" end="(1858, 86)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1812, 1)" end="(1857, 3)">
        <CommandDoccommentNode start="(1812, 1)" end="(1857, 3)" comment="The `norm_cast` attribute should be given to lemmas that describe the&#10;behaviour of a coercion with respect to an operator, a relation, or a particular&#10;function.&#10;&#10;It only concerns equality or iff lemmas involving `↑`, `⇑` and `↥`, describing the behavior of&#10;the coercion functions.&#10;It does not apply to the explicit functions that define the coercions.&#10;&#10;Examples:&#10;```lean&#10;@[norm_cast] theorem coe_nat_inj' {m n : ℕ} : (↑m : ℤ) = ↑n ↔ m = n&#10;&#10;@[norm_cast] theorem coe_int_denom (n : ℤ) : (n : ℚ).denom = 1&#10;&#10;@[norm_cast] theorem cast_id : ∀ n : ℚ, ↑n = n&#10;&#10;@[norm_cast] theorem coe_nat_add (m n : ℕ) : (↑(m + n) : ℤ) = ↑m + ↑n&#10;&#10;@[norm_cast] theorem cast_coe_nat (n : ℕ) : ((n : ℤ) : α) = n&#10;&#10;@[norm_cast] theorem cast_one : ((1 : ℚ) : α) = 1&#10;```&#10;&#10;Lemmas tagged with `@[norm_cast]` are classified into three categories: `move`, `elim`, and&#10;`squash`. They are classified roughly as follows:&#10;&#10;* elim lemma:   LHS has 0 head coes and ≥ 1 internal coe&#10;* move lemma:   LHS has 1 head coe and 0 internal coes,    RHS has 0 head coes and ≥ 1 internal coes&#10;* squash lemma: LHS has ≥ 1 head coes and 0 internal coes, RHS has fewer head coes&#10;&#10;`norm_cast` uses `move` and `elim` lemmas to factor coercions toward the root of an expression&#10;and to cancel them from both sides of an equation or relation. It uses `squash` lemmas to clean&#10;up the result.&#10;&#10;It is typically not necessary to specify these categories, as `norm_cast` lemmas are&#10;automatically classified by default. The automatic classification can be overridden by&#10;giving an optional `elim`, `move`, or `squash` parameter to the attribute.&#10;&#10;```lean&#10;@[simp, norm_cast elim] lemma nat_cast_re (n : ℕ) : (n : ℂ).re = n := by&#10;  rw [← of_real_nat_cast, of_real_re]&#10;```&#10;&#10;Don't do this unless you understand what you are doing.&#10;-/">
          <AtomNode start="(1812, 1)" end="(1812, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1813, 1)" end="(1857, 3)" leading="" trailing="&#10;" val="The `norm_cast` attribute should be given to lemmas that describe the&#10;behaviour of a coercion with respect to an operator, a relation, or a particular&#10;function.&#10;&#10;It only concerns equality or iff lemmas involving `↑`, `⇑` and `↥`, describing the behavior of&#10;the coercion functions.&#10;It does not apply to the explicit functions that define the coercions.&#10;&#10;Examples:&#10;```lean&#10;@[norm_cast] theorem coe_nat_inj' {m n : ℕ} : (↑m : ℤ) = ↑n ↔ m = n&#10;&#10;@[norm_cast] theorem coe_int_denom (n : ℤ) : (n : ℚ).denom = 1&#10;&#10;@[norm_cast] theorem cast_id : ∀ n : ℚ, ↑n = n&#10;&#10;@[norm_cast] theorem coe_nat_add (m n : ℕ) : (↑(m + n) : ℤ) = ↑m + ↑n&#10;&#10;@[norm_cast] theorem cast_coe_nat (n : ℕ) : ((n : ℤ) : α) = n&#10;&#10;@[norm_cast] theorem cast_one : ((1 : ℚ) : α) = 1&#10;```&#10;&#10;Lemmas tagged with `@[norm_cast]` are classified into three categories: `move`, `elim`, and&#10;`squash`. They are classified roughly as follows:&#10;&#10;* elim lemma:   LHS has 0 head coes and ≥ 1 internal coe&#10;* move lemma:   LHS has 1 head coe and 0 internal coes,    RHS has 0 head coes and ≥ 1 internal coes&#10;* squash lemma: LHS has ≥ 1 head coes and 0 internal coes, RHS has fewer head coes&#10;&#10;`norm_cast` uses `move` and `elim` lemmas to factor coercions toward the root of an expression&#10;and to cancel them from both sides of an equation or relation. It uses `squash` lemmas to clean&#10;up the result.&#10;&#10;It is typically not necessary to specify these categories, as `norm_cast` lemmas are&#10;automatically classified by default. The automatic classification can be overridden by&#10;giving an optional `elim`, `move`, or `squash` parameter to the attribute.&#10;&#10;```lean&#10;@[simp, norm_cast elim] lemma nat_cast_re (n : ℕ) : (n : ℂ).re = n := by&#10;  rw [← of_real_nat_cast, of_real_re]&#10;```&#10;&#10;Don't do this unless you understand what you are doing.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1858, 1)" end="(1858, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(1858, 8)" end="(1858, 27)">
        <OtherNode start="(1858, 8)" end="(1858, 27)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1858, 8)" end="(1858, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(1858, 9)" end="(1858, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1858, 14)" end="(1858, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1858, 17)" end="(1858, 26)" leading="" trailing="" raw_val="norm_cast" val="norm_cast"/>
          <AtomNode start="(1858, 26)" end="(1858, 27)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(1858, 28)" end="(1858, 79)">
        <OtherNode start="(1858, 28)" end="(1858, 39)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1858, 28)" end="(1858, 39)" kind="str">
            <AtomNode start="(1858, 28)" end="(1858, 39)" leading="" trailing=" " val="&amp;quot;norm_cast&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1858, 40)" end="(1858, 64)" kind="stx_?">
          <OtherNode start="(1858, 40)" end="(1858, 63)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(1858, 40)" end="(1858, 41)" leading="" trailing="" val="("/>
            <NullNode start="(1858, 41)" end="(1858, 62)">
              <OtherNode start="(1858, 41)" end="(1858, 48)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(1858, 41)" end="(1858, 48)" leading="" trailing=" " raw_val="ppSpace" val="ppSpace" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(1858, 49)" end="(1858, 62)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(1858, 49)" end="(1858, 62)" leading="" trailing="" raw_val="normCastLabel" val="normCastLabel" full_name="Lean.Parser.Attr.normCastLabel" mod_name="Init.Tactics" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Tactics.lean" def_start="(1810, 8)" def_end="(1810, 21)"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1858, 62)" end="(1858, 63)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(1858, 63)" end="(1858, 64)" leading="" trailing=" " val="?"/>
        </OtherNode>
        <OtherNode start="(1858, 65)" end="(1858, 79)" kind="stx_?">
          <OtherNode start="(1858, 65)" end="(1858, 78)" kind="Lean.Parser.Syntax.paren">
            <AtomNode start="(1858, 65)" end="(1858, 66)" leading="" trailing="" val="("/>
            <NullNode start="(1858, 66)" end="(1858, 77)">
              <OtherNode start="(1858, 66)" end="(1858, 73)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(1858, 66)" end="(1858, 73)" leading="" trailing=" " raw_val="ppSpace" val="ppSpace" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
              <OtherNode start="(1858, 74)" end="(1858, 77)" kind="Lean.Parser.Syntax.cat">
                <IdentNode start="(1858, 74)" end="(1858, 77)" leading="" trailing="" raw_val="num" val="num" full_name="Lean.ParserDescr.const" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                <NullNode/>
              </OtherNode>
            </NullNode>
            <AtomNode start="(1858, 77)" end="(1858, 78)" leading="" trailing="" val=")"/>
          </OtherNode>
          <AtomNode start="(1858, 78)" end="(1858, 79)" leading="" trailing=" " val="?"/>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1858, 80)" end="(1858, 81)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1858, 82)" end="(1858, 86)" leading="" trailing="&#10;&#10;" raw_val="attr" val="attr" full_name="Lean.Parser.Category.attr" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <CommandEndNode start="(1860, 1)" end="(1860, 9)" name="Attr">
      <AtomNode start="(1860, 1)" end="(1860, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(1860, 5)" end="(1860, 9)">
        <IdentNode start="(1860, 5)" end="(1860, 9)" leading="" trailing="&#10;&#10;" raw_val="Attr" val="Attr"/>
      </NullNode>
    </CommandEndNode>
    <CommandEndNode start="(1862, 1)" end="(1862, 11)" name="Parser">
      <AtomNode start="(1862, 1)" end="(1862, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(1862, 5)" end="(1862, 11)">
        <IdentNode start="(1862, 5)" end="(1862, 11)" leading="" trailing="&#10;" raw_val="Parser" val="Parser"/>
      </NullNode>
    </CommandEndNode>
    <CommandEndNode start="(1863, 1)" end="(1863, 9)" name="Lean">
      <AtomNode start="(1863, 1)" end="(1863, 4)" leading="" trailing=" " val="end"/>
      <NullNode start="(1863, 5)" end="(1863, 9)">
        <IdentNode start="(1863, 5)" end="(1863, 9)" leading="" trailing="&#10;&#10;" raw_val="Lean" val="Lean"/>
      </NullNode>
    </CommandEndNode>
    <OtherNode start="(1865, 1)" end="(1871, 44)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1865, 1)" end="(1870, 3)">
        <CommandDoccommentNode start="(1865, 1)" end="(1870, 3)" comment="`‹t›` resolves to an (arbitrary) hypothesis of type `t`.&#10;It is useful for referring to hypotheses without accessible names.&#10;`t` may contain holes that are solved by unification with the expected type;&#10;in particular, `‹_›` is a shortcut for `by assumption`.&#10;-/">
          <AtomNode start="(1865, 1)" end="(1865, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1866, 1)" end="(1870, 3)" leading="" trailing="&#10;" val="`‹t›` resolves to an (arbitrary) hypothesis of type `t`.&#10;It is useful for referring to hypotheses without accessible names.&#10;`t` may contain holes that are solved by unification with the expected type;&#10;in particular, `‹_›` is a shortcut for `by assumption`.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1871, 1)" end="(1871, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(1871, 8)" end="(1871, 37)">
        <OtherNode start="(1871, 8)" end="(1871, 11)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1871, 8)" end="(1871, 11)" kind="str">
            <AtomNode start="(1871, 8)" end="(1871, 11)" leading="" trailing=" " val="&amp;quot;‹&amp;quot;"/>
          </OtherNode>
        </OtherNode>
        <OtherNode start="(1871, 12)" end="(1871, 33)" kind="Lean.Parser.Syntax.unary">
          <IdentNode start="(1871, 12)" end="(1871, 27)" leading="" trailing="" raw_val="withoutPosition" val="withoutPosition"/>
          <AtomNode start="(1871, 27)" end="(1871, 28)" leading="" trailing="" val="("/>
          <NullNode start="(1871, 28)" end="(1871, 32)">
            <OtherNode start="(1871, 28)" end="(1871, 32)" kind="Lean.Parser.Syntax.cat">
              <IdentNode start="(1871, 28)" end="(1871, 32)" leading="" trailing="" raw_val="term" val="term" full_name="Lean.ParserDescr.cat" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
              <NullNode/>
            </OtherNode>
          </NullNode>
          <AtomNode start="(1871, 32)" end="(1871, 33)" leading="" trailing=" " val=")"/>
        </OtherNode>
        <OtherNode start="(1871, 34)" end="(1871, 37)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1871, 34)" end="(1871, 37)" kind="str">
            <AtomNode start="(1871, 34)" end="(1871, 37)" leading="" trailing=" " val="&amp;quot;›&amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1871, 38)" end="(1871, 39)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1871, 40)" end="(1871, 44)" leading="" trailing="&#10;" raw_val="term" val="term" full_name="Lean.Parser.Category.term" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(1872, 1)" end="(1872, 55)" kind="Lean.Parser.Command.macro_rules">
      <NullNode/>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1872, 1)" end="(1872, 12)" leading="" trailing=" " val="macro_rules"/>
      <NullNode/>
      <OtherNode start="(1872, 13)" end="(1872, 55)" kind="Lean.Parser.Term.matchAlts">
        <NullNode start="(1872, 13)" end="(1872, 55)">
          <OtherNode start="(1872, 13)" end="(1872, 55)" kind="Lean.Parser.Term.matchAlt">
            <AtomNode start="(1872, 13)" end="(1872, 14)" leading="" trailing=" " val="|"/>
            <NullNode start="(1872, 15)" end="(1872, 25)">
              <NullNode start="(1872, 15)" end="(1872, 25)">
                <OtherNode start="(1872, 15)" end="(1872, 25)" kind="Lean.Parser.Term.quot">
                  <AtomNode start="(1872, 15)" end="(1872, 17)" leading="" trailing="" val="`("/>
                  <OtherNode start="(1872, 17)" end="(1872, 24)" kind="«term‹_›»">
                    <AtomNode start="(1872, 17)" end="(1872, 18)" leading="" trailing="" val="‹"/>
                    <OtherNode start="(1872, 18)" end="(1872, 23)" kind="term.pseudo.antiquot">
                      <AtomNode start="(1872, 18)" end="(1872, 19)" leading="" trailing="" val="$"/>
                      <NullNode/>
                      <IdentNode start="(1872, 19)" end="(1872, 23)" leading="" trailing="" raw_val="type" val="type"/>
                      <NullNode/>
                    </OtherNode>
                    <AtomNode start="(1872, 23)" end="(1872, 24)" leading="" trailing="" val="›"/>
                  </OtherNode>
                  <AtomNode start="(1872, 24)" end="(1872, 25)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </NullNode>
            </NullNode>
            <AtomNode start="(1872, 26)" end="(1872, 28)" leading="" trailing=" " val="=&amp;gt;"/>
            <OtherNode start="(1872, 29)" end="(1872, 55)" kind="Lean.Parser.Term.quot">
              <AtomNode start="(1872, 29)" end="(1872, 31)" leading="" trailing="" val="`("/>
              <OtherNode start="(1872, 31)" end="(1872, 54)" kind="Lean.Parser.Term.typeAscription">
                <AtomNode start="(1872, 31)" end="(1872, 32)" leading="" trailing="" val="("/>
                <TermBytacticNode start="(1872, 32)" end="(1872, 45)">
                  <AtomNode start="(1872, 32)" end="(1872, 34)" leading="" trailing=" " val="by"/>
                  <TacticTacticseqNode start="(1872, 35)" end="(1872, 45)">
                    <TacticTacticseq1IndentedNode start="(1872, 35)" end="(1872, 45)">
                      <NullNode start="(1872, 35)" end="(1872, 45)">
                        <OtherNode start="(1872, 35)" end="(1872, 45)" kind="Lean.Parser.Tactic.assumption">
                          <AtomNode start="(1872, 35)" end="(1872, 45)" leading="" trailing=" " val="assumption"/>
                        </OtherNode>
                      </NullNode>
                    </TacticTacticseq1IndentedNode>
                  </TacticTacticseqNode>
                </TermBytacticNode>
                <AtomNode start="(1872, 46)" end="(1872, 47)" leading="" trailing=" " val=":"/>
                <NullNode start="(1872, 48)" end="(1872, 53)">
                  <OtherNode start="(1872, 48)" end="(1872, 53)" kind="term.pseudo.antiquot">
                    <AtomNode start="(1872, 48)" end="(1872, 49)" leading="" trailing="" val="$"/>
                    <NullNode/>
                    <IdentNode start="(1872, 49)" end="(1872, 53)" leading="" trailing="" raw_val="type" val="type"/>
                    <NullNode/>
                  </OtherNode>
                </NullNode>
                <AtomNode start="(1872, 53)" end="(1872, 54)" leading="" trailing="" val=")"/>
              </OtherNode>
              <AtomNode start="(1872, 54)" end="(1872, 55)" leading="" trailing="&#10;&#10;" val=")"/>
            </OtherNode>
          </OtherNode>
        </NullNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(1874, 1)" end="(1882, 42)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1874, 1)" end="(1881, 3)">
        <CommandDoccommentNode start="(1874, 1)" end="(1881, 3)" comment="`get_elem_tactic_trivial` is an extensible tactic automatically called&#10;by the notation `arr[i]` to prove any side conditions that arise when&#10;constructing the term (e.g. the index is in bounds of the array).&#10;The default behavior is to just try `trivial` (which handles the case&#10;where `i &amp;lt; arr.size` is in the context) and `simp +arith` and `omega`&#10;(for doing linear arithmetic in the index).&#10;-/">
          <AtomNode start="(1874, 1)" end="(1874, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1875, 1)" end="(1881, 3)" leading="" trailing="&#10;" val="`get_elem_tactic_trivial` is an extensible tactic automatically called&#10;by the notation `arr[i]` to prove any side conditions that arise when&#10;constructing the term (e.g. the index is in bounds of the array).&#10;The default behavior is to just try `trivial` (which handles the case&#10;where `i &amp;lt; arr.size` is in the context) and `simp +arith` and `omega`&#10;(for doing linear arithmetic in the index).&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1882, 1)" end="(1882, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(1882, 8)" end="(1882, 33)">
        <OtherNode start="(1882, 8)" end="(1882, 33)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1882, 8)" end="(1882, 33)" kind="str">
            <AtomNode start="(1882, 8)" end="(1882, 33)" leading="" trailing=" " val="&amp;quot;get_elem_tactic_trivial&amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1882, 34)" end="(1882, 35)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1882, 36)" end="(1882, 42)" leading="" trailing="&#10;&#10;" raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(1884, 1)" end="(1884, 69)" kind="Lean.Parser.Command.macro_rules">
      <NullNode/>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1884, 1)" end="(1884, 12)" leading="" trailing=" " val="macro_rules"/>
      <NullNode/>
      <OtherNode start="(1884, 13)" end="(1884, 69)" kind="Lean.Parser.Term.matchAlts">
        <NullNode start="(1884, 13)" end="(1884, 69)">
          <OtherNode start="(1884, 13)" end="(1884, 69)" kind="Lean.Parser.Term.matchAlt">
            <AtomNode start="(1884, 13)" end="(1884, 14)" leading="" trailing=" " val="|"/>
            <NullNode start="(1884, 15)" end="(1884, 49)">
              <NullNode start="(1884, 15)" end="(1884, 49)">
                <OtherNode start="(1884, 15)" end="(1884, 49)" kind="Lean.Parser.Tactic.quot">
                  <AtomNode start="(1884, 15)" end="(1884, 24)" leading="" trailing=" " val="`(tactic|"/>
                  <OtherNode start="(1884, 25)" end="(1884, 48)" kind="tacticGet_elem_tactic_trivial">
                    <AtomNode start="(1884, 25)" end="(1884, 48)" leading="" trailing="" val="get_elem_tactic_trivial"/>
                  </OtherNode>
                  <AtomNode start="(1884, 48)" end="(1884, 49)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </NullNode>
            </NullNode>
            <AtomNode start="(1884, 50)" end="(1884, 52)" leading="" trailing=" " val="=&amp;gt;"/>
            <OtherNode start="(1884, 53)" end="(1884, 69)" kind="Lean.Parser.Tactic.quot">
              <AtomNode start="(1884, 53)" end="(1884, 62)" leading="" trailing=" " val="`(tactic|"/>
              <OtherNode start="(1884, 63)" end="(1884, 68)" kind="Lean.Parser.Tactic.omega">
                <AtomNode start="(1884, 63)" end="(1884, 68)" leading="" trailing="" val="omega"/>
                <OtherNode kind="Lean.Parser.Tactic.optConfig">
                  <NullNode/>
                </OtherNode>
              </OtherNode>
              <AtomNode start="(1884, 68)" end="(1884, 69)" leading="" trailing="&#10;" val=")"/>
            </OtherNode>
          </OtherNode>
        </NullNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(1885, 1)" end="(1885, 81)" kind="Lean.Parser.Command.macro_rules">
      <NullNode/>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1885, 1)" end="(1885, 12)" leading="" trailing=" " val="macro_rules"/>
      <NullNode/>
      <OtherNode start="(1885, 13)" end="(1885, 81)" kind="Lean.Parser.Term.matchAlts">
        <NullNode start="(1885, 13)" end="(1885, 81)">
          <OtherNode start="(1885, 13)" end="(1885, 81)" kind="Lean.Parser.Term.matchAlt">
            <AtomNode start="(1885, 13)" end="(1885, 14)" leading="" trailing=" " val="|"/>
            <NullNode start="(1885, 15)" end="(1885, 49)">
              <NullNode start="(1885, 15)" end="(1885, 49)">
                <OtherNode start="(1885, 15)" end="(1885, 49)" kind="Lean.Parser.Tactic.quot">
                  <AtomNode start="(1885, 15)" end="(1885, 24)" leading="" trailing=" " val="`(tactic|"/>
                  <OtherNode start="(1885, 25)" end="(1885, 48)" kind="tacticGet_elem_tactic_trivial">
                    <AtomNode start="(1885, 25)" end="(1885, 48)" leading="" trailing="" val="get_elem_tactic_trivial"/>
                  </OtherNode>
                  <AtomNode start="(1885, 48)" end="(1885, 49)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </NullNode>
            </NullNode>
            <AtomNode start="(1885, 50)" end="(1885, 52)" leading="" trailing=" " val="=&amp;gt;"/>
            <OtherNode start="(1885, 53)" end="(1885, 81)" kind="Lean.Parser.Tactic.quotSeq">
              <AtomNode start="(1885, 53)" end="(1885, 62)" leading="" trailing=" " val="`(tactic|"/>
              <OtherNode start="(1885, 63)" end="(1885, 80)" kind="Lean.Parser.Tactic.seq1">
                <NullNode start="(1885, 63)" end="(1885, 80)">
                  <OtherNode start="(1885, 63)" end="(1885, 74)" kind="Lean.Parser.Tactic.simp">
                    <AtomNode start="(1885, 63)" end="(1885, 67)" leading="" trailing=" " val="simp"/>
                    <OtherNode start="(1885, 68)" end="(1885, 74)" kind="Lean.Parser.Tactic.optConfig">
                      <NullNode start="(1885, 68)" end="(1885, 74)">
                        <OtherNode start="(1885, 68)" end="(1885, 74)" kind="Lean.Parser.Tactic.configItem">
                          <OtherNode start="(1885, 68)" end="(1885, 74)" kind="Lean.Parser.Tactic.posConfigItem">
                            <AtomNode start="(1885, 68)" end="(1885, 69)" leading="" trailing="" val="+"/>
                            <IdentNode start="(1885, 69)" end="(1885, 74)" leading="" trailing="" raw_val="arith" val="arith"/>
                          </OtherNode>
                        </OtherNode>
                      </NullNode>
                    </OtherNode>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                    <NullNode/>
                  </OtherNode>
                  <AtomNode start="(1885, 74)" end="(1885, 75)" leading="" trailing=" " val=";"/>
                  <OtherNode start="(1885, 76)" end="(1885, 80)" kind="Lean.Parser.Tactic.done">
                    <AtomNode start="(1885, 76)" end="(1885, 80)" leading="" trailing="" val="done"/>
                  </OtherNode>
                </NullNode>
              </OtherNode>
              <AtomNode start="(1885, 80)" end="(1885, 81)" leading="" trailing="&#10;" val=")"/>
            </OtherNode>
          </OtherNode>
        </NullNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(1886, 1)" end="(1886, 71)" kind="Lean.Parser.Command.macro_rules">
      <NullNode/>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1886, 1)" end="(1886, 12)" leading="" trailing=" " val="macro_rules"/>
      <NullNode/>
      <OtherNode start="(1886, 13)" end="(1886, 71)" kind="Lean.Parser.Term.matchAlts">
        <NullNode start="(1886, 13)" end="(1886, 71)">
          <OtherNode start="(1886, 13)" end="(1886, 71)" kind="Lean.Parser.Term.matchAlt">
            <AtomNode start="(1886, 13)" end="(1886, 14)" leading="" trailing=" " val="|"/>
            <NullNode start="(1886, 15)" end="(1886, 49)">
              <NullNode start="(1886, 15)" end="(1886, 49)">
                <OtherNode start="(1886, 15)" end="(1886, 49)" kind="Lean.Parser.Tactic.quot">
                  <AtomNode start="(1886, 15)" end="(1886, 24)" leading="" trailing=" " val="`(tactic|"/>
                  <OtherNode start="(1886, 25)" end="(1886, 48)" kind="tacticGet_elem_tactic_trivial">
                    <AtomNode start="(1886, 25)" end="(1886, 48)" leading="" trailing="" val="get_elem_tactic_trivial"/>
                  </OtherNode>
                  <AtomNode start="(1886, 48)" end="(1886, 49)" leading="" trailing=" " val=")"/>
                </OtherNode>
              </NullNode>
            </NullNode>
            <AtomNode start="(1886, 50)" end="(1886, 52)" leading="" trailing=" " val="=&amp;gt;"/>
            <OtherNode start="(1886, 53)" end="(1886, 71)" kind="Lean.Parser.Tactic.quot">
              <AtomNode start="(1886, 53)" end="(1886, 62)" leading="" trailing=" " val="`(tactic|"/>
              <OtherNode start="(1886, 63)" end="(1886, 70)" kind="Lean.Parser.Tactic.tacticTrivial">
                <AtomNode start="(1886, 63)" end="(1886, 70)" leading="" trailing="" val="trivial"/>
              </OtherNode>
              <AtomNode start="(1886, 70)" end="(1886, 71)" leading="" trailing="&#10;&#10;" val=")"/>
            </OtherNode>
          </OtherNode>
        </NullNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(1888, 1)" end="(1925, 5)" kind="Lean.Parser.Command.macro">
      <NullNode start="(1888, 1)" end="(1894, 3)">
        <CommandDoccommentNode start="(1888, 1)" end="(1894, 3)" comment="`get_elem_tactic` is the tactic automatically called by the notation `arr[i]`&#10;to prove any side conditions that arise when constructing the term&#10;(e.g. the index is in bounds of the array). It just delegates to&#10;`get_elem_tactic_trivial` and gives a diagnostic error message otherwise;&#10;users are encouraged to extend `get_elem_tactic_trivial` instead of this tactic.&#10;-/">
          <AtomNode start="(1888, 1)" end="(1888, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1889, 1)" end="(1894, 3)" leading="" trailing="&#10;" val="`get_elem_tactic` is the tactic automatically called by the notation `arr[i]`&#10;to prove any side conditions that arise when constructing the term&#10;(e.g. the index is in bounds of the array). It just delegates to&#10;`get_elem_tactic_trivial` and gives a diagnostic error message otherwise;&#10;users are encouraged to extend `get_elem_tactic_trivial` instead of this tactic.&#10;-/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1895, 1)" end="(1895, 6)" leading="" trailing=" " val="macro"/>
      <NullNode/>
      <NullNode/>
      <NullNode/>
      <NullNode start="(1895, 7)" end="(1895, 24)">
        <OtherNode start="(1895, 7)" end="(1895, 24)" kind="Lean.Parser.Command.macroArg">
          <NullNode/>
          <OtherNode start="(1895, 7)" end="(1895, 24)" kind="Lean.Parser.Syntax.atom">
            <OtherNode start="(1895, 7)" end="(1895, 24)" kind="str">
              <AtomNode start="(1895, 7)" end="(1895, 24)" leading="" trailing=" " val="&amp;quot;get_elem_tactic&amp;quot;"/>
            </OtherNode>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <OtherNode start="(1895, 25)" end="(1925, 5)" kind="Lean.Parser.Command.macroTail">
        <AtomNode start="(1895, 25)" end="(1895, 26)" leading="" trailing=" " val=":"/>
        <IdentNode start="(1895, 27)" end="(1895, 33)" leading="" trailing=" " raw_val="tactic" val="tactic" full_name="Lean.Parser.Category.tactic" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
        <AtomNode start="(1895, 34)" end="(1895, 36)" leading="" trailing="&#10;  " val="=&amp;gt;"/>
        <OtherNode start="(1896, 3)" end="(1925, 5)" kind="Lean.Parser.Command.macroRhs">
          <OtherNode start="(1896, 3)" end="(1925, 5)" kind="Lean.Parser.Tactic.quot">
            <AtomNode start="(1896, 3)" end="(1896, 12)" leading="" trailing=" " val="`(tactic|"/>
            <OtherNode start="(1896, 13)" end="(1924, 77)" kind="Lean.Parser.Tactic.first">
              <AtomNode start="(1896, 13)" end="(1896, 18)" leading="" trailing="&#10;      /-&#10;      Recall that `macro_rules` (namely, for `get_elem_tactic_trivial`) are tried in reverse order.&#10;      We first, however, try `done`, since the necessary proof may already have been&#10;      found during unification, in which case there is no goal to solve (see #6999).&#10;      If a goal is present, we want `assumption` to be tried first.&#10;      This is important for theorems such as&#10;      ```&#10;      [simp] theorem getElem_pop (a : Array α) (i : Nat) (hi : i &amp;lt; a.pop.size) :&#10;      a.pop[i] = a[i]'(Nat.lt_of_lt_of_le (a.size_pop ▸ hi) (Nat.sub_le _ _)) :=&#10;      ```&#10;      There is a proof embedded in the right-hand-side, and we want it to be just `hi`.&#10;      If `omega` is used to &amp;quot;fill&amp;quot; this proof, we will have a more complex proof term that&#10;      cannot be inferred by unification.&#10;      We hardcoded `assumption` here to ensure users cannot accidentally break this IF&#10;      they add new `macro_rules` for `get_elem_tactic_trivial`.&#10;&#10;      TODO: Implement priorities for `macro_rules`.&#10;      TODO: Ensure we have **high-priority** macro_rules for `get_elem_tactic_trivial` which are&#10;            just `done` and `assumption`.&#10;      -/&#10;    " val="first"/>
              <NullNode start="(1917, 5)" end="(1924, 77)">
                <GroupNode start="(1917, 5)" end="(1917, 11)">
                  <AtomNode start="(1917, 5)" end="(1917, 6)" leading="" trailing=" " val="|"/>
                  <TacticTacticseqNode start="(1917, 7)" end="(1917, 11)">
                    <TacticTacticseq1IndentedNode start="(1917, 7)" end="(1917, 11)">
                      <NullNode start="(1917, 7)" end="(1917, 11)">
                        <OtherNode start="(1917, 7)" end="(1917, 11)" kind="Lean.Parser.Tactic.done">
                          <AtomNode start="(1917, 7)" end="(1917, 11)" leading="" trailing="&#10;    " val="done"/>
                        </OtherNode>
                      </NullNode>
                    </TacticTacticseq1IndentedNode>
                  </TacticTacticseqNode>
                </GroupNode>
                <GroupNode start="(1918, 5)" end="(1918, 17)">
                  <AtomNode start="(1918, 5)" end="(1918, 6)" leading="" trailing=" " val="|"/>
                  <TacticTacticseqNode start="(1918, 7)" end="(1918, 17)">
                    <TacticTacticseq1IndentedNode start="(1918, 7)" end="(1918, 17)">
                      <NullNode start="(1918, 7)" end="(1918, 17)">
                        <OtherNode start="(1918, 7)" end="(1918, 17)" kind="Lean.Parser.Tactic.assumption">
                          <AtomNode start="(1918, 7)" end="(1918, 17)" leading="" trailing="&#10;    " val="assumption"/>
                        </OtherNode>
                      </NullNode>
                    </TacticTacticseq1IndentedNode>
                  </TacticTacticseqNode>
                </GroupNode>
                <GroupNode start="(1919, 5)" end="(1919, 30)">
                  <AtomNode start="(1919, 5)" end="(1919, 6)" leading="" trailing=" " val="|"/>
                  <TacticTacticseqNode start="(1919, 7)" end="(1919, 30)">
                    <TacticTacticseq1IndentedNode start="(1919, 7)" end="(1919, 30)">
                      <NullNode start="(1919, 7)" end="(1919, 30)">
                        <OtherNode start="(1919, 7)" end="(1919, 30)" kind="tacticGet_elem_tactic_trivial">
                          <AtomNode start="(1919, 7)" end="(1919, 30)" leading="" trailing="&#10;    " val="get_elem_tactic_trivial"/>
                        </OtherNode>
                      </NullNode>
                    </TacticTacticseq1IndentedNode>
                  </TacticTacticseqNode>
                </GroupNode>
                <GroupNode start="(1920, 5)" end="(1924, 77)">
                  <AtomNode start="(1920, 5)" end="(1920, 6)" leading="" trailing=" " val="|"/>
                  <TacticTacticseqNode start="(1920, 7)" end="(1924, 77)">
                    <TacticTacticseq1IndentedNode start="(1920, 7)" end="(1924, 77)">
                      <NullNode start="(1920, 7)" end="(1924, 77)">
                        <OtherNode start="(1920, 7)" end="(1924, 77)" kind="Lean.Parser.Tactic.fail">
                          <AtomNode start="(1920, 7)" end="(1920, 11)" leading="" trailing=" " val="fail"/>
                          <NullNode start="(1920, 12)" end="(1924, 77)">
                            <OtherNode start="(1920, 12)" end="(1924, 77)" kind="str">
                              <AtomNode start="(1920, 12)" end="(1924, 77)" leading="" trailing="&#10;   " val="&amp;quot;failed to prove index is valid, possible solutions:&#10;  - Use `have`-expressions to prove the index is valid&#10;  - Use `a[i]!` notation instead, runtime check is performed, and 'Panic' error message is produced if index is not valid&#10;  - Use `a[i]?` notation instead, result is an `Option` type&#10;  - Use `a[i]'h` notation instead, where `h` is a proof that index is valid&amp;quot;"/>
                            </OtherNode>
                          </NullNode>
                        </OtherNode>
                      </NullNode>
                    </TacticTacticseq1IndentedNode>
                  </TacticTacticseqNode>
                </GroupNode>
              </NullNode>
            </OtherNode>
            <AtomNode start="(1925, 4)" end="(1925, 5)" leading="" trailing="&#10;&#10;" val=")"/>
          </OtherNode>
        </OtherNode>
      </OtherNode>
    </OtherNode>
    <OtherNode start="(1927, 1)" end="(1931, 60)" kind="Lean.Parser.Command.syntax">
      <NullNode start="(1927, 1)" end="(1930, 4)">
        <CommandDoccommentNode start="(1927, 1)" end="(1930, 4)" comment="Searches environment for definitions or theorems that can be substituted in&#10;for `exact?%` to solve the goal.&#10; -/">
          <AtomNode start="(1927, 1)" end="(1927, 4)" leading="" trailing="&#10;" val="/--"/>
          <AtomNode start="(1928, 1)" end="(1930, 4)" leading="" trailing="&#10;" val="Searches environment for definitions or theorems that can be substituted in&#10;for `exact?%` to solve the goal.&#10; -/"/>
        </CommandDoccommentNode>
      </NullNode>
      <NullNode/>
      <TermAttrkindNode>
        <NullNode/>
      </TermAttrkindNode>
      <AtomNode start="(1931, 1)" end="(1931, 7)" leading="" trailing=" " val="syntax"/>
      <NullNode/>
      <NullNode start="(1931, 8)" end="(1931, 43)">
        <OtherNode start="(1931, 8)" end="(1931, 43)" kind="Lean.Parser.Command.namedName">
          <AtomNode start="(1931, 8)" end="(1931, 9)" leading="" trailing="" val="("/>
          <AtomNode start="(1931, 9)" end="(1931, 13)" leading="" trailing=" " val="name"/>
          <AtomNode start="(1931, 14)" end="(1931, 16)" leading="" trailing=" " val=":="/>
          <IdentNode start="(1931, 17)" end="(1931, 42)" leading="" trailing="" raw_val="Lean.Parser.Syntax.exact?" val="Lean.Parser.Syntax.exact?"/>
          <AtomNode start="(1931, 42)" end="(1931, 43)" leading="" trailing=" " val=")"/>
        </OtherNode>
      </NullNode>
      <NullNode/>
      <NullNode start="(1931, 44)" end="(1931, 53)">
        <OtherNode start="(1931, 44)" end="(1931, 53)" kind="Lean.Parser.Syntax.atom">
          <OtherNode start="(1931, 44)" end="(1931, 53)" kind="str">
            <AtomNode start="(1931, 44)" end="(1931, 53)" leading="" trailing=" " val="&amp;quot;exact?%&amp;quot;"/>
          </OtherNode>
        </OtherNode>
      </NullNode>
      <AtomNode start="(1931, 54)" end="(1931, 55)" leading="" trailing=" " val=":"/>
      <IdentNode start="(1931, 56)" end="(1931, 60)" leading="" trailing="&#10;&#10;" raw_val="term" val="term" full_name="Lean.Parser.Category.term" mod_name="Init.Notation" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Notation.lean"/>
    </OtherNode>
    <OtherNode start="(1933, 1)" end="(1939, 71)" kind="Lean.Parser.Command.in">
      <OtherNode start="(1933, 1)" end="(1933, 48)" kind="Lean.Parser.Command.set_option">
        <AtomNode start="(1933, 1)" end="(1933, 11)" leading="" trailing=" " val="set_option"/>
        <IdentNode start="(1933, 12)" end="(1933, 42)" leading="" trailing=" " raw_val="linter.unusedVariables.funArgs" val="linter.unusedVariables.funArgs"/>
        <NullNode/>
        <AtomNode start="(1933, 43)" end="(1933, 48)" leading="" trailing=" " val="false"/>
      </OtherNode>
      <AtomNode start="(1933, 49)" end="(1933, 51)" leading="" trailing="&#10;" val="in"/>
      <CommandDeclarationNode start="(1934, 1)" end="(1939, 71)" name="autoParam" full_name="autoParam">
        <CommandDeclmodifiersNode start="(1934, 1)" end="(1938, 81)">
          <NullNode start="(1934, 1)" end="(1938, 81)">
            <CommandDoccommentNode start="(1934, 1)" end="(1938, 81)" comment="Gadget for automatic parameter support. This is similar to the `optParam` gadget, but it uses&#10;  the given tactic.&#10;  Like `optParam`, this gadget only affects elaboration.&#10;  For example, the tactic will *not* be invoked during type class resolution. -/">
              <AtomNode start="(1934, 1)" end="(1934, 4)" leading="" trailing="&#10;  " val="/--"/>
              <AtomNode start="(1935, 3)" end="(1938, 81)" leading="" trailing="&#10;" val="Gadget for automatic parameter support. This is similar to the `optParam` gadget, but it uses&#10;  the given tactic.&#10;  Like `optParam`, this gadget only affects elaboration.&#10;  For example, the tactic will *not* be invoked during type class resolution. -/"/>
            </CommandDoccommentNode>
          </NullNode>
          <NullNode/>
          <NullNode/>
          <NullNode/>
          <NullNode/>
          <NullNode/>
        </CommandDeclmodifiersNode>
        <CommandAbbrevNode start="(1939, 1)" end="(1939, 71)" name="autoParam">
          <AtomNode start="(1939, 1)" end="(1939, 7)" leading="" trailing=" " val="abbrev"/>
          <CommandDeclidNode start="(1939, 8)" end="(1939, 21)">
            <IdentNode start="(1939, 8)" end="(1939, 17)" leading="" trailing="" raw_val="autoParam" val="autoParam"/>
            <NullNode start="(1939, 17)" end="(1939, 21)">
              <AtomNode start="(1939, 17)" end="(1939, 19)" leading="" trailing="" val=".{"/>
              <NullNode start="(1939, 19)" end="(1939, 20)">
                <IdentNode start="(1939, 19)" end="(1939, 20)" leading="" trailing="" raw_val="u" val="u"/>
              </NullNode>
              <AtomNode start="(1939, 20)" end="(1939, 21)" leading="" trailing=" " val="}"/>
            </NullNode>
          </CommandDeclidNode>
          <OtherNode start="(1939, 22)" end="(1939, 66)" kind="Lean.Parser.Command.optDeclSig">
            <NullNode start="(1939, 22)" end="(1939, 57)">
              <TermExplicitbinderNode start="(1939, 22)" end="(1939, 34)">
                <AtomNode start="(1939, 22)" end="(1939, 23)" leading="" trailing="" val="("/>
                <NullNode start="(1939, 23)" end="(1939, 24)">
                  <IdentNode start="(1939, 23)" end="(1939, 24)" leading="" trailing=" " raw_val="α" val="α"/>
                </NullNode>
                <NullNode start="(1939, 25)" end="(1939, 33)">
                  <AtomNode start="(1939, 25)" end="(1939, 26)" leading="" trailing=" " val=":"/>
                  <OtherNode start="(1939, 27)" end="(1939, 33)" kind="Lean.Parser.Term.sort">
                    <AtomNode start="(1939, 27)" end="(1939, 31)" leading="" trailing=" " val="Sort"/>
                    <NullNode start="(1939, 32)" end="(1939, 33)">
                      <IdentNode start="(1939, 32)" end="(1939, 33)" leading="" trailing="" raw_val="u" val="u"/>
                    </NullNode>
                  </OtherNode>
                </NullNode>
                <NullNode/>
                <AtomNode start="(1939, 33)" end="(1939, 34)" leading="" trailing=" " val=")"/>
              </TermExplicitbinderNode>
              <TermExplicitbinderNode start="(1939, 35)" end="(1939, 57)">
                <AtomNode start="(1939, 35)" end="(1939, 36)" leading="" trailing="" val="("/>
                <NullNode start="(1939, 36)" end="(1939, 42)">
                  <IdentNode start="(1939, 36)" end="(1939, 42)" leading="" trailing=" " raw_val="tactic" val="tactic"/>
                </NullNode>
                <NullNode start="(1939, 43)" end="(1939, 56)">
                  <AtomNode start="(1939, 43)" end="(1939, 44)" leading="" trailing=" " val=":"/>
                  <IdentNode start="(1939, 45)" end="(1939, 56)" leading="" trailing="" raw_val="Lean.Syntax" val="Lean.Syntax" full_name="Lean.Syntax" mod_name="Init.Prelude" def_path="/home/linfe/.elan/toolchains/leanprover--lean4---v4.20.0/src/lean/Init/Prelude.lean"/>
                </NullNode>
                <NullNode/>
                <AtomNode start="(1939, 56)" end="(1939, 57)" leading="" trailing=" " val=")"/>
              </TermExplicitbinderNode>
            </NullNode>
            <NullNode start="(1939, 58)" end="(1939, 66)">
              <TermTypespecNode start="(1939, 58)" end="(1939, 66)">
                <AtomNode start="(1939, 58)" end="(1939, 59)" leading="" trailing=" " val=":"/>
                <OtherNode start="(1939, 60)" end="(1939, 66)" kind="Lean.Parser.Term.sort">
                  <AtomNode start="(1939, 60)" end="(1939, 64)" leading="" trailing=" " val="Sort"/>
                  <NullNode start="(1939, 65)" end="(1939, 66)">
                    <IdentNode start="(1939, 65)" end="(1939, 66)" leading="" trailing=" " raw_val="u" val="u"/>
                  </NullNode>
                </OtherNode>
              </TermTypespecNode>
            </NullNode>
          </OtherNode>
          <CommandDeclvalsimpleNode start="(1939, 67)" end="(1939, 71)">
            <AtomNode start="(1939, 67)" end="(1939, 69)" leading="" trailing=" " val=":="/>
            <IdentNode start="(1939, 70)" end="(1939, 71)" leading="" trailing="&#10;" raw_val="α" val="α"/>
            <OtherNode kind="Lean.Parser.Termination.suffix">
              <NullNode/>
              <NullNode/>
            </OtherNode>
            <NullNode/>
          </CommandDeclvalsimpleNode>
        </CommandAbbrevNode>
      </CommandDeclarationNode>
    </OtherNode>
  </FileNode>
  <Comments>
    <Comment start="(10, 36)" end="(12, 1)" text="-- keep it documented&#10;&#10;"/>
    <Comment start="(14, 1)" end="(18, 3)" text="`as_aux_lemma =&gt; tac` does the same as `tac`, except that it wraps the resulting expression&#10;into an auxiliary lemma. In some cases, this significantly reduces the size of expressions&#10;because the proof term is not duplicated.&#10;-/"/>
    <Comment start="(21, 1)" end="(24, 3)" text="`with_annotate_state stx t` annotates the lexical range of `stx : Syntax` with&#10;the initial and final state of running tactic `t`.&#10;-/"/>
    <Comment start="(28, 1)" end="(48, 3)" text="Introduces one or more hypotheses, optionally naming and/or pattern-matching them.&#10;For each hypothesis to be introduced, the remaining main goal's target type must&#10;be a `let` or function type.&#10;&#10;* `intro` by itself introduces one anonymous hypothesis, which can be accessed&#10;  by e.g. `assumption`.&#10;* `intro x y` introduces two hypotheses and names them. Individual hypotheses&#10;  can be anonymized via `_`, or matched against a pattern:&#10;  ```lean&#10;  -- ... ⊢ α × β → ...&#10;  intro (a, b)&#10;  -- ..., a : α, b : β ⊢ ...&#10;  ```&#10;* Alternatively, `intro` can be combined with pattern matching much like `fun`:&#10;  ```lean&#10;  intro&#10;  | n + 1, 0 =&gt; tac&#10;  | ...&#10;  ```&#10;-/"/>
    <Comment start="(51, 1)" end="(121, 3)" text="Introduces zero or more hypotheses, optionally naming them.&#10;&#10;- `intros` is equivalent to repeatedly applying `intro`&#10;  until the goal is not an obvious candidate for `intro`, which is to say&#10;  that so long as the goal is a `let` or a pi type (e.g. an implication, function, or universal quantifier),&#10;  the `intros` tactic will introduce an anonymous hypothesis.&#10;  This tactic does not unfold definitions.&#10;&#10;- `intros x y ...` is equivalent to `intro x y ...`,&#10;  introducing hypotheses for each supplied argument and unfolding definitions as necessary.&#10;  Each argument can be either an identifier or a `_`.&#10;  An identifier indicates a name to use for the corresponding introduced hypothesis,&#10;  and a `_` indicates that the hypotheses should be introduced anonymously.&#10;&#10;## Examples&#10;&#10;Basic properties:&#10;```lean&#10;def AllEven (f : Nat → Nat) := ∀ n, f n % 2 = 0&#10;&#10;-- Introduces the two obvious hypotheses automatically&#10;example : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k =&gt; f (k + 1)) := by&#10;  intros&#10;  /- Tactic state&#10;     f✝ : Nat → Nat&#10;     a✝ : AllEven f✝&#10;     ⊢ AllEven fun k =&gt; f✝ (k + 1) -/&#10;  sorry&#10;&#10;-- Introduces exactly two hypotheses, naming only the first&#10;example : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k =&gt; f (k + 1)) := by&#10;  intros g _&#10;  /- Tactic state&#10;     g : Nat → Nat&#10;     a✝ : AllEven g&#10;     ⊢ AllEven fun k =&gt; g (k + 1) -/&#10;  sorry&#10;&#10;-- Introduces exactly three hypotheses, which requires unfolding `AllEven`&#10;example : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k =&gt; f (k + 1)) := by&#10;  intros f h n&#10;  /- Tactic state&#10;     f : Nat → Nat&#10;     h : AllEven f&#10;     n : Nat&#10;     ⊢ (fun k =&gt; f (k + 1)) n % 2 = 0 -/&#10;  apply h&#10;```&#10;&#10;Implications:&#10;```lean&#10;example (p q : Prop) : p → q → p := by&#10;  intros&#10;  /- Tactic state&#10;     a✝¹ : p&#10;     a✝ : q&#10;     ⊢ p      -/&#10;  assumption&#10;```&#10;&#10;Let bindings:&#10;```lean&#10;example : let n := 1; let k := 2; n + k = 3 := by&#10;  intros&#10;  /- n✝ : Nat := 1&#10;     k✝ : Nat := 2&#10;     ⊢ n✝ + k✝ = 3 -/&#10;  rfl&#10;```&#10;-/"/>
    <Comment start="(124, 1)" end="(127, 3)" text="`rename t =&gt; x` renames the most recent hypothesis whose type matches `t`&#10;(which may contain placeholders) to `x`, or fails if no such hypothesis could be found.&#10;-/"/>
    <Comment start="(130, 1)" end="(133, 3)" text="`revert x...` is the inverse of `intro x...`: it moves the given hypotheses&#10;into the main goal's target type.&#10;-/"/>
    <Comment start="(136, 1)" end="(139, 3)" text="`clear x...` removes the given hypotheses, or fails if there are remaining&#10;references to a hypothesis.&#10;-/"/>
    <Comment start="(142, 1)" end="(146, 3)" text="`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis&#10;of type `x = e` or `e = x`.&#10;If `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead.&#10;-/"/>
    <Comment start="(149, 1)" end="(151, 3)" text="Applies `subst` to all hypotheses of the form `h : x = t` or `h : t = x`.&#10;-/"/>
    <Comment start="(154, 1)" end="(157, 3)" text="`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.&#10;Note also the `‹t›` term notation, which is a shorthand for `show t by assumption`.&#10;-/"/>
    <Comment start="(160, 1)" end="(183, 3)" text="`contradiction` closes the main goal if its hypotheses are &quot;trivially contradictory&quot;.&#10;&#10;- Inductive type/family with no applicable constructors&#10;  ```lean&#10;  example (h : False) : p := by contradiction&#10;  ```&#10;- Injectivity of constructors&#10;  ```lean&#10;  example (h : none = some true) : p := by contradiction  --&#10;  ```&#10;- Decidable false proposition&#10;  ```lean&#10;  example (h : 2 + 2 = 3) : p := by contradiction&#10;  ```&#10;- Contradictory hypotheses&#10;  ```lean&#10;  example (h : p) (h' : ¬ p) : q := by contradiction&#10;  ```&#10;- Other simple contradictions such as&#10;  ```lean&#10;  example (x : Nat) (h : x ≠ x) : p := by contradiction&#10;  ```&#10;-/"/>
    <Comment start="(186, 1)" end="(196, 3)" text="Changes the goal to `False`, retaining as much information as possible:&#10;&#10;* If the goal is `False`, do nothing.&#10;* If the goal is an implication or a function type, introduce the argument and restart.&#10;  (In particular, if the goal is `x ≠ y`, introduce `x = y`.)&#10;* Otherwise, for a propositional goal `P`, replace it with `¬ ¬ P`&#10;  (attempting to find a `Decidable` instance, but otherwise falling back to working classically)&#10;  and introduce `¬ P`.&#10;* For a non-propositional goal use `False.elim`.&#10;-/"/>
    <Comment start="(199, 1)" end="(207, 3)" text="`apply e` tries to match the current goal against the conclusion of `e`'s type.&#10;If it succeeds, then the tactic returns as many subgoals as the number of premises that&#10;have not been fixed by type inference or type class resolution.&#10;Non-dependent premises are added before dependent ones.&#10;&#10;The `apply` tactic uses higher-order pattern matching, type class resolution,&#10;and first-order unification with dependent types.&#10;-/"/>
    <Comment start="(210, 1)" end="(212, 3)" text="`exact e` closes the main goal if its target type matches that of `e`.&#10;-/"/>
    <Comment start="(215, 1)" end="(219, 3)" text="`refine e` behaves like `exact e`, except that named (`?x`) or unnamed (`?_`)&#10;holes in `e` that are not solved by unification with the main goal's target type&#10;are converted into new goals, using the hole's name, if any, as the goal case name.&#10;-/"/>
    <Comment start="(222, 1)" end="(225, 3)" text="`refine' e` behaves like `refine e`, except that unsolved placeholders (`_`)&#10;and implicit parameters are also converted into new goals.&#10;-/"/>
    <Comment start="(228, 1)" end="(228, 82)" text="`exfalso` converts a goal `⊢ tgt` into `⊢ False` by applying `False.elim`. -/"/>
    <Comment start="(231, 1)" end="(234, 3)" text="If the main goal's target type is an inductive type, `constructor` solves it with&#10;the first matching constructor, or else fails.&#10;-/"/>
    <Comment start="(237, 1)" end="(245, 3)" text="Applies the first constructor when&#10;the goal is an inductive type with exactly two constructors, or fails otherwise.&#10;```&#10;example : True ∨ False := by&#10;  left&#10;  trivial&#10;```&#10;-/"/>
    <Comment start="(248, 1)" end="(256, 3)" text="Applies the second constructor when&#10;the goal is an inductive type with exactly two constructors, or fails otherwise.&#10;```&#10;example {p q : Prop} (h : q) : p ∨ q := by&#10;  right&#10;  exact h&#10;```&#10;-/"/>
    <Comment start="(259, 1)" end="(265, 3)" text="* `case tag =&gt; tac` focuses on the goal with case name `tag` and solves it using `tac`,&#10;  or else fails.&#10;* `case tag x₁ ... xₙ =&gt; tac` additionally renames the `n` most recent hypotheses&#10;  with inaccessible names to the given names.&#10;* `case tag₁ | tag₂ =&gt; tac` is equivalent to `(case tag₁ =&gt; tac); (case tag₂ =&gt; tac)`.&#10;-/"/>
    <Comment start="(268, 1)" end="(273, 3)" text="`case'` is similar to the `case tag =&gt; tac` tactic, but does not ensure the goal&#10;has been solved after applying `tac`, nor admits the goal if `tac` failed.&#10;Recall that `case` closes the goal using `sorry` when `tac` fails, and&#10;the tactic execution is not interrupted.&#10;-/"/>
    <Comment start="(276, 1)" end="(280, 3)" text="`next =&gt; tac` focuses on the next goal and solves it using `tac`, or else fails.&#10;`next x₁ ... xₙ =&gt; tac` additionally renames the `n` most recent hypotheses with&#10;inaccessible names to the given names.&#10;-/"/>
    <Comment start="(282, 3)" end="(283, 3)" text="-- Limit ref variability for incrementality; see Note [Incremental Macros]&#10;  "/>
    <Comment start="(285, 1)" end="(290, 3)" text="`all_goals tac` runs `tac` on each goal, concatenating the resulting goals.&#10;If the tactic fails on any goal, the entire `all_goals` tactic fails.&#10;&#10;See also `any_goals tac`.&#10;-/"/>
    <Comment start="(293, 1)" end="(299, 3)" text="`any_goals tac` applies the tactic `tac` to every goal,&#10;concatenating the resulting goals for successful tactic applications.&#10;If the tactic fails on all of the goals, the entire `any_goals` tactic fails.&#10;&#10;This tactic is like `all_goals try tac` except that it fails if none of the applications of `tac` succeeds.&#10;-/"/>
    <Comment start="(302, 1)" end="(305, 3)" text="`focus tac` focuses on the main goal, suppressing all other goals, and runs `tac` on it.&#10;Usually `· tac`, which enforces that the goal is closed by `tac`, should be preferred.&#10;-/"/>
    <Comment start="(308, 1)" end="(308, 28)" text="`skip` does nothing. -/"/>
    <Comment start="(311, 1)" end="(311, 57)" text="`done` succeeds iff there are no remaining goals. -/"/>
    <Comment start="(314, 1)" end="(314, 66)" text="`trace_state` displays the current state in the info view. -/"/>
    <Comment start="(317, 1)" end="(317, 52)" text="`trace msg` displays `msg` in the info view. -/"/>
    <Comment start="(320, 1)" end="(320, 61)" text="`fail_if_success t` fails if the tactic `t` succeeds. -/"/>
    <Comment start="(323, 1)" end="(327, 3)" text="`(tacs)` executes a list of tactics in sequence, without requiring that&#10;the goal be closed at the end like `· tacs`. Like `by` itself, the tactics&#10;can be either separated by newlines or `;`.&#10;-/"/>
    <Comment start="(330, 1)" end="(333, 3)" text="`with_reducible tacs` executes `tacs` using the reducible transparency setting.&#10;In this setting only definitions tagged as `[reducible]` are unfolded.&#10;-/"/>
    <Comment start="(336, 1)" end="(339, 3)" text="`with_reducible_and_instances tacs` executes `tacs` using the `.instances` transparency setting.&#10;In this setting only definitions tagged as `[reducible]` or type class instances are unfolded.&#10;-/"/>
    <Comment start="(342, 1)" end="(345, 3)" text="`with_unfolding_all tacs` executes `tacs` using the `.all` transparency setting.&#10;In this setting all definitions that are not opaque are unfolded.&#10;-/"/>
    <Comment start="(348, 1)" end="(348, 78)" text="`first | tac | ...` runs each `tac` until one succeeds, or else fails. -/"/>
    <Comment start="(351, 1)" end="(355, 3)" text="`rotate_left n` rotates goals to the left by `n`. That is, `rotate_left 1`&#10;takes the main goal and puts it to the back of the subgoal list.&#10;If `n` is omitted, it defaults to `1`.&#10;-/"/>
    <Comment start="(358, 1)" end="(361, 3)" text="Rotate the goals to the right by `n`. That is, take the goal at the back&#10;and push it to the front `n` times. If `n` is omitted, it defaults to `1`.&#10;-/"/>
    <Comment start="(364, 1)" end="(364, 63)" text="`try tac` runs `tac` and succeeds even if `tac` failed. -/"/>
    <Comment start="(367, 1)" end="(370, 3)" text="`tac &lt;;&gt; tac'` runs `tac` on the main goal and `tac'` on each produced goal,&#10;concatenating all goals produced by `tac'`.&#10;-/"/>
    <Comment start="(374, 5)" end="(375, 5)" text="-- annotate token with state after executing `x`&#10;    "/>
    <Comment start="(378, 1)" end="(378, 96)" text="`fail msg` is a tactic that always fails, and produces an error using the given message. -/"/>
    <Comment start="(381, 1)" end="(381, 76)" text="`eq_refl` is equivalent to `exact rfl`, but has a few optimizations. -/"/>
    <Comment start="(384, 1)" end="(388, 3)" text="This tactic applies to a goal whose target has the form `x ~ x`,&#10;where `~` is equality, heterogeneous equality or any relation that&#10;has a reflexivity lemma tagged with the attribute @[refl].&#10;-/"/>
    <Comment start="(391, 1)" end="(393, 3)" text="The same as `rfl`, but without trying `eq_refl` at the end.&#10;-/"/>
    <Comment start="(396, 1)" end="(397, 1)" text="-- We try `apply_rfl` first, because it produces a nice error message&#10;"/>
    <Comment start="(399, 1)" end="(400, 1)" text="-- But, mostly for backward compatibility, we try `eq_refl` too (reduces more aggressively)&#10;"/>
    <Comment start="(401, 1)" end="(402, 1)" text="-- Also for backward compatibility, because `exact` can trigger the implicit lambda feature (see #5366)&#10;"/>
    <Comment start="(403, 1)" end="(406, 3)" text="`rfl'` is similar to `rfl`, but disables smart unfolding and unfolds all kinds of definitions,&#10;theorems included (relevant for declarations defined by well-founded recursion).&#10;-/"/>
    <Comment start="(409, 1)" end="(417, 3)" text="`ac_rfl` proves equalities up to application of an associative and commutative operator.&#10;```&#10;instance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩&#10;instance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩&#10;&#10;example (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by ac_rfl&#10;```&#10;-/"/>
    <Comment start="(420, 1)" end="(428, 3)" text="The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,&#10;closing the main goal using `exact sorry`.&#10;&#10;This is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.&#10;Lean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,&#10;but you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output&#10;of the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.&#10;-/"/>
    <Comment start="(431, 1)" end="(431, 41)" text="`admit` is a synonym for `sorry`. -/"/>
    <Comment start="(434, 1)" end="(437, 3)" text="`infer_instance` is an abbreviation for `exact inferInstance`.&#10;It synthesizes a value of any target type by typeclass inference.&#10;-/"/>
    <Comment start="(440, 1)" end="(442, 3)" text="`+opt` is short for `(opt := true)`. It sets the `opt` configuration option to `true`.&#10;-/"/>
    <Comment start="(444, 1)" end="(446, 3)" text="`-opt` is short for `(opt := false)`. It sets the `opt` configuration option to `false`.&#10;-/"/>
    <Comment start="(448, 1)" end="(452, 3)" text="`(opt := val)` sets the `opt` configuration option to `val`.&#10;&#10;As a special case, `(config := ...)` sets the entire configuration.&#10;-/"/>
    <Comment start="(454, 1)" end="(454, 56)" text="A configuration item for a tactic configuration. -/"/>
    <Comment start="(457, 1)" end="(457, 42)" text="Configuration options for tactics. -/"/>
    <Comment start="(460, 1)" end="(460, 102)" text="Optional configuration option for tactics. (Deprecated. Replace `(config)?` with `optConfig`.) -/"/>
    <Comment start="(463, 1)" end="(463, 63)" text="The `*` location refers to all hypotheses and the goal. -/"/>
    <Comment start="(466, 1)" end="(466, 52)" text="The `⊢` location refers to the current goal. -/"/>
    <Comment start="(469, 1)" end="(472, 3)" text="A sequence of one or more locations at which a tactic should operate. These can include local&#10;hypotheses and `⊢`, which denotes the goal.&#10;-/"/>
    <Comment start="(475, 1)" end="(483, 3)" text="Location specifications are used by many tactics that can operate on either the&#10;hypotheses or the goal. It can have one of the forms:&#10;* 'empty' is not actually present in this syntax, but most tactics use&#10;  `(location)?` matchers. It means to target the goal only.&#10;* `at h₁ ... hₙ`: target the hypotheses `h₁`, ..., `hₙ`&#10;* `at h₁ h₂ ⊢`: target the hypotheses `h₁` and `h₂`, and the goal&#10;* `at *`: target all hypotheses and the goal&#10;-/"/>
    <Comment start="(486, 1)" end="(491, 3)" text="* `change tgt'` will change the goal from `tgt` to `tgt'`,&#10;  assuming these are definitionally equal.&#10;* `change t' at h` will change hypothesis `h : t` to have type `t'`, assuming&#10;  assuming `t` and `t'` are definitionally equal.&#10;-/"/>
    <Comment start="(494, 1)" end="(498, 3)" text="* `change a with b` will change occurrences of `a` to `b` in the goal,&#10;  assuming `a` and `b` are definitionally equal.&#10;* `change a with b at h` similarly changes `a` to `b` in the type of hypothesis `h`.&#10;-/"/>
    <Comment start="(501, 1)" end="(512, 3)" text="Extracts `let` and `let_fun` expressions from within the target or a local hypothesis,&#10;introducing new local definitions.&#10;&#10;- `extract_lets` extracts all the lets from the target.&#10;- `extract_lets x y z` extracts all the lets from the target and uses `x`, `y`, and `z` for the first names.&#10;  Using `_` for a name leaves it unnamed.&#10;- `extract_lets x y z at h` operates on the local hypothesis `h` instead of the target.&#10;&#10;For example, given a local hypotheses if the form `h : let x := v; b x`, then `extract_lets z at h`&#10;introduces a new local definition `z := v` and changes `h` to be `h : b z`.&#10;-/"/>
    <Comment start="(515, 1)" end="(530, 3)" text="Lifts `let` and `let_fun` expressions within a term as far out as possible.&#10;It is like `extract_lets +lift`, but the top-level lets at the end of the procedure&#10;are not extracted as local hypotheses.&#10;&#10;- `lift_lets` lifts let expressions in the target.&#10;- `lift_lets at h` lifts let expressions at the given local hypothesis.&#10;&#10;For example,&#10;```lean&#10;example : (let x := 1; x) = 1 := by&#10;  lift_lets&#10;  -- ⊢ let x := 1; x = 1&#10;  ...&#10;```&#10;-/"/>
    <Comment start="(533, 1)" end="(537, 3)" text="If `thm` is a theorem `a = b`, then as a rewrite rule,&#10;* `thm` means to replace `a` with `b`, and&#10;* `← thm` means to replace `b` with `a`.&#10;-/"/>
    <Comment start="(539, 1)" end="(539, 56)" text="A `rwRuleSeq` is a list of `rwRule` in brackets. -/"/>
    <Comment start="(542, 1)" end="(560, 3)" text="`rewrite [e]` applies identity `e` as a rewrite rule to the target of the main goal.&#10;If `e` is preceded by left arrow (`←` or `&lt;-`), the rewrite is applied in the reverse direction.&#10;If `e` is a defined constant, then the equational theorems associated with `e` are used.&#10;This provides a convenient way to unfold `e`.&#10;- `rewrite [e₁, ..., eₙ]` applies the given rules sequentially.&#10;- `rewrite [e] at l` rewrites `e` at location(s) `l`, where `l` is either `*` or a&#10;  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`&#10;  can also be used, to signify the target of the goal.&#10;&#10;Using `rw (occs := .pos L) [e]`,&#10;where `L : List Nat`, you can control which &quot;occurrences&quot; are rewritten.&#10;(This option applies to each rule, so usually this will only be used with a single rule.)&#10;Occurrences count from `1`.&#10;At each allowed occurrence, arguments of the rewrite rule `e` may be instantiated,&#10;restricting which later rewrites can be found.&#10;(Disallowed occurrences do not result in instantiation.)&#10;`(occs := .neg L)` allows skipping specified occurrences.&#10;-/"/>
    <Comment start="(563, 1)" end="(565, 3)" text="`rw` is like `rewrite`, but also tries to close the goal by &quot;cheap&quot; (reducible) `rfl` afterwards.&#10;-/"/>
    <Comment start="(569, 5)" end="(570, 5)" text="-- We show the `rfl` state on `]`&#10;    "/>
    <Comment start="(573, 1)" end="(573, 49)" text="`rwa` is short-hand for `rw; assumption`. -/"/>
    <Comment start="(577, 1)" end="(589, 3)" text="The `injection` tactic is based on the fact that constructors of inductive data&#10;types are injections.&#10;That means that if `c` is a constructor of an inductive datatype, and if `(c t₁)`&#10;and `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.&#10;If `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies&#10;injectivity to derive the equality of all arguments of `t₁` and `t₂` placed in&#10;the same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`.&#10;To use this tactic `t₁` and `t₂` should be constructor applications of the same constructor.&#10;Given `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types&#10;`a = c` and `b = d` to the main goal.&#10;The tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.&#10;-/"/>
    <Comment start="(592, 1)" end="(594, 56)" text="`injections` applies `injection` to all hypotheses recursively&#10;(since `injection` can produce new hypotheses). Useful for destructing nested&#10;constructor equalities like `(a::b::c) = (d::e::f)`. -/"/>
    <Comment start="(595, 1)" end="(596, 1)" text="-- TODO: add with&#10;"/>
    <Comment start="(598, 1)" end="(601, 3)" text="The discharger clause of `simp` and related tactics.&#10;This is a tactic used to discharge the side conditions on conditional rewrite rules.&#10;-/"/>
    <Comment start="(604, 1)" end="(604, 58)" text="Use this rewrite rule before entering the subterms -/"/>
    <Comment start="(606, 1)" end="(606, 57)" text="Use this rewrite rule after entering the subterms -/"/>
    <Comment start="(608, 1)" end="(613, 3)" text="A simp lemma specification is:&#10;* optional `↑` or `↓` to specify use before or after entering the subterm&#10;* optional `←` to use the lemma backward&#10;* `thm` for the theorem to rewrite with&#10;-/"/>
    <Comment start="(615, 1)" end="(615, 78)" text="An erasure specification `-thm` says to remove `thm` from the simp set -/"/>
    <Comment start="(617, 1)" end="(617, 77)" text="The simp lemma specification `*` means to rewrite with all hypotheses -/"/>
    <Comment start="(619, 1)" end="(638, 3)" text="The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or&#10;non-dependent hypotheses. It has many variants:&#10;- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.&#10;- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged&#10;  with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions.-&#10;- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated&#10;  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.&#10;- `simp [*]` simplifies the main goal target using the lemmas tagged with the&#10;  attribute `[simp]` and all hypotheses.&#10;- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.&#10;- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged&#10;  with the attribute `[simp]`, but removes the ones named `idᵢ`.&#10;- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If&#10;  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis&#10;  `hᵢ` is introduced, but the old one remains in the local context.&#10;- `simp at *` simplifies all the hypotheses and the target.&#10;- `simp [*] at *` simplifies target and all (propositional) hypotheses using the&#10;  other hypotheses.&#10;-/"/>
    <Comment start="(641, 1)" end="(645, 3)" text="`simp_all` is a stronger version of `simp [*] at *` where the hypotheses and target&#10;are simplified multiple times until no simplification is applicable.&#10;Only non-dependent propositional hypotheses are considered.&#10;-/"/>
    <Comment start="(649, 1)" end="(653, 3)" text="The `dsimp` tactic is the definitional simplifier. It is similar to `simp` but only&#10;applies theorems that hold by reflexivity. Thus, the result is guaranteed to be&#10;definitionally equal to the input.&#10;-/"/>
    <Comment start="(657, 1)" end="(660, 3)" text="A `simpArg` is either a `*`, `-lemma` or a simp lemma specification&#10;(which includes the `↑` `↓` `←` specifications for pre, post, reverse rewriting).&#10;-/"/>
    <Comment start="(663, 1)" end="(663, 85)" text="A simp args list is a list of `simpArg`. This is the main argument to `simp`. -/"/>
    <Comment start="(666, 1)" end="(669, 3)" text="A `dsimpArg` is similar to `simpArg`, but it does not have the `simpStar` form&#10;because it does not make sense to use hypotheses in `dsimp`.&#10;-/"/>
    <Comment start="(672, 1)" end="(672, 88)" text="A dsimp args list is a list of `dsimpArg`. This is the main argument to `dsimp`. -/"/>
    <Comment start="(675, 1)" end="(675, 53)" text="The common arguments of `simp?` and `simp?!`. -/"/>
    <Comment start="(678, 1)" end="(688, 3)" text="`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`&#10;that would be sufficient to close the goal. This is useful for reducing the size of the simp&#10;set in a local invocation to speed up processing.&#10;```&#10;example (x : Nat) : (if True then x + 2 else 3) = x + 2 := by&#10;  simp? -- prints &quot;Try this: simp only [ite_true]&quot;&#10;```&#10;&#10;This command can also be used in `simp_all` and `dsimp`.&#10;-/"/>
    <Comment start="(694, 1)" end="(694, 61)" text="The common arguments of `simp_all?` and `simp_all?!`. -/"/>
    <Comment start="(703, 1)" end="(703, 55)" text="The common arguments of `dsimp?` and `dsimp?!`. -/"/>
    <Comment start="(712, 1)" end="(712, 52)" text="The arguments to the `simpa` family tactics. -/"/>
    <Comment start="(715, 1)" end="(728, 3)" text="This is a &quot;finishing&quot; tactic modification of `simp`. It has two forms.&#10;&#10;* `simpa [rules, ⋯] using e` will simplify the goal and the type of&#10;  `e` using `rules`, then try to close the goal using `e`.&#10;&#10;  Simplifying the type of `e` makes it more likely to match the goal&#10;  (which has also been simplified). This construction also tends to be&#10;  more robust under changes to the simp lemma set.&#10;&#10;* `simpa [rules, ⋯]` will simplify the goal and the type of a&#10;  hypothesis `this` if present in the context, then try to close the goal using&#10;  the `assumption` tactic.&#10;-/"/>
    <Comment start="(740, 1)" end="(744, 3)" text="`delta id1 id2 ...` delta-expands the definitions `id1`, `id2`, ....&#10;This is a low-level tactic, it will expose how recursive definitions have been&#10;compiled by Lean.&#10;-/"/>
    <Comment start="(747, 1)" end="(758, 3)" text="* `unfold id` unfolds all occurrences of definition `id` in the target.&#10;* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.&#10;* `unfold id at h` unfolds at the hypothesis `h`.&#10;&#10;Definitions can be either global or local definitions.&#10;&#10;For non-recursive global definitions, this tactic is identical to `delta`.&#10;For recursive global definitions, it uses the &quot;unfolding lemma&quot; `id.eq_def`,&#10;which is generated for each recursive definition, to unfold according to the recursive definition given by the user.&#10;Only one level of unfolding is performed, in contrast to `simp only [id]`, which unfolds definition `id` recursively.&#10;-/"/>
    <Comment start="(761, 1)" end="(764, 3)" text="Auxiliary macro for lifting have/suffices/let/...&#10;It makes sure the &quot;continuation&quot; `?_` is the main goal after refining.&#10;-/"/>
    <Comment start="(767, 1)" end="(777, 3)" text="The `have` tactic is for adding hypotheses to the local context of the main goal.&#10;* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.&#10;* `have h := e` uses the type of `e` for `t`.&#10;* `have : t := e` and `have := e` use `this` for the name of the hypothesis.&#10;* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,&#10;  where `_` stands for the tactics that follow this one.&#10;  It is convenient for types that have only one applicable constructor.&#10;  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the&#10;  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.&#10;-/"/>
    <Comment start="(780, 3)" end="(782, 3)" text="-- special case: when given a nested `by` block, move it outside of the `refine` to enable&#10;  -- incrementality&#10;  "/>
    <Comment start="(810, 1)" end="(816, 4)" text="Given a main goal `ctx ⊢ t`, `suffices h : t' from e` replaces the main goal with `ctx ⊢ t'`,&#10;`e` must have type `t` in the context `ctx, h : t'`.&#10;&#10;The variant `suffices h : t' by tac` is a shorthand for `suffices h : t' from by tac`.&#10;If `h :` is omitted, the name `this` is used.&#10; -/"/>
    <Comment start="(818, 1)" end="(828, 3)" text="The `let` tactic is for adding definitions to the local context of the main goal.&#10;* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.&#10;* `let x := e` uses the type of `e` for `t`.&#10;* `let : t := e` and `let := e` use `this` for the name of the hypothesis.&#10;* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,&#10;  where `_` stands for the tactics that follow this one.&#10;  It is convenient for types that let only one applicable constructor.&#10;  For example, given `p : α × β × γ`, `let ⟨x, y, z⟩ := p` produces the&#10;  local variables `x : α`, `y : β`, and `z : γ`.&#10;-/"/>
    <Comment start="(830, 1)" end="(833, 3)" text="`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,&#10; performs the unification, and replaces the target with the unified version of `t`.&#10;-/"/>
    <Comment start="(834, 73)" end="(835, 1)" text="-- TODO: fix, see comment&#10;"/>
    <Comment start="(835, 1)" end="(836, 50)" text="`let rec f : t := e` adds a recursive definition `f` to the current goal.&#10;The syntax is the same as term-mode `let rec`. -/"/>
    <Comment start="(841, 1)" end="(841, 53)" text="Similar to `refine_lift`, but using `refine'` -/"/>
    <Comment start="(843, 1)" end="(843, 46)" text="Similar to `have`, but using `refine'` -/"/>
    <Comment start="(845, 40)" end="(846, 1)" text="-- OK, because `tactic_alt` causes inheritance of docs&#10;"/>
    <Comment start="(848, 1)" end="(848, 45)" text="Similar to `let`, but using `refine'` -/"/>
    <Comment start="(851, 1)" end="(855, 3)" text="The left hand side of an induction arm, `| foo a b c` or `| @foo a b c`&#10;where `foo` is a constructor of the inductive type and `a b c` are the arguments&#10;to the constructor.&#10;-/"/>
    <Comment start="(857, 1)" end="(860, 3)" text="In induction alternative, which can have 1 or more cases on the left&#10;and `_`, `?_`, or a tactic sequence after the `=&gt;`.&#10;-/"/>
    <Comment start="(862, 1)" end="(865, 3)" text="After `with`, there is an optional tactic that runs on all branches, and&#10;then a list of alternatives.&#10;-/"/>
    <Comment start="(868, 1)" end="(874, 3)" text="A target for the `induction` or `cases` tactic, of the form `e` or `h : e`.&#10;&#10;The `h : e` syntax introduces a hypotheses of the form `h : e = _` in each goal,&#10;with `_` replaced by the corresponding value of the target.&#10;It is useful when `e` is not a free variable.&#10;-/"/>
    <Comment start="(876, 1)" end="(901, 3)" text="Assuming `x` is a variable in the local context with an inductive type,&#10;`induction x` applies induction on `x` to the main goal,&#10;producing one goal for each constructor of the inductive type,&#10;in which the target is replaced by a general instance of that constructor&#10;and an inductive hypothesis is added for each recursive argument to the constructor.&#10;If the type of an element in the local context depends on `x`,&#10;that element is reverted and reintroduced afterward,&#10;so that the inductive hypothesis incorporates that hypothesis as well.&#10;&#10;For example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,&#10;`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,&#10;and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.&#10;Here the names `a` and `ih₁` are chosen automatically and are not accessible.&#10;You can use `with` to provide the variables names for each constructor.&#10;- `induction e`, where `e` is an expression instead of a variable,&#10;  generalizes `e` in the goal, and then performs induction on the resulting variable.&#10;- `induction e using r` allows the user to specify the principle of induction that should be used.&#10;  Here `r` should be a term whose result type must be of the form `C t`,&#10;  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables&#10;- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,&#10;  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.&#10;  In other words, the net effect is that each inductive hypothesis is generalized.&#10;- Given `x : Nat`, `induction x with | zero =&gt; tac₁ | succ x' ih =&gt; tac₂`&#10;  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.&#10;-/"/>
    <Comment start="(905, 1)" end="(905, 74)" text="A `generalize` argument, of the form `term = x` or `h : term = x`. -/"/>
    <Comment start="(908, 1)" end="(914, 3)" text="* `generalize ([h :] e = x),+` replaces all occurrences `e`s in the main goal&#10;  with a fresh hypothesis `x`s. If `h` is given, `h : e = x` is introduced as well.&#10;* `generalize e = x at h₁ ... hₙ` also generalizes occurrences of `e`&#10;  inside `h₁`, ..., `hₙ`.&#10;* `generalize e = x at *` will generalize occurrences of `e` everywhere.&#10;-/"/>
    <Comment start="(917, 1)" end="(939, 3)" text="Assuming `x` is a variable in the local context with an inductive type,&#10;`cases x` splits the main goal, producing one goal for each constructor of the&#10;inductive type, in which the target is replaced by a general instance of that constructor.&#10;If the type of an element in the local context depends on `x`,&#10;that element is reverted and reintroduced afterward,&#10;so that the case split affects that hypothesis as well.&#10;`cases` detects unreachable cases and closes them automatically.&#10;&#10;For example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,&#10;`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,&#10;and one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.&#10;Here the name `a` is chosen automatically and is not accessible.&#10;You can use `with` to provide the variables names for each constructor.&#10;- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,&#10;  and then cases on the resulting variable.&#10;- Given `as : List α`, `cases as with | nil =&gt; tac₁ | cons a as' =&gt; tac₂`,&#10;  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,&#10;  and `a` and `as'` are used as names for the new variables introduced.&#10;- `cases h : e`, where `e` is a variable or an expression,&#10;  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,&#10;  where `...` is the constructor instance for that particular case.&#10;-/"/>
    <Comment start="(942, 1)" end="(967, 3)" text="The `fun_induction` tactic is a convenience wrapper of the `induction` tactic when using a functional&#10;induction principle.&#10;&#10;The tactic invocation&#10;```&#10;fun_induction f x₁ ... xₙ y₁ ... yₘ&#10;```&#10;where `f` is a function defined by non-mutual structural or well-founded recursion, is equivalent to&#10;```&#10;induction y₁, ... yₘ using f.induct x₁ ... xₙ&#10;```&#10;where the arguments of `f` are used as arguments to `f.induct` or targets of the induction, as&#10;appropriate.&#10;&#10;The form&#10;```&#10;fun_induction f&#10;```&#10;(with no arguments to `f`) searches the goal for an unique eligible application of `f`, and uses&#10;these arguments. An application of `f` is eligible if it is saturated and the arguments that will&#10;become targets are free variables.&#10;&#10;The forms `fun_induction f x y generalizing z₁ ... zₙ` and&#10;`fun_induction f x y with | case1 =&gt; tac₁ | case2 x' ih =&gt; tac₂` work like with `induction.`&#10;-/"/>
    <Comment start="(971, 1)" end="(995, 3)" text="The `fun_cases` tactic is a convenience wrapper of the `cases` tactic when using a functional&#10;cases principle.&#10;&#10;The tactic invocation&#10;```&#10;fun_cases f x ... y ...`&#10;```&#10;is equivalent to&#10;```&#10;cases y, ... using f.fun_cases x ...&#10;```&#10;where the arguments of `f` are used as arguments to `f.fun_cases` or targets of the case analysis, as&#10;appropriate.&#10;&#10;The form&#10;```&#10;fun_cases f&#10;```&#10;(with no arguments to `f`) searches the goal for an unique eligible application of `f`, and uses&#10;these arguments. An application of `f` is eligible if it is saturated and the arguments that will&#10;become targets are free variables.&#10;&#10;The form `fun_cases f x y with | case1 =&gt; tac₁ | case2 x' ih =&gt; tac₂` works like with `cases`.&#10;-/"/>
    <Comment start="(998, 1)" end="(998, 93)" text="`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. -/"/>
    <Comment start="(1001, 1)" end="(1012, 3)" text="`repeat tac` repeatedly applies `tac` so long as it succeeds.&#10;The tactic `tac` may be a tactic sequence, and if `tac` fails at any point in its execution,&#10;`repeat` will revert any partial changes that `tac` made to the tactic state.&#10;&#10;The tactic `tac` should eventually fail, otherwise `repeat tac` will run indefinitely.&#10;&#10;See also:&#10;* `try tac` is like `repeat tac` but will apply `tac` at most once.&#10;* `repeat' tac` recursively applies `tac` to each goal.&#10;* `first | tac1 | tac2` implements the backtracking used by `repeat`&#10;-/"/>
    <Comment start="(1017, 1)" end="(1024, 3)" text="`repeat' tac` recursively applies `tac` on all of the goals so long as it succeeds.&#10;That is to say, if `tac` produces multiple subgoals, then `repeat' tac` is applied to each of them.&#10;&#10;See also:&#10;* `repeat tac` simply repeatedly applies `tac`.&#10;* `repeat1' tac` is `repeat' tac` but requires that `tac` succeed for some goal at least once.&#10;-/"/>
    <Comment start="(1027, 1)" end="(1034, 3)" text="`repeat1' tac` recursively applies to `tac` on all of the goals so long as it succeeds,&#10;but `repeat1' tac` fails if `tac` succeeds on none of the initial goals.&#10;&#10;See also:&#10;* `repeat tac` simply applies `tac` repeatedly.&#10;* `repeat' tac` is like `repeat1' tac` but it does not require that `tac` succeed at least once.&#10;-/"/>
    <Comment start="(1037, 1)" end="(1044, 3)" text="`trivial` tries different simple tactics (e.g., `rfl`, `contradiction`, ...)&#10;to close the current goal.&#10;You can use the command `macro_rules` to extend the set of tactics used. Example:&#10;```&#10;macro_rules | `(tactic| trivial) =&gt; `(tactic| simp)&#10;```&#10;-/"/>
    <Comment start="(1047, 1)" end="(1053, 3)" text="`classical tacs` runs `tacs` in a scope where `Classical.propDecidable` is a low priority&#10;local instance.&#10;&#10;Note that `classical` is a scoping tactic: it adds the instance only within the&#10;scope of the tactic.&#10;-/"/>
    <Comment start="(1056, 1)" end="(1067, 3)" text="The `split` tactic is useful for breaking nested if-then-else and `match` expressions into separate cases.&#10;For a `match` expression with `n` cases, the `split` tactic generates at most `n` subgoals.&#10;&#10;For example, given `n : Nat`, and a target `if n = 0 then Q else R`, `split` will generate&#10;one goal with hypothesis `n = 0` and target `Q`, and a second goal with hypothesis&#10;`¬n = 0` and target `R`.  Note that the introduced hypothesis is unnamed, and is commonly&#10;renamed used the `case` or `next` tactics.&#10;&#10;- `split` will split the goal (target).&#10;- `split at h` will split the hypothesis `h`.&#10;-/"/>
    <Comment start="(1070, 1)" end="(1078, 3)" text="`dbg_trace &quot;foo&quot;` prints `foo` when elaborated.&#10;Useful for debugging tactic control flow:&#10;```&#10;example : False ∨ True := by&#10;  first&#10;  | apply Or.inl; trivial; dbg_trace &quot;left&quot;&#10;  | apply Or.inr; trivial; dbg_trace &quot;right&quot;&#10;```&#10;-/"/>
    <Comment start="(1081, 1)" end="(1086, 3)" text="`stop` is a helper tactic for &quot;discarding&quot; the rest of a proof:&#10;it is defined as `repeat sorry`.&#10;It is useful when working on the middle of a complex proofs,&#10;and less messy than commenting the remainder of the proof.&#10;-/"/>
    <Comment start="(1089, 1)" end="(1096, 3)" text="The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`.&#10;The premises of this hypothesis, either universal quantifications or&#10;non-dependent implications, are instantiated by concrete terms coming&#10;from arguments `a₁` ... `aₙ`.&#10;The tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ`&#10;and tries to clear the previous one.&#10;-/"/>
    <Comment start="(1099, 1)" end="(1110, 3)" text="`unhygienic tacs` runs `tacs` with name hygiene disabled.&#10;This means that tactics that would normally create inaccessible names will instead&#10;make regular variables. **Warning**: Tactics may change their variable naming&#10;strategies at any time, so code that depends on autogenerated names is brittle.&#10;Users should try not to use `unhygienic` if possible.&#10;```&#10;example : ∀ x : Nat, x = x := by unhygienic&#10;  intro            -- x would normally be intro'd as inaccessible&#10;  exact Eq.refl x  -- refer to x&#10;```&#10;-/"/>
    <Comment start="(1113, 1)" end="(1116, 3)" text="The tactic `sleep ms` sleeps for `ms` milliseconds and does nothing.&#10;It is used for debugging purposes only.&#10;-/"/>
    <Comment start="(1119, 1)" end="(1122, 3)" text="`exists e₁, e₂, ...` is shorthand for `refine ⟨e₁, e₂, ...⟩; try trivial`.&#10;It is useful for existential goals.&#10;-/"/>
    <Comment start="(1126, 1)" end="(1133, 3)" text="Apply congruence (recursively) to goals of the form `⊢ f as = f bs` and `⊢ HEq (f as) (f bs)`.&#10;The optional parameter is the depth of the recursive applications.&#10;This is useful when `congr` is too aggressive in breaking down the goal.&#10;For example, given `⊢ f (g (x + y)) = f (g (y + x))`,&#10;`congr` produces the goals `⊢ x = y` and `⊢ y = x`,&#10;while `congr 2` produces the intended `⊢ x + y = y + x`.&#10;-/"/>
    <Comment start="(1137, 1)" end="(1149, 3)" text="In tactic mode, `if h : t then tac1 else tac2` can be used as alternative syntax for:&#10;```&#10;by_cases h : t&#10;· tac1&#10;· tac2&#10;```&#10;It performs case distinction on `h : t` or `h : ¬t` and `tac1` and `tac2` are the subproofs.&#10;&#10;You can use `?_` or `_` for either subproof to delay the goal to after the tactic, but&#10;if a tactic sequence is provided for `tac1` or `tac2` then it will require the goal to be closed&#10;by the end of the block.&#10;-/"/>
    <Comment start="(1154, 1)" end="(1166, 3)" text="In tactic mode, `if t then tac1 else tac2` is alternative syntax for:&#10;```&#10;by_cases t&#10;· tac1&#10;· tac2&#10;```&#10;It performs case distinction on `h† : t` or `h† : ¬t`, where `h†` is an anonymous&#10;hypothesis, and `tac1` and `tac2` are the subproofs. (It doesn't actually use&#10;nondependent `if`, since this wouldn't add anything to the context and hence would be&#10;useless for proving theorems. To actually insert an `ite` application use&#10;`refine if t then ?_ else ?_`.)&#10;-/"/>
    <Comment start="(1171, 1)" end="(1174, 3)" text="The tactic `nofun` is shorthand for `exact nofun`: it introduces the assumptions, then performs an&#10;empty pattern match, closing the goal if the introduced pattern is impossible.&#10;-/"/>
    <Comment start="(1177, 1)" end="(1179, 3)" text="The tactic `nomatch h` is shorthand for `exact nomatch h`.&#10;-/"/>
    <Comment start="(1183, 1)" end="(1211, 3)" text="Acts like `have`, but removes a hypothesis with the same name as&#10;this one if possible. For example, if the state is:&#10;&#10;```lean&#10;f : α → β&#10;h : α&#10;⊢ goal&#10;```&#10;&#10;Then after `replace h := f h` the state will be:&#10;&#10;```lean&#10;f : α → β&#10;h : β&#10;⊢ goal&#10;```&#10;&#10;whereas `have h := f h` would result in:&#10;&#10;```lean&#10;f : α → β&#10;h† : α&#10;h : β&#10;⊢ goal&#10;```&#10;&#10;This can be used to simulate the `specialize` and `apply at` tactics of Coq.&#10;-/"/>
    <Comment start="(1214, 1)" end="(1214, 73)" text="`and_intros` applies `And.intro` until it does not make progress. -/"/>
    <Comment start="(1218, 1)" end="(1221, 3)" text="`subst_eq` repeatedly substitutes according to the equality proof hypotheses in the context,&#10;replacing the left side of the equality with the right, until no more progress can be made.&#10;-/"/>
    <Comment start="(1224, 1)" end="(1224, 67)" text="The `run_tac doSeq` tactic executes code in `TacticM Unit`. -/"/>
    <Comment start="(1227, 1)" end="(1227, 97)" text="`haveI` behaves like `have`, but inlines the value instead of producing a `let_fun` term. -/"/>
    <Comment start="(1230, 1)" end="(1230, 95)" text="`letI` behaves like `let`, but inlines the value instead of producing a `let_fun` term. -/"/>
    <Comment start="(1233, 1)" end="(1235, 3)" text="Configuration for the `decide` tactic family.&#10;-/"/>
    <Comment start="(1237, 3)" end="(1239, 61)" text="If true (default: false), then use only kernel reduction when reducing the `Decidable` instance.&#10;  This is more efficient, since the default mode reduces twice (once in the elaborator and again in the kernel),&#10;  however kernel reduction ignores transparency settings. -/"/>
    <Comment start="(1241, 3)" end="(1245, 104)" text="If true (default: false), then uses the native code compiler to evaluate the `Decidable` instance,&#10;  admitting the result via the axiom `Lean.ofReduceBool`.  This can be significantly more efficient,&#10;  but it is at the cost of increasing the trusted code base, namely the Lean compiler&#10;  and all definitions with an `@[implemented_by]` attribute.&#10;  The instance is only evaluated once. The `native_decide` tactic is a synonym for `decide +native`. -/"/>
    <Comment start="(1247, 3)" end="(1247, 126)" text="If true (default: true), then when preprocessing the goal, do zeta reduction to attempt to eliminate free variables. -/"/>
    <Comment start="(1249, 3)" end="(1251, 67)" text="If true (default: false), then when preprocessing, removes irrelevant variables and reverts the local context.&#10;  A variable is *relevant* if it appears in the target, if it appears in a relevant variable,&#10;  or if it is a proposition that refers to a relevant variable. -/"/>
    <Comment start="(1254, 1)" end="(1323, 3)" text="`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`&#10;and then reducing that instance to evaluate the truth value of `p`.&#10;If it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.&#10;&#10;The target is not allowed to contain local variables or metavariables.&#10;If there are local variables, you can first try using the `revert` tactic with these local variables to move them into the target,&#10;or you can use the `+revert` option, described below.&#10;&#10;Options:&#10;- `decide +revert` begins by reverting local variables that the target depends on,&#10;  after cleaning up the local context of irrelevant variables.&#10;  A variable is *relevant* if it appears in the target, if it appears in a relevant variable,&#10;  or if it is a proposition that refers to a relevant variable.&#10;- `decide +kernel` uses kernel for reduction instead of the elaborator.&#10;  It has two key properties: (1) since it uses the kernel, it ignores transparency and can unfold everything,&#10;  and (2) it reduces the `Decidable` instance only once instead of twice.&#10;- `decide +native` uses the native code compiler (`#eval`) to evaluate the `Decidable` instance,&#10;  admitting the result via the `Lean.ofReduceBool` axiom.&#10;  This can be significantly more efficient than using reduction, but it is at the cost of increasing the size&#10;  of the trusted code base.&#10;  Namely, it depends on the correctness of the Lean compiler and all definitions with an `@[implemented_by]` attribute.&#10;  Like with `+kernel`, the `Decidable` instance is evaluated only once.&#10;&#10;Limitation: In the default mode or `+kernel` mode, since `decide` uses reduction to evaluate the term,&#10;`Decidable` instances defined by well-founded recursion might not work because evaluating them requires reducing proofs.&#10;Reduction can also get stuck on `Decidable` instances with `Eq.rec` terms.&#10;These can appear in instances defined using tactics (such as `rw` and `simp`).&#10;To avoid this, create such instances using definitions such as `decidable_of_iff` instead.&#10;&#10;## Examples&#10;&#10;Proving inequalities:&#10;```lean&#10;example : 2 + 2 ≠ 5 := by decide&#10;```&#10;&#10;Trying to prove a false proposition:&#10;```lean&#10;example : 1 ≠ 1 := by decide&#10;/-&#10;tactic 'decide' proved that the proposition&#10;  1 ≠ 1&#10;is false&#10;-/&#10;```&#10;&#10;Trying to prove a proposition whose `Decidable` instance fails to reduce&#10;```lean&#10;opaque unknownProp : Prop&#10;&#10;open scoped Classical in&#10;example : unknownProp := by decide&#10;/-&#10;tactic 'decide' failed for proposition&#10;  unknownProp&#10;since its 'Decidable' instance reduced to&#10;  Classical.choice ⋯&#10;rather than to the 'isTrue' constructor.&#10;-/&#10;```&#10;&#10;## Properties and relations&#10;&#10;For equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.&#10;```lean&#10;example : 1 + 1 = 2 := by decide&#10;example : 1 + 1 = 2 := by rfl&#10;```&#10;-/"/>
    <Comment start="(1326, 1)" end="(1340, 3)" text="`native_decide` is a synonym for `decide +native`.&#10;It will attempt to prove a goal of type `p` by synthesizing an instance&#10;of `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this&#10;uses `#eval` to evaluate the decidability instance.&#10;&#10;This should be used with care because it adds the entire lean compiler to the trusted&#10;part, and the axiom `Lean.ofReduceBool` will show up in `#print axioms` for theorems using&#10;this method or anything that transitively depends on them. Nevertheless, because it is&#10;compiled, this can be significantly more efficient than using `decide`, and for very&#10;large computations this is one way to run external programs and trust the result.&#10;```lean&#10;example : (List.range 1000).length = 1000 := by native_decide&#10;```&#10;-/"/>
    <Comment start="(1350, 1)" end="(1379, 3)" text="The `omega` tactic, for resolving integer and natural linear arithmetic problems.&#10;&#10;It is not yet a full decision procedure (no &quot;dark&quot; or &quot;grey&quot; shadows),&#10;but should be effective on many problems.&#10;&#10;We handle hypotheses of the form `x = y`, `x &lt; y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`&#10;(and `k` a literal), along with negations of these statements.&#10;&#10;We decompose the sides of the inequalities as linear combinations of atoms.&#10;&#10;If we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables&#10;and the relevant inequalities.&#10;&#10;On the first pass, we do not perform case splits on natural subtraction.&#10;If `omega` fails, we recursively perform a case split on&#10;a natural subtraction appearing in a hypothesis, and try again.&#10;&#10;The options&#10;```&#10;omega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax&#10;```&#10;can be used to:&#10;* `splitDisjunctions`: split any disjunctions found in the context,&#10;  if the problem is not otherwise solvable.&#10;* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.&#10;* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.&#10;* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`&#10;Currently, all of these are on by default.&#10;-/"/>
    <Comment start="(1382, 1)" end="(1386, 3)" text="`bv_omega` is `omega` with an additional preprocessor that turns statements about `BitVec` into statements about `Nat`.&#10;Currently the preprocessor is implemented as `try simp only [bitvec_to_nat] at *`.&#10;`bitvec_to_nat` is a `@[simp]` attribute that you can (cautiously) add to more theorems.&#10;-/"/>
    <Comment start="(1389, 1)" end="(1389, 80)" text="Implementation of `ac_nf` (the full `ac_nf` calls `trivial` afterwards). -/"/>
    <Comment start="(1392, 1)" end="(1392, 88)" text="Implementation of `norm_cast` (the full `norm_cast` calls `trivial` afterwards). -/"/>
    <Comment start="(1395, 1)" end="(1401, 76)" text="`assumption_mod_cast` is a variant of `assumption` that solves the goal&#10;using a hypothesis. Unlike `assumption`, it first pre-processes the goal and&#10;each hypothesis to move casts as far outwards as possible, so it can be used&#10;in more situations.&#10;&#10;Concretely, it runs `norm_cast` on the goal. For each local hypothesis `h`, it also&#10;normalizes `h` with `norm_cast` and tries to use that to close the goal. -/"/>
    <Comment start="(1404, 1)" end="(1438, 3)" text="The `norm_cast` family of tactics is used to normalize certain coercions (*casts*) in expressions.&#10;- `norm_cast` normalizes casts in the target.&#10;- `norm_cast at h` normalizes casts in hypothesis `h`.&#10;&#10;The tactic is basically a version of `simp` with a specific set of lemmas to move casts&#10;upwards in the expression.&#10;Therefore even in situations where non-terminal `simp` calls are discouraged (because of fragility),&#10;`norm_cast` is considered to be safe.&#10;It also has special handling of numerals.&#10;&#10;For instance, given an assumption&#10;```lean&#10;a b : ℤ&#10;h : ↑a + ↑b &lt; (10 : ℚ)&#10;```&#10;writing `norm_cast at h` will turn `h` into&#10;```lean&#10;h : a + b &lt; 10&#10;```&#10;&#10;There are also variants of basic tactics that use `norm_cast` to normalize expressions during&#10;their operation, to make them more flexible about the expressions they accept&#10;(we say that it is a tactic *modulo* the effects of `norm_cast`):&#10;- `exact_mod_cast` for `exact` and `apply_mod_cast` for `apply`.&#10;  Writing `exact_mod_cast h` and `apply_mod_cast h` will normalize casts&#10;  in the goal and `h` before using `exact h` or `apply h`.&#10;- `rw_mod_cast` for `rw`. It applies `norm_cast` between rewrites.&#10;- `assumption_mod_cast` for `assumption`.&#10;  This is effectively `norm_cast at *; assumption`, but more efficient.&#10;  It normalizes casts in the goal and, for every hypothesis `h` in the context,&#10;  it will try to normalize casts in `h` and use `exact h`.&#10;&#10;See also `push_cast`, which moves casts inwards rather than lifting them outwards.&#10;-/"/>
    <Comment start="(1443, 1)" end="(1475, 3)" text="`push_cast` rewrites the goal to move certain coercions (*casts*) inward, toward the leaf nodes.&#10;This uses `norm_cast` lemmas in the forward direction.&#10;For example, `↑(a + b)` will be written to `↑a + ↑b`.&#10;- `push_cast` moves casts inward in the goal.&#10;- `push_cast at h` moves casts inward in the hypothesis `h`.&#10;It can be used with extra simp lemmas with, for example, `push_cast [Int.add_zero]`.&#10;&#10;Example:&#10;```lean&#10;example (a b : Nat)&#10;    (h1 : ((a + b : Nat) : Int) = 10)&#10;    (h2 : ((a + b + 0 : Nat) : Int) = 10) :&#10;    ((a + b : Nat) : Int) = 10 := by&#10;  /-&#10;  h1 : ↑(a + b) = 10&#10;  h2 : ↑(a + b + 0) = 10&#10;  ⊢ ↑(a + b) = 10&#10;  -/&#10;  push_cast&#10;  /- Now&#10;  ⊢ ↑a + ↑b = 10&#10;  -/&#10;  push_cast at h1&#10;  push_cast [Int.add_zero] at h2&#10;  /- Now&#10;  h1 h2 : ↑a + ↑b = 10&#10;  -/&#10;  exact h1&#10;```&#10;&#10;See also `norm_cast`.&#10;-/"/>
    <Comment start="(1479, 1)" end="(1481, 3)" text="`norm_cast_add_elim foo` registers `foo` as an elim-lemma in `norm_cast`.&#10;-/"/>
    <Comment start="(1484, 1)" end="(1498, 3)" text="`ac_nf` normalizes equalities up to application of an associative and commutative operator.&#10;- `ac_nf` normalizes all hypotheses and the goal target of the goal.&#10;- `ac_nf at l` normalizes at location(s) `l`, where `l` is either `*` or a&#10;  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`&#10;  can also be used, to signify the target of the goal.&#10;```&#10;instance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩&#10;instance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩&#10;&#10;example (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by&#10; ac_nf&#10; -- goal: a + (b + (c + d)) = a + (b + (c + d))&#10;```&#10;-/"/>
    <Comment start="(1502, 1)" end="(1507, 3)" text="* `symm` applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation,&#10;  that is, a relation which has a symmetry lemma tagged with the attribute [symm].&#10;  It replaces the target with `u ~ t`.&#10;* `symm at h` will rewrite a hypothesis `h : t ~ u` to `h : u ~ t`.&#10;-/"/>
    <Comment start="(1510, 1)" end="(1511, 38)" text="For every hypothesis `h : a ~ b` where a `@[symm]` lemma is available,&#10;add a hypothesis `h_symm : b ~ a`. -/"/>
    <Comment start="(1516, 1)" end="(1516, 66)" text="Syntax for omitting a local hypothesis in `solve_by_elim`. -/"/>
    <Comment start="(1518, 1)" end="(1518, 69)" text="Syntax for including all local hypotheses in `solve_by_elim`. -/"/>
    <Comment start="(1520, 1)" end="(1520, 73)" text="Syntax for adding or removing a term, or `*`, in `solve_by_elim`. -/"/>
    <Comment start="(1522, 1)" end="(1522, 64)" text="Syntax for adding and removing terms in `solve_by_elim`. -/"/>
    <Comment start="(1524, 1)" end="(1524, 82)" text="Syntax for using all lemmas labelled with an attribute in `solve_by_elim`. -/"/>
    <Comment start="(1532, 1)" end="(1568, 3)" text="`solve_by_elim` calls `apply` on the main goal to find an assumption whose head matches&#10;and then repeatedly calls `apply` on the generated subgoals until no subgoals remain,&#10;performing at most `maxDepth` (defaults to 6) recursive steps.&#10;&#10;`solve_by_elim` discharges the current goal or fails.&#10;&#10;`solve_by_elim` performs backtracking if subgoals can not be solved.&#10;&#10;By default, the assumptions passed to `apply` are the local context, `rfl`, `trivial`,&#10;`congrFun` and `congrArg`.&#10;&#10;The assumptions can be modified with similar syntax as for `simp`:&#10;* `solve_by_elim [h₁, h₂, ..., hᵣ]` also applies the given expressions.&#10;* `solve_by_elim only [h₁, h₂, ..., hᵣ]` does not include the local context,&#10;  `rfl`, `trivial`, `congrFun`, or `congrArg` unless they are explicitly included.&#10;* `solve_by_elim [-h₁, ... -hₙ]` removes the given local hypotheses.&#10;* `solve_by_elim using [a₁, ...]` uses all lemmas which have been labelled&#10;  with the attributes `aᵢ` (these attributes must be created using `register_label_attr`).&#10;&#10;`solve_by_elim*` tries to solve all goals together, using backtracking if a solution for one goal&#10;makes other goals impossible.&#10;(Adding or removing local hypotheses may not be well-behaved when starting with multiple goals.)&#10;&#10;Optional arguments passed via a configuration argument as `solve_by_elim (config := { ... })`&#10;- `maxDepth`: number of attempts at discharging generated subgoals&#10;- `symm`: adds all hypotheses derived by `symm` (defaults to `true`).&#10;- `exfalso`: allow calling `exfalso` and trying again if `solve_by_elim` fails&#10;  (defaults to `true`).&#10;- `transparency`: change the transparency mode when calling `apply`. Defaults to `.default`,&#10;  but it is often useful to change to `.reducible`,&#10;  so semireducible definitions will not be unfolded when trying to apply a lemma.&#10;&#10;See also the doc-comment for `Lean.Meta.Tactic.Backtrack.BacktrackConfig` for the options&#10;`proc`, `suspend`, and `discharge` which allow further customization of `solve_by_elim`.&#10;Both `apply_assumption` and `apply_rules` are implemented via these hooks.&#10;-/"/>
    <Comment start="(1572, 1)" end="(1591, 3)" text="`apply_assumption` looks for an assumption of the form `... → ∀ _, ... → head`&#10;where `head` matches the current goal.&#10;&#10;You can specify additional rules to apply using `apply_assumption [...]`.&#10;By default `apply_assumption` will also try `rfl`, `trivial`, `congrFun`, and `congrArg`.&#10;If you don't want these, or don't want to use all hypotheses, use `apply_assumption only [...]`.&#10;You can use `apply_assumption [-h]` to omit a local hypothesis.&#10;You can use `apply_assumption using [a₁, ...]` to use all lemmas which have been labelled&#10;with the attributes `aᵢ` (these attributes must be created using `register_label_attr`).&#10;&#10;`apply_assumption` will use consequences of local hypotheses obtained via `symm`.&#10;&#10;If `apply_assumption` fails, it will call `exfalso` and try again.&#10;Thus if there is an assumption of the form `P → ¬ Q`, the new tactic state&#10;will have two goals, `P` and `Q`.&#10;&#10;You can pass a further configuration via the syntax `apply_rules (config := {...}) lemmas`.&#10;The options supported are the same as for `solve_by_elim` (and include all the options for `apply`).&#10;-/"/>
    <Comment start="(1595, 1)" end="(1617, 3)" text="`apply_rules [l₁, l₂, ...]` tries to solve the main goal by iteratively&#10;applying the list of lemmas `[l₁, l₂, ...]` or by applying a local hypothesis.&#10;If `apply` generates new goals, `apply_rules` iteratively tries to solve those goals.&#10;You can use `apply_rules [-h]` to omit a local hypothesis.&#10;&#10;`apply_rules` will also use `rfl`, `trivial`, `congrFun` and `congrArg`.&#10;These can be disabled, as can local hypotheses, by using `apply_rules only [...]`.&#10;&#10;You can use `apply_rules using [a₁, ...]` to use all lemmas which have been labelled&#10;with the attributes `aᵢ` (these attributes must be created using `register_label_attr`).&#10;&#10;You can pass a further configuration via the syntax `apply_rules (config := {...})`.&#10;The options supported are the same as for `solve_by_elim` (and include all the options for `apply`).&#10;&#10;`apply_rules` will try calling `symm` on hypotheses and `exfalso` on the goal as needed.&#10;This can be disabled with `apply_rules (config := {symm := false, exfalso := false})`.&#10;&#10;You can bound the iteration depth using the syntax `apply_rules (config := {maxDepth := n})`.&#10;&#10;Unlike `solve_by_elim`, `apply_rules` does not perform backtracking, and greedily applies&#10;a lemma from the list until it gets stuck.&#10;-/"/>
    <Comment start="(1621, 1)" end="(1628, 3)" text="Searches environment for definitions or theorems that can solve the goal using `exact`&#10;with conditions resolved by `solve_by_elim`.&#10;&#10;The optional `using` clause provides identifiers in the local context that must be&#10;used by `exact?` when closing the goal.  This is most useful if there are multiple&#10;ways to resolve the goal, and one wants to guide which lemma is used.&#10;-/"/>
    <Comment start="(1631, 1)" end="(1637, 3)" text="Searches environment for definitions or theorems that can refine the goal using `apply`&#10;with conditions resolved when possible with `solve_by_elim`.&#10;&#10;The optional `using` clause provides identifiers in the local context that must be&#10;used when closing the goal.&#10;-/"/>
    <Comment start="(1640, 1)" end="(1642, 3)" text="Syntax for excluding some names, e.g. `[-my_lemma, -my_theorem]`.&#10;-/"/>
    <Comment start="(1645, 1)" end="(1653, 3)" text="`rw?` tries to find a lemma which can rewrite the goal.&#10;&#10;`rw?` should not be left in proofs; it is a search tool, like `apply?`.&#10;&#10;Suggestions are printed as `rw [h]` or `rw [← h]`.&#10;&#10;You can use `rw? [-my_lemma, -my_theorem]` to prevent `rw?` using the named lemmas.&#10;-/"/>
    <Comment start="(1656, 1)" end="(1662, 3)" text="`show_term tac` runs `tac`, then prints the generated term in the form&#10;&quot;exact X Y Z&quot; or &quot;refine X ?_ Z&quot; (prefixed by `expose_names` if necessary)&#10;if there are remaining subgoals.&#10;&#10;(For some tactics, the printed term will not be human readable.)&#10;-/"/>
    <Comment start="(1665, 1)" end="(1667, 3)" text="`show_term e` elaborates `e`, then prints the generated term.&#10;-/"/>
    <Comment start="(1671, 1)" end="(1674, 3)" text="The command `by?` will print a suggestion for replacing the proof block with a proof term&#10;using `show_term`.&#10;-/"/>
    <Comment start="(1677, 1)" end="(1686, 3)" text="`expose_names` renames all inaccessible variables with accessible names, making them available&#10;for reference in generated tactics. However, this renaming introduces machine-generated names&#10;that are not fully under user control. `expose_names` is primarily intended as a preamble for&#10;auto-generated end-game tactic scripts. It is also useful as an alternative to&#10;`set_option tactic.hygienic false`. If explicit control over renaming is needed in the&#10;middle of a tactic script, consider using structured tactic scripts with&#10;`match .. with`, `induction .. with`, or `intro` with explicit user-defined names,&#10;as well as tactics such as `next`, `case`, and `rename_i`.&#10;-/"/>
    <Comment start="(1689, 1)" end="(1693, 3)" text="`#suggest_premises` will suggest premises for the current goal, using the currently registered premise selector.&#10;&#10;The suggestions are printed in the order of their confidence, from highest to lowest.&#10;-/"/>
    <Comment start="(1696, 1)" end="(1723, 3)" text="Close fixed-width `BitVec` and `Bool` goals by obtaining a proof from an external SAT solver and&#10;verifying it inside Lean. The solvable goals are currently limited to&#10;- the Lean equivalent of [`QF_BV`](https://smt-lib.org/logics-all.shtml#QF_BV)&#10;- automatically splitting up `structure`s that contain information about `BitVec` or `Bool`&#10;```lean&#10;example : ∀ (a b : BitVec 64), (a &amp;&amp;&amp; b) + (a ^^^ b) = a ||| b := by&#10;  intros&#10;  bv_decide&#10;```&#10;&#10;If `bv_decide` encounters an unknown definition it will be treated like an unconstrained `BitVec`&#10;variable. Sometimes this enables solving goals despite not understanding the definition because&#10;the precise properties of the definition do not matter in the specific proof.&#10;&#10;If `bv_decide` fails to close a goal it provides a counter-example, containing assignments for all&#10;terms that were considered as variables.&#10;&#10;In order to avoid calling a SAT solver every time, the proof can be cached with `bv_decide?`.&#10;&#10;If solving your problem relies inherently on using associativity or commutativity, consider enabling&#10;the `bv.ac_nf` option.&#10;&#10;&#10;Note: `bv_decide` uses `ofReduceBool` and thus trusts the correctness of the code generator.&#10;&#10;Note: include `import Std.Tactic.BVDecide`&#10;-/"/>
    <Comment start="(1728, 1)" end="(1732, 3)" text="Suggest a proof script for a `bv_decide` tactic call. Useful for caching LRAT proofs.&#10;&#10;Note: include `import Std.Tactic.BVDecide`&#10;-/"/>
    <Comment start="(1737, 1)" end="(1742, 3)" text="Run the normalization procedure of `bv_decide` only. Sometimes this is enough to solve basic&#10;`BitVec` goals already.&#10;&#10;Note: include `import Std.Tactic.BVDecide`&#10;-/"/>
    <Comment start="(1750, 1)" end="(1798, 3)" text="Theorems tagged with the `simp` attribute are used by the simplifier&#10;(i.e., the `simp` tactic, and its variants) to simplify expressions occurring in your goals.&#10;We call theorems tagged with the `simp` attribute &quot;simp theorems&quot; or &quot;simp lemmas&quot;.&#10;Lean maintains a database/index containing all active simp theorems.&#10;Here is an example of a simp theorem.&#10;```lean&#10;@[simp] theorem ne_eq (a b : α) : (a ≠ b) = Not (a = b) := rfl&#10;```&#10;This simp theorem instructs the simplifier to replace instances of the term&#10;`a ≠ b` (e.g. `x + 0 ≠ y`) with `Not (a = b)` (e.g., `Not (x + 0 = y)`).&#10;The simplifier applies simp theorems in one direction only:&#10;if `A = B` is a simp theorem, then `simp` replaces `A`s with `B`s,&#10;but it doesn't replace `B`s with `A`s. Hence a simp theorem should have the&#10;property that its right-hand side is &quot;simpler&quot; than its left-hand side.&#10;In particular, `=` and `↔` should not be viewed as symmetric operators in this situation.&#10;The following would be a terrible simp theorem (if it were even allowed):&#10;```lean&#10;@[simp] lemma mul_right_inv_bad (a : G) : 1 = a * a⁻¹ := ...&#10;```&#10;Replacing 1 with a * a⁻¹ is not a sensible default direction to travel.&#10;Even worse would be a theorem that causes expressions to grow without bound,&#10;causing simp to loop forever.&#10;&#10;By default the simplifier applies `simp` theorems to an expression `e`&#10;after its sub-expressions have been simplified.&#10;We say it performs a bottom-up simplification.&#10;You can instruct the simplifier to apply a theorem before its sub-expressions&#10;have been simplified by using the modifier `↓`. Here is an example&#10;```lean&#10;@[simp↓] theorem not_and_eq (p q : Prop) : (¬ (p ∧ q)) = (¬p ∨ ¬q) :=&#10;```&#10;&#10;You can instruct the simplifier to rewrite the lemma from right-to-left:&#10;```lean&#10;attribute @[simp ←] and_assoc&#10;```&#10;&#10;When multiple simp theorems are applicable, the simplifier uses the one with highest priority.&#10;The equational theorems of functions are applied at very low priority (100 and below).&#10;If there are several with the same priority, it is uses the &quot;most recent one&quot;. Example:&#10;```lean&#10;@[simp high] theorem cond_true (a b : α) : cond true a b = a := rfl&#10;@[simp low+1] theorem or_true (p : Prop) : (p ∨ True) = True :=&#10;  propext &lt;| Iff.intro (fun _ =&gt; trivial) (fun _ =&gt; Or.inr trivial)&#10;@[simp 100] theorem ite_self {d : Decidable c} (a : α) : ite c a a = a := by&#10;  cases d &lt;;&gt; rfl&#10;```&#10;-/"/>
    <Comment start="(1801, 1)" end="(1806, 3)" text="Theorems tagged with the `wf_preprocess` attribute are used during the processing of functions defined&#10;by well-founded recursion. They are applied to the function's body to add additional hypotheses,&#10;such as replacing `if c then _ else _` with `if h : c then _ else _` or `xs.map` with&#10;`xs.attach.map`. Also see `wfParam`.&#10;-/"/>
    <Comment start="(1809, 1)" end="(1809, 68)" text="The possible `norm_cast` kinds: `elim`, `move`, or `squash`. -/"/>
    <Comment start="(1812, 1)" end="(1857, 3)" text="The `norm_cast` attribute should be given to lemmas that describe the&#10;behaviour of a coercion with respect to an operator, a relation, or a particular&#10;function.&#10;&#10;It only concerns equality or iff lemmas involving `↑`, `⇑` and `↥`, describing the behavior of&#10;the coercion functions.&#10;It does not apply to the explicit functions that define the coercions.&#10;&#10;Examples:&#10;```lean&#10;@[norm_cast] theorem coe_nat_inj' {m n : ℕ} : (↑m : ℤ) = ↑n ↔ m = n&#10;&#10;@[norm_cast] theorem coe_int_denom (n : ℤ) : (n : ℚ).denom = 1&#10;&#10;@[norm_cast] theorem cast_id : ∀ n : ℚ, ↑n = n&#10;&#10;@[norm_cast] theorem coe_nat_add (m n : ℕ) : (↑(m + n) : ℤ) = ↑m + ↑n&#10;&#10;@[norm_cast] theorem cast_coe_nat (n : ℕ) : ((n : ℤ) : α) = n&#10;&#10;@[norm_cast] theorem cast_one : ((1 : ℚ) : α) = 1&#10;```&#10;&#10;Lemmas tagged with `@[norm_cast]` are classified into three categories: `move`, `elim`, and&#10;`squash`. They are classified roughly as follows:&#10;&#10;* elim lemma:   LHS has 0 head coes and ≥ 1 internal coe&#10;* move lemma:   LHS has 1 head coe and 0 internal coes,    RHS has 0 head coes and ≥ 1 internal coes&#10;* squash lemma: LHS has ≥ 1 head coes and 0 internal coes, RHS has fewer head coes&#10;&#10;`norm_cast` uses `move` and `elim` lemmas to factor coercions toward the root of an expression&#10;and to cancel them from both sides of an equation or relation. It uses `squash` lemmas to clean&#10;up the result.&#10;&#10;It is typically not necessary to specify these categories, as `norm_cast` lemmas are&#10;automatically classified by default. The automatic classification can be overridden by&#10;giving an optional `elim`, `move`, or `squash` parameter to the attribute.&#10;&#10;```lean&#10;@[simp, norm_cast elim] lemma nat_cast_re (n : ℕ) : (n : ℂ).re = n := by&#10;  rw [← of_real_nat_cast, of_real_re]&#10;```&#10;&#10;Don't do this unless you understand what you are doing.&#10;-/"/>
    <Comment start="(1865, 1)" end="(1870, 3)" text="`‹t›` resolves to an (arbitrary) hypothesis of type `t`.&#10;It is useful for referring to hypotheses without accessible names.&#10;`t` may contain holes that are solved by unification with the expected type;&#10;in particular, `‹_›` is a shortcut for `by assumption`.&#10;-/"/>
    <Comment start="(1874, 1)" end="(1881, 3)" text="`get_elem_tactic_trivial` is an extensible tactic automatically called&#10;by the notation `arr[i]` to prove any side conditions that arise when&#10;constructing the term (e.g. the index is in bounds of the array).&#10;The default behavior is to just try `trivial` (which handles the case&#10;where `i &lt; arr.size` is in the context) and `simp +arith` and `omega`&#10;(for doing linear arithmetic in the index).&#10;-/"/>
    <Comment start="(1888, 1)" end="(1894, 3)" text="`get_elem_tactic` is the tactic automatically called by the notation `arr[i]`&#10;to prove any side conditions that arise when constructing the term&#10;(e.g. the index is in bounds of the array). It just delegates to&#10;`get_elem_tactic_trivial` and gives a diagnostic error message otherwise;&#10;users are encouraged to extend `get_elem_tactic_trivial` instead of this tactic.&#10;-/"/>
    <Comment start="(1927, 1)" end="(1930, 4)" text="Searches environment for definitions or theorems that can be substituted in&#10;for `exact?%` to solve the goal.&#10; -/"/>
    <Comment start="(1934, 1)" end="(1938, 81)" text="Gadget for automatic parameter support. This is similar to the `optParam` gadget, but it uses&#10;  the given tactic.&#10;  Like `optParam`, this gadget only affects elaboration.&#10;  For example, the tactic will *not* be invoked during type class resolution. -/"/>
  </Comments>
</TracedFile>
